//Generated by script_binding_generator2.py. Do not edit. Edit script_binding_generator2.py instead.
#include "platform.h"
#include "jobsystem.h"
#include "filesystem.h"
#include "misc_macros.h"
#include "error.h"
#include "globals.h"
#include "memory.h"
#include "imgui.h"
#include "application.h"
#include "endian_utils.h"
#include "logging.h"
#include "backtrace.h"
#include "file.h"
#include "graphics/gfxdefs.h"
#include "graphics/gfxmaterial.h"
#include "graphics/gfxdebugdrawer.h"
#include "graphics/light.h"
#include "graphics/gfxterrain.h"
#include "graphics/gputimer.h"
#include "graphics/gfxbuffer.h"
#include "graphics/gfxframebuffer.h"
#include "graphics/renderlist.h"
#include "graphics/gfxapi.h"
#include "graphics/font.h"
#include "graphics/gfxtexture.h"
#include "graphics/gfxmesh.h"
#include "graphics/gfxrenderer.h"
#include "graphics/gfxshader.h"
#include "graphics/camera.h"
#include "graphics/gfxmodel.h"
#include "graphics/GL/gfxglframebuffer.h"
#include "graphics/GL/glfl.h"
#include "graphics/GL/glgputimer.h"
#include "graphics/GL/gfxglbuffer.h"
#include "graphics/GL/gfxglapi.h"
#include "graphics/GL/gfxgltextureimpl.h"
#include "extensions/mc_clone/mc_clone.h"
#include "audio/audioworld.h"
#include "audio/audio.h"
#include "audio/audiodevice.h"
#include "resource/resourcemanager.h"
#include "resource/resource.h"
#include "physics/ghostobject.h"
#include "physics/physicsshape.h"
#include "physics/rigidbody.h"
#include "physics/physicsworld.h"
#include "physics/physicsdebugdrawer.h"
#include "math/quaternion.h"
#include "math/aabb.h"
#include "math/t2.h"
#include "math/t3.h"
#include "math/frustum.h"
#include "math/plane.h"
#include "math/t4.h"
#include "math/matrix4x4.h"
#include "math/matrix3x3.h"
#include "scene/entity.h"
#include "scene/scene.h"
#include "scene/transform.h"
#include "containers/resizabledata.h"
#include "containers/hashmap.h"
#include "containers/list.h"
#include "containers/string.h"
#include "scripting/autoval.h"
#include "scripting/parser.h"
#include "scripting/bytecodegen.h"
#include "scripting/bindings.h"
#include "scripting/disasm.h"
#include "scripting/script.h"
#include "scripting/vm/engine.h"
#include "scripting/vm/context.h"
#include "scripting/vm/bytecode.h"
#include "scripting/vm/types.h"
#include "scripting/parser/ast.h"
#include "scripting/parser/tokenizer.h"
#include <stdint.h>

#include "scripting/vm/engine.h"
#include "scripting/vm/context.h"
#include "scripting/vm/bytecode.h"
#include "scripting/vm/types.h"
#include "scripting/parser.h"
#include "scripting/bytecodegen.h"
#include <type_traits>

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#pragma GCC diagnostic ignored "-Wreturn-type"
#pragma GCC diagnostic ignored "-Wsign-compare"
#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
#pragma GCC diagnostic ignored "-Wunused-variable"

struct BindingsExt
{
    int64_t MCChunk_typeID, GfxCompiledShader_typeID, RayCastResult_typeID, Entity_typeID, Stats_typeID, Camera_typeID, EntityList_typeID, Light_typeID, TextureSampler_typeID, GhostObject_typeID, RayCastResultList_typeID, RenderStats_typeID, Quaternion_typeID, ImGui_typeID, LightDirectionalData_typeID, LightSpotData_typeID, FloatList_typeID, GfxLOD_typeID, List_typeID, File_typeID, Matrix3x3_typeID, GPUTimer_typeID, Filesystem_typeID, GfxFramebuffer_typeID, Event_typeID, Platform_typeID, GfxMesh_typeID, GfxShader_typeID, GfxAnimationState_typeID, StringList_typeID, GfxRenderer_typeID, Float4_typeID, LightList_typeID, Float2_typeID, Float3_typeID, Container_typeID, Frustum_typeID, AudioDevice_typeID, UInt4_typeID, UInt3_typeID, UInt2_typeID, AABB_typeID, Scene_typeID, GfxSubModelList_typeID, GfxDebugDrawer_typeID, GuiPlacer_typeID, GhostObjList_typeID, PhysicsWorld_typeID, Script_typeID, MCWorld_typeID, GfxObject_typeID, Transform_typeID, AudioSourceList_typeID, Int4_typeID, ScrollBar_typeID, Int3_typeID, ScriptInstance_typeID, RenderComponent_typeID, RigidBody_typeID, RenderList_typeID, Plane_typeID, PhysicsShape_typeID, RigidBodyList_typeID, Resource_typeID, GfxTexture_typeID, GfxModel_typeID, GfxLODList_typeID, RigidBodyConstructionInfo_typeID, GfxApi_typeID, ResourceManager_typeID, Font_typeID, AudioSource_typeID, DrawCall_typeID, Application_typeID, ResizableData_typeID, GfxBuffer_typeID, GfxMaterial_typeID, GfxMeshAttrib_typeID, Int2_typeID, StrStrMap_typeID, LightPointData_typeID, Matrix4x4_typeID, Map_typeID, ScriptInstanceList_typeID, AudioWorld_typeID, Audio_typeID, GfxShaderCombination_typeID, Key_typeID, MouseButton_typeID, EventType_typeID, FileOrigin_typeID, ResType_typeID, GfxTextureType_typeID, GfxFilter_typeID, GfxMipmapMode_typeID, GfxWrapMode_typeID, GfxTexFormat_typeID, GfxFace_typeID, GfxBufferUsage_typeID, GfxShaderType_typeID, GfxPrimitive_typeID, GfxDepthFunction_typeID, GfxBlendMode_typeID, GfxBlendFactor_typeID, GfxCullMode_typeID, GfxWinding_typeID, GfxVertexAttribPurpose_typeID, GfxVertexAttribType_typeID, GfxMeshIndexDataType_typeID, GfxMeshAttribType_typeID, GfxMeshAttribDataType_typeID, XOrigin_typeID, GfxShadowmapPrecision_typeID, GfxLightType_typeID, GfxDriver_typeID, CameraType_typeID, Axis_typeID, RigidBodyType_typeID, PhysicsObjectType_typeID, RenderMode_typeID;
    scripting::Value MCChunk, GfxCompiledShader, RayCastResult, Entity, Stats, Camera, EntityList, Light, TextureSampler, GhostObject, RayCastResultList, RenderStats, Quaternion, ImGui, LightDirectionalData, LightSpotData, FloatList, GfxLOD, List, File, Matrix3x3, GPUTimer, Filesystem, GfxFramebuffer, Event, Platform, GfxMesh, GfxShader, GfxAnimationState, StringList, GfxRenderer, Float4, LightList, Float2, Float3, Container, Frustum, AudioDevice, UInt4, UInt3, UInt2, AABB, Scene, GfxSubModelList, GfxDebugDrawer, GuiPlacer, GhostObjList, PhysicsWorld, Script, MCWorld, GfxObject, Transform, AudioSourceList, Int4, ScrollBar, Int3, ScriptInstance, RenderComponent, RigidBody, RenderList, Plane, PhysicsShape, RigidBodyList, Resource, GfxTexture, GfxModel, GfxLODList, RigidBodyConstructionInfo, GfxApi, ResourceManager, Font, AudioSource, DrawCall, Application, ResizableData, GfxBuffer, GfxMaterial, GfxMeshAttrib, Int2, StrStrMap, LightPointData, Matrix4x4, Map, ScriptInstanceList, AudioWorld, Audio, GfxShaderCombination, Key, MouseButton, EventType, FileOrigin, ResType, GfxTextureType, GfxFilter, GfxMipmapMode, GfxWrapMode, GfxTexFormat, GfxFace, GfxBufferUsage, GfxShaderType, GfxPrimitive, GfxDepthFunction, GfxBlendMode, GfxBlendFactor, GfxCullMode, GfxWinding, GfxVertexAttribPurpose, GfxVertexAttribType, GfxMeshIndexDataType, GfxMeshAttribType, GfxMeshAttribDataType, XOrigin, GfxShadowmapPrecision, GfxLightType, GfxDriver, CameraType, Axis, RigidBodyType, PhysicsObjectType, RenderMode;
};


#define CATE ctx->throwException(scripting::createException
#define SV scripting::Value
#define NO scripting::NativeObjectData*
#define CV(expr) create_val<std::remove_const<std::remove_reference<decltype(expr)>::type>::type>::f(ctx, expr)
#define TS(expr, ...) type_same<std::remove_reference<__VA_ARGS__>::type>::f(ctx, expr)
#define VE scripting::ExcType::ValueError
#define TE scripting::ExcType::TypeError
#define KE scripting::ExcType::KeyError
#define CTX scripting::Context*
#define EXT ((BindingsExt *)ctx->getEngine()->getExtension("bindings").data)
#define STG scripting
#define EI else if
#define RET return
#define UFOF(cm) "Unable to find overload for " cm
#define FAE(meth, cls) meth " expects " cls " as first argument."
#define EAOE " expects at least one argument."
#define CN STG::createNil()
#define CNF STG::createNativeFunction
#define TYPE(...) __VA_ARGS__

template <typename T>
struct val_to_c {};

#define VAL_TO_C_INT(T, T2, min, max) template <>struct val_to_c<T2>{    static T f(scripting::Context *ctx, const SV& val)    {        int64_t v;                if (val.type == scripting::ValueType::Int)        {            v = val.i;        } else if (val.type == scripting::ValueType::Float)        {            v = val.f;        } else        {            CATE(scripting::ExcType::TypeError, "Value can not be converted to int."));        }                if (v < min or v > max)        {            CATE(scripting::ExcType::TypeError, "Value out of bounds."));        }                return v;    }};

VAL_TO_C_INT(uint8_t, uint8_t, 0, UINT8_MAX)
VAL_TO_C_INT(int8_t, int8_t, INT8_MIN, INT8_MAX)
VAL_TO_C_INT(uint16_t, uint16_t, 0, UINT16_MAX)
VAL_TO_C_INT(int16_t, int16_t, INT16_MIN, INT16_MAX)
VAL_TO_C_INT(uint32_t, uint32_t, 0, UINT32_MAX)
VAL_TO_C_INT(int32_t, int32_t, INT32_MIN, INT32_MAX)
VAL_TO_C_INT(uint64_t, uint64_t, 0, UINT64_MAX)
VAL_TO_C_INT(int64_t, int64_t, INT64_MIN, INT64_MAX)
VAL_TO_C_INT(uint8_t, const uint8_t&, 0, UINT8_MAX)
VAL_TO_C_INT(int8_t, const int8_t&, INT8_MIN, INT8_MAX)
VAL_TO_C_INT(uint16_t, const uint16_t&, 0, UINT16_MAX)
VAL_TO_C_INT(int16_t, const int16_t&, INT16_MIN, INT16_MAX)
VAL_TO_C_INT(uint32_t, const uint32_t&, 0, UINT32_MAX)
VAL_TO_C_INT(int32_t, const int32_t&, INT32_MIN, INT32_MAX)
VAL_TO_C_INT(uint64_t, const uint64_t&, 0, UINT64_MAX)
VAL_TO_C_INT(int64_t, const int64_t&, INT64_MIN, INT64_MAX)

template <>
struct val_to_c<float>
{
    static float f(scripting::Context *ctx, const SV& val)
    {
        if (val.type == scripting::ValueType::Int)
        {
            return val.i;
        } else if (val.type == scripting::ValueType::Float)
        {
            return val.f;
        } else
        {
            CATE(scripting::ExcType::TypeError, "Value can not be converted to float."));
        }
    }
};

template <>
struct val_to_c<double>
{
    static double f(scripting::Context *ctx, const SV& val)
    {
        if (val.type == scripting::ValueType::Int)
        {
            return val.i;
        } else if (val.type == scripting::ValueType::Float)
        {
            return val.f;
        } else
        {
            CATE(scripting::ExcType::TypeError, "Value can not be converted to float."));
        }
    }
};

template <>
struct val_to_c<bool>
{
    static bool f(scripting::Context *ctx, const SV& val)
    {
        if (val.type == scripting::ValueType::Boolean)
        {
            return val.b;
        } else
        {
            CATE(scripting::ExcType::TypeError, "Value can not be converted to bool."));
        }
    }
};

template <>
struct val_to_c<Str>
{
    static Str f(scripting::Context *ctx, const SV& val)
    {
        if (val.type == scripting::ValueType::StringType)
        {
            return val.getStr();
        } else
        {
            CATE(scripting::ExcType::TypeError, "Value can not be converted to string."));
        }
    }
};

template <>
struct val_to_c<const Str>
{
    static const Str f(scripting::Context *ctx, const SV& val)
    {
        if (val.type == scripting::ValueType::StringType)
        {
            return val.getStr();
        } else
        {
            CATE(scripting::ExcType::TypeError, "Value can not be converted to string."));
        }
    }
};

template <>
struct val_to_c<const char *>
{
    static const char *f(scripting::Context *ctx, const SV& val)
    {
        if (val.type == scripting::ValueType::StringType)
        {
            return val.getStr().getData();
        } else
        {
            CATE(scripting::ExcType::TypeError, "Value can not be converted to string."));
        }
    }
};

template <>
struct val_to_c<char>
{
    static char f(scripting::Context *ctx, const SV& val)
    {
        if (val.type == scripting::ValueType::StringType)
        {
            if (val.getStr().getLength() == 1)
            {
                return val.getStr()[0];
            } else
            {
                CATE(scripting::ExcType::ValueError, "Value can not be converted to character."));
            }
        } else
        {
            CATE(scripting::ExcType::TypeError, "Value can not be converted to character."));
        }
    }
};

template <>
struct val_to_c<SV>
{
    static SV f(scripting::Context *ctx, const SV& val)
    {
        return scripting::createCopy(val);
    }
};

template <>
struct val_to_c<const SV>
{
    static SV f(scripting::Context *ctx, const SV& val)
    {
        return scripting::createCopy(val);
    }
};

template <>
struct val_to_c<const SV&>
{
    static SV f(scripting::Context *ctx, const SV& val)
    {
        return scripting::createCopy(val);
    }
};

template <>
struct val_to_c<AutoVal>
{
    static AutoVal f(scripting::Context *ctx, const SV& val)
    {
        return AutoVal(val);
    }
};

template <>
struct val_to_c<const AutoVal>
{
    static AutoVal f(scripting::Context *ctx, const SV& val)
    {
        return AutoVal(val);
    }
};

template <>
struct val_to_c<AutoVal&>
{
    static AutoVal f(scripting::Context *ctx, const SV& val)
    {
        return AutoVal(val);
    }
};

template <typename T>
struct val_to_c<const T&> {
    static T f(scripting::Context *ctx, const SV& val)
    {
        return val_to_c<T>::f(ctx, val);
    }
};

template <typename T>
struct create_val {};

#define CREATE_VAL(T, func) template <>struct create_val<T>{    static SV f(scripting::Context *ctx, const T& v)    {        return scripting::func(v);    }};

template <>
struct create_val<SV>
{
    static SV f(scripting::Context *ctx, const SV& val)
    {
        return scripting::createCopy(val);
    }
};

template <>
struct create_val<AutoVal>
{
    static SV f(scripting::Context *ctx, const AutoVal& val)
    {
        return scripting::createCopy(val.getVal());
    }
};

template <>
struct create_val<const char *>
{
    static SV f(scripting::Context *ctx, const char *data)
    {
        return scripting::createString(Str(data));
    }
};

template <>
struct create_val<char>
{
    static SV f(scripting::Context *ctx, char data)
    {
        return scripting::createString(Str(data));
    }
};

template <>
struct create_val<const Str>
{
    static SV f(scripting::Context *ctx, const Str& data)
    {
        return scripting::createString(data);
    }
};

CREATE_VAL(uint8_t, createInt)
CREATE_VAL(int8_t, createInt)
CREATE_VAL(uint16_t, createInt)
CREATE_VAL(int16_t, createInt)
CREATE_VAL(uint32_t, createInt)
CREATE_VAL(int32_t, createInt)
CREATE_VAL(uint64_t, createInt)
CREATE_VAL(int64_t, createInt)
CREATE_VAL(float, createFloat)
CREATE_VAL(double, createFloat)
CREATE_VAL(bool, createBoolean)
CREATE_VAL(Str, createString)

template <typename T>
struct type_same;

template <typename T>
struct type_same<const T&>
{
    static bool f(scripting::Context *ctx, const SV& val)
    {
        return type_same<T>::f(ctx, val);
    }
};

template <typename T>
struct type_same<const T>
{
    static bool f(scripting::Context *ctx, const SV& val)
    {
        return type_same<T>::f(ctx, val);
    }
};

template <>
struct type_same<SV>
{
    static bool f(scripting::Context *ctx, const SV& val)
    {
        return true;
    }
};

template <>
struct type_same<const SV&>
{
    static bool f(scripting::Context *ctx, const SV& val)
    {
        return true;
    }
};

template <>
struct type_same<const SV>
{
    static bool f(scripting::Context *ctx, const SV& val)
    {
        return true;
    }
};

template <>
struct type_same<AutoVal>
{
    static bool f(scripting::Context *ctx, const SV& val)
    {
        return true;
    }
};

template <>
struct type_same<const AutoVal&>
{
    static bool f(scripting::Context *ctx, const SV& val)
    {
        return true;
    }
};

template <>
struct type_same<const AutoVal>
{
    static bool f(scripting::Context *ctx, const SV& val)
    {
        return true;
    }
};

template <>
struct type_same<char>
{
    static bool f(scripting::Context *ctx, const SV& val)
    {
        if (val.type == scripting::ValueType::StringType)
        {
            return val.getStr().getLength() == 1;
        } else
        {
            return false;
        }
    }
};

#define TYPE_SAME_HELPER(T, enumValue) template <>struct type_same<T>{    static bool f(scripting::Context *ctx, const SV& val)    {        return val.type == scripting::ValueType::enumValue;    }};

TYPE_SAME_HELPER(uint8_t, Int)
TYPE_SAME_HELPER(int8_t, Int)
TYPE_SAME_HELPER(uint16_t, Int)
TYPE_SAME_HELPER(int16_t, Int)
TYPE_SAME_HELPER(uint32_t, Int)
TYPE_SAME_HELPER(int32_t, Int)
TYPE_SAME_HELPER(uint64_t, Int)
TYPE_SAME_HELPER(int64_t, Int)
TYPE_SAME_HELPER(float, Float)
TYPE_SAME_HELPER(double, Float)
TYPE_SAME_HELPER(bool, Boolean)
TYPE_SAME_HELPER(Str, StringType)
TYPE_SAME_HELPER(const char *, StringType)

template <typename T>
T *own(scripting::Context *ctx, const SV& value)
{
    if (type_same<T *>::f(ctx, value))
    {
        void *ptr = ((NO)value.p)->data;
        AllocInfo i = getAllocInfo(ptr);
        i.cppRef = true;
        setAllocInfo(ptr, i);

        return (T *)ptr;
    }

    CATE(scripting::ExcType::TypeError, "Argument's value can not be converted."));
}
void Key_destroy(CTX,const SV&) {}
SV Key_get_member(CTX,const SV&,const SV&);
void Key_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Key_funcs={
.destroy = Key_destroy,
.getMember = Key_get_member,
.setMember = Key_set_member
};
template <>
struct create_val<Key>
{
static SV f(CTX ctx,Key v)
{
RET STG::createNativeObject(Key_funcs,(void *)v,EXT->Key_typeID);
}
};
template <>
struct val_to_c<Key>
{
static Key f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to Key."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->Key_typeID)
CATE(TE,"Value can not be converted to Key."));
size_t v=size_t(obj->data);
if(v==271)return Key::ScrollLock;
if(v==93)return Key::RightBracket;
if(v==274)return Key::Pause;
if(v==92)return Key::Backslash;
if(v==91)return Key::LeftBracket;
if(v==32)return Key::Space;
if(v==292)return Key::Menu;
if(v==257)return Key::Enter;
if(v==277)return Key::F3;
if(v==50)return Key::_2;
if(v==289)return Key::RightControl;
if(v==259)return Key::Backspace;
if(v==47)return Key::Slash;
if(v==120)return Key::X;
if(v==269)return Key::End;
if(v==265)return Key::Up;
if(v==291)return Key::RightSuper;
if(v==283)return Key::F9;
if(v==287)return Key::LeftSuper;
if(v==273)return Key::PrintScreen;
if(v==122)return Key::Z;
if(v==290)return Key::RightAlt;
if(v==279)return Key::F5;
if(v==266)return Key::PageUp;
if(v==284)return Key::LeftShift;
if(v==281)return Key::F7;
if(v==286)return Key::LeftAlt;
if(v==285)return Key::LeftControl;
if(v==293)return Key::Unknown;
if(v==263)return Key::Left;
if(v==97)return Key::A;
if(v==260)return Key::Insert;
if(v==99)return Key::C;
if(v==98)return Key::B;
if(v==101)return Key::E;
if(v==100)return Key::D;
if(v==103)return Key::G;
if(v==102)return Key::F;
if(v==105)return Key::I;
if(v==104)return Key::H;
if(v==107)return Key::K;
if(v==106)return Key::J;
if(v==109)return Key::M;
if(v==61)return Key::Equal;
if(v==111)return Key::O;
if(v==108)return Key::L;
if(v==113)return Key::Q;
if(v==112)return Key::P;
if(v==115)return Key::S;
if(v==114)return Key::R;
if(v==117)return Key::U;
if(v==116)return Key::T;
if(v==119)return Key::W;
if(v==118)return Key::V;
if(v==121)return Key::Y;
if(v==39)return Key::Apostrophe;
if(v==272)return Key::NumLock;
if(v==110)return Key::N;
if(v==270)return Key::CapsLock;
if(v==45)return Key::Minus;
if(v==261)return Key::Delete;
if(v==275)return Key::F1;
if(v==276)return Key::F2;
if(v==262)return Key::Right;
if(v==278)return Key::F4;
if(v==57)return Key::_9;
if(v==59)return Key::Semicolon;
if(v==56)return Key::_8;
if(v==55)return Key::_7;
if(v==54)return Key::_6;
if(v==53)return Key::_5;
if(v==52)return Key::_4;
if(v==51)return Key::_3;
if(v==46)return Key::Period;
if(v==49)return Key::_1;
if(v==48)return Key::_0;
if(v==264)return Key::Down;
if(v==282)return Key::F8;
if(v==44)return Key::Comma;
if(v==267)return Key::PageDown;
if(v==258)return Key::Tab;
if(v==256)return Key::Escape;
if(v==268)return Key::Home;
if(v==280)return Key::F6;
if(v==288)return Key::RightShift;
}
};
template <>
struct type_same<Key>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Key_typeID;
else
 RET false;
}
};void MouseButton_destroy(CTX,const SV&) {}
SV MouseButton_get_member(CTX,const SV&,const SV&);
void MouseButton_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs MouseButton_funcs={
.destroy = MouseButton_destroy,
.getMember = MouseButton_get_member,
.setMember = MouseButton_set_member
};
template <>
struct create_val<MouseButton>
{
static SV f(CTX ctx,MouseButton v)
{
RET STG::createNativeObject(MouseButton_funcs,(void *)v,EXT->MouseButton_typeID);
}
};
template <>
struct val_to_c<MouseButton>
{
static MouseButton f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to MouseButton."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->MouseButton_typeID)
CATE(TE,"Value can not be converted to MouseButton."));
size_t v=size_t(obj->data);
if(v==1)return MouseButton::Middle;
if(v==2)return MouseButton::Right;
if(v==3)return MouseButton::Unknown;
if(v==0)return MouseButton::Left;
}
};
template <>
struct type_same<MouseButton>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->MouseButton_typeID;
else
 RET false;
}
};void EventType_destroy(CTX,const SV&) {}
SV EventType_get_member(CTX,const SV&,const SV&);
void EventType_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs EventType_funcs={
.destroy = EventType_destroy,
.getMember = EventType_get_member,
.setMember = EventType_set_member
};
template <>
struct create_val<EventType>
{
static SV f(CTX ctx,EventType v)
{
RET STG::createNativeObject(EventType_funcs,(void *)v,EXT->EventType_typeID);
}
};
template <>
struct val_to_c<EventType>
{
static EventType f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to EventType."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->EventType_typeID)
CATE(TE,"Value can not be converted to EventType."));
size_t v=size_t(obj->data);
if(v==1)return EventType::WindowResize;
if(v==0)return EventType::Quit;
if(v==7)return EventType::MouseWheel;
if(v==4)return EventType::MouseMotion;
if(v==8)return EventType::Unknown;
if(v==5)return EventType::MouseButtonDown;
if(v==3)return EventType::KeyUp;
if(v==2)return EventType::KeyDown;
if(v==6)return EventType::MouseButtonUp;
}
};
template <>
struct type_same<EventType>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->EventType_typeID;
else
 RET false;
}
};void FileOrigin_destroy(CTX,const SV&) {}
SV FileOrigin_get_member(CTX,const SV&,const SV&);
void FileOrigin_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs FileOrigin_funcs={
.destroy = FileOrigin_destroy,
.getMember = FileOrigin_get_member,
.setMember = FileOrigin_set_member
};
template <>
struct create_val<FileOrigin>
{
static SV f(CTX ctx,FileOrigin v)
{
RET STG::createNativeObject(FileOrigin_funcs,(void *)v,EXT->FileOrigin_typeID);
}
};
template <>
struct val_to_c<FileOrigin>
{
static FileOrigin f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to FileOrigin."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->FileOrigin_typeID)
CATE(TE,"Value can not be converted to FileOrigin."));
size_t v=size_t(obj->data);
if(v==1)return FileOrigin::Current;
if(v==0)return FileOrigin::Set;
if(v==2)return FileOrigin::End;
}
};
template <>
struct type_same<FileOrigin>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->FileOrigin_typeID;
else
 RET false;
}
};void ResType_destroy(CTX,const SV&) {}
SV ResType_get_member(CTX,const SV&,const SV&);
void ResType_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs ResType_funcs={
.destroy = ResType_destroy,
.getMember = ResType_get_member,
.setMember = ResType_set_member
};
template <>
struct create_val<ResType>
{
static SV f(CTX ctx,ResType v)
{
RET STG::createNativeObject(ResType_funcs,(void *)v,EXT->ResType_typeID);
}
};
template <>
struct val_to_c<ResType>
{
static ResType f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to ResType."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->ResType_typeID)
CATE(TE,"Value can not be converted to ResType."));
size_t v=size_t(obj->data);
if(v==3)return ResType::GfxMaterialType;
if(v==6)return ResType::ScriptType;
if(v==1)return ResType::GfxTextureType;
if(v==2)return ResType::GfxMeshType;
if(v==8)return ResType::AudioType;
if(v==9)return ResType::FontType;
if(v==4)return ResType::GfxModelType;
if(v==7)return ResType::PhysicsShapeType;
if(v==0)return ResType::GfxShaderType;
if(v==5)return ResType::SceneType;
}
};
template <>
struct type_same<ResType>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ResType_typeID;
else
 RET false;
}
};void GfxTextureType_destroy(CTX,const SV&) {}
SV GfxTextureType_get_member(CTX,const SV&,const SV&);
void GfxTextureType_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxTextureType_funcs={
.destroy = GfxTextureType_destroy,
.getMember = GfxTextureType_get_member,
.setMember = GfxTextureType_set_member
};
template <>
struct create_val<GfxTextureType>
{
static SV f(CTX ctx,GfxTextureType v)
{
RET STG::createNativeObject(GfxTextureType_funcs,(void *)v,EXT->GfxTextureType_typeID);
}
};
template <>
struct val_to_c<GfxTextureType>
{
static GfxTextureType f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxTextureType."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxTextureType_typeID)
CATE(TE,"Value can not be converted to GfxTextureType."));
size_t v=size_t(obj->data);
if(v==3)return GfxTextureType::Texture2DArray;
if(v==1)return GfxTextureType::CubeMap;
if(v==2)return GfxTextureType::Texture3D;
if(v==0)return GfxTextureType::Texture2D;
}
};
template <>
struct type_same<GfxTextureType>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxTextureType_typeID;
else
 RET false;
}
};void GfxFilter_destroy(CTX,const SV&) {}
SV GfxFilter_get_member(CTX,const SV&,const SV&);
void GfxFilter_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxFilter_funcs={
.destroy = GfxFilter_destroy,
.getMember = GfxFilter_get_member,
.setMember = GfxFilter_set_member
};
template <>
struct create_val<GfxFilter>
{
static SV f(CTX ctx,GfxFilter v)
{
RET STG::createNativeObject(GfxFilter_funcs,(void *)v,EXT->GfxFilter_typeID);
}
};
template <>
struct val_to_c<GfxFilter>
{
static GfxFilter f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxFilter."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxFilter_typeID)
CATE(TE,"Value can not be converted to GfxFilter."));
size_t v=size_t(obj->data);
if(v==1)return GfxFilter::Bilinear;
if(v==0)return GfxFilter::Nearest;
}
};
template <>
struct type_same<GfxFilter>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxFilter_typeID;
else
 RET false;
}
};void GfxMipmapMode_destroy(CTX,const SV&) {}
SV GfxMipmapMode_get_member(CTX,const SV&,const SV&);
void GfxMipmapMode_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxMipmapMode_funcs={
.destroy = GfxMipmapMode_destroy,
.getMember = GfxMipmapMode_get_member,
.setMember = GfxMipmapMode_set_member
};
template <>
struct create_val<GfxMipmapMode>
{
static SV f(CTX ctx,GfxMipmapMode v)
{
RET STG::createNativeObject(GfxMipmapMode_funcs,(void *)v,EXT->GfxMipmapMode_typeID);
}
};
template <>
struct val_to_c<GfxMipmapMode>
{
static GfxMipmapMode f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxMipmapMode."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxMipmapMode_typeID)
CATE(TE,"Value can not be converted to GfxMipmapMode."));
size_t v=size_t(obj->data);
if(v==1)return GfxMipmapMode::Nearest;
if(v==0)return GfxMipmapMode::None;
if(v==2)return GfxMipmapMode::Linear;
}
};
template <>
struct type_same<GfxMipmapMode>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxMipmapMode_typeID;
else
 RET false;
}
};void GfxWrapMode_destroy(CTX,const SV&) {}
SV GfxWrapMode_get_member(CTX,const SV&,const SV&);
void GfxWrapMode_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxWrapMode_funcs={
.destroy = GfxWrapMode_destroy,
.getMember = GfxWrapMode_get_member,
.setMember = GfxWrapMode_set_member
};
template <>
struct create_val<GfxWrapMode>
{
static SV f(CTX ctx,GfxWrapMode v)
{
RET STG::createNativeObject(GfxWrapMode_funcs,(void *)v,EXT->GfxWrapMode_typeID);
}
};
template <>
struct val_to_c<GfxWrapMode>
{
static GfxWrapMode f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxWrapMode."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxWrapMode_typeID)
CATE(TE,"Value can not be converted to GfxWrapMode."));
size_t v=size_t(obj->data);
if(v==0)return GfxWrapMode::Stretch;
if(v==1)return GfxWrapMode::Repeat;
if(v==2)return GfxWrapMode::Mirror;
}
};
template <>
struct type_same<GfxWrapMode>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxWrapMode_typeID;
else
 RET false;
}
};void GfxTexFormat_destroy(CTX,const SV&) {}
SV GfxTexFormat_get_member(CTX,const SV&,const SV&);
void GfxTexFormat_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxTexFormat_funcs={
.destroy = GfxTexFormat_destroy,
.getMember = GfxTexFormat_get_member,
.setMember = GfxTexFormat_set_member
};
template <>
struct create_val<GfxTexFormat>
{
static SV f(CTX ctx,GfxTexFormat v)
{
RET STG::createNativeObject(GfxTexFormat_funcs,(void *)v,EXT->GfxTexFormat_typeID);
}
};
template <>
struct val_to_c<GfxTexFormat>
{
static GfxTexFormat f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxTexFormat."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxTexFormat_typeID)
CATE(TE,"Value can not be converted to GfxTexFormat."));
size_t v=size_t(obj->data);
if(v==29)return GfxTexFormat::RGBAF32_F16;
if(v==13)return GfxTexFormat::LuminanceAlphaI8;
if(v==9)return GfxTexFormat::LuminanceI16;
if(v==1)return GfxTexFormat::AlphaI8;
if(v==36)return GfxTexFormat::Int2_8;
if(v==70)return GfxTexFormat::RedF32_F16;
if(v==34)return GfxTexFormat::Int_32;
if(v==39)return GfxTexFormat::UInt2_16;
if(v==12)return GfxTexFormat::LuminanceAlphaU8;
if(v==41)return GfxTexFormat::UInt2_32;
if(v==19)return GfxTexFormat::RGBI8;
if(v==68)return GfxTexFormat::RedI16;
if(v==67)return GfxTexFormat::RedU16;
if(v==7)return GfxTexFormat::LuminanceI8;
if(v==38)return GfxTexFormat::Int2_16;
if(v==26)return GfxTexFormat::RGBAU16;
if(v==23)return GfxTexFormat::RGBF32_F16;
if(v==62)return GfxTexFormat::RedGreenI16;
if(v==65)return GfxTexFormat::RedU8;
if(v==42)return GfxTexFormat::Int3_8;
if(v==30)return GfxTexFormat::Int_8;
if(v==8)return GfxTexFormat::LuminanceU16;
if(v==3)return GfxTexFormat::AlphaI16;
if(v==21)return GfxTexFormat::RGBI16;
if(v==11)return GfxTexFormat::LuminanceF32_F16;
if(v==6)return GfxTexFormat::LuminanceU8;
if(v==31)return GfxTexFormat::UInt_8;
if(v==37)return GfxTexFormat::UInt2_8;
if(v==44)return GfxTexFormat::Int3_16;
if(v==24)return GfxTexFormat::RGBAU8;
if(v==20)return GfxTexFormat::RGBU16;
if(v==16)return GfxTexFormat::LuminanceAlphaF32;
if(v==28)return GfxTexFormat::RGBAF32;
if(v==43)return GfxTexFormat::UInt3_8;
if(v==48)return GfxTexFormat::Int4_8;
if(v==14)return GfxTexFormat::LuminanceAlphaU16;
if(v==40)return GfxTexFormat::Int2_32;
if(v==33)return GfxTexFormat::UInt_16;
if(v==49)return GfxTexFormat::UInt4_8;
if(v==2)return GfxTexFormat::AlphaU16;
if(v==60)return GfxTexFormat::RedGreenI8;
if(v==17)return GfxTexFormat::LuminanceAlphaF32_F16;
if(v==46)return GfxTexFormat::Int3_32;
if(v==64)return GfxTexFormat::RedGreenF32_F16;
if(v==18)return GfxTexFormat::RGBU8;
if(v==54)return GfxTexFormat::SRGBU8;
if(v==59)return GfxTexFormat::RedGreenU8;
if(v==58)return GfxTexFormat::DepthF32;
if(v==4)return GfxTexFormat::AlphaF32;
if(v==35)return GfxTexFormat::UInt_32;
if(v==0)return GfxTexFormat::AlphaU8;
if(v==57)return GfxTexFormat::DepthF32_F24;
if(v==69)return GfxTexFormat::RedF32;
if(v==63)return GfxTexFormat::RedGreenF32;
if(v==50)return GfxTexFormat::Int4_16;
if(v==25)return GfxTexFormat::RGBAI8;
if(v==53)return GfxTexFormat::UInt4_32;
if(v==51)return GfxTexFormat::UInt4_16;
if(v==45)return GfxTexFormat::UInt3_16;
if(v==47)return GfxTexFormat::UInt3_32;
if(v==66)return GfxTexFormat::RedI8;
if(v==52)return GfxTexFormat::Int4_32;
if(v==55)return GfxTexFormat::SRGBAU8;
if(v==10)return GfxTexFormat::LuminanceF32;
if(v==22)return GfxTexFormat::RGBF32;
if(v==32)return GfxTexFormat::Int_16;
if(v==61)return GfxTexFormat::RedGreenU16;
if(v==15)return GfxTexFormat::LuminanceAlphaI16;
if(v==27)return GfxTexFormat::RGBAI16;
if(v==56)return GfxTexFormat::DepthF32_F16;
if(v==5)return GfxTexFormat::AlphaF32_F16;
}
};
template <>
struct type_same<GfxTexFormat>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxTexFormat_typeID;
else
 RET false;
}
};void GfxFace_destroy(CTX,const SV&) {}
SV GfxFace_get_member(CTX,const SV&,const SV&);
void GfxFace_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxFace_funcs={
.destroy = GfxFace_destroy,
.getMember = GfxFace_get_member,
.setMember = GfxFace_set_member
};
template <>
struct create_val<GfxFace>
{
static SV f(CTX ctx,GfxFace v)
{
RET STG::createNativeObject(GfxFace_funcs,(void *)v,EXT->GfxFace_typeID);
}
};
template <>
struct val_to_c<GfxFace>
{
static GfxFace f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxFace."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxFace_typeID)
CATE(TE,"Value can not be converted to GfxFace."));
size_t v=size_t(obj->data);
if(v==4)return GfxFace::PositiveZ;
if(v==0)return GfxFace::PositiveX;
if(v==2)return GfxFace::PositiveY;
if(v==5)return GfxFace::NegativeZ;
if(v==1)return GfxFace::NegativeX;
if(v==3)return GfxFace::NegativeY;
}
};
template <>
struct type_same<GfxFace>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxFace_typeID;
else
 RET false;
}
};void GfxBufferUsage_destroy(CTX,const SV&) {}
SV GfxBufferUsage_get_member(CTX,const SV&,const SV&);
void GfxBufferUsage_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxBufferUsage_funcs={
.destroy = GfxBufferUsage_destroy,
.getMember = GfxBufferUsage_get_member,
.setMember = GfxBufferUsage_set_member
};
template <>
struct create_val<GfxBufferUsage>
{
static SV f(CTX ctx,GfxBufferUsage v)
{
RET STG::createNativeObject(GfxBufferUsage_funcs,(void *)v,EXT->GfxBufferUsage_typeID);
}
};
template <>
struct val_to_c<GfxBufferUsage>
{
static GfxBufferUsage f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxBufferUsage."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxBufferUsage_typeID)
CATE(TE,"Value can not be converted to GfxBufferUsage."));
size_t v=size_t(obj->data);
if(v==2)return GfxBufferUsage::Dynamic;
if(v==1)return GfxBufferUsage::Static;
if(v==0)return GfxBufferUsage::Stream;
}
};
template <>
struct type_same<GfxBufferUsage>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxBufferUsage_typeID;
else
 RET false;
}
};void GfxShaderType_destroy(CTX,const SV&) {}
SV GfxShaderType_get_member(CTX,const SV&,const SV&);
void GfxShaderType_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxShaderType_funcs={
.destroy = GfxShaderType_destroy,
.getMember = GfxShaderType_get_member,
.setMember = GfxShaderType_set_member
};
template <>
struct create_val<GfxShaderType>
{
static SV f(CTX ctx,GfxShaderType v)
{
RET STG::createNativeObject(GfxShaderType_funcs,(void *)v,EXT->GfxShaderType_typeID);
}
};
template <>
struct val_to_c<GfxShaderType>
{
static GfxShaderType f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxShaderType."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxShaderType_typeID)
CATE(TE,"Value can not be converted to GfxShaderType."));
size_t v=size_t(obj->data);
if(v==5)return GfxShaderType::Compute;
if(v==3)return GfxShaderType::Geometry;
if(v==0)return GfxShaderType::Vertex;
if(v==4)return GfxShaderType::Fragment;
if(v==1)return GfxShaderType::TessControl;
if(v==2)return GfxShaderType::TessEval;
}
};
template <>
struct type_same<GfxShaderType>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxShaderType_typeID;
else
 RET false;
}
};void GfxPrimitive_destroy(CTX,const SV&) {}
SV GfxPrimitive_get_member(CTX,const SV&,const SV&);
void GfxPrimitive_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxPrimitive_funcs={
.destroy = GfxPrimitive_destroy,
.getMember = GfxPrimitive_get_member,
.setMember = GfxPrimitive_set_member
};
template <>
struct create_val<GfxPrimitive>
{
static SV f(CTX ctx,GfxPrimitive v)
{
RET STG::createNativeObject(GfxPrimitive_funcs,(void *)v,EXT->GfxPrimitive_typeID);
}
};
template <>
struct val_to_c<GfxPrimitive>
{
static GfxPrimitive f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxPrimitive."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxPrimitive_typeID)
CATE(TE,"Value can not be converted to GfxPrimitive."));
size_t v=size_t(obj->data);
if(v==1)return GfxLineStrip;
if(v==5)return GfxTriangleFan;
if(v==6)return GfxTriangles;
if(v==0)return GfxPoints;
if(v==3)return GfxLines;
if(v==2)return GfxLineLoop;
if(v==4)return GfxTriangleStrip;
if(v==7)return GfxPatches;
}
};
template <>
struct type_same<GfxPrimitive>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxPrimitive_typeID;
else
 RET false;
}
};void GfxDepthFunction_destroy(CTX,const SV&) {}
SV GfxDepthFunction_get_member(CTX,const SV&,const SV&);
void GfxDepthFunction_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxDepthFunction_funcs={
.destroy = GfxDepthFunction_destroy,
.getMember = GfxDepthFunction_get_member,
.setMember = GfxDepthFunction_set_member
};
template <>
struct create_val<GfxDepthFunction>
{
static SV f(CTX ctx,GfxDepthFunction v)
{
RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)v,EXT->GfxDepthFunction_typeID);
}
};
template <>
struct val_to_c<GfxDepthFunction>
{
static GfxDepthFunction f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxDepthFunction."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxDepthFunction_typeID)
CATE(TE,"Value can not be converted to GfxDepthFunction."));
size_t v=size_t(obj->data);
if(v==6)return GfxGreaterEqual;
if(v==0)return GfxNever;
if(v==3)return GfxLessEqual;
if(v==7)return GfxAlways;
if(v==1)return GfxLess;
if(v==4)return GfxGreater;
if(v==2)return GfxEqual;
if(v==5)return GfxNotEqual;
}
};
template <>
struct type_same<GfxDepthFunction>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxDepthFunction_typeID;
else
 RET false;
}
};void GfxBlendMode_destroy(CTX,const SV&) {}
SV GfxBlendMode_get_member(CTX,const SV&,const SV&);
void GfxBlendMode_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxBlendMode_funcs={
.destroy = GfxBlendMode_destroy,
.getMember = GfxBlendMode_get_member,
.setMember = GfxBlendMode_set_member
};
template <>
struct create_val<GfxBlendMode>
{
static SV f(CTX ctx,GfxBlendMode v)
{
RET STG::createNativeObject(GfxBlendMode_funcs,(void *)v,EXT->GfxBlendMode_typeID);
}
};
template <>
struct val_to_c<GfxBlendMode>
{
static GfxBlendMode f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxBlendMode."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxBlendMode_typeID)
CATE(TE,"Value can not be converted to GfxBlendMode."));
size_t v=size_t(obj->data);
if(v==2)return GfxReverseSubtract;
if(v==0)return GfxAdd;
if(v==1)return GfxSubtract;
}
};
template <>
struct type_same<GfxBlendMode>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxBlendMode_typeID;
else
 RET false;
}
};void GfxBlendFactor_destroy(CTX,const SV&) {}
SV GfxBlendFactor_get_member(CTX,const SV&,const SV&);
void GfxBlendFactor_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxBlendFactor_funcs={
.destroy = GfxBlendFactor_destroy,
.getMember = GfxBlendFactor_get_member,
.setMember = GfxBlendFactor_set_member
};
template <>
struct create_val<GfxBlendFactor>
{
static SV f(CTX ctx,GfxBlendFactor v)
{
RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)v,EXT->GfxBlendFactor_typeID);
}
};
template <>
struct val_to_c<GfxBlendFactor>
{
static GfxBlendFactor f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxBlendFactor."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxBlendFactor_typeID)
CATE(TE,"Value can not be converted to GfxBlendFactor."));
size_t v=size_t(obj->data);
if(v==0)return GfxZero;
if(v==2)return GfxSrcColor;
if(v==7)return GfxOneMinusSrcAlpha;
if(v==12)return GfxConstantAlpha;
if(v==8)return GfxDstAlpha;
if(v==6)return GfxSrcAlpha;
if(v==5)return GfxOneMinusDstColor;
if(v==4)return GfxDstColor;
if(v==11)return GfxOneMinusConstantColor;
if(v==3)return GfxOneMinusSrcColor;
if(v==10)return GfxConstantColor;
if(v==13)return GfxOneMinusConstantAlpha;
if(v==1)return GfxOne;
if(v==9)return GfxOneMinusDstAlpha;
}
};
template <>
struct type_same<GfxBlendFactor>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxBlendFactor_typeID;
else
 RET false;
}
};void GfxCullMode_destroy(CTX,const SV&) {}
SV GfxCullMode_get_member(CTX,const SV&,const SV&);
void GfxCullMode_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxCullMode_funcs={
.destroy = GfxCullMode_destroy,
.getMember = GfxCullMode_get_member,
.setMember = GfxCullMode_set_member
};
template <>
struct create_val<GfxCullMode>
{
static SV f(CTX ctx,GfxCullMode v)
{
RET STG::createNativeObject(GfxCullMode_funcs,(void *)v,EXT->GfxCullMode_typeID);
}
};
template <>
struct val_to_c<GfxCullMode>
{
static GfxCullMode f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxCullMode."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxCullMode_typeID)
CATE(TE,"Value can not be converted to GfxCullMode."));
size_t v=size_t(obj->data);
if(v==0)return GfxCullNone;
if(v==2)return GfxCullBack;
if(v==1)return GfxCullFront;
}
};
template <>
struct type_same<GfxCullMode>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxCullMode_typeID;
else
 RET false;
}
};void GfxWinding_destroy(CTX,const SV&) {}
SV GfxWinding_get_member(CTX,const SV&,const SV&);
void GfxWinding_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxWinding_funcs={
.destroy = GfxWinding_destroy,
.getMember = GfxWinding_get_member,
.setMember = GfxWinding_set_member
};
template <>
struct create_val<GfxWinding>
{
static SV f(CTX ctx,GfxWinding v)
{
RET STG::createNativeObject(GfxWinding_funcs,(void *)v,EXT->GfxWinding_typeID);
}
};
template <>
struct val_to_c<GfxWinding>
{
static GfxWinding f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxWinding."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxWinding_typeID)
CATE(TE,"Value can not be converted to GfxWinding."));
size_t v=size_t(obj->data);
if(v==1)return GfxCCW;
if(v==0)return GfxCW;
}
};
template <>
struct type_same<GfxWinding>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxWinding_typeID;
else
 RET false;
}
};void GfxVertexAttribPurpose_destroy(CTX,const SV&) {}
SV GfxVertexAttribPurpose_get_member(CTX,const SV&,const SV&);
void GfxVertexAttribPurpose_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxVertexAttribPurpose_funcs={
.destroy = GfxVertexAttribPurpose_destroy,
.getMember = GfxVertexAttribPurpose_get_member,
.setMember = GfxVertexAttribPurpose_set_member
};
template <>
struct create_val<GfxVertexAttribPurpose>
{
static SV f(CTX ctx,GfxVertexAttribPurpose v)
{
RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)v,EXT->GfxVertexAttribPurpose_typeID);
}
};
template <>
struct val_to_c<GfxVertexAttribPurpose>
{
static GfxVertexAttribPurpose f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxVertexAttribPurpose."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxVertexAttribPurpose_typeID)
CATE(TE,"Value can not be converted to GfxVertexAttribPurpose."));
size_t v=size_t(obj->data);
if(v==4)return GfxTexCoord;
if(v==2)return GfxTangent;
if(v==0)return GfxPosition;
if(v==1)return GfxNormal;
if(v==3)return GfxColor;
}
};
template <>
struct type_same<GfxVertexAttribPurpose>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxVertexAttribPurpose_typeID;
else
 RET false;
}
};void GfxVertexAttribType_destroy(CTX,const SV&) {}
SV GfxVertexAttribType_get_member(CTX,const SV&,const SV&);
void GfxVertexAttribType_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxVertexAttribType_funcs={
.destroy = GfxVertexAttribType_destroy,
.getMember = GfxVertexAttribType_get_member,
.setMember = GfxVertexAttribType_set_member
};
template <>
struct create_val<GfxVertexAttribType>
{
static SV f(CTX ctx,GfxVertexAttribType v)
{
RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)v,EXT->GfxVertexAttribType_typeID);
}
};
template <>
struct val_to_c<GfxVertexAttribType>
{
static GfxVertexAttribType f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxVertexAttribType."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxVertexAttribType_typeID)
CATE(TE,"Value can not be converted to GfxVertexAttribType."));
size_t v=size_t(obj->data);
if(v==8)return GfxUnsignedInteger;
if(v==10)return GfxNormalizedUnsignedByte;
if(v==1)return GfxFloat;
if(v==14)return GfxNormalizedUnsignedInteger;
if(v==5)return GfxShort;
if(v==7)return GfxInteger;
if(v==3)return GfxByte;
if(v==9)return GfxNormalizedByte;
if(v==6)return GfxUnsignedShort;
if(v==2)return GfxDouble;
if(v==0)return GfxHalfFloat;
if(v==11)return GfxNormalizedShort;
if(v==13)return GfxNormalizedInteger;
if(v==4)return GfxUnsignedByte;
if(v==12)return GfxNormalizedUnsignedShort;
}
};
template <>
struct type_same<GfxVertexAttribType>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxVertexAttribType_typeID;
else
 RET false;
}
};void GfxMeshIndexDataType_destroy(CTX,const SV&) {}
SV GfxMeshIndexDataType_get_member(CTX,const SV&,const SV&);
void GfxMeshIndexDataType_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxMeshIndexDataType_funcs={
.destroy = GfxMeshIndexDataType_destroy,
.getMember = GfxMeshIndexDataType_get_member,
.setMember = GfxMeshIndexDataType_set_member
};
template <>
struct create_val<GfxMeshIndexDataType>
{
static SV f(CTX ctx,GfxMeshIndexDataType v)
{
RET STG::createNativeObject(GfxMeshIndexDataType_funcs,(void *)v,EXT->GfxMeshIndexDataType_typeID);
}
};
template <>
struct val_to_c<GfxMeshIndexDataType>
{
static GfxMeshIndexDataType f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxMeshIndexDataType."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxMeshIndexDataType_typeID)
CATE(TE,"Value can not be converted to GfxMeshIndexDataType."));
size_t v=size_t(obj->data);
if(v==2)return GfxMeshIndexDataType::U32;
if(v==0)return GfxMeshIndexDataType::U8;
if(v==1)return GfxMeshIndexDataType::U16;
}
};
template <>
struct type_same<GfxMeshIndexDataType>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxMeshIndexDataType_typeID;
else
 RET false;
}
};void GfxMeshAttribType_destroy(CTX,const SV&) {}
SV GfxMeshAttribType_get_member(CTX,const SV&,const SV&);
void GfxMeshAttribType_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxMeshAttribType_funcs={
.destroy = GfxMeshAttribType_destroy,
.getMember = GfxMeshAttribType_get_member,
.setMember = GfxMeshAttribType_set_member
};
template <>
struct create_val<GfxMeshAttribType>
{
static SV f(CTX ctx,GfxMeshAttribType v)
{
RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)v,EXT->GfxMeshAttribType_typeID);
}
};
template <>
struct val_to_c<GfxMeshAttribType>
{
static GfxMeshAttribType f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxMeshAttribType."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxMeshAttribType_typeID)
CATE(TE,"Value can not be converted to GfxMeshAttribType."));
size_t v=size_t(obj->data);
if(v==1)return GfxMeshAttribType::Normal;
if(v==3)return GfxMeshAttribType::Color;
if(v==4)return GfxMeshAttribType::TexCoord;
if(v==2)return GfxMeshAttribType::Tangent;
if(v==6)return GfxMeshAttribType::BoneWeight;
if(v==0)return GfxMeshAttribType::Position;
if(v==5)return GfxMeshAttribType::BoneIndex;
}
};
template <>
struct type_same<GfxMeshAttribType>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxMeshAttribType_typeID;
else
 RET false;
}
};void GfxMeshAttribDataType_destroy(CTX,const SV&) {}
SV GfxMeshAttribDataType_get_member(CTX,const SV&,const SV&);
void GfxMeshAttribDataType_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxMeshAttribDataType_funcs={
.destroy = GfxMeshAttribDataType_destroy,
.getMember = GfxMeshAttribDataType_get_member,
.setMember = GfxMeshAttribDataType_set_member
};
template <>
struct create_val<GfxMeshAttribDataType>
{
static SV f(CTX ctx,GfxMeshAttribDataType v)
{
RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)v,EXT->GfxMeshAttribDataType_typeID);
}
};
template <>
struct val_to_c<GfxMeshAttribDataType>
{
static GfxMeshAttribDataType f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxMeshAttribDataType."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxMeshAttribDataType_typeID)
CATE(TE,"Value can not be converted to GfxMeshAttribDataType."));
size_t v=size_t(obj->data);
if(v==54)return GfxMeshAttribDataType::S32_3Norm;
if(v==21)return GfxMeshAttribDataType::S16_2;
if(v==22)return GfxMeshAttribDataType::S16_3;
if(v==20)return GfxMeshAttribDataType::S16_1;
if(v==37)return GfxMeshAttribDataType::S8_2Norm;
if(v==23)return GfxMeshAttribDataType::S16_4;
if(v==53)return GfxMeshAttribDataType::S32_2Norm;
if(v==42)return GfxMeshAttribDataType::U16_3Norm;
if(v==55)return GfxMeshAttribDataType::S32_4Norm;
if(v==38)return GfxMeshAttribDataType::S8_3Norm;
if(v==25)return GfxMeshAttribDataType::U32_2;
if(v==26)return GfxMeshAttribDataType::U32_3;
if(v==24)return GfxMeshAttribDataType::U32_1;
if(v==27)return GfxMeshAttribDataType::U32_4;
if(v==36)return GfxMeshAttribDataType::S8_1Norm;
if(v==9)return GfxMeshAttribDataType::U8_2;
if(v==10)return GfxMeshAttribDataType::U8_3;
if(v==8)return GfxMeshAttribDataType::U8_1;
if(v==39)return GfxMeshAttribDataType::S8_4Norm;
if(v==11)return GfxMeshAttribDataType::U8_4;
if(v==34)return GfxMeshAttribDataType::U8_3Norm;
if(v==2)return GfxMeshAttribDataType::F16_3;
if(v==1)return GfxMeshAttribDataType::F16_2;
if(v==0)return GfxMeshAttribDataType::F16_1;
if(v==52)return GfxMeshAttribDataType::S32_1Norm;
if(v==3)return GfxMeshAttribDataType::F16_4;
if(v==50)return GfxMeshAttribDataType::U32_3Norm;
if(v==41)return GfxMeshAttribDataType::U16_2Norm;
if(v==40)return GfxMeshAttribDataType::U16_1Norm;
if(v==33)return GfxMeshAttribDataType::U8_2Norm;
if(v==35)return GfxMeshAttribDataType::U8_4Norm;
if(v==51)return GfxMeshAttribDataType::U32_4Norm;
if(v==48)return GfxMeshAttribDataType::U32_1Norm;
if(v==45)return GfxMeshAttribDataType::S16_2Norm;
if(v==19)return GfxMeshAttribDataType::U16_4;
if(v==16)return GfxMeshAttribDataType::U16_1;
if(v==17)return GfxMeshAttribDataType::U16_2;
if(v==18)return GfxMeshAttribDataType::U16_3;
if(v==47)return GfxMeshAttribDataType::S16_4Norm;
if(v==32)return GfxMeshAttribDataType::U8_1Norm;
if(v==31)return GfxMeshAttribDataType::S32_4;
if(v==12)return GfxMeshAttribDataType::S8_1;
if(v==13)return GfxMeshAttribDataType::S8_2;
if(v==14)return GfxMeshAttribDataType::S8_3;
if(v==15)return GfxMeshAttribDataType::S8_4;
if(v==28)return GfxMeshAttribDataType::S32_1;
if(v==29)return GfxMeshAttribDataType::S32_2;
if(v==30)return GfxMeshAttribDataType::S32_3;
if(v==49)return GfxMeshAttribDataType::U32_2Norm;
if(v==46)return GfxMeshAttribDataType::S16_3Norm;
if(v==4)return GfxMeshAttribDataType::F32_1;
if(v==6)return GfxMeshAttribDataType::F32_3;
if(v==5)return GfxMeshAttribDataType::F32_2;
if(v==7)return GfxMeshAttribDataType::F32_4;
if(v==43)return GfxMeshAttribDataType::U16_4Norm;
if(v==44)return GfxMeshAttribDataType::S16_1Norm;
}
};
template <>
struct type_same<GfxMeshAttribDataType>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxMeshAttribDataType_typeID;
else
 RET false;
}
};void XOrigin_destroy(CTX,const SV&) {}
SV XOrigin_get_member(CTX,const SV&,const SV&);
void XOrigin_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs XOrigin_funcs={
.destroy = XOrigin_destroy,
.getMember = XOrigin_get_member,
.setMember = XOrigin_set_member
};
template <>
struct create_val<XOrigin>
{
static SV f(CTX ctx,XOrigin v)
{
RET STG::createNativeObject(XOrigin_funcs,(void *)v,EXT->XOrigin_typeID);
}
};
template <>
struct val_to_c<XOrigin>
{
static XOrigin f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to XOrigin."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->XOrigin_typeID)
CATE(TE,"Value can not be converted to XOrigin."));
size_t v=size_t(obj->data);
if(v==1)return XOrigin::Right;
if(v==0)return XOrigin::Left;
}
};
template <>
struct type_same<XOrigin>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->XOrigin_typeID;
else
 RET false;
}
};void GfxShadowmapPrecision_destroy(CTX,const SV&) {}
SV GfxShadowmapPrecision_get_member(CTX,const SV&,const SV&);
void GfxShadowmapPrecision_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxShadowmapPrecision_funcs={
.destroy = GfxShadowmapPrecision_destroy,
.getMember = GfxShadowmapPrecision_get_member,
.setMember = GfxShadowmapPrecision_set_member
};
template <>
struct create_val<GfxShadowmapPrecision>
{
static SV f(CTX ctx,GfxShadowmapPrecision v)
{
RET STG::createNativeObject(GfxShadowmapPrecision_funcs,(void *)v,EXT->GfxShadowmapPrecision_typeID);
}
};
template <>
struct val_to_c<GfxShadowmapPrecision>
{
static GfxShadowmapPrecision f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxShadowmapPrecision."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxShadowmapPrecision_typeID)
CATE(TE,"Value can not be converted to GfxShadowmapPrecision."));
size_t v=size_t(obj->data);
if(v==2)return GfxShadowmapPrecision::High;
if(v==1)return GfxShadowmapPrecision::Medium;
if(v==0)return GfxShadowmapPrecision::Low;
}
};
template <>
struct type_same<GfxShadowmapPrecision>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxShadowmapPrecision_typeID;
else
 RET false;
}
};void GfxLightType_destroy(CTX,const SV&) {}
SV GfxLightType_get_member(CTX,const SV&,const SV&);
void GfxLightType_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxLightType_funcs={
.destroy = GfxLightType_destroy,
.getMember = GfxLightType_get_member,
.setMember = GfxLightType_set_member
};
template <>
struct create_val<GfxLightType>
{
static SV f(CTX ctx,GfxLightType v)
{
RET STG::createNativeObject(GfxLightType_funcs,(void *)v,EXT->GfxLightType_typeID);
}
};
template <>
struct val_to_c<GfxLightType>
{
static GfxLightType f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxLightType."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxLightType_typeID)
CATE(TE,"Value can not be converted to GfxLightType."));
size_t v=size_t(obj->data);
if(v==2)return GfxLightType::Point;
if(v==1)return GfxLightType::Spot;
if(v==0)return GfxLightType::Directional;
}
};
template <>
struct type_same<GfxLightType>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxLightType_typeID;
else
 RET false;
}
};void GfxDriver_destroy(CTX,const SV&) {}
SV GfxDriver_get_member(CTX,const SV&,const SV&);
void GfxDriver_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxDriver_funcs={
.destroy = GfxDriver_destroy,
.getMember = GfxDriver_get_member,
.setMember = GfxDriver_set_member
};
template <>
struct create_val<GfxDriver>
{
static SV f(CTX ctx,GfxDriver v)
{
RET STG::createNativeObject(GfxDriver_funcs,(void *)v,EXT->GfxDriver_typeID);
}
};
template <>
struct val_to_c<GfxDriver>
{
static GfxDriver f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxDriver."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->GfxDriver_typeID)
CATE(TE,"Value can not be converted to GfxDriver."));
size_t v=size_t(obj->data);
if(v==2)return GfxDriver::Unknown;
if(v==1)return GfxDriver::Mesa;
if(v==0)return GfxDriver::Nvidia;
}
};
template <>
struct type_same<GfxDriver>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxDriver_typeID;
else
 RET false;
}
};void CameraType_destroy(CTX,const SV&) {}
SV CameraType_get_member(CTX,const SV&,const SV&);
void CameraType_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs CameraType_funcs={
.destroy = CameraType_destroy,
.getMember = CameraType_get_member,
.setMember = CameraType_set_member
};
template <>
struct create_val<CameraType>
{
static SV f(CTX ctx,CameraType v)
{
RET STG::createNativeObject(CameraType_funcs,(void *)v,EXT->CameraType_typeID);
}
};
template <>
struct val_to_c<CameraType>
{
static CameraType f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to CameraType."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->CameraType_typeID)
CATE(TE,"Value can not be converted to CameraType."));
size_t v=size_t(obj->data);
if(v==2)return CameraType::Matrices;
if(v==0)return CameraType::Perspective;
if(v==1)return CameraType::Orthographic;
}
};
template <>
struct type_same<CameraType>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->CameraType_typeID;
else
 RET false;
}
};void Axis_destroy(CTX,const SV&) {}
SV Axis_get_member(CTX,const SV&,const SV&);
void Axis_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Axis_funcs={
.destroy = Axis_destroy,
.getMember = Axis_get_member,
.setMember = Axis_set_member
};
template <>
struct create_val<Axis>
{
static SV f(CTX ctx,Axis v)
{
RET STG::createNativeObject(Axis_funcs,(void *)v,EXT->Axis_typeID);
}
};
template <>
struct val_to_c<Axis>
{
static Axis f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to Axis."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->Axis_typeID)
CATE(TE,"Value can not be converted to Axis."));
size_t v=size_t(obj->data);
if(v==1)return Axis::Y;
if(v==0)return Axis::X;
if(v==2)return Axis::Z;
}
};
template <>
struct type_same<Axis>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Axis_typeID;
else
 RET false;
}
};void RigidBodyType_destroy(CTX,const SV&) {}
SV RigidBodyType_get_member(CTX,const SV&,const SV&);
void RigidBodyType_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs RigidBodyType_funcs={
.destroy = RigidBodyType_destroy,
.getMember = RigidBodyType_get_member,
.setMember = RigidBodyType_set_member
};
template <>
struct create_val<RigidBodyType>
{
static SV f(CTX ctx,RigidBodyType v)
{
RET STG::createNativeObject(RigidBodyType_funcs,(void *)v,EXT->RigidBodyType_typeID);
}
};
template <>
struct val_to_c<RigidBodyType>
{
static RigidBodyType f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to RigidBodyType."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->RigidBodyType_typeID)
CATE(TE,"Value can not be converted to RigidBodyType."));
size_t v=size_t(obj->data);
if(v==1)return RigidBodyType::Dynamic;
if(v==0)return RigidBodyType::Static;
if(v==2)return RigidBodyType::Kinematic;
}
};
template <>
struct type_same<RigidBodyType>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RigidBodyType_typeID;
else
 RET false;
}
};void PhysicsObjectType_destroy(CTX,const SV&) {}
SV PhysicsObjectType_get_member(CTX,const SV&,const SV&);
void PhysicsObjectType_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs PhysicsObjectType_funcs={
.destroy = PhysicsObjectType_destroy,
.getMember = PhysicsObjectType_get_member,
.setMember = PhysicsObjectType_set_member
};
template <>
struct create_val<PhysicsObjectType>
{
static SV f(CTX ctx,PhysicsObjectType v)
{
RET STG::createNativeObject(PhysicsObjectType_funcs,(void *)v,EXT->PhysicsObjectType_typeID);
}
};
template <>
struct val_to_c<PhysicsObjectType>
{
static PhysicsObjectType f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to PhysicsObjectType."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->PhysicsObjectType_typeID)
CATE(TE,"Value can not be converted to PhysicsObjectType."));
size_t v=size_t(obj->data);
if(v==0)return PhysicsObjectType::Body;
if(v==1)return PhysicsObjectType::Ghost;
}
};
template <>
struct type_same<PhysicsObjectType>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->PhysicsObjectType_typeID;
else
 RET false;
}
};void RenderMode_destroy(CTX,const SV&) {}
SV RenderMode_get_member(CTX,const SV&,const SV&);
void RenderMode_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs RenderMode_funcs={
.destroy = RenderMode_destroy,
.getMember = RenderMode_get_member,
.setMember = RenderMode_set_member
};
template <>
struct create_val<RenderMode>
{
static SV f(CTX ctx,RenderMode v)
{
RET STG::createNativeObject(RenderMode_funcs,(void *)v,EXT->RenderMode_typeID);
}
};
template <>
struct val_to_c<RenderMode>
{
static RenderMode f(CTX ctx,const SV val)
{
if(val.type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to RenderMode."));

NO obj=(NO)val.p;
if(obj->typeID!=EXT->RenderMode_typeID)
CATE(TE,"Value can not be converted to RenderMode."));
size_t v=size_t(obj->data);
if(v==0)return RenderMode::Nothing;
if(v==1)return RenderMode::Model;
if(v==2)return RenderMode::Overlay;
}
};
template <>
struct type_same<RenderMode>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RenderMode_typeID;
else
 RET false;
}
};void MCChunk_destroy(CTX,const SV&);
SV MCChunk_get_member(CTX,const SV&,const SV&);
void MCChunk_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs MCChunk_funcs={
.destroy = MCChunk_destroy,
.getMember = MCChunk_get_member,
.setMember = MCChunk_set_member
};
template <>
struct type_same<MCChunk>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->MCChunk_typeID;
else
 RET false;
}
};

SV MCChunk_updateMeshes(CTX ctx,const List<SV>&a);
SV MCChunk_updateRigidBodies(CTX ctx,const List<SV>&a);
SV MCChunk_getMesh(CTX ctx,const List<SV>&a);
SV MCChunk_getCube(CTX ctx,const List<SV>&a);
SV MCChunk_setCube(CTX ctx,const List<SV>&a);
SV MCChunk_render(CTX ctx,const List<SV>&a);
SV MCChunk_getData(CTX ctx,const List<SV>&a);
void GfxCompiledShader_destroy(CTX,const SV&);
SV GfxCompiledShader_get_member(CTX,const SV&,const SV&);
void GfxCompiledShader_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxCompiledShader_funcs={
.destroy = GfxCompiledShader_destroy,
.getMember = GfxCompiledShader_get_member,
.setMember = GfxCompiledShader_set_member
};
template <>
struct create_val<GfxCompiledShader>
{
static SV f(CTX ctx,const GfxCompiledShader&obj)
{
void *p = (void *)NEW(TYPE(GfxCompiledShader), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxCompiledShader_funcs,p,EXT->GfxCompiledShader_typeID);
}
};
template <>
struct val_to_c<GfxCompiledShader>
{
static GfxCompiledShader f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxCompiledShader_typeID)
RET*((GfxCompiledShader*)obj->data);
else
 CATE(TE,"Value can not be converted to GfxCompiledShader."));
} else
 CATE(TE,"Value can not be converted to GfxCompiledShader."));
}
};

template <>
struct val_to_c<const GfxCompiledShader>
{
static GfxCompiledShader f(CTX ctx,const SV val) {return val_to_c<GfxCompiledShader>::f(ctx, val);}
};

template <>
struct create_val<const GfxCompiledShader>
{
static SV f(CTX ctx,const GfxCompiledShader&obj) {return create_val<GfxCompiledShader>::f(ctx,obj);}
};

template <>
struct type_same<GfxCompiledShader>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxCompiledShader_typeID;
else
 RET false;
}
};

SV GfxCompiledShader_getShader(CTX ctx,const List<SV>&a);
SV GfxCompiledShader_getGLProgram(CTX ctx,const List<SV>&a);
SV GfxCompiledShader_getGLShader(CTX ctx,const List<SV>&a);
void RayCastResult_destroy(CTX,const SV&);
SV RayCastResult_get_member(CTX,const SV&,const SV&);
void RayCastResult_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs RayCastResult_funcs={
.destroy = RayCastResult_destroy,
.getMember = RayCastResult_get_member,
.setMember = RayCastResult_set_member
};
template <>
struct create_val<RayCastResult>
{
static SV f(CTX ctx,const RayCastResult&obj)
{
void *p = (void *)NEW(TYPE(RayCastResult), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(RayCastResult_funcs,p,EXT->RayCastResult_typeID);
}
};
template <>
struct val_to_c<RayCastResult>
{
static RayCastResult f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RayCastResult_typeID)
RET*((RayCastResult*)obj->data);
else
 CATE(TE,"Value can not be converted to RayCastResult."));
} else
 CATE(TE,"Value can not be converted to RayCastResult."));
}
};

template <>
struct val_to_c<const RayCastResult>
{
static RayCastResult f(CTX ctx,const SV val) {return val_to_c<RayCastResult>::f(ctx, val);}
};

template <>
struct create_val<const RayCastResult>
{
static SV f(CTX ctx,const RayCastResult&obj) {return create_val<RayCastResult>::f(ctx,obj);}
};

template <>
struct type_same<RayCastResult>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RayCastResult_typeID;
else
 RET false;
}
};

SV RayCastResult_getRigidBody(CTX ctx,const List<SV>&a);
SV RayCastResult_getGhost(CTX ctx,const List<SV>&a);
SV RayCastResult___eq__(CTX ctx,const List<SV>&a);
void Entity_destroy(CTX,const SV&);
SV Entity_get_member(CTX,const SV&,const SV&);
void Entity_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Entity_funcs={
.destroy = Entity_destroy,
.getMember = Entity_get_member,
.setMember = Entity_set_member
};
template <>
struct type_same<Entity>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Entity_typeID;
else
 RET false;
}
};

SV Entity_addScript(CTX ctx,const List<SV>&a);
SV Entity_removeScript(CTX ctx,const List<SV>&a);
SV Entity_getScripts(CTX ctx,const List<SV>&a);
SV Entity_findScriptInstance(CTX ctx,const List<SV>&a);
SV Entity_findScriptInstanceObj(CTX ctx,const List<SV>&a);
SV Entity_addRigidBody(CTX ctx,const List<SV>&a);
SV Entity_getRigidBody(CTX ctx,const List<SV>&a);
SV Entity_removeRigidBody(CTX ctx,const List<SV>&a);
SV Entity_hasRigidBody(CTX ctx,const List<SV>&a);
SV Entity_addModel(CTX ctx,const List<SV>&a);
SV Entity_addOverlay(CTX ctx,const List<SV>&a);
SV Entity_removeRenderComponent(CTX ctx,const List<SV>&a);
SV Entity_getRenderComponent(CTX ctx,const List<SV>&a);
SV Entity_hasRenderComponent(CTX ctx,const List<SV>&a);
SV Entity_getScene(CTX ctx,const List<SV>&a);
SV Entity_createEntity(CTX ctx,const List<SV>&a);
SV Entity_removeEntity(CTX ctx,const List<SV>&a);
SV Entity_findEntity(CTX ctx,const List<SV>&a);
SV Entity_getEntities(CTX ctx,const List<SV>&a);
SV Entity_getParent(CTX ctx,const List<SV>&a);
SV Entity_updateFinalTransform(CTX ctx,const List<SV>&a);
SV Entity_getFinalTransform(CTX ctx,const List<SV>&a);
SV Entity_getFinalTransformNoScale(CTX ctx,const List<SV>&a);
SV Entity_getAudioSources(CTX ctx,const List<SV>&a);
SV Entity_addAudioSource(CTX ctx,const List<SV>&a);
SV Entity_removeAudioSource(CTX ctx,const List<SV>&a);
void Stats_destroy(CTX,const SV&);
SV Stats_get_member(CTX,const SV&,const SV&);
void Stats_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Stats_funcs={
.destroy = Stats_destroy,
.getMember = Stats_get_member,
.setMember = Stats_set_member
};
template <>
struct create_val<Stats>
{
static SV f(CTX ctx,const Stats&obj)
{
void *p = (void *)NEW(TYPE(Stats), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Stats_funcs,p,EXT->Stats_typeID);
}
};
template <>
struct val_to_c<Stats>
{
static Stats f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Stats_typeID)
RET*((Stats*)obj->data);
else
 CATE(TE,"Value can not be converted to Stats."));
} else
 CATE(TE,"Value can not be converted to Stats."));
}
};

template <>
struct val_to_c<const Stats>
{
static Stats f(CTX ctx,const SV val) {return val_to_c<Stats>::f(ctx, val);}
};

template <>
struct create_val<const Stats>
{
static SV f(CTX ctx,const Stats&obj) {return create_val<Stats>::f(ctx,obj);}
};

template <>
struct type_same<Stats>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Stats_typeID;
else
 RET false;
}
};

void Camera_destroy(CTX,const SV&);
SV Camera_get_member(CTX,const SV&,const SV&);
void Camera_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Camera_funcs={
.destroy = Camera_destroy,
.getMember = Camera_get_member,
.setMember = Camera_set_member
};
template <>
struct create_val<Camera>
{
static SV f(CTX ctx,const Camera&obj)
{
void *p = (void *)NEW(TYPE(Camera), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Camera_funcs,p,EXT->Camera_typeID);
}
};
template <>
struct val_to_c<Camera>
{
static Camera f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Camera_typeID)
RET*((Camera*)obj->data);
else
 CATE(TE,"Value can not be converted to Camera."));
} else
 CATE(TE,"Value can not be converted to Camera."));
}
};

template <>
struct val_to_c<const Camera>
{
static Camera f(CTX ctx,const SV val) {return val_to_c<Camera>::f(ctx, val);}
};

template <>
struct create_val<const Camera>
{
static SV f(CTX ctx,const Camera&obj) {return create_val<Camera>::f(ctx,obj);}
};

template <>
struct type_same<Camera>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Camera_typeID;
else
 RET false;
}
};

SV Camera_setType(CTX ctx,const List<SV>&a);
SV Camera_setPosition(CTX ctx,const List<SV>&a);
SV Camera_setDirection(CTX ctx,const List<SV>&a);
SV Camera_setUp(CTX ctx,const List<SV>&a);
SV Camera_setWidth(CTX ctx,const List<SV>&a);
SV Camera_setHeight(CTX ctx,const List<SV>&a);
SV Camera_setFieldOfView(CTX ctx,const List<SV>&a);
SV Camera_setLeft(CTX ctx,const List<SV>&a);
SV Camera_setRight(CTX ctx,const List<SV>&a);
SV Camera_setBottom(CTX ctx,const List<SV>&a);
SV Camera_setTop(CTX ctx,const List<SV>&a);
SV Camera_setNear(CTX ctx,const List<SV>&a);
SV Camera_setFar(CTX ctx,const List<SV>&a);
SV Camera_setViewMatrix(CTX ctx,const List<SV>&a);
SV Camera_setProjectionMatrix(CTX ctx,const List<SV>&a);
SV Camera_getType(CTX ctx,const List<SV>&a);
SV Camera_getPosition(CTX ctx,const List<SV>&a);
SV Camera_getDirection(CTX ctx,const List<SV>&a);
SV Camera_getUp(CTX ctx,const List<SV>&a);
SV Camera_getWidth(CTX ctx,const List<SV>&a);
SV Camera_getHeight(CTX ctx,const List<SV>&a);
SV Camera_getFieldOfView(CTX ctx,const List<SV>&a);
SV Camera_getLeft(CTX ctx,const List<SV>&a);
SV Camera_getRight(CTX ctx,const List<SV>&a);
SV Camera_getBottom(CTX ctx,const List<SV>&a);
SV Camera_getTop(CTX ctx,const List<SV>&a);
SV Camera_getNear(CTX ctx,const List<SV>&a);
SV Camera_getFar(CTX ctx,const List<SV>&a);
SV Camera_getViewMatrix(CTX ctx,const List<SV>&a);
SV Camera_getProjectionMatrix(CTX ctx,const List<SV>&a);
SV Camera_getFrustum(CTX ctx,const List<SV>&a);
void EntityList_destroy(CTX,const SV&);
SV EntityList_get_member(CTX,const SV&,const SV&);
void EntityList_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs EntityList_funcs={
.destroy = EntityList_destroy,
.getMember = EntityList_get_member,
.setMember = EntityList_set_member
};
template <>
struct create_val<List<Entity*>>
{
static SV f(CTX ctx,const List<Entity*>&obj)
{
void *p = (void *)NEW(TYPE(List<Entity*>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(EntityList_funcs,p,EXT->EntityList_typeID);
}
};
template <>
struct val_to_c<List<Entity*>>
{
static List<Entity*> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->EntityList_typeID)
RET*((List<Entity*>*)obj->data);
else
 CATE(TE,"Value can not be converted to EntityList."));
} else
 CATE(TE,"Value can not be converted to EntityList."));
}
};

template <>
struct val_to_c<const List<Entity*>>
{
static List<Entity*> f(CTX ctx,const SV val) {return val_to_c<List<Entity*>>::f(ctx, val);}
};

template <>
struct create_val<const List<Entity*>>
{
static SV f(CTX ctx,const List<Entity*>&obj) {return create_val<List<Entity*>>::f(ctx,obj);}
};

template <>
struct type_same<List<Entity*>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->EntityList_typeID;
else
 RET false;
}
};

SV EntityList___eq__(CTX ctx,const List<SV>&a);
SV EntityList___neq__(CTX ctx,const List<SV>&a);
SV EntityList_get(CTX ctx,const List<SV>&a);
SV EntityList_set(CTX ctx,const List<SV>&a);
SV EntityList_getCount(CTX ctx,const List<SV>&a);
SV EntityList_getData(CTX ctx,const List<SV>&a);
SV EntityList_append(CTX ctx,const List<SV>&a);
SV EntityList_insert(CTX ctx,const List<SV>&a);
SV EntityList_remove(CTX ctx,const List<SV>&a);
SV EntityList_clear(CTX ctx,const List<SV>&a);
SV EntityList_find(CTX ctx,const List<SV>&a);
SV EntityList_copy(CTX ctx,const List<SV>&a);
SV EntityList_in(CTX ctx,const List<SV>&a);
SV EntityList_reserve(CTX ctx,const List<SV>&a);
SV EntityList_begin(CTX ctx,const List<SV>&a);
SV EntityList_end(CTX ctx,const List<SV>&a);
void Light_destroy(CTX,const SV&);
SV Light_get_member(CTX,const SV&,const SV&);
void Light_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Light_funcs={
.destroy = Light_destroy,
.getMember = Light_get_member,
.setMember = Light_set_member
};
template <>
struct type_same<Light>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Light_typeID;
else
 RET false;
}
};

SV Light_addShadowmap(CTX ctx,const List<SV>&a);
SV Light_removeShadowmap(CTX ctx,const List<SV>&a);
SV Light_getShadowmap(CTX ctx,const List<SV>&a);
SV Light_getFramebuffers(CTX ctx,const List<SV>&a);
SV Light_getShadowmapResolution(CTX ctx,const List<SV>&a);
SV Light_getShadowmapPrecision(CTX ctx,const List<SV>&a);
SV Light_getPointLightInfluence(CTX ctx,const List<SV>&a);
SV Light_getSpotLightInfluence(CTX ctx,const List<SV>&a);
SV Light_updateMatrices(CTX ctx,const List<SV>&a);
SV Light_getViewMatrix(CTX ctx,const List<SV>&a);
SV Light_getProjectionMatrix(CTX ctx,const List<SV>&a);
SV Light_getCascadeViewMatrix(CTX ctx,const List<SV>&a);
SV Light_getCascadeProjectionMatrix(CTX ctx,const List<SV>&a);
void TextureSampler_destroy(CTX,const SV&);
SV TextureSampler_get_member(CTX,const SV&,const SV&);
void TextureSampler_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs TextureSampler_funcs={
.destroy = TextureSampler_destroy,
.getMember = TextureSampler_get_member,
.setMember = TextureSampler_set_member
};
template <>
struct create_val<TextureSampler>
{
static SV f(CTX ctx,const TextureSampler&obj)
{
void *p = (void *)NEW(TYPE(TextureSampler), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(TextureSampler_funcs,p,EXT->TextureSampler_typeID);
}
};
template <>
struct val_to_c<TextureSampler>
{
static TextureSampler f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->TextureSampler_typeID)
RET*((TextureSampler*)obj->data);
else
 CATE(TE,"Value can not be converted to TextureSampler."));
} else
 CATE(TE,"Value can not be converted to TextureSampler."));
}
};

template <>
struct val_to_c<const TextureSampler>
{
static TextureSampler f(CTX ctx,const SV val) {return val_to_c<TextureSampler>::f(ctx, val);}
};

template <>
struct create_val<const TextureSampler>
{
static SV f(CTX ctx,const TextureSampler&obj) {return create_val<TextureSampler>::f(ctx,obj);}
};

template <>
struct type_same<TextureSampler>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->TextureSampler_typeID;
else
 RET false;
}
};

SV TextureSampler_createShadowmap(CTX ctx,const List<SV>&a);
void GhostObject_destroy(CTX,const SV&);
SV GhostObject_get_member(CTX,const SV&,const SV&);
void GhostObject_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GhostObject_funcs={
.destroy = GhostObject_destroy,
.getMember = GhostObject_get_member,
.setMember = GhostObject_set_member
};
template <>
struct type_same<GhostObject>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GhostObject_typeID;
else
 RET false;
}
};

SV GhostObject_getBulletGhostObject(CTX ctx,const List<SV>&a);
SV GhostObject_getTransform(CTX ctx,const List<SV>&a);
SV GhostObject_setTransform(CTX ctx,const List<SV>&a);
SV GhostObject_getWorld(CTX ctx,const List<SV>&a);
SV GhostObject_getCollisionMask(CTX ctx,const List<SV>&a);
SV GhostObject_setShape(CTX ctx,const List<SV>&a);
SV GhostObject_getCollisions(CTX ctx,const List<SV>&a);
SV GhostObject_getRigidBodyCollisions(CTX ctx,const List<SV>&a);
SV GhostObject_getGhostCollisions(CTX ctx,const List<SV>&a);
SV GhostObject_getShape(CTX ctx,const List<SV>&a);
void RayCastResultList_destroy(CTX,const SV&);
SV RayCastResultList_get_member(CTX,const SV&,const SV&);
void RayCastResultList_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs RayCastResultList_funcs={
.destroy = RayCastResultList_destroy,
.getMember = RayCastResultList_get_member,
.setMember = RayCastResultList_set_member
};
template <>
struct create_val<List<RayCastResult>>
{
static SV f(CTX ctx,const List<RayCastResult>&obj)
{
void *p = (void *)NEW(TYPE(List<RayCastResult>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(RayCastResultList_funcs,p,EXT->RayCastResultList_typeID);
}
};
template <>
struct val_to_c<List<RayCastResult>>
{
static List<RayCastResult> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RayCastResultList_typeID)
RET*((List<RayCastResult>*)obj->data);
else
 CATE(TE,"Value can not be converted to RayCastResultList."));
} else
 CATE(TE,"Value can not be converted to RayCastResultList."));
}
};

template <>
struct val_to_c<const List<RayCastResult>>
{
static List<RayCastResult> f(CTX ctx,const SV val) {return val_to_c<List<RayCastResult>>::f(ctx, val);}
};

template <>
struct create_val<const List<RayCastResult>>
{
static SV f(CTX ctx,const List<RayCastResult>&obj) {return create_val<List<RayCastResult>>::f(ctx,obj);}
};

template <>
struct type_same<List<RayCastResult>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RayCastResultList_typeID;
else
 RET false;
}
};

SV RayCastResultList___eq__(CTX ctx,const List<SV>&a);
SV RayCastResultList___neq__(CTX ctx,const List<SV>&a);
SV RayCastResultList_get(CTX ctx,const List<SV>&a);
SV RayCastResultList_set(CTX ctx,const List<SV>&a);
SV RayCastResultList_getCount(CTX ctx,const List<SV>&a);
SV RayCastResultList_getData(CTX ctx,const List<SV>&a);
SV RayCastResultList_append(CTX ctx,const List<SV>&a);
SV RayCastResultList_insert(CTX ctx,const List<SV>&a);
SV RayCastResultList_remove(CTX ctx,const List<SV>&a);
SV RayCastResultList_clear(CTX ctx,const List<SV>&a);
SV RayCastResultList_find(CTX ctx,const List<SV>&a);
SV RayCastResultList_copy(CTX ctx,const List<SV>&a);
SV RayCastResultList_in(CTX ctx,const List<SV>&a);
SV RayCastResultList_reserve(CTX ctx,const List<SV>&a);
SV RayCastResultList_begin(CTX ctx,const List<SV>&a);
SV RayCastResultList_end(CTX ctx,const List<SV>&a);
void RenderStats_destroy(CTX,const SV&);
SV RenderStats_get_member(CTX,const SV&,const SV&);
void RenderStats_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs RenderStats_funcs={
.destroy = RenderStats_destroy,
.getMember = RenderStats_get_member,
.setMember = RenderStats_set_member
};
template <>
struct create_val<RenderStats>
{
static SV f(CTX ctx,const RenderStats&obj)
{
void *p = (void *)NEW(TYPE(RenderStats), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(RenderStats_funcs,p,EXT->RenderStats_typeID);
}
};
template <>
struct val_to_c<RenderStats>
{
static RenderStats f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RenderStats_typeID)
RET*((RenderStats*)obj->data);
else
 CATE(TE,"Value can not be converted to RenderStats."));
} else
 CATE(TE,"Value can not be converted to RenderStats."));
}
};

template <>
struct val_to_c<const RenderStats>
{
static RenderStats f(CTX ctx,const SV val) {return val_to_c<RenderStats>::f(ctx, val);}
};

template <>
struct create_val<const RenderStats>
{
static SV f(CTX ctx,const RenderStats&obj) {return create_val<RenderStats>::f(ctx,obj);}
};

template <>
struct type_same<RenderStats>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RenderStats_typeID;
else
 RET false;
}
};

void Quaternion_destroy(CTX,const SV&);
SV Quaternion_get_member(CTX,const SV&,const SV&);
void Quaternion_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Quaternion_funcs={
.destroy = Quaternion_destroy,
.getMember = Quaternion_get_member,
.setMember = Quaternion_set_member
};
template <>
struct create_val<Quaternion>
{
static SV f(CTX ctx,const Quaternion&obj)
{
void *p = (void *)NEW(TYPE(Quaternion), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Quaternion_funcs,p,EXT->Quaternion_typeID);
}
};
template <>
struct val_to_c<Quaternion>
{
static Quaternion f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Quaternion_typeID)
RET*((Quaternion*)obj->data);
else
 CATE(TE,"Value can not be converted to Quaternion."));
} else
 CATE(TE,"Value can not be converted to Quaternion."));
}
};

template <>
struct val_to_c<const Quaternion>
{
static Quaternion f(CTX ctx,const SV val) {return val_to_c<Quaternion>::f(ctx, val);}
};

template <>
struct create_val<const Quaternion>
{
static SV f(CTX ctx,const Quaternion&obj) {return create_val<Quaternion>::f(ctx,obj);}
};

template <>
struct type_same<Quaternion>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Quaternion_typeID;
else
 RET false;
}
};

SV Quaternion___mul__(CTX ctx,const List<SV>&a);
SV Quaternion_toMatrix(CTX ctx,const List<SV>&a);
SV Quaternion___eq__(CTX ctx,const List<SV>&a);
SV Quaternion_normalize(CTX ctx,const List<SV>&a);
SV Quaternion_getAngle(CTX ctx,const List<SV>&a);
SV Quaternion_getXAxis(CTX ctx,const List<SV>&a);
SV Quaternion_getYAxis(CTX ctx,const List<SV>&a);
SV Quaternion_getZAxis(CTX ctx,const List<SV>&a);
SV Quaternion_getAxis(CTX ctx,const List<SV>&a);
SV Quaternion_getAxisAndAngle(CTX ctx,const List<SV>&a);
SV Quaternion_setAngle(CTX ctx,const List<SV>&a);
SV Quaternion_setXAxis(CTX ctx,const List<SV>&a);
SV Quaternion_setYAxis(CTX ctx,const List<SV>&a);
SV Quaternion_setZAxis(CTX ctx,const List<SV>&a);
SV Quaternion_setAxis(CTX ctx,const List<SV>&a);
SV Quaternion_setAxisAndAngle(CTX ctx,const List<SV>&a);
SV Quaternion_setEulerAngles(CTX ctx,const List<SV>&a);
SV Quaternion_getEulerAngles(CTX ctx,const List<SV>&a);
void ImGui_destroy(CTX,const SV&);
SV ImGui_get_member(CTX,const SV&,const SV&);
void ImGui_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs ImGui_funcs={
.destroy = ImGui_destroy,
.getMember = ImGui_get_member,
.setMember = ImGui_set_member
};
template <>
struct create_val<ImGui>
{
static SV f(CTX ctx,const ImGui&obj)
{
void *p = (void *)NEW(TYPE(ImGui), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(ImGui_funcs,p,EXT->ImGui_typeID);
}
};
template <>
struct val_to_c<ImGui>
{
static ImGui f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->ImGui_typeID)
RET*((ImGui*)obj->data);
else
 CATE(TE,"Value can not be converted to ImGui."));
} else
 CATE(TE,"Value can not be converted to ImGui."));
}
};

template <>
struct val_to_c<const ImGui>
{
static ImGui f(CTX ctx,const SV val) {return val_to_c<ImGui>::f(ctx, val);}
};

template <>
struct create_val<const ImGui>
{
static SV f(CTX ctx,const ImGui&obj) {return create_val<ImGui>::f(ctx,obj);}
};

template <>
struct type_same<ImGui>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ImGui_typeID;
else
 RET false;
}
};

SV ImGui_rectangle(CTX ctx,const List<SV>&a);
SV ImGui_beginContainer(CTX ctx,const List<SV>&a);
SV ImGui_endContainer(CTX ctx,const List<SV>&a);
SV ImGui_verticalScrollBar(CTX ctx,const List<SV>&a);
SV ImGui_horizontalScrollBar(CTX ctx,const List<SV>&a);
SV ImGui_button(CTX ctx,const List<SV>&a);
SV ImGui_label(CTX ctx,const List<SV>&a);
SV ImGui_render(CTX ctx,const List<SV>&a);
void LightDirectionalData_destroy(CTX,const SV&);
SV LightDirectionalData_get_member(CTX,const SV&,const SV&);
void LightDirectionalData_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs LightDirectionalData_funcs={
.destroy = LightDirectionalData_destroy,
.getMember = LightDirectionalData_get_member,
.setMember = LightDirectionalData_set_member
};
template <>
struct create_val<LightDirectionalData>
{
static SV f(CTX ctx,const LightDirectionalData&obj)
{
void *p = (void *)NEW(TYPE(LightDirectionalData), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(LightDirectionalData_funcs,p,EXT->LightDirectionalData_typeID);
}
};
template <>
struct val_to_c<LightDirectionalData>
{
static LightDirectionalData f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->LightDirectionalData_typeID)
RET*((LightDirectionalData*)obj->data);
else
 CATE(TE,"Value can not be converted to LightDirectionalData."));
} else
 CATE(TE,"Value can not be converted to LightDirectionalData."));
}
};

template <>
struct val_to_c<const LightDirectionalData>
{
static LightDirectionalData f(CTX ctx,const SV val) {return val_to_c<LightDirectionalData>::f(ctx, val);}
};

template <>
struct create_val<const LightDirectionalData>
{
static SV f(CTX ctx,const LightDirectionalData&obj) {return create_val<LightDirectionalData>::f(ctx,obj);}
};

template <>
struct type_same<LightDirectionalData>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->LightDirectionalData_typeID;
else
 RET false;
}
};

void LightSpotData_destroy(CTX,const SV&);
SV LightSpotData_get_member(CTX,const SV&,const SV&);
void LightSpotData_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs LightSpotData_funcs={
.destroy = LightSpotData_destroy,
.getMember = LightSpotData_get_member,
.setMember = LightSpotData_set_member
};
template <>
struct create_val<LightSpotData>
{
static SV f(CTX ctx,const LightSpotData&obj)
{
void *p = (void *)NEW(TYPE(LightSpotData), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(LightSpotData_funcs,p,EXT->LightSpotData_typeID);
}
};
template <>
struct val_to_c<LightSpotData>
{
static LightSpotData f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->LightSpotData_typeID)
RET*((LightSpotData*)obj->data);
else
 CATE(TE,"Value can not be converted to LightSpotData."));
} else
 CATE(TE,"Value can not be converted to LightSpotData."));
}
};

template <>
struct val_to_c<const LightSpotData>
{
static LightSpotData f(CTX ctx,const SV val) {return val_to_c<LightSpotData>::f(ctx, val);}
};

template <>
struct create_val<const LightSpotData>
{
static SV f(CTX ctx,const LightSpotData&obj) {return create_val<LightSpotData>::f(ctx,obj);}
};

template <>
struct type_same<LightSpotData>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->LightSpotData_typeID;
else
 RET false;
}
};

void FloatList_destroy(CTX,const SV&);
SV FloatList_get_member(CTX,const SV&,const SV&);
void FloatList_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs FloatList_funcs={
.destroy = FloatList_destroy,
.getMember = FloatList_get_member,
.setMember = FloatList_set_member
};
template <>
struct create_val<List<float>>
{
static SV f(CTX ctx,const List<float>&obj)
{
void *p = (void *)NEW(TYPE(List<float>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(FloatList_funcs,p,EXT->FloatList_typeID);
}
};
template <>
struct val_to_c<List<float>>
{
static List<float> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->FloatList_typeID)
RET*((List<float>*)obj->data);
else
 CATE(TE,"Value can not be converted to FloatList."));
} else
 CATE(TE,"Value can not be converted to FloatList."));
}
};

template <>
struct val_to_c<const List<float>>
{
static List<float> f(CTX ctx,const SV val) {return val_to_c<List<float>>::f(ctx, val);}
};

template <>
struct create_val<const List<float>>
{
static SV f(CTX ctx,const List<float>&obj) {return create_val<List<float>>::f(ctx,obj);}
};

template <>
struct type_same<List<float>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->FloatList_typeID;
else
 RET false;
}
};

SV FloatList___eq__(CTX ctx,const List<SV>&a);
SV FloatList___neq__(CTX ctx,const List<SV>&a);
SV FloatList_get(CTX ctx,const List<SV>&a);
SV FloatList_set(CTX ctx,const List<SV>&a);
SV FloatList_getCount(CTX ctx,const List<SV>&a);
SV FloatList_getData(CTX ctx,const List<SV>&a);
SV FloatList_append(CTX ctx,const List<SV>&a);
SV FloatList_insert(CTX ctx,const List<SV>&a);
SV FloatList_remove(CTX ctx,const List<SV>&a);
SV FloatList_clear(CTX ctx,const List<SV>&a);
SV FloatList_find(CTX ctx,const List<SV>&a);
SV FloatList_copy(CTX ctx,const List<SV>&a);
SV FloatList_in(CTX ctx,const List<SV>&a);
SV FloatList_reserve(CTX ctx,const List<SV>&a);
SV FloatList_begin(CTX ctx,const List<SV>&a);
SV FloatList_end(CTX ctx,const List<SV>&a);
void GfxLOD_destroy(CTX,const SV&);
SV GfxLOD_get_member(CTX,const SV&,const SV&);
void GfxLOD_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxLOD_funcs={
.destroy = GfxLOD_destroy,
.getMember = GfxLOD_get_member,
.setMember = GfxLOD_set_member
};
template <>
struct create_val<GfxLOD>
{
static SV f(CTX ctx,const GfxLOD&obj)
{
void *p = (void *)NEW(TYPE(GfxLOD), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxLOD_funcs,p,EXT->GfxLOD_typeID);
}
};
template <>
struct val_to_c<GfxLOD>
{
static GfxLOD f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxLOD_typeID)
RET*((GfxLOD*)obj->data);
else
 CATE(TE,"Value can not be converted to GfxLOD."));
} else
 CATE(TE,"Value can not be converted to GfxLOD."));
}
};

template <>
struct val_to_c<const GfxLOD>
{
static GfxLOD f(CTX ctx,const SV val) {return val_to_c<GfxLOD>::f(ctx, val);}
};

template <>
struct create_val<const GfxLOD>
{
static SV f(CTX ctx,const GfxLOD&obj) {return create_val<GfxLOD>::f(ctx,obj);}
};

template <>
struct type_same<GfxLOD>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxLOD_typeID;
else
 RET false;
}
};

SV GfxLOD___eq__(CTX ctx,const List<SV>&a);
void List_destroy(CTX,const SV&);
SV List_get_member(CTX,const SV&,const SV&);
void List_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs List_funcs={
.destroy = List_destroy,
.getMember = List_get_member,
.setMember = List_set_member
};
template <>
struct create_val<List<AutoVal>>
{
static SV f(CTX ctx,const List<AutoVal>&obj)
{
void *p = (void *)NEW(TYPE(List<AutoVal>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(List_funcs,p,EXT->List_typeID);
}
};
template <>
struct val_to_c<List<AutoVal>>
{
static List<AutoVal> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->List_typeID)
RET*((List<AutoVal>*)obj->data);
else
 CATE(TE,"Value can not be converted to List."));
} else
 CATE(TE,"Value can not be converted to List."));
}
};

template <>
struct val_to_c<const List<AutoVal>>
{
static List<AutoVal> f(CTX ctx,const SV val) {return val_to_c<List<AutoVal>>::f(ctx, val);}
};

template <>
struct create_val<const List<AutoVal>>
{
static SV f(CTX ctx,const List<AutoVal>&obj) {return create_val<List<AutoVal>>::f(ctx,obj);}
};

template <>
struct type_same<List<AutoVal>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->List_typeID;
else
 RET false;
}
};

SV List___eq__(CTX ctx,const List<SV>&a);
SV List___neq__(CTX ctx,const List<SV>&a);
SV List_get(CTX ctx,const List<SV>&a);
SV List_set(CTX ctx,const List<SV>&a);
SV List_getCount(CTX ctx,const List<SV>&a);
SV List_getData(CTX ctx,const List<SV>&a);
SV List_append(CTX ctx,const List<SV>&a);
SV List_insert(CTX ctx,const List<SV>&a);
SV List_remove(CTX ctx,const List<SV>&a);
SV List_clear(CTX ctx,const List<SV>&a);
SV List_find(CTX ctx,const List<SV>&a);
SV List_copy(CTX ctx,const List<SV>&a);
SV List_in(CTX ctx,const List<SV>&a);
SV List_reserve(CTX ctx,const List<SV>&a);
SV List_begin(CTX ctx,const List<SV>&a);
SV List_end(CTX ctx,const List<SV>&a);
void File_destroy(CTX,const SV&);
SV File_get_member(CTX,const SV&,const SV&);
void File_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs File_funcs={
.destroy = File_destroy,
.getMember = File_get_member,
.setMember = File_set_member
};
template <>
struct type_same<File>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->File_typeID;
else
 RET false;
}
};

SV File_read(CTX ctx,const List<SV>&a);
SV File_write(CTX ctx,const List<SV>&a);
SV File_seek(CTX ctx,const List<SV>&a);
SV File_tell(CTX ctx,const List<SV>&a);
SV File_flush(CTX ctx,const List<SV>&a);
SV File_isAtEndOfFile(CTX ctx,const List<SV>&a);
SV File_getSize(CTX ctx,const List<SV>&a);
SV File_readUInt8(CTX ctx,const List<SV>&a);
SV File_readInt8(CTX ctx,const List<SV>&a);
SV File_readUInt16LE(CTX ctx,const List<SV>&a);
SV File_readInt16LE(CTX ctx,const List<SV>&a);
SV File_readUInt32LE(CTX ctx,const List<SV>&a);
SV File_readInt32LE(CTX ctx,const List<SV>&a);
SV File_readUInt64LE(CTX ctx,const List<SV>&a);
SV File_readInt64LE(CTX ctx,const List<SV>&a);
SV File_readUInt16BE(CTX ctx,const List<SV>&a);
SV File_readInt16BE(CTX ctx,const List<SV>&a);
SV File_readUInt32BE(CTX ctx,const List<SV>&a);
SV File_readInt32BE(CTX ctx,const List<SV>&a);
SV File_readUInt64BE(CTX ctx,const List<SV>&a);
SV File_readInt64BE(CTX ctx,const List<SV>&a);
SV File_readFloat32(CTX ctx,const List<SV>&a);
SV File_readChar(CTX ctx,const List<SV>&a);
SV File_readStr(CTX ctx,const List<SV>&a);
SV File_writeUInt8(CTX ctx,const List<SV>&a);
SV File_writeInt8(CTX ctx,const List<SV>&a);
SV File_writeUInt16LE(CTX ctx,const List<SV>&a);
SV File_writeInt16LE(CTX ctx,const List<SV>&a);
SV File_writeUInt32LE(CTX ctx,const List<SV>&a);
SV File_writeInt32LE(CTX ctx,const List<SV>&a);
SV File_writeUInt64LE(CTX ctx,const List<SV>&a);
SV File_writeInt64LE(CTX ctx,const List<SV>&a);
SV File_writeUInt16BE(CTX ctx,const List<SV>&a);
SV File_writeInt16BE(CTX ctx,const List<SV>&a);
SV File_writeUInt32BE(CTX ctx,const List<SV>&a);
SV File_writeInt32BE(CTX ctx,const List<SV>&a);
SV File_writeUInt64BE(CTX ctx,const List<SV>&a);
SV File_writeInt64BE(CTX ctx,const List<SV>&a);
SV File_writeFloat32(CTX ctx,const List<SV>&a);
SV File_writeStr(CTX ctx,const List<SV>&a);
SV File_printf(CTX ctx,const List<SV>&a);
SV File_vprintf(CTX ctx,const List<SV>&a);
SV File_writeChar(CTX ctx,const List<SV>&a);
void Matrix3x3_destroy(CTX,const SV&);
SV Matrix3x3_get_member(CTX,const SV&,const SV&);
void Matrix3x3_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Matrix3x3_funcs={
.destroy = Matrix3x3_destroy,
.getMember = Matrix3x3_get_member,
.setMember = Matrix3x3_set_member
};
template <>
struct create_val<Matrix3x3>
{
static SV f(CTX ctx,const Matrix3x3&obj)
{
void *p = (void *)NEW(TYPE(Matrix3x3), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Matrix3x3_funcs,p,EXT->Matrix3x3_typeID);
}
};
template <>
struct val_to_c<Matrix3x3>
{
static Matrix3x3 f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Matrix3x3_typeID)
RET*((Matrix3x3*)obj->data);
else
 CATE(TE,"Value can not be converted to Matrix3x3."));
} else
 CATE(TE,"Value can not be converted to Matrix3x3."));
}
};

template <>
struct val_to_c<const Matrix3x3>
{
static Matrix3x3 f(CTX ctx,const SV val) {return val_to_c<Matrix3x3>::f(ctx, val);}
};

template <>
struct create_val<const Matrix3x3>
{
static SV f(CTX ctx,const Matrix3x3&obj) {return create_val<Matrix3x3>::f(ctx,obj);}
};

template <>
struct type_same<Matrix3x3>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Matrix3x3_typeID;
else
 RET false;
}
};

SV Matrix3x3___mul__(CTX ctx,const List<SV>&a);
SV Matrix3x3___div__(CTX ctx,const List<SV>&a);
SV Matrix3x3_get(CTX ctx,const List<SV>&a);
SV Matrix3x3_set(CTX ctx,const List<SV>&a);
SV Matrix3x3___eq__(CTX ctx,const List<SV>&a);
SV Matrix3x3_transpose(CTX ctx,const List<SV>&a);
SV Matrix3x3_inverse(CTX ctx,const List<SV>&a);
SV Matrix3x3_translate(CTX ctx,const List<SV>&a);
SV Matrix3x3_scale(CTX ctx,const List<SV>&a);
SV Matrix3x3_rotate(CTX ctx,const List<SV>&a);
SV Matrix3x3_rotatex(CTX ctx,const List<SV>&a);
SV Matrix3x3_rotatey(CTX ctx,const List<SV>&a);
SV Matrix3x3_rotatez(CTX ctx,const List<SV>&a);
void GPUTimer_destroy(CTX,const SV&);
SV GPUTimer_get_member(CTX,const SV&,const SV&);
void GPUTimer_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GPUTimer_funcs={
.destroy = GPUTimer_destroy,
.getMember = GPUTimer_get_member,
.setMember = GPUTimer_set_member
};
template <>
struct type_same<GPUTimer>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GPUTimer_typeID;
else
 RET false;
}
};

SV GPUTimer_resultAvailable(CTX ctx,const List<SV>&a);
SV GPUTimer_getResult(CTX ctx,const List<SV>&a);
SV GPUTimer_getResultResolution(CTX ctx,const List<SV>&a);
SV GPUTimer_begin(CTX ctx,const List<SV>&a);
SV GPUTimer_end(CTX ctx,const List<SV>&a);
SV GPUTimer_swap(CTX ctx,const List<SV>&a);
void Filesystem_destroy(CTX,const SV&);
SV Filesystem_get_member(CTX,const SV&,const SV&);
void Filesystem_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Filesystem_funcs={
.destroy = Filesystem_destroy,
.getMember = Filesystem_get_member,
.setMember = Filesystem_set_member
};
template <>
struct create_val<Filesystem>
{
static SV f(CTX ctx,const Filesystem&obj)
{
void *p = (void *)NEW(TYPE(Filesystem), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Filesystem_funcs,p,EXT->Filesystem_typeID);
}
};
template <>
struct val_to_c<Filesystem>
{
static Filesystem f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Filesystem_typeID)
RET*((Filesystem*)obj->data);
else
 CATE(TE,"Value can not be converted to Filesystem."));
} else
 CATE(TE,"Value can not be converted to Filesystem."));
}
};

template <>
struct val_to_c<const Filesystem>
{
static Filesystem f(CTX ctx,const SV val) {return val_to_c<Filesystem>::f(ctx, val);}
};

template <>
struct create_val<const Filesystem>
{
static SV f(CTX ctx,const Filesystem&obj) {return create_val<Filesystem>::f(ctx,obj);}
};

template <>
struct type_same<Filesystem>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Filesystem_typeID;
else
 RET false;
}
};

SV Filesystem_pushSearchPaths(CTX ctx,const List<SV>&a);
SV Filesystem_popSearchPaths(CTX ctx,const List<SV>&a);
SV Filesystem_addSearchPath(CTX ctx,const List<SV>&a);
SV Filesystem_getAbsolutePath(CTX ctx,const List<SV>&a);
void GfxFramebuffer_destroy(CTX,const SV&);
SV GfxFramebuffer_get_member(CTX,const SV&,const SV&);
void GfxFramebuffer_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxFramebuffer_funcs={
.destroy = GfxFramebuffer_destroy,
.getMember = GfxFramebuffer_get_member,
.setMember = GfxFramebuffer_set_member
};
template <>
struct type_same<GfxFramebuffer>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxFramebuffer_typeID;
else
 RET false;
}
};

SV GfxFramebuffer_addColorAttachment(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_removeColorAttachment(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_getNumColorAttachments(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_getColorRT(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_getColorAttachment(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_getColorAttachmentMipmapLevel(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_getColorAttachmentLayer(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_setDepthAttachment(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_removeDepthAttachment(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_hasDepthAttachment(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_getDepthTexture(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_getDepthTextureMipmapLevel(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_getDepthAttachmentLayer(CTX ctx,const List<SV>&a);
void Event_destroy(CTX,const SV&);
SV Event_get_member(CTX,const SV&,const SV&);
void Event_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Event_funcs={
.destroy = Event_destroy,
.getMember = Event_get_member,
.setMember = Event_set_member
};
template <>
struct create_val<Event>
{
static SV f(CTX ctx,const Event&obj)
{
void *p = (void *)NEW(TYPE(Event), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Event_funcs,p,EXT->Event_typeID);
}
};
template <>
struct val_to_c<Event>
{
static Event f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Event_typeID)
RET*((Event*)obj->data);
else
 CATE(TE,"Value can not be converted to Event."));
} else
 CATE(TE,"Value can not be converted to Event."));
}
};

template <>
struct val_to_c<const Event>
{
static Event f(CTX ctx,const SV val) {return val_to_c<Event>::f(ctx, val);}
};

template <>
struct create_val<const Event>
{
static SV f(CTX ctx,const Event&obj) {return create_val<Event>::f(ctx,obj);}
};

template <>
struct type_same<Event>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Event_typeID;
else
 RET false;
}
};

SV Event_getWidth(CTX ctx,const List<SV>&a);
SV Event_getHeight(CTX ctx,const List<SV>&a);
SV Event_getKey(CTX ctx,const List<SV>&a);
SV Event_getX(CTX ctx,const List<SV>&a);
SV Event_getY(CTX ctx,const List<SV>&a);
SV Event_getRelX(CTX ctx,const List<SV>&a);
SV Event_getRelY(CTX ctx,const List<SV>&a);
SV Event_getButton(CTX ctx,const List<SV>&a);
SV Event_getDoubleClicked(CTX ctx,const List<SV>&a);
void Platform_destroy(CTX,const SV&);
SV Platform_get_member(CTX,const SV&,const SV&);
void Platform_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Platform_funcs={
.destroy = Platform_destroy,
.getMember = Platform_get_member,
.setMember = Platform_set_member
};
template <>
struct type_same<Platform>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Platform_typeID;
else
 RET false;
}
};

SV Platform_initWindow(CTX ctx,const List<SV>&a);
SV Platform_destroyWindow(CTX ctx,const List<SV>&a);
SV Platform_run(CTX ctx,const List<SV>&a);
SV Platform_pollEvent(CTX ctx,const List<SV>&a);
SV Platform_eventsLeft(CTX ctx,const List<SV>&a);
SV Platform_popEvent(CTX ctx,const List<SV>&a);
SV Platform_getTime(CTX ctx,const List<SV>&a);
SV Platform_getTimerFrequency(CTX ctx,const List<SV>&a);
SV Platform_getWindowWidth(CTX ctx,const List<SV>&a);
SV Platform_getWindowHeight(CTX ctx,const List<SV>&a);
SV Platform_getMousePosition(CTX ctx,const List<SV>&a);
SV Platform_setMousePosition(CTX ctx,const List<SV>&a);
SV Platform_isLeftMouseButtonPressed(CTX ctx,const List<SV>&a);
SV Platform_isRightMouseButtonPressed(CTX ctx,const List<SV>&a);
SV Platform_isMiddleMouseButtonPressed(CTX ctx,const List<SV>&a);
SV Platform_getMouseWheel(CTX ctx,const List<SV>&a);
SV Platform_isCursorVisible(CTX ctx,const List<SV>&a);
SV Platform_setCursorVisible(CTX ctx,const List<SV>&a);
SV Platform_isKeyPressed(CTX ctx,const List<SV>&a);
SV Platform_getFullscreen(CTX ctx,const List<SV>&a);
SV Platform_setFullscreen(CTX ctx,const List<SV>&a);
SV Platform_getFrametime(CTX ctx,const List<SV>&a);
SV Platform_getGPUFrametime(CTX ctx,const List<SV>&a);
SV Platform_getCPUFrametime(CTX ctx,const List<SV>&a);
void GfxMesh_destroy(CTX,const SV&);
SV GfxMesh_get_member(CTX,const SV&,const SV&);
void GfxMesh_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxMesh_funcs={
.destroy = GfxMesh_destroy,
.getMember = GfxMesh_get_member,
.setMember = GfxMesh_set_member
};
template <>
struct type_same<GfxMesh>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxMesh_typeID;
else
 RET false;
}
};

SV GfxMesh_addIndices(CTX ctx,const List<SV>&a);
SV GfxMesh_removeIndices(CTX ctx,const List<SV>&a);
SV GfxMesh_setAttribute(CTX ctx,const List<SV>&a);
SV GfxMesh_removeAttribute(CTX ctx,const List<SV>&a);
SV GfxMesh_getIndexed(CTX ctx,const List<SV>&a);
SV GfxMesh_getIndexType(CTX ctx,const List<SV>&a);
SV GfxMesh_getIndices(CTX ctx,const List<SV>&a);
SV GfxMesh_getAttribs(CTX ctx,const List<SV>&a);
SV GfxMesh_getAttribCount(CTX ctx,const List<SV>&a);
SV GfxMesh_getAttrib(CTX ctx,const List<SV>&a);
SV GfxMesh_getGLVAO(CTX ctx,const List<SV>&a);
SV GfxMesh_getGLIndexBuffer(CTX ctx,const List<SV>&a);
SV GfxMesh_removeContent(CTX ctx,const List<SV>&a);
SV GfxMesh_save(CTX ctx,const List<SV>&a);
SV GfxMesh_load(CTX ctx,const List<SV>&a);
SV GfxMesh_copy(CTX ctx,const List<SV>&a);
SV GfxMesh_getType(CTX ctx,const List<SV>&a);
SV GfxMesh_release(CTX ctx,const List<SV>&a);
SV GfxMesh_getRefCount(CTX ctx,const List<SV>&a);
SV GfxMesh_getFilename(CTX ctx,const List<SV>&a);
SV GfxMesh_setFilename(CTX ctx,const List<SV>&a);
void GfxShader_destroy(CTX,const SV&);
SV GfxShader_get_member(CTX,const SV&,const SV&);
void GfxShader_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxShader_funcs={
.destroy = GfxShader_destroy,
.getMember = GfxShader_get_member,
.setMember = GfxShader_set_member
};
template <>
struct type_same<GfxShader>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxShader_typeID;
else
 RET false;
}
};

SV GfxShader_removeContent(CTX ctx,const List<SV>&a);
SV GfxShader_save(CTX ctx,const List<SV>&a);
SV GfxShader_compile(CTX ctx,const List<SV>&a);
SV GfxShader_getSource(CTX ctx,const List<SV>&a);
SV GfxShader_getShaderType(CTX ctx,const List<SV>&a);
SV GfxShader_getCompiled(CTX ctx,const List<SV>&a);
SV GfxShader_load(CTX ctx,const List<SV>&a);
SV GfxShader_copy(CTX ctx,const List<SV>&a);
SV GfxShader_getType(CTX ctx,const List<SV>&a);
SV GfxShader_release(CTX ctx,const List<SV>&a);
SV GfxShader_getRefCount(CTX ctx,const List<SV>&a);
SV GfxShader_getFilename(CTX ctx,const List<SV>&a);
SV GfxShader_setFilename(CTX ctx,const List<SV>&a);
void GfxAnimationState_destroy(CTX,const SV&);
SV GfxAnimationState_get_member(CTX,const SV&,const SV&);
void GfxAnimationState_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxAnimationState_funcs={
.destroy = GfxAnimationState_destroy,
.getMember = GfxAnimationState_get_member,
.setMember = GfxAnimationState_set_member
};
template <>
struct type_same<GfxAnimationState>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxAnimationState_typeID;
else
 RET false;
}
};

SV GfxAnimationState_updateMatrices(CTX ctx,const List<SV>&a);
SV GfxAnimationState_getAnimName(CTX ctx,const List<SV>&a);
SV GfxAnimationState_getMesh(CTX ctx,const List<SV>&a);
SV GfxAnimationState_getMatrixBuffer(CTX ctx,const List<SV>&a);
SV GfxAnimationState_getNormalMatrixBuffer(CTX ctx,const List<SV>&a);
void StringList_destroy(CTX,const SV&);
SV StringList_get_member(CTX,const SV&,const SV&);
void StringList_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs StringList_funcs={
.destroy = StringList_destroy,
.getMember = StringList_get_member,
.setMember = StringList_set_member
};
template <>
struct create_val<List<Str>>
{
static SV f(CTX ctx,const List<Str>&obj)
{
void *p = (void *)NEW(TYPE(List<Str>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(StringList_funcs,p,EXT->StringList_typeID);
}
};
template <>
struct val_to_c<List<Str>>
{
static List<Str> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->StringList_typeID)
RET*((List<Str>*)obj->data);
else
 CATE(TE,"Value can not be converted to StringList."));
} else
 CATE(TE,"Value can not be converted to StringList."));
}
};

template <>
struct val_to_c<const List<Str>>
{
static List<Str> f(CTX ctx,const SV val) {return val_to_c<List<Str>>::f(ctx, val);}
};

template <>
struct create_val<const List<Str>>
{
static SV f(CTX ctx,const List<Str>&obj) {return create_val<List<Str>>::f(ctx,obj);}
};

template <>
struct type_same<List<Str>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->StringList_typeID;
else
 RET false;
}
};

SV StringList___eq__(CTX ctx,const List<SV>&a);
SV StringList___neq__(CTX ctx,const List<SV>&a);
SV StringList_get(CTX ctx,const List<SV>&a);
SV StringList_set(CTX ctx,const List<SV>&a);
SV StringList_getCount(CTX ctx,const List<SV>&a);
SV StringList_getData(CTX ctx,const List<SV>&a);
SV StringList_append(CTX ctx,const List<SV>&a);
SV StringList_insert(CTX ctx,const List<SV>&a);
SV StringList_remove(CTX ctx,const List<SV>&a);
SV StringList_clear(CTX ctx,const List<SV>&a);
SV StringList_find(CTX ctx,const List<SV>&a);
SV StringList_copy(CTX ctx,const List<SV>&a);
SV StringList_in(CTX ctx,const List<SV>&a);
SV StringList_reserve(CTX ctx,const List<SV>&a);
SV StringList_begin(CTX ctx,const List<SV>&a);
SV StringList_end(CTX ctx,const List<SV>&a);
void GfxRenderer_destroy(CTX,const SV&);
SV GfxRenderer_get_member(CTX,const SV&,const SV&);
void GfxRenderer_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxRenderer_funcs={
.destroy = GfxRenderer_destroy,
.getMember = GfxRenderer_get_member,
.setMember = GfxRenderer_set_member
};
template <>
struct type_same<GfxRenderer>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxRenderer_typeID;
else
 RET false;
}
};

SV GfxRenderer_resize(CTX ctx,const List<SV>&a);
SV GfxRenderer_render(CTX ctx,const List<SV>&a);
SV GfxRenderer_addObject(CTX ctx,const List<SV>&a);
SV GfxRenderer_getNumLights(CTX ctx,const List<SV>&a);
SV GfxRenderer_getLightBuffer(CTX ctx,const List<SV>&a);
SV GfxRenderer_getStats(CTX ctx,const List<SV>&a);
SV GfxRenderer_addLight(CTX ctx,const List<SV>&a);
SV GfxRenderer_removeLight(CTX ctx,const List<SV>&a);
SV GfxRenderer_getLights(CTX ctx,const List<SV>&a);
SV GfxRenderer_updateStats(CTX ctx,const List<SV>&a);
SV GfxRenderer_updateColorModifierShader(CTX ctx,const List<SV>&a);
SV GfxRenderer_setSkybox(CTX ctx,const List<SV>&a);
SV GfxRenderer_getSkybox(CTX ctx,const List<SV>&a);
SV GfxRenderer_addTerrain(CTX ctx,const List<SV>&a);
SV GfxRenderer_removeTerrain(CTX ctx,const List<SV>&a);
SV GfxRenderer_getTerrain(CTX ctx,const List<SV>&a);
SV GfxRenderer_getForwardList(CTX ctx,const List<SV>&a);
SV GfxRenderer_getDeferredList(CTX ctx,const List<SV>&a);
SV GfxRenderer_getShadowmapList(CTX ctx,const List<SV>&a);
SV GfxRenderer_getSceneAABB(CTX ctx,const List<SV>&a);
SV GfxRenderer_getShadowCasterAABB(CTX ctx,const List<SV>&a);
SV GfxRenderer_computeSceneAABB(CTX ctx,const List<SV>&a);
SV GfxRenderer_computeShadowCasterAABB(CTX ctx,const List<SV>&a);
void Float4_destroy(CTX,const SV&);
SV Float4_get_member(CTX,const SV&,const SV&);
void Float4_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Float4_funcs={
.destroy = Float4_destroy,
.getMember = Float4_get_member,
.setMember = Float4_set_member
};
template <>
struct create_val<T4<float>>
{
static SV f(CTX ctx,const T4<float>&obj)
{
void *p = (void *)NEW(TYPE(T4<float>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float4_funcs,p,EXT->Float4_typeID);
}
};
template <>
struct val_to_c<T4<float>>
{
static T4<float> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Float4_typeID)
RET*((T4<float>*)obj->data);
else
 CATE(TE,"Value can not be converted to Float4."));
} else
 CATE(TE,"Value can not be converted to Float4."));
}
};

template <>
struct val_to_c<const T4<float>>
{
static T4<float> f(CTX ctx,const SV val) {return val_to_c<T4<float>>::f(ctx, val);}
};

template <>
struct create_val<const T4<float>>
{
static SV f(CTX ctx,const T4<float>&obj) {return create_val<T4<float>>::f(ctx,obj);}
};

template <>
struct type_same<T4<float>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Float4_typeID;
else
 RET false;
}
};

SV Float4___add__(CTX ctx,const List<SV>&a);
SV Float4___sub__(CTX ctx,const List<SV>&a);
SV Float4___mul__(CTX ctx,const List<SV>&a);
SV Float4___div__(CTX ctx,const List<SV>&a);
SV Float4___eq__(CTX ctx,const List<SV>&a);
SV Float4___neq__(CTX ctx,const List<SV>&a);
SV Float4___less__(CTX ctx,const List<SV>&a);
SV Float4___grtr__(CTX ctx,const List<SV>&a);
SV Float4___leq__(CTX ctx,const List<SV>&a);
SV Float4___geq__(CTX ctx,const List<SV>&a);
SV Float4_sum(CTX ctx,const List<SV>&a);
SV Float4_length(CTX ctx,const List<SV>&a);
SV Float4_lengthSquared(CTX ctx,const List<SV>&a);
SV Float4_dot(CTX ctx,const List<SV>&a);
SV Float4_distance(CTX ctx,const List<SV>&a);
SV Float4_distanceSquared(CTX ctx,const List<SV>&a);
SV Float4_normalize(CTX ctx,const List<SV>&a);
SV Float4_getXY(CTX ctx,const List<SV>&a);
SV Float4_setXY(CTX ctx,const List<SV>&a);
SV Float4_getXZ(CTX ctx,const List<SV>&a);
SV Float4_setXZ(CTX ctx,const List<SV>&a);
SV Float4_getXW(CTX ctx,const List<SV>&a);
SV Float4_setXW(CTX ctx,const List<SV>&a);
SV Float4_getYX(CTX ctx,const List<SV>&a);
SV Float4_setYX(CTX ctx,const List<SV>&a);
SV Float4_getYZ(CTX ctx,const List<SV>&a);
SV Float4_setYZ(CTX ctx,const List<SV>&a);
SV Float4_getYW(CTX ctx,const List<SV>&a);
SV Float4_setYW(CTX ctx,const List<SV>&a);
SV Float4_getZX(CTX ctx,const List<SV>&a);
SV Float4_setZX(CTX ctx,const List<SV>&a);
SV Float4_getZY(CTX ctx,const List<SV>&a);
SV Float4_setZY(CTX ctx,const List<SV>&a);
SV Float4_getZW(CTX ctx,const List<SV>&a);
SV Float4_setZW(CTX ctx,const List<SV>&a);
SV Float4_getWX(CTX ctx,const List<SV>&a);
SV Float4_setWX(CTX ctx,const List<SV>&a);
SV Float4_getWY(CTX ctx,const List<SV>&a);
SV Float4_setWY(CTX ctx,const List<SV>&a);
SV Float4_getWZ(CTX ctx,const List<SV>&a);
SV Float4_setWZ(CTX ctx,const List<SV>&a);
SV Float4_getXYZ(CTX ctx,const List<SV>&a);
SV Float4_setXYZ(CTX ctx,const List<SV>&a);
SV Float4_getXYW(CTX ctx,const List<SV>&a);
SV Float4_setXYW(CTX ctx,const List<SV>&a);
SV Float4_getXZY(CTX ctx,const List<SV>&a);
SV Float4_setXZY(CTX ctx,const List<SV>&a);
SV Float4_getXZW(CTX ctx,const List<SV>&a);
SV Float4_setXZW(CTX ctx,const List<SV>&a);
SV Float4_getXWZ(CTX ctx,const List<SV>&a);
SV Float4_setXWZ(CTX ctx,const List<SV>&a);
SV Float4_getXWY(CTX ctx,const List<SV>&a);
SV Float4_setXWY(CTX ctx,const List<SV>&a);
SV Float4_getYXZ(CTX ctx,const List<SV>&a);
SV Float4_setYXZ(CTX ctx,const List<SV>&a);
SV Float4_getYXW(CTX ctx,const List<SV>&a);
SV Float4_setYXW(CTX ctx,const List<SV>&a);
SV Float4_getYZX(CTX ctx,const List<SV>&a);
SV Float4_setYZX(CTX ctx,const List<SV>&a);
SV Float4_getYZW(CTX ctx,const List<SV>&a);
SV Float4_setYZW(CTX ctx,const List<SV>&a);
SV Float4_getYWZ(CTX ctx,const List<SV>&a);
SV Float4_setYWZ(CTX ctx,const List<SV>&a);
SV Float4_getYWX(CTX ctx,const List<SV>&a);
SV Float4_setYWX(CTX ctx,const List<SV>&a);
SV Float4_getZXY(CTX ctx,const List<SV>&a);
SV Float4_setZXY(CTX ctx,const List<SV>&a);
SV Float4_getZXW(CTX ctx,const List<SV>&a);
SV Float4_setZXW(CTX ctx,const List<SV>&a);
SV Float4_getZYX(CTX ctx,const List<SV>&a);
SV Float4_setZYX(CTX ctx,const List<SV>&a);
SV Float4_getZYW(CTX ctx,const List<SV>&a);
SV Float4_setZYW(CTX ctx,const List<SV>&a);
SV Float4_getZWY(CTX ctx,const List<SV>&a);
SV Float4_setZWY(CTX ctx,const List<SV>&a);
SV Float4_getZWX(CTX ctx,const List<SV>&a);
SV Float4_setZWX(CTX ctx,const List<SV>&a);
SV Float4_getWXY(CTX ctx,const List<SV>&a);
SV Float4_setWXY(CTX ctx,const List<SV>&a);
SV Float4_getWXZ(CTX ctx,const List<SV>&a);
SV Float4_setWXZ(CTX ctx,const List<SV>&a);
SV Float4_getWYX(CTX ctx,const List<SV>&a);
SV Float4_setWYX(CTX ctx,const List<SV>&a);
SV Float4_getWYZ(CTX ctx,const List<SV>&a);
SV Float4_setWYZ(CTX ctx,const List<SV>&a);
SV Float4_getWZY(CTX ctx,const List<SV>&a);
SV Float4_setWZY(CTX ctx,const List<SV>&a);
SV Float4_getWZX(CTX ctx,const List<SV>&a);
SV Float4_setWZX(CTX ctx,const List<SV>&a);
SV Float4_getXYZW(CTX ctx,const List<SV>&a);
SV Float4_setXYZW(CTX ctx,const List<SV>&a);
SV Float4_getXYWZ(CTX ctx,const List<SV>&a);
SV Float4_setXYWZ(CTX ctx,const List<SV>&a);
SV Float4_getXZYW(CTX ctx,const List<SV>&a);
SV Float4_setXZYW(CTX ctx,const List<SV>&a);
SV Float4_getXZWY(CTX ctx,const List<SV>&a);
SV Float4_setXZWY(CTX ctx,const List<SV>&a);
SV Float4_getXWZY(CTX ctx,const List<SV>&a);
SV Float4_setXWZY(CTX ctx,const List<SV>&a);
SV Float4_getXWYZ(CTX ctx,const List<SV>&a);
SV Float4_setXWYZ(CTX ctx,const List<SV>&a);
SV Float4_getYXZW(CTX ctx,const List<SV>&a);
SV Float4_setYXZW(CTX ctx,const List<SV>&a);
SV Float4_getYXWZ(CTX ctx,const List<SV>&a);
SV Float4_setYXWZ(CTX ctx,const List<SV>&a);
SV Float4_getYZXW(CTX ctx,const List<SV>&a);
SV Float4_setYZXW(CTX ctx,const List<SV>&a);
SV Float4_getYZWX(CTX ctx,const List<SV>&a);
SV Float4_setYZWX(CTX ctx,const List<SV>&a);
SV Float4_getYWZX(CTX ctx,const List<SV>&a);
SV Float4_setYWZX(CTX ctx,const List<SV>&a);
SV Float4_getYWXZ(CTX ctx,const List<SV>&a);
SV Float4_setYWXZ(CTX ctx,const List<SV>&a);
SV Float4_getZYXW(CTX ctx,const List<SV>&a);
SV Float4_setZYXW(CTX ctx,const List<SV>&a);
SV Float4_getZYWX(CTX ctx,const List<SV>&a);
SV Float4_setZYWX(CTX ctx,const List<SV>&a);
SV Float4_getZXYW(CTX ctx,const List<SV>&a);
SV Float4_setZXYW(CTX ctx,const List<SV>&a);
SV Float4_getZXWY(CTX ctx,const List<SV>&a);
SV Float4_setZXWY(CTX ctx,const List<SV>&a);
SV Float4_getZWXY(CTX ctx,const List<SV>&a);
SV Float4_setZWXY(CTX ctx,const List<SV>&a);
SV Float4_getZWYX(CTX ctx,const List<SV>&a);
SV Float4_setZWYX(CTX ctx,const List<SV>&a);
SV Float4_getWYZX(CTX ctx,const List<SV>&a);
SV Float4_setWYZX(CTX ctx,const List<SV>&a);
SV Float4_getWYXZ(CTX ctx,const List<SV>&a);
SV Float4_setWYXZ(CTX ctx,const List<SV>&a);
SV Float4_getWZYX(CTX ctx,const List<SV>&a);
SV Float4_setWZYX(CTX ctx,const List<SV>&a);
SV Float4_getWZXY(CTX ctx,const List<SV>&a);
SV Float4_setWZXY(CTX ctx,const List<SV>&a);
SV Float4_getWXZY(CTX ctx,const List<SV>&a);
SV Float4_setWXZY(CTX ctx,const List<SV>&a);
SV Float4_getWXYZ(CTX ctx,const List<SV>&a);
SV Float4_setWXYZ(CTX ctx,const List<SV>&a);
SV Float4_copy(CTX ctx,const List<SV>&a);
void LightList_destroy(CTX,const SV&);
SV LightList_get_member(CTX,const SV&,const SV&);
void LightList_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs LightList_funcs={
.destroy = LightList_destroy,
.getMember = LightList_get_member,
.setMember = LightList_set_member
};
template <>
struct create_val<List<Light*>>
{
static SV f(CTX ctx,const List<Light*>&obj)
{
void *p = (void *)NEW(TYPE(List<Light*>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(LightList_funcs,p,EXT->LightList_typeID);
}
};
template <>
struct val_to_c<List<Light*>>
{
static List<Light*> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->LightList_typeID)
RET*((List<Light*>*)obj->data);
else
 CATE(TE,"Value can not be converted to LightList."));
} else
 CATE(TE,"Value can not be converted to LightList."));
}
};

template <>
struct val_to_c<const List<Light*>>
{
static List<Light*> f(CTX ctx,const SV val) {return val_to_c<List<Light*>>::f(ctx, val);}
};

template <>
struct create_val<const List<Light*>>
{
static SV f(CTX ctx,const List<Light*>&obj) {return create_val<List<Light*>>::f(ctx,obj);}
};

template <>
struct type_same<List<Light*>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->LightList_typeID;
else
 RET false;
}
};

SV LightList___eq__(CTX ctx,const List<SV>&a);
SV LightList___neq__(CTX ctx,const List<SV>&a);
SV LightList_get(CTX ctx,const List<SV>&a);
SV LightList_set(CTX ctx,const List<SV>&a);
SV LightList_getCount(CTX ctx,const List<SV>&a);
SV LightList_getData(CTX ctx,const List<SV>&a);
SV LightList_append(CTX ctx,const List<SV>&a);
SV LightList_insert(CTX ctx,const List<SV>&a);
SV LightList_remove(CTX ctx,const List<SV>&a);
SV LightList_clear(CTX ctx,const List<SV>&a);
SV LightList_find(CTX ctx,const List<SV>&a);
SV LightList_copy(CTX ctx,const List<SV>&a);
SV LightList_in(CTX ctx,const List<SV>&a);
SV LightList_reserve(CTX ctx,const List<SV>&a);
SV LightList_begin(CTX ctx,const List<SV>&a);
SV LightList_end(CTX ctx,const List<SV>&a);
void Float2_destroy(CTX,const SV&);
SV Float2_get_member(CTX,const SV&,const SV&);
void Float2_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Float2_funcs={
.destroy = Float2_destroy,
.getMember = Float2_get_member,
.setMember = Float2_set_member
};
template <>
struct create_val<T2<float>>
{
static SV f(CTX ctx,const T2<float>&obj)
{
void *p = (void *)NEW(TYPE(T2<float>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float2_funcs,p,EXT->Float2_typeID);
}
};
template <>
struct val_to_c<T2<float>>
{
static T2<float> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Float2_typeID)
RET*((T2<float>*)obj->data);
else
 CATE(TE,"Value can not be converted to Float2."));
} else
 CATE(TE,"Value can not be converted to Float2."));
}
};

template <>
struct val_to_c<const T2<float>>
{
static T2<float> f(CTX ctx,const SV val) {return val_to_c<T2<float>>::f(ctx, val);}
};

template <>
struct create_val<const T2<float>>
{
static SV f(CTX ctx,const T2<float>&obj) {return create_val<T2<float>>::f(ctx,obj);}
};

template <>
struct type_same<T2<float>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Float2_typeID;
else
 RET false;
}
};

SV Float2___add__(CTX ctx,const List<SV>&a);
SV Float2___sub__(CTX ctx,const List<SV>&a);
SV Float2___mul__(CTX ctx,const List<SV>&a);
SV Float2___div__(CTX ctx,const List<SV>&a);
SV Float2___eq__(CTX ctx,const List<SV>&a);
SV Float2___neq__(CTX ctx,const List<SV>&a);
SV Float2___less__(CTX ctx,const List<SV>&a);
SV Float2___grtr__(CTX ctx,const List<SV>&a);
SV Float2___leq__(CTX ctx,const List<SV>&a);
SV Float2___geq__(CTX ctx,const List<SV>&a);
SV Float2_sum(CTX ctx,const List<SV>&a);
SV Float2_length(CTX ctx,const List<SV>&a);
SV Float2_lengthSquared(CTX ctx,const List<SV>&a);
SV Float2_dot(CTX ctx,const List<SV>&a);
SV Float2_distance(CTX ctx,const List<SV>&a);
SV Float2_distanceSquared(CTX ctx,const List<SV>&a);
SV Float2_normalize(CTX ctx,const List<SV>&a);
SV Float2_getXY(CTX ctx,const List<SV>&a);
SV Float2_setXY(CTX ctx,const List<SV>&a);
SV Float2_getYX(CTX ctx,const List<SV>&a);
SV Float2_setYX(CTX ctx,const List<SV>&a);
SV Float2_copy(CTX ctx,const List<SV>&a);
void Float3_destroy(CTX,const SV&);
SV Float3_get_member(CTX,const SV&,const SV&);
void Float3_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Float3_funcs={
.destroy = Float3_destroy,
.getMember = Float3_get_member,
.setMember = Float3_set_member
};
template <>
struct create_val<T3<float>>
{
static SV f(CTX ctx,const T3<float>&obj)
{
void *p = (void *)NEW(TYPE(T3<float>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float3_funcs,p,EXT->Float3_typeID);
}
};
template <>
struct val_to_c<T3<float>>
{
static T3<float> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Float3_typeID)
RET*((T3<float>*)obj->data);
else
 CATE(TE,"Value can not be converted to Float3."));
} else
 CATE(TE,"Value can not be converted to Float3."));
}
};

template <>
struct val_to_c<const T3<float>>
{
static T3<float> f(CTX ctx,const SV val) {return val_to_c<T3<float>>::f(ctx, val);}
};

template <>
struct create_val<const T3<float>>
{
static SV f(CTX ctx,const T3<float>&obj) {return create_val<T3<float>>::f(ctx,obj);}
};

template <>
struct type_same<T3<float>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Float3_typeID;
else
 RET false;
}
};

SV Float3___add__(CTX ctx,const List<SV>&a);
SV Float3___sub__(CTX ctx,const List<SV>&a);
SV Float3___mul__(CTX ctx,const List<SV>&a);
SV Float3___div__(CTX ctx,const List<SV>&a);
SV Float3___eq__(CTX ctx,const List<SV>&a);
SV Float3___neq__(CTX ctx,const List<SV>&a);
SV Float3___less__(CTX ctx,const List<SV>&a);
SV Float3___grtr__(CTX ctx,const List<SV>&a);
SV Float3___leq__(CTX ctx,const List<SV>&a);
SV Float3___geq__(CTX ctx,const List<SV>&a);
SV Float3_sum(CTX ctx,const List<SV>&a);
SV Float3_length(CTX ctx,const List<SV>&a);
SV Float3_lengthSquared(CTX ctx,const List<SV>&a);
SV Float3_dot(CTX ctx,const List<SV>&a);
SV Float3_distance(CTX ctx,const List<SV>&a);
SV Float3_distanceSquared(CTX ctx,const List<SV>&a);
SV Float3_normalize(CTX ctx,const List<SV>&a);
SV Float3_cross(CTX ctx,const List<SV>&a);
SV Float3_getXY(CTX ctx,const List<SV>&a);
SV Float3_setXY(CTX ctx,const List<SV>&a);
SV Float3_getXZ(CTX ctx,const List<SV>&a);
SV Float3_setXZ(CTX ctx,const List<SV>&a);
SV Float3_getYX(CTX ctx,const List<SV>&a);
SV Float3_setYX(CTX ctx,const List<SV>&a);
SV Float3_getYZ(CTX ctx,const List<SV>&a);
SV Float3_setYZ(CTX ctx,const List<SV>&a);
SV Float3_getZX(CTX ctx,const List<SV>&a);
SV Float3_setZX(CTX ctx,const List<SV>&a);
SV Float3_getZY(CTX ctx,const List<SV>&a);
SV Float3_setZY(CTX ctx,const List<SV>&a);
SV Float3_getXYZ(CTX ctx,const List<SV>&a);
SV Float3_setXYZ(CTX ctx,const List<SV>&a);
SV Float3_getXZY(CTX ctx,const List<SV>&a);
SV Float3_setXZY(CTX ctx,const List<SV>&a);
SV Float3_getYXZ(CTX ctx,const List<SV>&a);
SV Float3_setYXZ(CTX ctx,const List<SV>&a);
SV Float3_getYZX(CTX ctx,const List<SV>&a);
SV Float3_setYZX(CTX ctx,const List<SV>&a);
SV Float3_getZXY(CTX ctx,const List<SV>&a);
SV Float3_setZXY(CTX ctx,const List<SV>&a);
SV Float3_getZYX(CTX ctx,const List<SV>&a);
SV Float3_setZYX(CTX ctx,const List<SV>&a);
SV Float3_copy(CTX ctx,const List<SV>&a);
void Container_destroy(CTX,const SV&);
SV Container_get_member(CTX,const SV&,const SV&);
void Container_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Container_funcs={
.destroy = Container_destroy,
.getMember = Container_get_member,
.setMember = Container_set_member
};
template <>
struct create_val<Container>
{
static SV f(CTX ctx,const Container&obj)
{
void *p = (void *)NEW(TYPE(Container), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Container_funcs,p,EXT->Container_typeID);
}
};
template <>
struct val_to_c<Container>
{
static Container f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Container_typeID)
RET*((Container*)obj->data);
else
 CATE(TE,"Value can not be converted to Container."));
} else
 CATE(TE,"Value can not be converted to Container."));
}
};

template <>
struct val_to_c<const Container>
{
static Container f(CTX ctx,const SV val) {return val_to_c<Container>::f(ctx, val);}
};

template <>
struct create_val<const Container>
{
static SV f(CTX ctx,const Container&obj) {return create_val<Container>::f(ctx,obj);}
};

template <>
struct type_same<Container>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Container_typeID;
else
 RET false;
}
};

void Frustum_destroy(CTX,const SV&);
SV Frustum_get_member(CTX,const SV&,const SV&);
void Frustum_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Frustum_funcs={
.destroy = Frustum_destroy,
.getMember = Frustum_get_member,
.setMember = Frustum_set_member
};
template <>
struct create_val<Frustum>
{
static SV f(CTX ctx,const Frustum&obj)
{
void *p = (void *)NEW(TYPE(Frustum), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Frustum_funcs,p,EXT->Frustum_typeID);
}
};
template <>
struct val_to_c<Frustum>
{
static Frustum f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Frustum_typeID)
RET*((Frustum*)obj->data);
else
 CATE(TE,"Value can not be converted to Frustum."));
} else
 CATE(TE,"Value can not be converted to Frustum."));
}
};

template <>
struct val_to_c<const Frustum>
{
static Frustum f(CTX ctx,const SV val) {return val_to_c<Frustum>::f(ctx, val);}
};

template <>
struct create_val<const Frustum>
{
static SV f(CTX ctx,const Frustum&obj) {return create_val<Frustum>::f(ctx,obj);}
};

template <>
struct type_same<Frustum>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Frustum_typeID;
else
 RET false;
}
};

SV Frustum_getOrigin(CTX ctx,const List<SV>&a);
SV Frustum_getCorner(CTX ctx,const List<SV>&a);
SV Frustum_getPlane(CTX ctx,const List<SV>&a);
SV Frustum_view(CTX ctx,const List<SV>&a);
SV Frustum_box(CTX ctx,const List<SV>&a);
SV Frustum_getAABB(CTX ctx,const List<SV>&a);
SV Frustum_sphereIntersection(CTX ctx,const List<SV>&a);
SV Frustum_aabbIntersection(CTX ctx,const List<SV>&a);
void AudioDevice_destroy(CTX,const SV&);
SV AudioDevice_get_member(CTX,const SV&,const SV&);
void AudioDevice_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs AudioDevice_funcs={
.destroy = AudioDevice_destroy,
.getMember = AudioDevice_get_member,
.setMember = AudioDevice_set_member
};
template <>
struct create_val<AudioDevice>
{
static SV f(CTX ctx,const AudioDevice&obj)
{
void *p = (void *)NEW(TYPE(AudioDevice), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(AudioDevice_funcs,p,EXT->AudioDevice_typeID);
}
};
template <>
struct val_to_c<AudioDevice>
{
static AudioDevice f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->AudioDevice_typeID)
RET*((AudioDevice*)obj->data);
else
 CATE(TE,"Value can not be converted to AudioDevice."));
} else
 CATE(TE,"Value can not be converted to AudioDevice."));
}
};

template <>
struct val_to_c<const AudioDevice>
{
static AudioDevice f(CTX ctx,const SV val) {return val_to_c<AudioDevice>::f(ctx, val);}
};

template <>
struct create_val<const AudioDevice>
{
static SV f(CTX ctx,const AudioDevice&obj) {return create_val<AudioDevice>::f(ctx,obj);}
};

template <>
struct type_same<AudioDevice>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->AudioDevice_typeID;
else
 RET false;
}
};

SV AudioDevice_getName(CTX ctx,const List<SV>&a);
SV AudioDevice_getDeviceCount(CTX ctx,const List<SV>&a);
SV AudioDevice_setIndex(CTX ctx,const List<SV>&a);
SV AudioDevice_setFrequency(CTX ctx,const List<SV>&a);
SV AudioDevice_setSamples(CTX ctx,const List<SV>&a);
SV AudioDevice_getIndex(CTX ctx,const List<SV>&a);
SV AudioDevice_getFrequency(CTX ctx,const List<SV>&a);
SV AudioDevice_getSamples(CTX ctx,const List<SV>&a);
SV AudioDevice_getNumQueuedSamples(CTX ctx,const List<SV>&a);
SV AudioDevice_pause(CTX ctx,const List<SV>&a);
SV AudioDevice_play(CTX ctx,const List<SV>&a);
SV AudioDevice_getPaused(CTX ctx,const List<SV>&a);
SV AudioDevice_runCallbacks(CTX ctx,const List<SV>&a);
void UInt4_destroy(CTX,const SV&);
SV UInt4_get_member(CTX,const SV&,const SV&);
void UInt4_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs UInt4_funcs={
.destroy = UInt4_destroy,
.getMember = UInt4_get_member,
.setMember = UInt4_set_member
};
template <>
struct create_val<T4<uint32_t>>
{
static SV f(CTX ctx,const T4<uint32_t>&obj)
{
void *p = (void *)NEW(TYPE(T4<uint32_t>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt4_funcs,p,EXT->UInt4_typeID);
}
};
template <>
struct val_to_c<T4<uint32_t>>
{
static T4<uint32_t> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->UInt4_typeID)
RET*((T4<uint32_t>*)obj->data);
else
 CATE(TE,"Value can not be converted to UInt4."));
} else
 CATE(TE,"Value can not be converted to UInt4."));
}
};

template <>
struct val_to_c<const T4<uint32_t>>
{
static T4<uint32_t> f(CTX ctx,const SV val) {return val_to_c<T4<uint32_t>>::f(ctx, val);}
};

template <>
struct create_val<const T4<uint32_t>>
{
static SV f(CTX ctx,const T4<uint32_t>&obj) {return create_val<T4<uint32_t>>::f(ctx,obj);}
};

template <>
struct type_same<T4<uint32_t>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->UInt4_typeID;
else
 RET false;
}
};

SV UInt4___add__(CTX ctx,const List<SV>&a);
SV UInt4___sub__(CTX ctx,const List<SV>&a);
SV UInt4___mul__(CTX ctx,const List<SV>&a);
SV UInt4___div__(CTX ctx,const List<SV>&a);
SV UInt4___eq__(CTX ctx,const List<SV>&a);
SV UInt4___neq__(CTX ctx,const List<SV>&a);
SV UInt4___less__(CTX ctx,const List<SV>&a);
SV UInt4___grtr__(CTX ctx,const List<SV>&a);
SV UInt4___leq__(CTX ctx,const List<SV>&a);
SV UInt4___geq__(CTX ctx,const List<SV>&a);
SV UInt4_sum(CTX ctx,const List<SV>&a);
SV UInt4_length(CTX ctx,const List<SV>&a);
SV UInt4_lengthSquared(CTX ctx,const List<SV>&a);
SV UInt4_dot(CTX ctx,const List<SV>&a);
SV UInt4_distance(CTX ctx,const List<SV>&a);
SV UInt4_distanceSquared(CTX ctx,const List<SV>&a);
SV UInt4_normalize(CTX ctx,const List<SV>&a);
SV UInt4_getXY(CTX ctx,const List<SV>&a);
SV UInt4_setXY(CTX ctx,const List<SV>&a);
SV UInt4_getXZ(CTX ctx,const List<SV>&a);
SV UInt4_setXZ(CTX ctx,const List<SV>&a);
SV UInt4_getXW(CTX ctx,const List<SV>&a);
SV UInt4_setXW(CTX ctx,const List<SV>&a);
SV UInt4_getYX(CTX ctx,const List<SV>&a);
SV UInt4_setYX(CTX ctx,const List<SV>&a);
SV UInt4_getYZ(CTX ctx,const List<SV>&a);
SV UInt4_setYZ(CTX ctx,const List<SV>&a);
SV UInt4_getYW(CTX ctx,const List<SV>&a);
SV UInt4_setYW(CTX ctx,const List<SV>&a);
SV UInt4_getZX(CTX ctx,const List<SV>&a);
SV UInt4_setZX(CTX ctx,const List<SV>&a);
SV UInt4_getZY(CTX ctx,const List<SV>&a);
SV UInt4_setZY(CTX ctx,const List<SV>&a);
SV UInt4_getZW(CTX ctx,const List<SV>&a);
SV UInt4_setZW(CTX ctx,const List<SV>&a);
SV UInt4_getWX(CTX ctx,const List<SV>&a);
SV UInt4_setWX(CTX ctx,const List<SV>&a);
SV UInt4_getWY(CTX ctx,const List<SV>&a);
SV UInt4_setWY(CTX ctx,const List<SV>&a);
SV UInt4_getWZ(CTX ctx,const List<SV>&a);
SV UInt4_setWZ(CTX ctx,const List<SV>&a);
SV UInt4_getXYZ(CTX ctx,const List<SV>&a);
SV UInt4_setXYZ(CTX ctx,const List<SV>&a);
SV UInt4_getXYW(CTX ctx,const List<SV>&a);
SV UInt4_setXYW(CTX ctx,const List<SV>&a);
SV UInt4_getXZY(CTX ctx,const List<SV>&a);
SV UInt4_setXZY(CTX ctx,const List<SV>&a);
SV UInt4_getXZW(CTX ctx,const List<SV>&a);
SV UInt4_setXZW(CTX ctx,const List<SV>&a);
SV UInt4_getXWZ(CTX ctx,const List<SV>&a);
SV UInt4_setXWZ(CTX ctx,const List<SV>&a);
SV UInt4_getXWY(CTX ctx,const List<SV>&a);
SV UInt4_setXWY(CTX ctx,const List<SV>&a);
SV UInt4_getYXZ(CTX ctx,const List<SV>&a);
SV UInt4_setYXZ(CTX ctx,const List<SV>&a);
SV UInt4_getYXW(CTX ctx,const List<SV>&a);
SV UInt4_setYXW(CTX ctx,const List<SV>&a);
SV UInt4_getYZX(CTX ctx,const List<SV>&a);
SV UInt4_setYZX(CTX ctx,const List<SV>&a);
SV UInt4_getYZW(CTX ctx,const List<SV>&a);
SV UInt4_setYZW(CTX ctx,const List<SV>&a);
SV UInt4_getYWZ(CTX ctx,const List<SV>&a);
SV UInt4_setYWZ(CTX ctx,const List<SV>&a);
SV UInt4_getYWX(CTX ctx,const List<SV>&a);
SV UInt4_setYWX(CTX ctx,const List<SV>&a);
SV UInt4_getZXY(CTX ctx,const List<SV>&a);
SV UInt4_setZXY(CTX ctx,const List<SV>&a);
SV UInt4_getZXW(CTX ctx,const List<SV>&a);
SV UInt4_setZXW(CTX ctx,const List<SV>&a);
SV UInt4_getZYX(CTX ctx,const List<SV>&a);
SV UInt4_setZYX(CTX ctx,const List<SV>&a);
SV UInt4_getZYW(CTX ctx,const List<SV>&a);
SV UInt4_setZYW(CTX ctx,const List<SV>&a);
SV UInt4_getZWY(CTX ctx,const List<SV>&a);
SV UInt4_setZWY(CTX ctx,const List<SV>&a);
SV UInt4_getZWX(CTX ctx,const List<SV>&a);
SV UInt4_setZWX(CTX ctx,const List<SV>&a);
SV UInt4_getWXY(CTX ctx,const List<SV>&a);
SV UInt4_setWXY(CTX ctx,const List<SV>&a);
SV UInt4_getWXZ(CTX ctx,const List<SV>&a);
SV UInt4_setWXZ(CTX ctx,const List<SV>&a);
SV UInt4_getWYX(CTX ctx,const List<SV>&a);
SV UInt4_setWYX(CTX ctx,const List<SV>&a);
SV UInt4_getWYZ(CTX ctx,const List<SV>&a);
SV UInt4_setWYZ(CTX ctx,const List<SV>&a);
SV UInt4_getWZY(CTX ctx,const List<SV>&a);
SV UInt4_setWZY(CTX ctx,const List<SV>&a);
SV UInt4_getWZX(CTX ctx,const List<SV>&a);
SV UInt4_setWZX(CTX ctx,const List<SV>&a);
SV UInt4_getXYZW(CTX ctx,const List<SV>&a);
SV UInt4_setXYZW(CTX ctx,const List<SV>&a);
SV UInt4_getXYWZ(CTX ctx,const List<SV>&a);
SV UInt4_setXYWZ(CTX ctx,const List<SV>&a);
SV UInt4_getXZYW(CTX ctx,const List<SV>&a);
SV UInt4_setXZYW(CTX ctx,const List<SV>&a);
SV UInt4_getXZWY(CTX ctx,const List<SV>&a);
SV UInt4_setXZWY(CTX ctx,const List<SV>&a);
SV UInt4_getXWZY(CTX ctx,const List<SV>&a);
SV UInt4_setXWZY(CTX ctx,const List<SV>&a);
SV UInt4_getXWYZ(CTX ctx,const List<SV>&a);
SV UInt4_setXWYZ(CTX ctx,const List<SV>&a);
SV UInt4_getYXZW(CTX ctx,const List<SV>&a);
SV UInt4_setYXZW(CTX ctx,const List<SV>&a);
SV UInt4_getYXWZ(CTX ctx,const List<SV>&a);
SV UInt4_setYXWZ(CTX ctx,const List<SV>&a);
SV UInt4_getYZXW(CTX ctx,const List<SV>&a);
SV UInt4_setYZXW(CTX ctx,const List<SV>&a);
SV UInt4_getYZWX(CTX ctx,const List<SV>&a);
SV UInt4_setYZWX(CTX ctx,const List<SV>&a);
SV UInt4_getYWZX(CTX ctx,const List<SV>&a);
SV UInt4_setYWZX(CTX ctx,const List<SV>&a);
SV UInt4_getYWXZ(CTX ctx,const List<SV>&a);
SV UInt4_setYWXZ(CTX ctx,const List<SV>&a);
SV UInt4_getZYXW(CTX ctx,const List<SV>&a);
SV UInt4_setZYXW(CTX ctx,const List<SV>&a);
SV UInt4_getZYWX(CTX ctx,const List<SV>&a);
SV UInt4_setZYWX(CTX ctx,const List<SV>&a);
SV UInt4_getZXYW(CTX ctx,const List<SV>&a);
SV UInt4_setZXYW(CTX ctx,const List<SV>&a);
SV UInt4_getZXWY(CTX ctx,const List<SV>&a);
SV UInt4_setZXWY(CTX ctx,const List<SV>&a);
SV UInt4_getZWXY(CTX ctx,const List<SV>&a);
SV UInt4_setZWXY(CTX ctx,const List<SV>&a);
SV UInt4_getZWYX(CTX ctx,const List<SV>&a);
SV UInt4_setZWYX(CTX ctx,const List<SV>&a);
SV UInt4_getWYZX(CTX ctx,const List<SV>&a);
SV UInt4_setWYZX(CTX ctx,const List<SV>&a);
SV UInt4_getWYXZ(CTX ctx,const List<SV>&a);
SV UInt4_setWYXZ(CTX ctx,const List<SV>&a);
SV UInt4_getWZYX(CTX ctx,const List<SV>&a);
SV UInt4_setWZYX(CTX ctx,const List<SV>&a);
SV UInt4_getWZXY(CTX ctx,const List<SV>&a);
SV UInt4_setWZXY(CTX ctx,const List<SV>&a);
SV UInt4_getWXZY(CTX ctx,const List<SV>&a);
SV UInt4_setWXZY(CTX ctx,const List<SV>&a);
SV UInt4_getWXYZ(CTX ctx,const List<SV>&a);
SV UInt4_setWXYZ(CTX ctx,const List<SV>&a);
SV UInt4_copy(CTX ctx,const List<SV>&a);
void UInt3_destroy(CTX,const SV&);
SV UInt3_get_member(CTX,const SV&,const SV&);
void UInt3_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs UInt3_funcs={
.destroy = UInt3_destroy,
.getMember = UInt3_get_member,
.setMember = UInt3_set_member
};
template <>
struct create_val<T3<uint32_t>>
{
static SV f(CTX ctx,const T3<uint32_t>&obj)
{
void *p = (void *)NEW(TYPE(T3<uint32_t>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt3_funcs,p,EXT->UInt3_typeID);
}
};
template <>
struct val_to_c<T3<uint32_t>>
{
static T3<uint32_t> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->UInt3_typeID)
RET*((T3<uint32_t>*)obj->data);
else
 CATE(TE,"Value can not be converted to UInt3."));
} else
 CATE(TE,"Value can not be converted to UInt3."));
}
};

template <>
struct val_to_c<const T3<uint32_t>>
{
static T3<uint32_t> f(CTX ctx,const SV val) {return val_to_c<T3<uint32_t>>::f(ctx, val);}
};

template <>
struct create_val<const T3<uint32_t>>
{
static SV f(CTX ctx,const T3<uint32_t>&obj) {return create_val<T3<uint32_t>>::f(ctx,obj);}
};

template <>
struct type_same<T3<uint32_t>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->UInt3_typeID;
else
 RET false;
}
};

SV UInt3___add__(CTX ctx,const List<SV>&a);
SV UInt3___sub__(CTX ctx,const List<SV>&a);
SV UInt3___mul__(CTX ctx,const List<SV>&a);
SV UInt3___div__(CTX ctx,const List<SV>&a);
SV UInt3___eq__(CTX ctx,const List<SV>&a);
SV UInt3___neq__(CTX ctx,const List<SV>&a);
SV UInt3___less__(CTX ctx,const List<SV>&a);
SV UInt3___grtr__(CTX ctx,const List<SV>&a);
SV UInt3___leq__(CTX ctx,const List<SV>&a);
SV UInt3___geq__(CTX ctx,const List<SV>&a);
SV UInt3_sum(CTX ctx,const List<SV>&a);
SV UInt3_length(CTX ctx,const List<SV>&a);
SV UInt3_lengthSquared(CTX ctx,const List<SV>&a);
SV UInt3_dot(CTX ctx,const List<SV>&a);
SV UInt3_distance(CTX ctx,const List<SV>&a);
SV UInt3_distanceSquared(CTX ctx,const List<SV>&a);
SV UInt3_normalize(CTX ctx,const List<SV>&a);
SV UInt3_cross(CTX ctx,const List<SV>&a);
SV UInt3_getXY(CTX ctx,const List<SV>&a);
SV UInt3_setXY(CTX ctx,const List<SV>&a);
SV UInt3_getXZ(CTX ctx,const List<SV>&a);
SV UInt3_setXZ(CTX ctx,const List<SV>&a);
SV UInt3_getYX(CTX ctx,const List<SV>&a);
SV UInt3_setYX(CTX ctx,const List<SV>&a);
SV UInt3_getYZ(CTX ctx,const List<SV>&a);
SV UInt3_setYZ(CTX ctx,const List<SV>&a);
SV UInt3_getZX(CTX ctx,const List<SV>&a);
SV UInt3_setZX(CTX ctx,const List<SV>&a);
SV UInt3_getZY(CTX ctx,const List<SV>&a);
SV UInt3_setZY(CTX ctx,const List<SV>&a);
SV UInt3_getXYZ(CTX ctx,const List<SV>&a);
SV UInt3_setXYZ(CTX ctx,const List<SV>&a);
SV UInt3_getXZY(CTX ctx,const List<SV>&a);
SV UInt3_setXZY(CTX ctx,const List<SV>&a);
SV UInt3_getYXZ(CTX ctx,const List<SV>&a);
SV UInt3_setYXZ(CTX ctx,const List<SV>&a);
SV UInt3_getYZX(CTX ctx,const List<SV>&a);
SV UInt3_setYZX(CTX ctx,const List<SV>&a);
SV UInt3_getZXY(CTX ctx,const List<SV>&a);
SV UInt3_setZXY(CTX ctx,const List<SV>&a);
SV UInt3_getZYX(CTX ctx,const List<SV>&a);
SV UInt3_setZYX(CTX ctx,const List<SV>&a);
SV UInt3_copy(CTX ctx,const List<SV>&a);
void UInt2_destroy(CTX,const SV&);
SV UInt2_get_member(CTX,const SV&,const SV&);
void UInt2_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs UInt2_funcs={
.destroy = UInt2_destroy,
.getMember = UInt2_get_member,
.setMember = UInt2_set_member
};
template <>
struct create_val<T2<uint32_t>>
{
static SV f(CTX ctx,const T2<uint32_t>&obj)
{
void *p = (void *)NEW(TYPE(T2<uint32_t>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt2_funcs,p,EXT->UInt2_typeID);
}
};
template <>
struct val_to_c<T2<uint32_t>>
{
static T2<uint32_t> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->UInt2_typeID)
RET*((T2<uint32_t>*)obj->data);
else
 CATE(TE,"Value can not be converted to UInt2."));
} else
 CATE(TE,"Value can not be converted to UInt2."));
}
};

template <>
struct val_to_c<const T2<uint32_t>>
{
static T2<uint32_t> f(CTX ctx,const SV val) {return val_to_c<T2<uint32_t>>::f(ctx, val);}
};

template <>
struct create_val<const T2<uint32_t>>
{
static SV f(CTX ctx,const T2<uint32_t>&obj) {return create_val<T2<uint32_t>>::f(ctx,obj);}
};

template <>
struct type_same<T2<uint32_t>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->UInt2_typeID;
else
 RET false;
}
};

SV UInt2___add__(CTX ctx,const List<SV>&a);
SV UInt2___sub__(CTX ctx,const List<SV>&a);
SV UInt2___mul__(CTX ctx,const List<SV>&a);
SV UInt2___div__(CTX ctx,const List<SV>&a);
SV UInt2___eq__(CTX ctx,const List<SV>&a);
SV UInt2___neq__(CTX ctx,const List<SV>&a);
SV UInt2___less__(CTX ctx,const List<SV>&a);
SV UInt2___grtr__(CTX ctx,const List<SV>&a);
SV UInt2___leq__(CTX ctx,const List<SV>&a);
SV UInt2___geq__(CTX ctx,const List<SV>&a);
SV UInt2_sum(CTX ctx,const List<SV>&a);
SV UInt2_length(CTX ctx,const List<SV>&a);
SV UInt2_lengthSquared(CTX ctx,const List<SV>&a);
SV UInt2_dot(CTX ctx,const List<SV>&a);
SV UInt2_distance(CTX ctx,const List<SV>&a);
SV UInt2_distanceSquared(CTX ctx,const List<SV>&a);
SV UInt2_normalize(CTX ctx,const List<SV>&a);
SV UInt2_getXY(CTX ctx,const List<SV>&a);
SV UInt2_setXY(CTX ctx,const List<SV>&a);
SV UInt2_getYX(CTX ctx,const List<SV>&a);
SV UInt2_setYX(CTX ctx,const List<SV>&a);
SV UInt2_copy(CTX ctx,const List<SV>&a);
void AABB_destroy(CTX,const SV&);
SV AABB_get_member(CTX,const SV&,const SV&);
void AABB_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs AABB_funcs={
.destroy = AABB_destroy,
.getMember = AABB_get_member,
.setMember = AABB_set_member
};
template <>
struct create_val<AABB>
{
static SV f(CTX ctx,const AABB&obj)
{
void *p = (void *)NEW(TYPE(AABB), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(AABB_funcs,p,EXT->AABB_typeID);
}
};
template <>
struct val_to_c<AABB>
{
static AABB f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->AABB_typeID)
RET*((AABB*)obj->data);
else
 CATE(TE,"Value can not be converted to AABB."));
} else
 CATE(TE,"Value can not be converted to AABB."));
}
};

template <>
struct val_to_c<const AABB>
{
static AABB f(CTX ctx,const SV val) {return val_to_c<AABB>::f(ctx, val);}
};

template <>
struct create_val<const AABB>
{
static SV f(CTX ctx,const AABB&obj) {return create_val<AABB>::f(ctx,obj);}
};

template <>
struct type_same<AABB>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->AABB_typeID;
else
 RET false;
}
};

SV AABB_transform(CTX ctx,const List<SV>&a);
SV AABB_extend(CTX ctx,const List<SV>&a);
SV AABB_grow(CTX ctx,const List<SV>&a);
SV AABB_getCorner(CTX ctx,const List<SV>&a);
SV AABB_intersection(CTX ctx,const List<SV>&a);
void Scene_destroy(CTX,const SV&);
SV Scene_get_member(CTX,const SV&,const SV&);
void Scene_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Scene_funcs={
.destroy = Scene_destroy,
.getMember = Scene_get_member,
.setMember = Scene_set_member
};
template <>
struct type_same<Scene>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Scene_typeID;
else
 RET false;
}
};

SV Scene_removeContent(CTX ctx,const List<SV>&a);
SV Scene_handleInput(CTX ctx,const List<SV>&a);
SV Scene_update(CTX ctx,const List<SV>&a);
SV Scene_fixedUpdate(CTX ctx,const List<SV>&a);
SV Scene_render(CTX ctx,const List<SV>&a);
SV Scene_getPhysicsWorld(CTX ctx,const List<SV>&a);
SV Scene_getRenderer(CTX ctx,const List<SV>&a);
SV Scene_getAudioWorld(CTX ctx,const List<SV>&a);
SV Scene_save(CTX ctx,const List<SV>&a);
SV Scene_createEntity(CTX ctx,const List<SV>&a);
SV Scene_removeEntity(CTX ctx,const List<SV>&a);
SV Scene_findEntity(CTX ctx,const List<SV>&a);
SV Scene_getEntities(CTX ctx,const List<SV>&a);
SV Scene_addScript(CTX ctx,const List<SV>&a);
SV Scene_removeScript(CTX ctx,const List<SV>&a);
SV Scene_getScripts(CTX ctx,const List<SV>&a);
SV Scene_findScriptInstance(CTX ctx,const List<SV>&a);
SV Scene_load(CTX ctx,const List<SV>&a);
SV Scene_copy(CTX ctx,const List<SV>&a);
SV Scene_getType(CTX ctx,const List<SV>&a);
SV Scene_release(CTX ctx,const List<SV>&a);
SV Scene_getRefCount(CTX ctx,const List<SV>&a);
SV Scene_getFilename(CTX ctx,const List<SV>&a);
SV Scene_setFilename(CTX ctx,const List<SV>&a);
void GfxSubModelList_destroy(CTX,const SV&);
SV GfxSubModelList_get_member(CTX,const SV&,const SV&);
void GfxSubModelList_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxSubModelList_funcs={
.destroy = GfxSubModelList_destroy,
.getMember = GfxSubModelList_get_member,
.setMember = GfxSubModelList_set_member
};
template <>
struct create_val<List<GfxModel::SubModel>>
{
static SV f(CTX ctx,const List<GfxModel::SubModel>&obj)
{
void *p = (void *)NEW(TYPE(List<GfxModel::SubModel>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxSubModelList_funcs,p,EXT->GfxSubModelList_typeID);
}
};
template <>
struct val_to_c<List<GfxModel::SubModel>>
{
static List<GfxModel::SubModel> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxSubModelList_typeID)
RET*((List<GfxModel::SubModel>*)obj->data);
else
 CATE(TE,"Value can not be converted to GfxSubModelList."));
} else
 CATE(TE,"Value can not be converted to GfxSubModelList."));
}
};

template <>
struct val_to_c<const List<GfxModel::SubModel>>
{
static List<GfxModel::SubModel> f(CTX ctx,const SV val) {return val_to_c<List<GfxModel::SubModel>>::f(ctx, val);}
};

template <>
struct create_val<const List<GfxModel::SubModel>>
{
static SV f(CTX ctx,const List<GfxModel::SubModel>&obj) {return create_val<List<GfxModel::SubModel>>::f(ctx,obj);}
};

template <>
struct type_same<List<GfxModel::SubModel>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxSubModelList_typeID;
else
 RET false;
}
};

SV GfxSubModelList___eq__(CTX ctx,const List<SV>&a);
SV GfxSubModelList___neq__(CTX ctx,const List<SV>&a);
SV GfxSubModelList_get(CTX ctx,const List<SV>&a);
SV GfxSubModelList_set(CTX ctx,const List<SV>&a);
SV GfxSubModelList_getCount(CTX ctx,const List<SV>&a);
SV GfxSubModelList_getData(CTX ctx,const List<SV>&a);
SV GfxSubModelList_append(CTX ctx,const List<SV>&a);
SV GfxSubModelList_insert(CTX ctx,const List<SV>&a);
SV GfxSubModelList_remove(CTX ctx,const List<SV>&a);
SV GfxSubModelList_clear(CTX ctx,const List<SV>&a);
SV GfxSubModelList_find(CTX ctx,const List<SV>&a);
SV GfxSubModelList_copy(CTX ctx,const List<SV>&a);
SV GfxSubModelList_in(CTX ctx,const List<SV>&a);
SV GfxSubModelList_reserve(CTX ctx,const List<SV>&a);
SV GfxSubModelList_begin(CTX ctx,const List<SV>&a);
SV GfxSubModelList_end(CTX ctx,const List<SV>&a);
void GfxDebugDrawer_destroy(CTX,const SV&);
SV GfxDebugDrawer_get_member(CTX,const SV&,const SV&);
void GfxDebugDrawer_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxDebugDrawer_funcs={
.destroy = GfxDebugDrawer_destroy,
.getMember = GfxDebugDrawer_get_member,
.setMember = GfxDebugDrawer_set_member
};
template <>
struct type_same<GfxDebugDrawer>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxDebugDrawer_typeID;
else
 RET false;
}
};

SV GfxDebugDrawer_addLine(CTX ctx,const List<SV>&a);
SV GfxDebugDrawer_addBox(CTX ctx,const List<SV>&a);
SV GfxDebugDrawer_render(CTX ctx,const List<SV>&a);
void GuiPlacer_destroy(CTX,const SV&);
SV GuiPlacer_get_member(CTX,const SV&,const SV&);
void GuiPlacer_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GuiPlacer_funcs={
.destroy = GuiPlacer_destroy,
.getMember = GuiPlacer_get_member,
.setMember = GuiPlacer_set_member
};
template <>
struct create_val<GuiPlacer>
{
static SV f(CTX ctx,const GuiPlacer&obj)
{
void *p = (void *)NEW(TYPE(GuiPlacer), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GuiPlacer_funcs,p,EXT->GuiPlacer_typeID);
}
};
template <>
struct val_to_c<GuiPlacer>
{
static GuiPlacer f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GuiPlacer_typeID)
RET*((GuiPlacer*)obj->data);
else
 CATE(TE,"Value can not be converted to GuiPlacer."));
} else
 CATE(TE,"Value can not be converted to GuiPlacer."));
}
};

template <>
struct val_to_c<const GuiPlacer>
{
static GuiPlacer f(CTX ctx,const SV val) {return val_to_c<GuiPlacer>::f(ctx, val);}
};

template <>
struct create_val<const GuiPlacer>
{
static SV f(CTX ctx,const GuiPlacer&obj) {return create_val<GuiPlacer>::f(ctx,obj);}
};

template <>
struct type_same<GuiPlacer>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GuiPlacer_typeID;
else
 RET false;
}
};

SV GuiPlacer_button(CTX ctx,const List<SV>&a);
SV GuiPlacer_label(CTX ctx,const List<SV>&a);
SV GuiPlacer_placer(CTX ctx,const List<SV>&a);
SV GuiPlacer_advanceY(CTX ctx,const List<SV>&a);
SV GuiPlacer_resetY(CTX ctx,const List<SV>&a);
SV GuiPlacer_setXOrigin(CTX ctx,const List<SV>&a);
SV GuiPlacer_getXOriginMode(CTX ctx,const List<SV>&a);
SV GuiPlacer_getXOrigin(CTX ctx,const List<SV>&a);
SV GuiPlacer_getPadding(CTX ctx,const List<SV>&a);
void GhostObjList_destroy(CTX,const SV&);
SV GhostObjList_get_member(CTX,const SV&,const SV&);
void GhostObjList_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GhostObjList_funcs={
.destroy = GhostObjList_destroy,
.getMember = GhostObjList_get_member,
.setMember = GhostObjList_set_member
};
template <>
struct create_val<List<GhostObject*>>
{
static SV f(CTX ctx,const List<GhostObject*>&obj)
{
void *p = (void *)NEW(TYPE(List<GhostObject*>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GhostObjList_funcs,p,EXT->GhostObjList_typeID);
}
};
template <>
struct val_to_c<List<GhostObject*>>
{
static List<GhostObject*> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GhostObjList_typeID)
RET*((List<GhostObject*>*)obj->data);
else
 CATE(TE,"Value can not be converted to GhostObjList."));
} else
 CATE(TE,"Value can not be converted to GhostObjList."));
}
};

template <>
struct val_to_c<const List<GhostObject*>>
{
static List<GhostObject*> f(CTX ctx,const SV val) {return val_to_c<List<GhostObject*>>::f(ctx, val);}
};

template <>
struct create_val<const List<GhostObject*>>
{
static SV f(CTX ctx,const List<GhostObject*>&obj) {return create_val<List<GhostObject*>>::f(ctx,obj);}
};

template <>
struct type_same<List<GhostObject*>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GhostObjList_typeID;
else
 RET false;
}
};

SV GhostObjList___eq__(CTX ctx,const List<SV>&a);
SV GhostObjList___neq__(CTX ctx,const List<SV>&a);
SV GhostObjList_get(CTX ctx,const List<SV>&a);
SV GhostObjList_set(CTX ctx,const List<SV>&a);
SV GhostObjList_getCount(CTX ctx,const List<SV>&a);
SV GhostObjList_getData(CTX ctx,const List<SV>&a);
SV GhostObjList_append(CTX ctx,const List<SV>&a);
SV GhostObjList_insert(CTX ctx,const List<SV>&a);
SV GhostObjList_remove(CTX ctx,const List<SV>&a);
SV GhostObjList_clear(CTX ctx,const List<SV>&a);
SV GhostObjList_find(CTX ctx,const List<SV>&a);
SV GhostObjList_copy(CTX ctx,const List<SV>&a);
SV GhostObjList_in(CTX ctx,const List<SV>&a);
SV GhostObjList_reserve(CTX ctx,const List<SV>&a);
SV GhostObjList_begin(CTX ctx,const List<SV>&a);
SV GhostObjList_end(CTX ctx,const List<SV>&a);
void PhysicsWorld_destroy(CTX,const SV&);
SV PhysicsWorld_get_member(CTX,const SV&,const SV&);
void PhysicsWorld_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs PhysicsWorld_funcs={
.destroy = PhysicsWorld_destroy,
.getMember = PhysicsWorld_get_member,
.setMember = PhysicsWorld_set_member
};
template <>
struct type_same<PhysicsWorld>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->PhysicsWorld_typeID;
else
 RET false;
}
};

SV PhysicsWorld_addDebugDrawer(CTX ctx,const List<SV>&a);
SV PhysicsWorld_setGravity(CTX ctx,const List<SV>&a);
SV PhysicsWorld_getGravity(CTX ctx,const List<SV>&a);
SV PhysicsWorld_getRigidBodies(CTX ctx,const List<SV>&a);
SV PhysicsWorld_getGhostObjects(CTX ctx,const List<SV>&a);
SV PhysicsWorld_createRigidBody(CTX ctx,const List<SV>&a);
SV PhysicsWorld_destroyRigidBody(CTX ctx,const List<SV>&a);
SV PhysicsWorld_createGhostObject(CTX ctx,const List<SV>&a);
SV PhysicsWorld_destroyGhostObject(CTX ctx,const List<SV>&a);
SV PhysicsWorld_stepSimulation(CTX ctx,const List<SV>&a);
SV PhysicsWorld_debugDraw(CTX ctx,const List<SV>&a);
SV PhysicsWorld_castRay(CTX ctx,const List<SV>&a);
SV PhysicsWorld_getBulletWorld(CTX ctx,const List<SV>&a);
void Script_destroy(CTX,const SV&);
SV Script_get_member(CTX,const SV&,const SV&);
void Script_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Script_funcs={
.destroy = Script_destroy,
.getMember = Script_get_member,
.setMember = Script_set_member
};
template <>
struct type_same<Script>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Script_typeID;
else
 RET false;
}
};

SV Script_removeContent(CTX ctx,const List<SV>&a);
SV Script_createInstance(CTX ctx,const List<SV>&a);
SV Script_getContext(CTX ctx,const List<SV>&a);
SV Script_load(CTX ctx,const List<SV>&a);
SV Script_save(CTX ctx,const List<SV>&a);
SV Script_copy(CTX ctx,const List<SV>&a);
SV Script_getType(CTX ctx,const List<SV>&a);
SV Script_release(CTX ctx,const List<SV>&a);
SV Script_getRefCount(CTX ctx,const List<SV>&a);
SV Script_getFilename(CTX ctx,const List<SV>&a);
SV Script_setFilename(CTX ctx,const List<SV>&a);
void MCWorld_destroy(CTX,const SV&);
SV MCWorld_get_member(CTX,const SV&,const SV&);
void MCWorld_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs MCWorld_funcs={
.destroy = MCWorld_destroy,
.getMember = MCWorld_get_member,
.setMember = MCWorld_set_member
};
template <>
struct type_same<MCWorld>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->MCWorld_typeID;
else
 RET false;
}
};

SV MCWorld_setMaterial(CTX ctx,const List<SV>&a);
SV MCWorld_render(CTX ctx,const List<SV>&a);
SV MCWorld_update(CTX ctx,const List<SV>&a);
SV MCWorld_setCube(CTX ctx,const List<SV>&a);
SV MCWorld_getCube(CTX ctx,const List<SV>&a);
SV MCWorld_getChunkSize(CTX ctx,const List<SV>&a);
SV MCWorld_getNumTypes(CTX ctx,const List<SV>&a);
SV MCWorld_getBlockSize(CTX ctx,const List<SV>&a);
SV MCWorld_getPhysicsWorld(CTX ctx,const List<SV>&a);
SV MCWorld_getCubeShape(CTX ctx,const List<SV>&a);
SV MCWorld_getMaterial(CTX ctx,const List<SV>&a);
SV MCWorld_save(CTX ctx,const List<SV>&a);
SV MCWorld_load(CTX ctx,const List<SV>&a);
SV MCWorld_clear(CTX ctx,const List<SV>&a);
void GfxObject_destroy(CTX,const SV&);
SV GfxObject_get_member(CTX,const SV&,const SV&);
void GfxObject_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxObject_funcs={
.destroy = GfxObject_destroy,
.getMember = GfxObject_get_member,
.setMember = GfxObject_set_member
};
template <>
struct create_val<GfxObject>
{
static SV f(CTX ctx,const GfxObject&obj)
{
void *p = (void *)NEW(TYPE(GfxObject), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxObject_funcs,p,EXT->GfxObject_typeID);
}
};
template <>
struct val_to_c<GfxObject>
{
static GfxObject f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxObject_typeID)
RET*((GfxObject*)obj->data);
else
 CATE(TE,"Value can not be converted to GfxObject."));
} else
 CATE(TE,"Value can not be converted to GfxObject."));
}
};

template <>
struct val_to_c<const GfxObject>
{
static GfxObject f(CTX ctx,const SV val) {return val_to_c<GfxObject>::f(ctx, val);}
};

template <>
struct create_val<const GfxObject>
{
static SV f(CTX ctx,const GfxObject&obj) {return create_val<GfxObject>::f(ctx,obj);}
};

template <>
struct type_same<GfxObject>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxObject_typeID;
else
 RET false;
}
};

void Transform_destroy(CTX,const SV&);
SV Transform_get_member(CTX,const SV&,const SV&);
void Transform_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Transform_funcs={
.destroy = Transform_destroy,
.getMember = Transform_get_member,
.setMember = Transform_set_member
};
template <>
struct create_val<Transform>
{
static SV f(CTX ctx,const Transform&obj)
{
void *p = (void *)NEW(TYPE(Transform), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Transform_funcs,p,EXT->Transform_typeID);
}
};
template <>
struct val_to_c<Transform>
{
static Transform f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Transform_typeID)
RET*((Transform*)obj->data);
else
 CATE(TE,"Value can not be converted to Transform."));
} else
 CATE(TE,"Value can not be converted to Transform."));
}
};

template <>
struct val_to_c<const Transform>
{
static Transform f(CTX ctx,const SV val) {return val_to_c<Transform>::f(ctx, val);}
};

template <>
struct create_val<const Transform>
{
static SV f(CTX ctx,const Transform&obj) {return create_val<Transform>::f(ctx,obj);}
};

template <>
struct type_same<Transform>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Transform_typeID;
else
 RET false;
}
};

SV Transform_createMatrix(CTX ctx,const List<SV>&a);
void AudioSourceList_destroy(CTX,const SV&);
SV AudioSourceList_get_member(CTX,const SV&,const SV&);
void AudioSourceList_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs AudioSourceList_funcs={
.destroy = AudioSourceList_destroy,
.getMember = AudioSourceList_get_member,
.setMember = AudioSourceList_set_member
};
template <>
struct create_val<List<AudioSource*>>
{
static SV f(CTX ctx,const List<AudioSource*>&obj)
{
void *p = (void *)NEW(TYPE(List<AudioSource*>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(AudioSourceList_funcs,p,EXT->AudioSourceList_typeID);
}
};
template <>
struct val_to_c<List<AudioSource*>>
{
static List<AudioSource*> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->AudioSourceList_typeID)
RET*((List<AudioSource*>*)obj->data);
else
 CATE(TE,"Value can not be converted to AudioSourceList."));
} else
 CATE(TE,"Value can not be converted to AudioSourceList."));
}
};

template <>
struct val_to_c<const List<AudioSource*>>
{
static List<AudioSource*> f(CTX ctx,const SV val) {return val_to_c<List<AudioSource*>>::f(ctx, val);}
};

template <>
struct create_val<const List<AudioSource*>>
{
static SV f(CTX ctx,const List<AudioSource*>&obj) {return create_val<List<AudioSource*>>::f(ctx,obj);}
};

template <>
struct type_same<List<AudioSource*>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->AudioSourceList_typeID;
else
 RET false;
}
};

SV AudioSourceList___eq__(CTX ctx,const List<SV>&a);
SV AudioSourceList___neq__(CTX ctx,const List<SV>&a);
SV AudioSourceList_get(CTX ctx,const List<SV>&a);
SV AudioSourceList_set(CTX ctx,const List<SV>&a);
SV AudioSourceList_getCount(CTX ctx,const List<SV>&a);
SV AudioSourceList_getData(CTX ctx,const List<SV>&a);
SV AudioSourceList_append(CTX ctx,const List<SV>&a);
SV AudioSourceList_insert(CTX ctx,const List<SV>&a);
SV AudioSourceList_remove(CTX ctx,const List<SV>&a);
SV AudioSourceList_clear(CTX ctx,const List<SV>&a);
SV AudioSourceList_find(CTX ctx,const List<SV>&a);
SV AudioSourceList_copy(CTX ctx,const List<SV>&a);
SV AudioSourceList_in(CTX ctx,const List<SV>&a);
SV AudioSourceList_reserve(CTX ctx,const List<SV>&a);
SV AudioSourceList_begin(CTX ctx,const List<SV>&a);
SV AudioSourceList_end(CTX ctx,const List<SV>&a);
void Int4_destroy(CTX,const SV&);
SV Int4_get_member(CTX,const SV&,const SV&);
void Int4_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Int4_funcs={
.destroy = Int4_destroy,
.getMember = Int4_get_member,
.setMember = Int4_set_member
};
template <>
struct create_val<T4<int32_t>>
{
static SV f(CTX ctx,const T4<int32_t>&obj)
{
void *p = (void *)NEW(TYPE(T4<int32_t>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int4_funcs,p,EXT->Int4_typeID);
}
};
template <>
struct val_to_c<T4<int32_t>>
{
static T4<int32_t> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Int4_typeID)
RET*((T4<int32_t>*)obj->data);
else
 CATE(TE,"Value can not be converted to Int4."));
} else
 CATE(TE,"Value can not be converted to Int4."));
}
};

template <>
struct val_to_c<const T4<int32_t>>
{
static T4<int32_t> f(CTX ctx,const SV val) {return val_to_c<T4<int32_t>>::f(ctx, val);}
};

template <>
struct create_val<const T4<int32_t>>
{
static SV f(CTX ctx,const T4<int32_t>&obj) {return create_val<T4<int32_t>>::f(ctx,obj);}
};

template <>
struct type_same<T4<int32_t>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Int4_typeID;
else
 RET false;
}
};

SV Int4___add__(CTX ctx,const List<SV>&a);
SV Int4___sub__(CTX ctx,const List<SV>&a);
SV Int4___mul__(CTX ctx,const List<SV>&a);
SV Int4___div__(CTX ctx,const List<SV>&a);
SV Int4___eq__(CTX ctx,const List<SV>&a);
SV Int4___neq__(CTX ctx,const List<SV>&a);
SV Int4___less__(CTX ctx,const List<SV>&a);
SV Int4___grtr__(CTX ctx,const List<SV>&a);
SV Int4___leq__(CTX ctx,const List<SV>&a);
SV Int4___geq__(CTX ctx,const List<SV>&a);
SV Int4_sum(CTX ctx,const List<SV>&a);
SV Int4_length(CTX ctx,const List<SV>&a);
SV Int4_lengthSquared(CTX ctx,const List<SV>&a);
SV Int4_dot(CTX ctx,const List<SV>&a);
SV Int4_distance(CTX ctx,const List<SV>&a);
SV Int4_distanceSquared(CTX ctx,const List<SV>&a);
SV Int4_normalize(CTX ctx,const List<SV>&a);
SV Int4_getXY(CTX ctx,const List<SV>&a);
SV Int4_setXY(CTX ctx,const List<SV>&a);
SV Int4_getXZ(CTX ctx,const List<SV>&a);
SV Int4_setXZ(CTX ctx,const List<SV>&a);
SV Int4_getXW(CTX ctx,const List<SV>&a);
SV Int4_setXW(CTX ctx,const List<SV>&a);
SV Int4_getYX(CTX ctx,const List<SV>&a);
SV Int4_setYX(CTX ctx,const List<SV>&a);
SV Int4_getYZ(CTX ctx,const List<SV>&a);
SV Int4_setYZ(CTX ctx,const List<SV>&a);
SV Int4_getYW(CTX ctx,const List<SV>&a);
SV Int4_setYW(CTX ctx,const List<SV>&a);
SV Int4_getZX(CTX ctx,const List<SV>&a);
SV Int4_setZX(CTX ctx,const List<SV>&a);
SV Int4_getZY(CTX ctx,const List<SV>&a);
SV Int4_setZY(CTX ctx,const List<SV>&a);
SV Int4_getZW(CTX ctx,const List<SV>&a);
SV Int4_setZW(CTX ctx,const List<SV>&a);
SV Int4_getWX(CTX ctx,const List<SV>&a);
SV Int4_setWX(CTX ctx,const List<SV>&a);
SV Int4_getWY(CTX ctx,const List<SV>&a);
SV Int4_setWY(CTX ctx,const List<SV>&a);
SV Int4_getWZ(CTX ctx,const List<SV>&a);
SV Int4_setWZ(CTX ctx,const List<SV>&a);
SV Int4_getXYZ(CTX ctx,const List<SV>&a);
SV Int4_setXYZ(CTX ctx,const List<SV>&a);
SV Int4_getXYW(CTX ctx,const List<SV>&a);
SV Int4_setXYW(CTX ctx,const List<SV>&a);
SV Int4_getXZY(CTX ctx,const List<SV>&a);
SV Int4_setXZY(CTX ctx,const List<SV>&a);
SV Int4_getXZW(CTX ctx,const List<SV>&a);
SV Int4_setXZW(CTX ctx,const List<SV>&a);
SV Int4_getXWZ(CTX ctx,const List<SV>&a);
SV Int4_setXWZ(CTX ctx,const List<SV>&a);
SV Int4_getXWY(CTX ctx,const List<SV>&a);
SV Int4_setXWY(CTX ctx,const List<SV>&a);
SV Int4_getYXZ(CTX ctx,const List<SV>&a);
SV Int4_setYXZ(CTX ctx,const List<SV>&a);
SV Int4_getYXW(CTX ctx,const List<SV>&a);
SV Int4_setYXW(CTX ctx,const List<SV>&a);
SV Int4_getYZX(CTX ctx,const List<SV>&a);
SV Int4_setYZX(CTX ctx,const List<SV>&a);
SV Int4_getYZW(CTX ctx,const List<SV>&a);
SV Int4_setYZW(CTX ctx,const List<SV>&a);
SV Int4_getYWZ(CTX ctx,const List<SV>&a);
SV Int4_setYWZ(CTX ctx,const List<SV>&a);
SV Int4_getYWX(CTX ctx,const List<SV>&a);
SV Int4_setYWX(CTX ctx,const List<SV>&a);
SV Int4_getZXY(CTX ctx,const List<SV>&a);
SV Int4_setZXY(CTX ctx,const List<SV>&a);
SV Int4_getZXW(CTX ctx,const List<SV>&a);
SV Int4_setZXW(CTX ctx,const List<SV>&a);
SV Int4_getZYX(CTX ctx,const List<SV>&a);
SV Int4_setZYX(CTX ctx,const List<SV>&a);
SV Int4_getZYW(CTX ctx,const List<SV>&a);
SV Int4_setZYW(CTX ctx,const List<SV>&a);
SV Int4_getZWY(CTX ctx,const List<SV>&a);
SV Int4_setZWY(CTX ctx,const List<SV>&a);
SV Int4_getZWX(CTX ctx,const List<SV>&a);
SV Int4_setZWX(CTX ctx,const List<SV>&a);
SV Int4_getWXY(CTX ctx,const List<SV>&a);
SV Int4_setWXY(CTX ctx,const List<SV>&a);
SV Int4_getWXZ(CTX ctx,const List<SV>&a);
SV Int4_setWXZ(CTX ctx,const List<SV>&a);
SV Int4_getWYX(CTX ctx,const List<SV>&a);
SV Int4_setWYX(CTX ctx,const List<SV>&a);
SV Int4_getWYZ(CTX ctx,const List<SV>&a);
SV Int4_setWYZ(CTX ctx,const List<SV>&a);
SV Int4_getWZY(CTX ctx,const List<SV>&a);
SV Int4_setWZY(CTX ctx,const List<SV>&a);
SV Int4_getWZX(CTX ctx,const List<SV>&a);
SV Int4_setWZX(CTX ctx,const List<SV>&a);
SV Int4_getXYZW(CTX ctx,const List<SV>&a);
SV Int4_setXYZW(CTX ctx,const List<SV>&a);
SV Int4_getXYWZ(CTX ctx,const List<SV>&a);
SV Int4_setXYWZ(CTX ctx,const List<SV>&a);
SV Int4_getXZYW(CTX ctx,const List<SV>&a);
SV Int4_setXZYW(CTX ctx,const List<SV>&a);
SV Int4_getXZWY(CTX ctx,const List<SV>&a);
SV Int4_setXZWY(CTX ctx,const List<SV>&a);
SV Int4_getXWZY(CTX ctx,const List<SV>&a);
SV Int4_setXWZY(CTX ctx,const List<SV>&a);
SV Int4_getXWYZ(CTX ctx,const List<SV>&a);
SV Int4_setXWYZ(CTX ctx,const List<SV>&a);
SV Int4_getYXZW(CTX ctx,const List<SV>&a);
SV Int4_setYXZW(CTX ctx,const List<SV>&a);
SV Int4_getYXWZ(CTX ctx,const List<SV>&a);
SV Int4_setYXWZ(CTX ctx,const List<SV>&a);
SV Int4_getYZXW(CTX ctx,const List<SV>&a);
SV Int4_setYZXW(CTX ctx,const List<SV>&a);
SV Int4_getYZWX(CTX ctx,const List<SV>&a);
SV Int4_setYZWX(CTX ctx,const List<SV>&a);
SV Int4_getYWZX(CTX ctx,const List<SV>&a);
SV Int4_setYWZX(CTX ctx,const List<SV>&a);
SV Int4_getYWXZ(CTX ctx,const List<SV>&a);
SV Int4_setYWXZ(CTX ctx,const List<SV>&a);
SV Int4_getZYXW(CTX ctx,const List<SV>&a);
SV Int4_setZYXW(CTX ctx,const List<SV>&a);
SV Int4_getZYWX(CTX ctx,const List<SV>&a);
SV Int4_setZYWX(CTX ctx,const List<SV>&a);
SV Int4_getZXYW(CTX ctx,const List<SV>&a);
SV Int4_setZXYW(CTX ctx,const List<SV>&a);
SV Int4_getZXWY(CTX ctx,const List<SV>&a);
SV Int4_setZXWY(CTX ctx,const List<SV>&a);
SV Int4_getZWXY(CTX ctx,const List<SV>&a);
SV Int4_setZWXY(CTX ctx,const List<SV>&a);
SV Int4_getZWYX(CTX ctx,const List<SV>&a);
SV Int4_setZWYX(CTX ctx,const List<SV>&a);
SV Int4_getWYZX(CTX ctx,const List<SV>&a);
SV Int4_setWYZX(CTX ctx,const List<SV>&a);
SV Int4_getWYXZ(CTX ctx,const List<SV>&a);
SV Int4_setWYXZ(CTX ctx,const List<SV>&a);
SV Int4_getWZYX(CTX ctx,const List<SV>&a);
SV Int4_setWZYX(CTX ctx,const List<SV>&a);
SV Int4_getWZXY(CTX ctx,const List<SV>&a);
SV Int4_setWZXY(CTX ctx,const List<SV>&a);
SV Int4_getWXZY(CTX ctx,const List<SV>&a);
SV Int4_setWXZY(CTX ctx,const List<SV>&a);
SV Int4_getWXYZ(CTX ctx,const List<SV>&a);
SV Int4_setWXYZ(CTX ctx,const List<SV>&a);
SV Int4_copy(CTX ctx,const List<SV>&a);
void ScrollBar_destroy(CTX,const SV&);
SV ScrollBar_get_member(CTX,const SV&,const SV&);
void ScrollBar_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs ScrollBar_funcs={
.destroy = ScrollBar_destroy,
.getMember = ScrollBar_get_member,
.setMember = ScrollBar_set_member
};
template <>
struct create_val<ScrollBar>
{
static SV f(CTX ctx,const ScrollBar&obj)
{
void *p = (void *)NEW(TYPE(ScrollBar), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(ScrollBar_funcs,p,EXT->ScrollBar_typeID);
}
};
template <>
struct val_to_c<ScrollBar>
{
static ScrollBar f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->ScrollBar_typeID)
RET*((ScrollBar*)obj->data);
else
 CATE(TE,"Value can not be converted to ScrollBar."));
} else
 CATE(TE,"Value can not be converted to ScrollBar."));
}
};

template <>
struct val_to_c<const ScrollBar>
{
static ScrollBar f(CTX ctx,const SV val) {return val_to_c<ScrollBar>::f(ctx, val);}
};

template <>
struct create_val<const ScrollBar>
{
static SV f(CTX ctx,const ScrollBar&obj) {return create_val<ScrollBar>::f(ctx,obj);}
};

template <>
struct type_same<ScrollBar>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ScrollBar_typeID;
else
 RET false;
}
};

SV ScrollBar_getValue(CTX ctx,const List<SV>&a);
SV ScrollBar_setValue(CTX ctx,const List<SV>&a);
void Int3_destroy(CTX,const SV&);
SV Int3_get_member(CTX,const SV&,const SV&);
void Int3_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Int3_funcs={
.destroy = Int3_destroy,
.getMember = Int3_get_member,
.setMember = Int3_set_member
};
template <>
struct create_val<T3<int32_t>>
{
static SV f(CTX ctx,const T3<int32_t>&obj)
{
void *p = (void *)NEW(TYPE(T3<int32_t>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int3_funcs,p,EXT->Int3_typeID);
}
};
template <>
struct val_to_c<T3<int32_t>>
{
static T3<int32_t> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Int3_typeID)
RET*((T3<int32_t>*)obj->data);
else
 CATE(TE,"Value can not be converted to Int3."));
} else
 CATE(TE,"Value can not be converted to Int3."));
}
};

template <>
struct val_to_c<const T3<int32_t>>
{
static T3<int32_t> f(CTX ctx,const SV val) {return val_to_c<T3<int32_t>>::f(ctx, val);}
};

template <>
struct create_val<const T3<int32_t>>
{
static SV f(CTX ctx,const T3<int32_t>&obj) {return create_val<T3<int32_t>>::f(ctx,obj);}
};

template <>
struct type_same<T3<int32_t>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Int3_typeID;
else
 RET false;
}
};

SV Int3___add__(CTX ctx,const List<SV>&a);
SV Int3___sub__(CTX ctx,const List<SV>&a);
SV Int3___mul__(CTX ctx,const List<SV>&a);
SV Int3___div__(CTX ctx,const List<SV>&a);
SV Int3___eq__(CTX ctx,const List<SV>&a);
SV Int3___neq__(CTX ctx,const List<SV>&a);
SV Int3___less__(CTX ctx,const List<SV>&a);
SV Int3___grtr__(CTX ctx,const List<SV>&a);
SV Int3___leq__(CTX ctx,const List<SV>&a);
SV Int3___geq__(CTX ctx,const List<SV>&a);
SV Int3_sum(CTX ctx,const List<SV>&a);
SV Int3_length(CTX ctx,const List<SV>&a);
SV Int3_lengthSquared(CTX ctx,const List<SV>&a);
SV Int3_dot(CTX ctx,const List<SV>&a);
SV Int3_distance(CTX ctx,const List<SV>&a);
SV Int3_distanceSquared(CTX ctx,const List<SV>&a);
SV Int3_normalize(CTX ctx,const List<SV>&a);
SV Int3_cross(CTX ctx,const List<SV>&a);
SV Int3_getXY(CTX ctx,const List<SV>&a);
SV Int3_setXY(CTX ctx,const List<SV>&a);
SV Int3_getXZ(CTX ctx,const List<SV>&a);
SV Int3_setXZ(CTX ctx,const List<SV>&a);
SV Int3_getYX(CTX ctx,const List<SV>&a);
SV Int3_setYX(CTX ctx,const List<SV>&a);
SV Int3_getYZ(CTX ctx,const List<SV>&a);
SV Int3_setYZ(CTX ctx,const List<SV>&a);
SV Int3_getZX(CTX ctx,const List<SV>&a);
SV Int3_setZX(CTX ctx,const List<SV>&a);
SV Int3_getZY(CTX ctx,const List<SV>&a);
SV Int3_setZY(CTX ctx,const List<SV>&a);
SV Int3_getXYZ(CTX ctx,const List<SV>&a);
SV Int3_setXYZ(CTX ctx,const List<SV>&a);
SV Int3_getXZY(CTX ctx,const List<SV>&a);
SV Int3_setXZY(CTX ctx,const List<SV>&a);
SV Int3_getYXZ(CTX ctx,const List<SV>&a);
SV Int3_setYXZ(CTX ctx,const List<SV>&a);
SV Int3_getYZX(CTX ctx,const List<SV>&a);
SV Int3_setYZX(CTX ctx,const List<SV>&a);
SV Int3_getZXY(CTX ctx,const List<SV>&a);
SV Int3_setZXY(CTX ctx,const List<SV>&a);
SV Int3_getZYX(CTX ctx,const List<SV>&a);
SV Int3_setZYX(CTX ctx,const List<SV>&a);
SV Int3_copy(CTX ctx,const List<SV>&a);
void ScriptInstance_destroy(CTX,const SV&);
SV ScriptInstance_get_member(CTX,const SV&,const SV&);
void ScriptInstance_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs ScriptInstance_funcs={
.destroy = ScriptInstance_destroy,
.getMember = ScriptInstance_get_member,
.setMember = ScriptInstance_set_member
};
template <>
struct type_same<ScriptInstance>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ScriptInstance_typeID;
else
 RET false;
}
};

SV ScriptInstance_method(CTX ctx,const List<SV>&a);
SV ScriptInstance_getScript(CTX ctx,const List<SV>&a);
SV ScriptInstance_getObj(CTX ctx,const List<SV>&a);
void RenderComponent_destroy(CTX,const SV&);
SV RenderComponent_get_member(CTX,const SV&,const SV&);
void RenderComponent_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs RenderComponent_funcs={
.destroy = RenderComponent_destroy,
.getMember = RenderComponent_get_member,
.setMember = RenderComponent_set_member
};
template <>
struct type_same<RenderComponent>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RenderComponent_typeID;
else
 RET false;
}
};

SV RenderComponent_getShadowCaster(CTX ctx,const List<SV>&a);
SV RenderComponent_setShadowCaster(CTX ctx,const List<SV>&a);
SV RenderComponent_getOverlayColor(CTX ctx,const List<SV>&a);
SV RenderComponent_setOverlayColor(CTX ctx,const List<SV>&a);
SV RenderComponent_setAnimationState(CTX ctx,const List<SV>&a);
SV RenderComponent_removeAnimationState(CTX ctx,const List<SV>&a);
SV RenderComponent_getAnimationState(CTX ctx,const List<SV>&a);
void RigidBody_destroy(CTX,const SV&);
SV RigidBody_get_member(CTX,const SV&,const SV&);
void RigidBody_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs RigidBody_funcs={
.destroy = RigidBody_destroy,
.getMember = RigidBody_get_member,
.setMember = RigidBody_set_member
};
template <>
struct type_same<RigidBody>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RigidBody_typeID;
else
 RET false;
}
};

SV RigidBody_getBulletRigidBody(CTX ctx,const List<SV>&a);
SV RigidBody_getType(CTX ctx,const List<SV>&a);
SV RigidBody_getGravity(CTX ctx,const List<SV>&a);
SV RigidBody_setGravity(CTX ctx,const List<SV>&a);
SV RigidBody_setLinearDamping(CTX ctx,const List<SV>&a);
SV RigidBody_getLinearDamping(CTX ctx,const List<SV>&a);
SV RigidBody_setAngularDamping(CTX ctx,const List<SV>&a);
SV RigidBody_getAngularDamping(CTX ctx,const List<SV>&a);
SV RigidBody_setMass(CTX ctx,const List<SV>&a);
SV RigidBody_getMass(CTX ctx,const List<SV>&a);
SV RigidBody_getLinearSleepingThreshold(CTX ctx,const List<SV>&a);
SV RigidBody_setLinearSleepingThreshold(CTX ctx,const List<SV>&a);
SV RigidBody_getAngularSleepingThreshold(CTX ctx,const List<SV>&a);
SV RigidBody_setAngularSleepingThreshold(CTX ctx,const List<SV>&a);
SV RigidBody_applyTorque(CTX ctx,const List<SV>&a);
SV RigidBody_applyForce(CTX ctx,const List<SV>&a);
SV RigidBody_applyCentralImpulse(CTX ctx,const List<SV>&a);
SV RigidBody_applyTorqueImpulse(CTX ctx,const List<SV>&a);
SV RigidBody_applyImpulse(CTX ctx,const List<SV>&a);
SV RigidBody_clearForces(CTX ctx,const List<SV>&a);
SV RigidBody_getLinearVelocity(CTX ctx,const List<SV>&a);
SV RigidBody_setLinearVelocity(CTX ctx,const List<SV>&a);
SV RigidBody_getAngularVelocity(CTX ctx,const List<SV>&a);
SV RigidBody_setAngularVelocity(CTX ctx,const List<SV>&a);
SV RigidBody_getVelocityOfPoint(CTX ctx,const List<SV>&a);
SV RigidBody_getRestitution(CTX ctx,const List<SV>&a);
SV RigidBody_setRestitution(CTX ctx,const List<SV>&a);
SV RigidBody_getFriction(CTX ctx,const List<SV>&a);
SV RigidBody_setFriction(CTX ctx,const List<SV>&a);
SV RigidBody_getRollingFriction(CTX ctx,const List<SV>&a);
SV RigidBody_setRollingFriction(CTX ctx,const List<SV>&a);
SV RigidBody_getLinearFactor(CTX ctx,const List<SV>&a);
SV RigidBody_setLinearFactor(CTX ctx,const List<SV>&a);
SV RigidBody_getAngularFactor(CTX ctx,const List<SV>&a);
SV RigidBody_setAngularFactor(CTX ctx,const List<SV>&a);
SV RigidBody_setTransform(CTX ctx,const List<SV>&a);
SV RigidBody_getWorld(CTX ctx,const List<SV>&a);
SV RigidBody_getCollisionMask(CTX ctx,const List<SV>&a);
SV RigidBody_setShape(CTX ctx,const List<SV>&a);
SV RigidBody_getShape(CTX ctx,const List<SV>&a);
SV RigidBody_getEntity(CTX ctx,const List<SV>&a);
void RenderList_destroy(CTX,const SV&);
SV RenderList_get_member(CTX,const SV&,const SV&);
void RenderList_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs RenderList_funcs={
.destroy = RenderList_destroy,
.getMember = RenderList_get_member,
.setMember = RenderList_set_member
};
template <>
struct type_same<RenderList>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RenderList_typeID;
else
 RET false;
}
};

SV RenderList_addDrawCall(CTX ctx,const List<SV>&a);
SV RenderList_addRenderList(CTX ctx,const List<SV>&a);
SV RenderList_execute(CTX ctx,const List<SV>&a);
SV RenderList_clear(CTX ctx,const List<SV>&a);
void Plane_destroy(CTX,const SV&);
SV Plane_get_member(CTX,const SV&,const SV&);
void Plane_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Plane_funcs={
.destroy = Plane_destroy,
.getMember = Plane_get_member,
.setMember = Plane_set_member
};
template <>
struct create_val<Plane>
{
static SV f(CTX ctx,const Plane&obj)
{
void *p = (void *)NEW(TYPE(Plane), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Plane_funcs,p,EXT->Plane_typeID);
}
};
template <>
struct val_to_c<Plane>
{
static Plane f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Plane_typeID)
RET*((Plane*)obj->data);
else
 CATE(TE,"Value can not be converted to Plane."));
} else
 CATE(TE,"Value can not be converted to Plane."));
}
};

template <>
struct val_to_c<const Plane>
{
static Plane f(CTX ctx,const SV val) {return val_to_c<Plane>::f(ctx, val);}
};

template <>
struct create_val<const Plane>
{
static SV f(CTX ctx,const Plane&obj) {return create_val<Plane>::f(ctx,obj);}
};

template <>
struct type_same<Plane>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Plane_typeID;
else
 RET false;
}
};

SV Plane_distanceToPoint(CTX ctx,const List<SV>&a);
void PhysicsShape_destroy(CTX,const SV&);
SV PhysicsShape_get_member(CTX,const SV&,const SV&);
void PhysicsShape_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs PhysicsShape_funcs={
.destroy = PhysicsShape_destroy,
.getMember = PhysicsShape_get_member,
.setMember = PhysicsShape_set_member
};
template <>
struct type_same<PhysicsShape>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->PhysicsShape_typeID;
else
 RET false;
}
};

SV PhysicsShape_removeContent(CTX ctx,const List<SV>&a);
SV PhysicsShape_getImpl(CTX ctx,const List<SV>&a);
SV PhysicsShape_getShapeType(CTX ctx,const List<SV>&a);
SV PhysicsShape_getMargin(CTX ctx,const List<SV>&a);
SV PhysicsShape_setMargin(CTX ctx,const List<SV>&a);
SV PhysicsShape_getScale(CTX ctx,const List<SV>&a);
SV PhysicsShape_setScale(CTX ctx,const List<SV>&a);
SV PhysicsShape_getBulletShape(CTX ctx,const List<SV>&a);
SV PhysicsShape_setEmpty(CTX ctx,const List<SV>&a);
SV PhysicsShape_setSphere(CTX ctx,const List<SV>&a);
SV PhysicsShape_setBox(CTX ctx,const List<SV>&a);
SV PhysicsShape_setCylinder(CTX ctx,const List<SV>&a);
SV PhysicsShape_setCapsule(CTX ctx,const List<SV>&a);
SV PhysicsShape_setCone(CTX ctx,const List<SV>&a);
SV PhysicsShape_setConvexHull(CTX ctx,const List<SV>&a);
SV PhysicsShape_setStaticTriangleMesh(CTX ctx,const List<SV>&a);
SV PhysicsShape_setHeightfield(CTX ctx,const List<SV>&a);
SV PhysicsShape_setPlane(CTX ctx,const List<SV>&a);
SV PhysicsShape_setCompound(CTX ctx,const List<SV>&a);
SV PhysicsShape_save(CTX ctx,const List<SV>&a);
SV PhysicsShape_load(CTX ctx,const List<SV>&a);
SV PhysicsShape_copy(CTX ctx,const List<SV>&a);
SV PhysicsShape_getType(CTX ctx,const List<SV>&a);
SV PhysicsShape_release(CTX ctx,const List<SV>&a);
SV PhysicsShape_getRefCount(CTX ctx,const List<SV>&a);
SV PhysicsShape_getFilename(CTX ctx,const List<SV>&a);
SV PhysicsShape_setFilename(CTX ctx,const List<SV>&a);
void RigidBodyList_destroy(CTX,const SV&);
SV RigidBodyList_get_member(CTX,const SV&,const SV&);
void RigidBodyList_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs RigidBodyList_funcs={
.destroy = RigidBodyList_destroy,
.getMember = RigidBodyList_get_member,
.setMember = RigidBodyList_set_member
};
template <>
struct create_val<List<RigidBody*>>
{
static SV f(CTX ctx,const List<RigidBody*>&obj)
{
void *p = (void *)NEW(TYPE(List<RigidBody*>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(RigidBodyList_funcs,p,EXT->RigidBodyList_typeID);
}
};
template <>
struct val_to_c<List<RigidBody*>>
{
static List<RigidBody*> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RigidBodyList_typeID)
RET*((List<RigidBody*>*)obj->data);
else
 CATE(TE,"Value can not be converted to RigidBodyList."));
} else
 CATE(TE,"Value can not be converted to RigidBodyList."));
}
};

template <>
struct val_to_c<const List<RigidBody*>>
{
static List<RigidBody*> f(CTX ctx,const SV val) {return val_to_c<List<RigidBody*>>::f(ctx, val);}
};

template <>
struct create_val<const List<RigidBody*>>
{
static SV f(CTX ctx,const List<RigidBody*>&obj) {return create_val<List<RigidBody*>>::f(ctx,obj);}
};

template <>
struct type_same<List<RigidBody*>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RigidBodyList_typeID;
else
 RET false;
}
};

SV RigidBodyList___eq__(CTX ctx,const List<SV>&a);
SV RigidBodyList___neq__(CTX ctx,const List<SV>&a);
SV RigidBodyList_get(CTX ctx,const List<SV>&a);
SV RigidBodyList_set(CTX ctx,const List<SV>&a);
SV RigidBodyList_getCount(CTX ctx,const List<SV>&a);
SV RigidBodyList_getData(CTX ctx,const List<SV>&a);
SV RigidBodyList_append(CTX ctx,const List<SV>&a);
SV RigidBodyList_insert(CTX ctx,const List<SV>&a);
SV RigidBodyList_remove(CTX ctx,const List<SV>&a);
SV RigidBodyList_clear(CTX ctx,const List<SV>&a);
SV RigidBodyList_find(CTX ctx,const List<SV>&a);
SV RigidBodyList_copy(CTX ctx,const List<SV>&a);
SV RigidBodyList_in(CTX ctx,const List<SV>&a);
SV RigidBodyList_reserve(CTX ctx,const List<SV>&a);
SV RigidBodyList_begin(CTX ctx,const List<SV>&a);
SV RigidBodyList_end(CTX ctx,const List<SV>&a);
void Resource_destroy(CTX,const SV&);
SV Resource_get_member(CTX,const SV&,const SV&);
void Resource_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Resource_funcs={
.destroy = Resource_destroy,
.getMember = Resource_get_member,
.setMember = Resource_set_member
};
template <>
struct type_same<Resource>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Resource_typeID;
else
 RET false;
}
};

SV Resource_removeContent(CTX ctx,const List<SV>&a);
SV Resource_load(CTX ctx,const List<SV>&a);
SV Resource_save(CTX ctx,const List<SV>&a);
SV Resource_copy(CTX ctx,const List<SV>&a);
SV Resource_getType(CTX ctx,const List<SV>&a);
SV Resource_release(CTX ctx,const List<SV>&a);
SV Resource_getRefCount(CTX ctx,const List<SV>&a);
SV Resource_getFilename(CTX ctx,const List<SV>&a);
SV Resource_setFilename(CTX ctx,const List<SV>&a);
void GfxTexture_destroy(CTX,const SV&);
SV GfxTexture_get_member(CTX,const SV&,const SV&);
void GfxTexture_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxTexture_funcs={
.destroy = GfxTexture_destroy,
.getMember = GfxTexture_get_member,
.setMember = GfxTexture_set_member
};
template <>
struct type_same<GfxTexture>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxTexture_typeID;
else
 RET false;
}
};

SV GfxTexture_removeContent(CTX ctx,const List<SV>&a);
SV GfxTexture_startCreation(CTX ctx,const List<SV>&a);
SV GfxTexture_allocMipmapFace(CTX ctx,const List<SV>&a);
SV GfxTexture_allocMipmap(CTX ctx,const List<SV>&a);
SV GfxTexture_getMipmapFace(CTX ctx,const List<SV>&a);
SV GfxTexture_getMipmap(CTX ctx,const List<SV>&a);
SV GfxTexture_generateMipmaps(CTX ctx,const List<SV>&a);
SV GfxTexture_getTextureType(CTX ctx,const List<SV>&a);
SV GfxTexture_getBaseWidth(CTX ctx,const List<SV>&a);
SV GfxTexture_getBaseHeight(CTX ctx,const List<SV>&a);
SV GfxTexture_getBaseDepth(CTX ctx,const List<SV>&a);
SV GfxTexture_getFormat(CTX ctx,const List<SV>&a);
SV GfxTexture_getImpl(CTX ctx,const List<SV>&a);
SV GfxTexture_save(CTX ctx,const List<SV>&a);
SV GfxTexture_load(CTX ctx,const List<SV>&a);
SV GfxTexture_copy(CTX ctx,const List<SV>&a);
SV GfxTexture_getType(CTX ctx,const List<SV>&a);
SV GfxTexture_release(CTX ctx,const List<SV>&a);
SV GfxTexture_getRefCount(CTX ctx,const List<SV>&a);
SV GfxTexture_getFilename(CTX ctx,const List<SV>&a);
SV GfxTexture_setFilename(CTX ctx,const List<SV>&a);
void GfxModel_destroy(CTX,const SV&);
SV GfxModel_get_member(CTX,const SV&,const SV&);
void GfxModel_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxModel_funcs={
.destroy = GfxModel_destroy,
.getMember = GfxModel_get_member,
.setMember = GfxModel_set_member
};
template <>
struct type_same<GfxModel>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxModel_typeID;
else
 RET false;
}
};

SV GfxModel_removeContent(CTX ctx,const List<SV>&a);
SV GfxModel_save(CTX ctx,const List<SV>&a);
SV GfxModel_load(CTX ctx,const List<SV>&a);
SV GfxModel_copy(CTX ctx,const List<SV>&a);
SV GfxModel_getType(CTX ctx,const List<SV>&a);
SV GfxModel_release(CTX ctx,const List<SV>&a);
SV GfxModel_getRefCount(CTX ctx,const List<SV>&a);
SV GfxModel_getFilename(CTX ctx,const List<SV>&a);
SV GfxModel_setFilename(CTX ctx,const List<SV>&a);
void GfxLODList_destroy(CTX,const SV&);
SV GfxLODList_get_member(CTX,const SV&,const SV&);
void GfxLODList_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxLODList_funcs={
.destroy = GfxLODList_destroy,
.getMember = GfxLODList_get_member,
.setMember = GfxLODList_set_member
};
template <>
struct create_val<List<GfxLOD>>
{
static SV f(CTX ctx,const List<GfxLOD>&obj)
{
void *p = (void *)NEW(TYPE(List<GfxLOD>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxLODList_funcs,p,EXT->GfxLODList_typeID);
}
};
template <>
struct val_to_c<List<GfxLOD>>
{
static List<GfxLOD> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxLODList_typeID)
RET*((List<GfxLOD>*)obj->data);
else
 CATE(TE,"Value can not be converted to GfxLODList."));
} else
 CATE(TE,"Value can not be converted to GfxLODList."));
}
};

template <>
struct val_to_c<const List<GfxLOD>>
{
static List<GfxLOD> f(CTX ctx,const SV val) {return val_to_c<List<GfxLOD>>::f(ctx, val);}
};

template <>
struct create_val<const List<GfxLOD>>
{
static SV f(CTX ctx,const List<GfxLOD>&obj) {return create_val<List<GfxLOD>>::f(ctx,obj);}
};

template <>
struct type_same<List<GfxLOD>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxLODList_typeID;
else
 RET false;
}
};

SV GfxLODList___eq__(CTX ctx,const List<SV>&a);
SV GfxLODList___neq__(CTX ctx,const List<SV>&a);
SV GfxLODList_get(CTX ctx,const List<SV>&a);
SV GfxLODList_set(CTX ctx,const List<SV>&a);
SV GfxLODList_getCount(CTX ctx,const List<SV>&a);
SV GfxLODList_getData(CTX ctx,const List<SV>&a);
SV GfxLODList_append(CTX ctx,const List<SV>&a);
SV GfxLODList_insert(CTX ctx,const List<SV>&a);
SV GfxLODList_remove(CTX ctx,const List<SV>&a);
SV GfxLODList_clear(CTX ctx,const List<SV>&a);
SV GfxLODList_find(CTX ctx,const List<SV>&a);
SV GfxLODList_copy(CTX ctx,const List<SV>&a);
SV GfxLODList_in(CTX ctx,const List<SV>&a);
SV GfxLODList_reserve(CTX ctx,const List<SV>&a);
SV GfxLODList_begin(CTX ctx,const List<SV>&a);
SV GfxLODList_end(CTX ctx,const List<SV>&a);
void RigidBodyConstructionInfo_destroy(CTX,const SV&);
SV RigidBodyConstructionInfo_get_member(CTX,const SV&,const SV&);
void RigidBodyConstructionInfo_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs RigidBodyConstructionInfo_funcs={
.destroy = RigidBodyConstructionInfo_destroy,
.getMember = RigidBodyConstructionInfo_get_member,
.setMember = RigidBodyConstructionInfo_set_member
};
template <>
struct create_val<RigidBodyConstructionInfo>
{
static SV f(CTX ctx,const RigidBodyConstructionInfo&obj)
{
void *p = (void *)NEW(TYPE(RigidBodyConstructionInfo), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(RigidBodyConstructionInfo_funcs,p,EXT->RigidBodyConstructionInfo_typeID);
}
};
template <>
struct val_to_c<RigidBodyConstructionInfo>
{
static RigidBodyConstructionInfo f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RigidBodyConstructionInfo_typeID)
RET*((RigidBodyConstructionInfo*)obj->data);
else
 CATE(TE,"Value can not be converted to RigidBodyConstructionInfo."));
} else
 CATE(TE,"Value can not be converted to RigidBodyConstructionInfo."));
}
};

template <>
struct val_to_c<const RigidBodyConstructionInfo>
{
static RigidBodyConstructionInfo f(CTX ctx,const SV val) {return val_to_c<RigidBodyConstructionInfo>::f(ctx, val);}
};

template <>
struct create_val<const RigidBodyConstructionInfo>
{
static SV f(CTX ctx,const RigidBodyConstructionInfo&obj) {return create_val<RigidBodyConstructionInfo>::f(ctx,obj);}
};

template <>
struct type_same<RigidBodyConstructionInfo>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RigidBodyConstructionInfo_typeID;
else
 RET false;
}
};

void GfxApi_destroy(CTX,const SV&);
SV GfxApi_get_member(CTX,const SV&,const SV&);
void GfxApi_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxApi_funcs={
.destroy = GfxApi_destroy,
.getMember = GfxApi_get_member,
.setMember = GfxApi_set_member
};
template <>
struct type_same<GfxApi>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxApi_typeID;
else
 RET false;
}
};

SV GfxApi_getDriver(CTX ctx,const List<SV>&a);
SV GfxApi_getMaxTextureSize(CTX ctx,const List<SV>&a);
SV GfxApi_createBuffer(CTX ctx,const List<SV>&a);
SV GfxApi_createTextureImpl(CTX ctx,const List<SV>&a);
SV GfxApi_createFramebuffer(CTX ctx,const List<SV>&a);
SV GfxApi_createTimer(CTX ctx,const List<SV>&a);
SV GfxApi_setCurrentFramebuffer(CTX ctx,const List<SV>&a);
SV GfxApi_clearDepth(CTX ctx,const List<SV>&a);
SV GfxApi_clearColor(CTX ctx,const List<SV>&a);
SV GfxApi_begin(CTX ctx,const List<SV>&a);
SV GfxApi_draw(CTX ctx,const List<SV>&a);
SV GfxApi_end(CTX ctx,const List<SV>&a);
SV GfxApi_setMesh(CTX ctx,const List<SV>&a);
SV GfxApi_getVertexShader(CTX ctx,const List<SV>&a);
SV GfxApi_getTessControlShader(CTX ctx,const List<SV>&a);
SV GfxApi_getTessEvalShader(CTX ctx,const List<SV>&a);
SV GfxApi_getGeometryShader(CTX ctx,const List<SV>&a);
SV GfxApi_getFragmentShader(CTX ctx,const List<SV>&a);
SV GfxApi_uniform(CTX ctx,const List<SV>&a);
SV GfxApi_uniformU(CTX ctx,const List<SV>&a);
SV GfxApi_addUBOBinding(CTX ctx,const List<SV>&a);
SV GfxApi_addTextureBinding(CTX ctx,const List<SV>&a);
SV GfxApi_pushState(CTX ctx,const List<SV>&a);
SV GfxApi_popState(CTX ctx,const List<SV>&a);
SV GfxApi_resetState(CTX ctx,const List<SV>&a);
SV GfxApi_setBlendingEnabled(CTX ctx,const List<SV>&a);
SV GfxApi_isBlendingEnabled(CTX ctx,const List<SV>&a);
SV GfxApi_setBlendConstantColor(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendConstantColor(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendConstantColorR(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendConstantColorG(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendConstantColorB(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendConstantColorA(CTX ctx,const List<SV>&a);
SV GfxApi_setBlendFactors(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendSrcFactorRGB(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendSrcFactorAlpha(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendDstFactorRGB(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendDstFactorAlpha(CTX ctx,const List<SV>&a);
SV GfxApi_setBlendMode(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendModeRGB(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendModeAlpha(CTX ctx,const List<SV>&a);
SV GfxApi_setWriteDepth(CTX ctx,const List<SV>&a);
SV GfxApi_getWriteDepth(CTX ctx,const List<SV>&a);
SV GfxApi_setDepthFunction(CTX ctx,const List<SV>&a);
SV GfxApi_getDepthFunction(CTX ctx,const List<SV>&a);
SV GfxApi_setViewport(CTX ctx,const List<SV>&a);
SV GfxApi_getViewportLeft(CTX ctx,const List<SV>&a);
SV GfxApi_getViewportBottom(CTX ctx,const List<SV>&a);
SV GfxApi_getViewportWidth(CTX ctx,const List<SV>&a);
SV GfxApi_getViewportHeight(CTX ctx,const List<SV>&a);
SV GfxApi_setScissor(CTX ctx,const List<SV>&a);
SV GfxApi_getScissorLeft(CTX ctx,const List<SV>&a);
SV GfxApi_getScissorBottom(CTX ctx,const List<SV>&a);
SV GfxApi_getScissorWidth(CTX ctx,const List<SV>&a);
SV GfxApi_getScissorHeight(CTX ctx,const List<SV>&a);
SV GfxApi_setScissorEnabled(CTX ctx,const List<SV>&a);
SV GfxApi_getScissorEnabled(CTX ctx,const List<SV>&a);
SV GfxApi_setTessPatchSize(CTX ctx,const List<SV>&a);
SV GfxApi_getTessPatchSize(CTX ctx,const List<SV>&a);
void ResourceManager_destroy(CTX,const SV&);
SV ResourceManager_get_member(CTX,const SV&,const SV&);
void ResourceManager_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs ResourceManager_funcs={
.destroy = ResourceManager_destroy,
.getMember = ResourceManager_get_member,
.setMember = ResourceManager_set_member
};
template <>
struct type_same<ResourceManager>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ResourceManager_typeID;
else
 RET false;
}
};

SV ResourceManager_loadShader(CTX ctx,const List<SV>&a);
SV ResourceManager_loadTexture(CTX ctx,const List<SV>&a);
SV ResourceManager_loadMesh(CTX ctx,const List<SV>&a);
SV ResourceManager_loadMaterial(CTX ctx,const List<SV>&a);
SV ResourceManager_loadModel(CTX ctx,const List<SV>&a);
SV ResourceManager_loadScene(CTX ctx,const List<SV>&a);
SV ResourceManager_loadScript(CTX ctx,const List<SV>&a);
SV ResourceManager_loadPhysicsShape(CTX ctx,const List<SV>&a);
SV ResourceManager_loadAudio(CTX ctx,const List<SV>&a);
SV ResourceManager_loadFont(CTX ctx,const List<SV>&a);
SV ResourceManager_load(CTX ctx,const List<SV>&a);
SV ResourceManager_loadShaderAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadTextureAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadMeshAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadMaterialAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadModelAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadSceneAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadScriptAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadPhysicsShapeAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadAudioAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadFontAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_isResource(CTX ctx,const List<SV>&a);
SV ResourceManager_cleanupResources(CTX ctx,const List<SV>&a);
void Font_destroy(CTX,const SV&);
SV Font_get_member(CTX,const SV&,const SV&);
void Font_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Font_funcs={
.destroy = Font_destroy,
.getMember = Font_get_member,
.setMember = Font_set_member
};
template <>
struct type_same<Font>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Font_typeID;
else
 RET false;
}
};

SV Font_removeContent(CTX ctx,const List<SV>&a);
SV Font_predictWidth(CTX ctx,const List<SV>&a);
SV Font_render(CTX ctx,const List<SV>&a);
SV Font_load(CTX ctx,const List<SV>&a);
SV Font_save(CTX ctx,const List<SV>&a);
SV Font_copy(CTX ctx,const List<SV>&a);
SV Font_getType(CTX ctx,const List<SV>&a);
SV Font_release(CTX ctx,const List<SV>&a);
SV Font_getRefCount(CTX ctx,const List<SV>&a);
SV Font_getFilename(CTX ctx,const List<SV>&a);
SV Font_setFilename(CTX ctx,const List<SV>&a);
void AudioSource_destroy(CTX,const SV&);
SV AudioSource_get_member(CTX,const SV&,const SV&);
void AudioSource_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs AudioSource_funcs={
.destroy = AudioSource_destroy,
.getMember = AudioSource_get_member,
.setMember = AudioSource_set_member
};
template <>
struct create_val<AudioSource>
{
static SV f(CTX ctx,const AudioSource&obj)
{
void *p = (void *)NEW(TYPE(AudioSource), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(AudioSource_funcs,p,EXT->AudioSource_typeID);
}
};
template <>
struct val_to_c<AudioSource>
{
static AudioSource f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->AudioSource_typeID)
RET*((AudioSource*)obj->data);
else
 CATE(TE,"Value can not be converted to AudioSource."));
} else
 CATE(TE,"Value can not be converted to AudioSource."));
}
};

template <>
struct val_to_c<const AudioSource>
{
static AudioSource f(CTX ctx,const SV val) {return val_to_c<AudioSource>::f(ctx, val);}
};

template <>
struct create_val<const AudioSource>
{
static SV f(CTX ctx,const AudioSource&obj) {return create_val<AudioSource>::f(ctx,obj);}
};

template <>
struct type_same<AudioSource>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->AudioSource_typeID;
else
 RET false;
}
};

SV AudioSource_getAudio(CTX ctx,const List<SV>&a);
SV AudioSource_setAudio(CTX ctx,const List<SV>&a);
void DrawCall_destroy(CTX,const SV&);
SV DrawCall_get_member(CTX,const SV&,const SV&);
void DrawCall_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs DrawCall_funcs={
.destroy = DrawCall_destroy,
.getMember = DrawCall_get_member,
.setMember = DrawCall_set_member
};
template <>
struct create_val<DrawCall>
{
static SV f(CTX ctx,const DrawCall&obj)
{
void *p = (void *)NEW(TYPE(DrawCall), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(DrawCall_funcs,p,EXT->DrawCall_typeID);
}
};
template <>
struct val_to_c<DrawCall>
{
static DrawCall f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->DrawCall_typeID)
RET*((DrawCall*)obj->data);
else
 CATE(TE,"Value can not be converted to DrawCall."));
} else
 CATE(TE,"Value can not be converted to DrawCall."));
}
};

template <>
struct val_to_c<const DrawCall>
{
static DrawCall f(CTX ctx,const SV val) {return val_to_c<DrawCall>::f(ctx, val);}
};

template <>
struct create_val<const DrawCall>
{
static SV f(CTX ctx,const DrawCall&obj) {return create_val<DrawCall>::f(ctx,obj);}
};

template <>
struct type_same<DrawCall>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->DrawCall_typeID;
else
 RET false;
}
};

void Application_destroy(CTX,const SV&);
SV Application_get_member(CTX,const SV&,const SV&);
void Application_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Application_funcs={
.destroy = Application_destroy,
.getMember = Application_get_member,
.setMember = Application_set_member
};
template <>
struct type_same<Application>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Application_typeID;
else
 RET false;
}
};

SV Application_mainloop(CTX ctx,const List<SV>&a);
SV Application_getPlatform(CTX ctx,const List<SV>&a);
SV Application_getResourceManager(CTX ctx,const List<SV>&a);
SV Application_getGfxApi(CTX ctx,const List<SV>&a);
SV Application_getFilesystem(CTX ctx,const List<SV>&a);
SV Application_getDebugDrawer(CTX ctx,const List<SV>&a);
SV Application_getFreeType(CTX ctx,const List<SV>&a);
SV Application_getAudioDevice(CTX ctx,const List<SV>&a);
SV Application_getScriptEngine(CTX ctx,const List<SV>&a);
SV Application_setNextScript(CTX ctx,const List<SV>&a);
SV Application_getNextScript(CTX ctx,const List<SV>&a);
SV Application_getScript(CTX ctx,const List<SV>&a);
SV Application_getStats(CTX ctx,const List<SV>&a);
SV Application_getExtensions(CTX ctx,const List<SV>&a);
void ResizableData_destroy(CTX,const SV&);
SV ResizableData_get_member(CTX,const SV&,const SV&);
void ResizableData_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs ResizableData_funcs={
.destroy = ResizableData_destroy,
.getMember = ResizableData_get_member,
.setMember = ResizableData_set_member
};
template <>
struct create_val<ResizableData>
{
static SV f(CTX ctx,const ResizableData&obj)
{
void *p = (void *)NEW(TYPE(ResizableData), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(ResizableData_funcs,p,EXT->ResizableData_typeID);
}
};
template <>
struct val_to_c<ResizableData>
{
static ResizableData f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->ResizableData_typeID)
RET*((ResizableData*)obj->data);
else
 CATE(TE,"Value can not be converted to ResizableData."));
} else
 CATE(TE,"Value can not be converted to ResizableData."));
}
};

template <>
struct val_to_c<const ResizableData>
{
static ResizableData f(CTX ctx,const SV val) {return val_to_c<ResizableData>::f(ctx, val);}
};

template <>
struct create_val<const ResizableData>
{
static SV f(CTX ctx,const ResizableData&obj) {return create_val<ResizableData>::f(ctx,obj);}
};

template <>
struct type_same<ResizableData>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ResizableData_typeID;
else
 RET false;
}
};

SV ResizableData___eq__(CTX ctx,const List<SV>&a);
SV ResizableData___neq__(CTX ctx,const List<SV>&a);
SV ResizableData_getData(CTX ctx,const List<SV>&a);
SV ResizableData_getSize(CTX ctx,const List<SV>&a);
SV ResizableData_resize(CTX ctx,const List<SV>&a);
SV ResizableData_insert(CTX ctx,const List<SV>&a);
SV ResizableData_append(CTX ctx,const List<SV>&a);
SV ResizableData_remove(CTX ctx,const List<SV>&a);
SV ResizableData_clear(CTX ctx,const List<SV>&a);
SV ResizableData_copy(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt8(CTX ctx,const List<SV>&a);
SV ResizableData_getInt8(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt16(CTX ctx,const List<SV>&a);
SV ResizableData_getInt16(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt32(CTX ctx,const List<SV>&a);
SV ResizableData_getInt32(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt64(CTX ctx,const List<SV>&a);
SV ResizableData_getInt64(CTX ctx,const List<SV>&a);
SV ResizableData_getFloat32(CTX ctx,const List<SV>&a);
SV ResizableData_getFloat64(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt16LE(CTX ctx,const List<SV>&a);
SV ResizableData_getInt16LE(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt32LE(CTX ctx,const List<SV>&a);
SV ResizableData_getInt32LE(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt64LE(CTX ctx,const List<SV>&a);
SV ResizableData_getInt64LE(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt16BE(CTX ctx,const List<SV>&a);
SV ResizableData_getInt16BE(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt32BE(CTX ctx,const List<SV>&a);
SV ResizableData_getInt32BE(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt64BE(CTX ctx,const List<SV>&a);
SV ResizableData_getInt64BE(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt8(CTX ctx,const List<SV>&a);
SV ResizableData_setInt8(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt16(CTX ctx,const List<SV>&a);
SV ResizableData_setInt16(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt32(CTX ctx,const List<SV>&a);
SV ResizableData_setInt32(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt64(CTX ctx,const List<SV>&a);
SV ResizableData_setInt64(CTX ctx,const List<SV>&a);
SV ResizableData_setFloat32(CTX ctx,const List<SV>&a);
SV ResizableData_setFloat64(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt16LE(CTX ctx,const List<SV>&a);
SV ResizableData_setInt16LE(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt32LE(CTX ctx,const List<SV>&a);
SV ResizableData_setInt32LE(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt64LE(CTX ctx,const List<SV>&a);
SV ResizableData_setInt64LE(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt16BE(CTX ctx,const List<SV>&a);
SV ResizableData_setInt16BE(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt32BE(CTX ctx,const List<SV>&a);
SV ResizableData_setInt32BE(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt64BE(CTX ctx,const List<SV>&a);
SV ResizableData_setInt64BE(CTX ctx,const List<SV>&a);
SV ResizableData_getChar(CTX ctx,const List<SV>&a);
SV ResizableData_setChar(CTX ctx,const List<SV>&a);
void GfxBuffer_destroy(CTX,const SV&);
SV GfxBuffer_get_member(CTX,const SV&,const SV&);
void GfxBuffer_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxBuffer_funcs={
.destroy = GfxBuffer_destroy,
.getMember = GfxBuffer_get_member,
.setMember = GfxBuffer_set_member
};
template <>
struct type_same<GfxBuffer>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxBuffer_typeID;
else
 RET false;
}
};

SV GfxBuffer_allocData(CTX ctx,const List<SV>&a);
SV GfxBuffer_setData(CTX ctx,const List<SV>&a);
SV GfxBuffer_getData(CTX ctx,const List<SV>&a);
SV GfxBuffer_getSize(CTX ctx,const List<SV>&a);
void GfxMaterial_destroy(CTX,const SV&);
SV GfxMaterial_get_member(CTX,const SV&,const SV&);
void GfxMaterial_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxMaterial_funcs={
.destroy = GfxMaterial_destroy,
.getMember = GfxMaterial_get_member,
.setMember = GfxMaterial_set_member
};
template <>
struct type_same<GfxMaterial>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxMaterial_typeID;
else
 RET false;
}
};

SV GfxMaterial_removeContent(CTX ctx,const List<SV>&a);
SV GfxMaterial_save(CTX ctx,const List<SV>&a);
SV GfxMaterial_setScript(CTX ctx,const List<SV>&a);
SV GfxMaterial_getScriptInst(CTX ctx,const List<SV>&a);
SV GfxMaterial_setupRender(CTX ctx,const List<SV>&a);
SV GfxMaterial_load(CTX ctx,const List<SV>&a);
SV GfxMaterial_copy(CTX ctx,const List<SV>&a);
SV GfxMaterial_getType(CTX ctx,const List<SV>&a);
SV GfxMaterial_release(CTX ctx,const List<SV>&a);
SV GfxMaterial_getRefCount(CTX ctx,const List<SV>&a);
SV GfxMaterial_getFilename(CTX ctx,const List<SV>&a);
SV GfxMaterial_setFilename(CTX ctx,const List<SV>&a);
void GfxMeshAttrib_destroy(CTX,const SV&);
SV GfxMeshAttrib_get_member(CTX,const SV&,const SV&);
void GfxMeshAttrib_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxMeshAttrib_funcs={
.destroy = GfxMeshAttrib_destroy,
.getMember = GfxMeshAttrib_get_member,
.setMember = GfxMeshAttrib_set_member
};
template <>
struct create_val<GfxMeshAttrib>
{
static SV f(CTX ctx,const GfxMeshAttrib&obj)
{
void *p = (void *)NEW(TYPE(GfxMeshAttrib), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxMeshAttrib_funcs,p,EXT->GfxMeshAttrib_typeID);
}
};
template <>
struct val_to_c<GfxMeshAttrib>
{
static GfxMeshAttrib f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxMeshAttrib_typeID)
RET*((GfxMeshAttrib*)obj->data);
else
 CATE(TE,"Value can not be converted to GfxMeshAttrib."));
} else
 CATE(TE,"Value can not be converted to GfxMeshAttrib."));
}
};

template <>
struct val_to_c<const GfxMeshAttrib>
{
static GfxMeshAttrib f(CTX ctx,const SV val) {return val_to_c<GfxMeshAttrib>::f(ctx, val);}
};

template <>
struct create_val<const GfxMeshAttrib>
{
static SV f(CTX ctx,const GfxMeshAttrib&obj) {return create_val<GfxMeshAttrib>::f(ctx,obj);}
};

template <>
struct type_same<GfxMeshAttrib>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxMeshAttrib_typeID;
else
 RET false;
}
};

void Int2_destroy(CTX,const SV&);
SV Int2_get_member(CTX,const SV&,const SV&);
void Int2_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Int2_funcs={
.destroy = Int2_destroy,
.getMember = Int2_get_member,
.setMember = Int2_set_member
};
template <>
struct create_val<T2<int32_t>>
{
static SV f(CTX ctx,const T2<int32_t>&obj)
{
void *p = (void *)NEW(TYPE(T2<int32_t>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int2_funcs,p,EXT->Int2_typeID);
}
};
template <>
struct val_to_c<T2<int32_t>>
{
static T2<int32_t> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Int2_typeID)
RET*((T2<int32_t>*)obj->data);
else
 CATE(TE,"Value can not be converted to Int2."));
} else
 CATE(TE,"Value can not be converted to Int2."));
}
};

template <>
struct val_to_c<const T2<int32_t>>
{
static T2<int32_t> f(CTX ctx,const SV val) {return val_to_c<T2<int32_t>>::f(ctx, val);}
};

template <>
struct create_val<const T2<int32_t>>
{
static SV f(CTX ctx,const T2<int32_t>&obj) {return create_val<T2<int32_t>>::f(ctx,obj);}
};

template <>
struct type_same<T2<int32_t>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Int2_typeID;
else
 RET false;
}
};

SV Int2___add__(CTX ctx,const List<SV>&a);
SV Int2___sub__(CTX ctx,const List<SV>&a);
SV Int2___mul__(CTX ctx,const List<SV>&a);
SV Int2___div__(CTX ctx,const List<SV>&a);
SV Int2___eq__(CTX ctx,const List<SV>&a);
SV Int2___neq__(CTX ctx,const List<SV>&a);
SV Int2___less__(CTX ctx,const List<SV>&a);
SV Int2___grtr__(CTX ctx,const List<SV>&a);
SV Int2___leq__(CTX ctx,const List<SV>&a);
SV Int2___geq__(CTX ctx,const List<SV>&a);
SV Int2_sum(CTX ctx,const List<SV>&a);
SV Int2_length(CTX ctx,const List<SV>&a);
SV Int2_lengthSquared(CTX ctx,const List<SV>&a);
SV Int2_dot(CTX ctx,const List<SV>&a);
SV Int2_distance(CTX ctx,const List<SV>&a);
SV Int2_distanceSquared(CTX ctx,const List<SV>&a);
SV Int2_normalize(CTX ctx,const List<SV>&a);
SV Int2_getXY(CTX ctx,const List<SV>&a);
SV Int2_setXY(CTX ctx,const List<SV>&a);
SV Int2_getYX(CTX ctx,const List<SV>&a);
SV Int2_setYX(CTX ctx,const List<SV>&a);
SV Int2_copy(CTX ctx,const List<SV>&a);
void StrStrMap_destroy(CTX,const SV&);
SV StrStrMap_get_member(CTX,const SV&,const SV&);
void StrStrMap_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs StrStrMap_funcs={
.destroy = StrStrMap_destroy,
.getMember = StrStrMap_get_member,
.setMember = StrStrMap_set_member
};
template <>
struct create_val<HashMap<Str,Str>>
{
static SV f(CTX ctx,const HashMap<Str,Str>&obj)
{
void *p = (void *)NEW(TYPE(HashMap<Str,Str>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(StrStrMap_funcs,p,EXT->StrStrMap_typeID);
}
};
template <>
struct val_to_c<HashMap<Str,Str>>
{
static HashMap<Str,Str> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->StrStrMap_typeID)
RET*((HashMap<Str,Str>*)obj->data);
else
 CATE(TE,"Value can not be converted to StrStrMap."));
} else
 CATE(TE,"Value can not be converted to StrStrMap."));
}
};

template <>
struct val_to_c<const HashMap<Str,Str>>
{
static HashMap<Str,Str> f(CTX ctx,const SV val) {return val_to_c<HashMap<Str,Str>>::f(ctx, val);}
};

template <>
struct create_val<const HashMap<Str,Str>>
{
static SV f(CTX ctx,const HashMap<Str,Str>&obj) {return create_val<HashMap<Str,Str>>::f(ctx,obj);}
};

template <>
struct type_same<HashMap<Str,Str>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->StrStrMap_typeID;
else
 RET false;
}
};

SV StrStrMap___eq__(CTX ctx,const List<SV>&a);
SV StrStrMap___neq__(CTX ctx,const List<SV>&a);
SV StrStrMap_get(CTX ctx,const List<SV>&a);
SV StrStrMap_set(CTX ctx,const List<SV>&a);
SV StrStrMap_remove(CTX ctx,const List<SV>&a);
SV StrStrMap_isEntry(CTX ctx,const List<SV>&a);
SV StrStrMap_begin(CTX ctx,const List<SV>&a);
SV StrStrMap_end(CTX ctx,const List<SV>&a);
SV StrStrMap_find(CTX ctx,const List<SV>&a);
SV StrStrMap_removeEntry(CTX ctx,const List<SV>&a);
SV StrStrMap_getCount(CTX ctx,const List<SV>&a);
SV StrStrMap_getKey(CTX ctx,const List<SV>&a);
SV StrStrMap_getValue(CTX ctx,const List<SV>&a);
SV StrStrMap_clear(CTX ctx,const List<SV>&a);
void LightPointData_destroy(CTX,const SV&);
SV LightPointData_get_member(CTX,const SV&,const SV&);
void LightPointData_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs LightPointData_funcs={
.destroy = LightPointData_destroy,
.getMember = LightPointData_get_member,
.setMember = LightPointData_set_member
};
template <>
struct create_val<LightPointData>
{
static SV f(CTX ctx,const LightPointData&obj)
{
void *p = (void *)NEW(TYPE(LightPointData), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(LightPointData_funcs,p,EXT->LightPointData_typeID);
}
};
template <>
struct val_to_c<LightPointData>
{
static LightPointData f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->LightPointData_typeID)
RET*((LightPointData*)obj->data);
else
 CATE(TE,"Value can not be converted to LightPointData."));
} else
 CATE(TE,"Value can not be converted to LightPointData."));
}
};

template <>
struct val_to_c<const LightPointData>
{
static LightPointData f(CTX ctx,const SV val) {return val_to_c<LightPointData>::f(ctx, val);}
};

template <>
struct create_val<const LightPointData>
{
static SV f(CTX ctx,const LightPointData&obj) {return create_val<LightPointData>::f(ctx,obj);}
};

template <>
struct type_same<LightPointData>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->LightPointData_typeID;
else
 RET false;
}
};

void Matrix4x4_destroy(CTX,const SV&);
SV Matrix4x4_get_member(CTX,const SV&,const SV&);
void Matrix4x4_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Matrix4x4_funcs={
.destroy = Matrix4x4_destroy,
.getMember = Matrix4x4_get_member,
.setMember = Matrix4x4_set_member
};
template <>
struct create_val<Matrix4x4>
{
static SV f(CTX ctx,const Matrix4x4&obj)
{
void *p = (void *)NEW(TYPE(Matrix4x4), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Matrix4x4_funcs,p,EXT->Matrix4x4_typeID);
}
};
template <>
struct val_to_c<Matrix4x4>
{
static Matrix4x4 f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Matrix4x4_typeID)
RET*((Matrix4x4*)obj->data);
else
 CATE(TE,"Value can not be converted to Matrix4x4."));
} else
 CATE(TE,"Value can not be converted to Matrix4x4."));
}
};

template <>
struct val_to_c<const Matrix4x4>
{
static Matrix4x4 f(CTX ctx,const SV val) {return val_to_c<Matrix4x4>::f(ctx, val);}
};

template <>
struct create_val<const Matrix4x4>
{
static SV f(CTX ctx,const Matrix4x4&obj) {return create_val<Matrix4x4>::f(ctx,obj);}
};

template <>
struct type_same<Matrix4x4>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Matrix4x4_typeID;
else
 RET false;
}
};

SV Matrix4x4___mul__(CTX ctx,const List<SV>&a);
SV Matrix4x4___div__(CTX ctx,const List<SV>&a);
SV Matrix4x4_get(CTX ctx,const List<SV>&a);
SV Matrix4x4_set(CTX ctx,const List<SV>&a);
SV Matrix4x4___eq__(CTX ctx,const List<SV>&a);
SV Matrix4x4_transpose(CTX ctx,const List<SV>&a);
SV Matrix4x4_determinant(CTX ctx,const List<SV>&a);
SV Matrix4x4_inverse(CTX ctx,const List<SV>&a);
SV Matrix4x4_multTrans(CTX ctx,const List<SV>&a);
SV Matrix4x4_multScale(CTX ctx,const List<SV>&a);
SV Matrix4x4_multQuat(CTX ctx,const List<SV>&a);
SV Matrix4x4_translate(CTX ctx,const List<SV>&a);
SV Matrix4x4_scale(CTX ctx,const List<SV>&a);
SV Matrix4x4_rotate(CTX ctx,const List<SV>&a);
SV Matrix4x4_rotatex(CTX ctx,const List<SV>&a);
SV Matrix4x4_rotatey(CTX ctx,const List<SV>&a);
SV Matrix4x4_rotatez(CTX ctx,const List<SV>&a);
SV Matrix4x4_perspective(CTX ctx,const List<SV>&a);
SV Matrix4x4_orthographic(CTX ctx,const List<SV>&a);
SV Matrix4x4_lookAt(CTX ctx,const List<SV>&a);
SV Matrix4x4_lookAtDir(CTX ctx,const List<SV>&a);
void Map_destroy(CTX,const SV&);
SV Map_get_member(CTX,const SV&,const SV&);
void Map_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Map_funcs={
.destroy = Map_destroy,
.getMember = Map_get_member,
.setMember = Map_set_member
};
template <>
struct create_val<HashMap<AutoVal,AutoVal>>
{
static SV f(CTX ctx,const HashMap<AutoVal,AutoVal>&obj)
{
void *p = (void *)NEW(TYPE(HashMap<AutoVal,AutoVal>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Map_funcs,p,EXT->Map_typeID);
}
};
template <>
struct val_to_c<HashMap<AutoVal,AutoVal>>
{
static HashMap<AutoVal,AutoVal> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Map_typeID)
RET*((HashMap<AutoVal,AutoVal>*)obj->data);
else
 CATE(TE,"Value can not be converted to Map."));
} else
 CATE(TE,"Value can not be converted to Map."));
}
};

template <>
struct val_to_c<const HashMap<AutoVal,AutoVal>>
{
static HashMap<AutoVal,AutoVal> f(CTX ctx,const SV val) {return val_to_c<HashMap<AutoVal,AutoVal>>::f(ctx, val);}
};

template <>
struct create_val<const HashMap<AutoVal,AutoVal>>
{
static SV f(CTX ctx,const HashMap<AutoVal,AutoVal>&obj) {return create_val<HashMap<AutoVal,AutoVal>>::f(ctx,obj);}
};

template <>
struct type_same<HashMap<AutoVal,AutoVal>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Map_typeID;
else
 RET false;
}
};

SV Map___eq__(CTX ctx,const List<SV>&a);
SV Map___neq__(CTX ctx,const List<SV>&a);
SV Map_get(CTX ctx,const List<SV>&a);
SV Map_set(CTX ctx,const List<SV>&a);
SV Map_remove(CTX ctx,const List<SV>&a);
SV Map_isEntry(CTX ctx,const List<SV>&a);
SV Map_begin(CTX ctx,const List<SV>&a);
SV Map_end(CTX ctx,const List<SV>&a);
SV Map_find(CTX ctx,const List<SV>&a);
SV Map_removeEntry(CTX ctx,const List<SV>&a);
SV Map_getCount(CTX ctx,const List<SV>&a);
SV Map_getKey(CTX ctx,const List<SV>&a);
SV Map_getValue(CTX ctx,const List<SV>&a);
SV Map_clear(CTX ctx,const List<SV>&a);
void ScriptInstanceList_destroy(CTX,const SV&);
SV ScriptInstanceList_get_member(CTX,const SV&,const SV&);
void ScriptInstanceList_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs ScriptInstanceList_funcs={
.destroy = ScriptInstanceList_destroy,
.getMember = ScriptInstanceList_get_member,
.setMember = ScriptInstanceList_set_member
};
template <>
struct create_val<List<ScriptInstance*>>
{
static SV f(CTX ctx,const List<ScriptInstance*>&obj)
{
void *p = (void *)NEW(TYPE(List<ScriptInstance*>), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(ScriptInstanceList_funcs,p,EXT->ScriptInstanceList_typeID);
}
};
template <>
struct val_to_c<List<ScriptInstance*>>
{
static List<ScriptInstance*> f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->ScriptInstanceList_typeID)
RET*((List<ScriptInstance*>*)obj->data);
else
 CATE(TE,"Value can not be converted to ScriptInstanceList."));
} else
 CATE(TE,"Value can not be converted to ScriptInstanceList."));
}
};

template <>
struct val_to_c<const List<ScriptInstance*>>
{
static List<ScriptInstance*> f(CTX ctx,const SV val) {return val_to_c<List<ScriptInstance*>>::f(ctx, val);}
};

template <>
struct create_val<const List<ScriptInstance*>>
{
static SV f(CTX ctx,const List<ScriptInstance*>&obj) {return create_val<List<ScriptInstance*>>::f(ctx,obj);}
};

template <>
struct type_same<List<ScriptInstance*>>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ScriptInstanceList_typeID;
else
 RET false;
}
};

SV ScriptInstanceList___eq__(CTX ctx,const List<SV>&a);
SV ScriptInstanceList___neq__(CTX ctx,const List<SV>&a);
SV ScriptInstanceList_get(CTX ctx,const List<SV>&a);
SV ScriptInstanceList_set(CTX ctx,const List<SV>&a);
SV ScriptInstanceList_getCount(CTX ctx,const List<SV>&a);
SV ScriptInstanceList_getData(CTX ctx,const List<SV>&a);
SV ScriptInstanceList_append(CTX ctx,const List<SV>&a);
SV ScriptInstanceList_insert(CTX ctx,const List<SV>&a);
SV ScriptInstanceList_remove(CTX ctx,const List<SV>&a);
SV ScriptInstanceList_clear(CTX ctx,const List<SV>&a);
SV ScriptInstanceList_find(CTX ctx,const List<SV>&a);
SV ScriptInstanceList_copy(CTX ctx,const List<SV>&a);
SV ScriptInstanceList_in(CTX ctx,const List<SV>&a);
SV ScriptInstanceList_reserve(CTX ctx,const List<SV>&a);
SV ScriptInstanceList_begin(CTX ctx,const List<SV>&a);
SV ScriptInstanceList_end(CTX ctx,const List<SV>&a);
void AudioWorld_destroy(CTX,const SV&);
SV AudioWorld_get_member(CTX,const SV&,const SV&);
void AudioWorld_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs AudioWorld_funcs={
.destroy = AudioWorld_destroy,
.getMember = AudioWorld_get_member,
.setMember = AudioWorld_set_member
};
template <>
struct create_val<AudioWorld>
{
static SV f(CTX ctx,const AudioWorld&obj)
{
void *p = (void *)NEW(TYPE(AudioWorld), obj);
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(AudioWorld_funcs,p,EXT->AudioWorld_typeID);
}
};
template <>
struct val_to_c<AudioWorld>
{
static AudioWorld f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->AudioWorld_typeID)
RET*((AudioWorld*)obj->data);
else
 CATE(TE,"Value can not be converted to AudioWorld."));
} else
 CATE(TE,"Value can not be converted to AudioWorld."));
}
};

template <>
struct val_to_c<const AudioWorld>
{
static AudioWorld f(CTX ctx,const SV val) {return val_to_c<AudioWorld>::f(ctx, val);}
};

template <>
struct create_val<const AudioWorld>
{
static SV f(CTX ctx,const AudioWorld&obj) {return create_val<AudioWorld>::f(ctx,obj);}
};

template <>
struct type_same<AudioWorld>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->AudioWorld_typeID;
else
 RET false;
}
};

SV AudioWorld_createSource(CTX ctx,const List<SV>&a);
SV AudioWorld_destroySource(CTX ctx,const List<SV>&a);
SV AudioWorld_clearSources(CTX ctx,const List<SV>&a);
SV AudioWorld_getSources(CTX ctx,const List<SV>&a);
SV AudioWorld_addToAudioDevice(CTX ctx,const List<SV>&a);
SV AudioWorld_removeFromAudioDevice(CTX ctx,const List<SV>&a);
void Audio_destroy(CTX,const SV&);
SV Audio_get_member(CTX,const SV&,const SV&);
void Audio_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs Audio_funcs={
.destroy = Audio_destroy,
.getMember = Audio_get_member,
.setMember = Audio_set_member
};
template <>
struct type_same<Audio>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Audio_typeID;
else
 RET false;
}
};

SV Audio_removeContent(CTX ctx,const List<SV>&a);
SV Audio_changeSampleFrequency(CTX ctx,const List<SV>&a);
SV Audio_getNumSamples(CTX ctx,const List<SV>&a);
SV Audio_getSample(CTX ctx,const List<SV>&a);
SV Audio_getMonoSample(CTX ctx,const List<SV>&a);
SV Audio_setSample(CTX ctx,const List<SV>&a);
SV Audio_setMonoSample(CTX ctx,const List<SV>&a);
SV Audio_getDuration(CTX ctx,const List<SV>&a);
SV Audio_getSampleIndex(CTX ctx,const List<SV>&a);
SV Audio_load(CTX ctx,const List<SV>&a);
SV Audio_save(CTX ctx,const List<SV>&a);
SV Audio_copy(CTX ctx,const List<SV>&a);
SV Audio_getType(CTX ctx,const List<SV>&a);
SV Audio_release(CTX ctx,const List<SV>&a);
SV Audio_getRefCount(CTX ctx,const List<SV>&a);
SV Audio_getFilename(CTX ctx,const List<SV>&a);
SV Audio_setFilename(CTX ctx,const List<SV>&a);
void GfxShaderCombination_destroy(CTX,const SV&);
SV GfxShaderCombination_get_member(CTX,const SV&,const SV&);
void GfxShaderCombination_set_member(CTX,const SV&,const SV&,const SV&);
static const STG::NativeObjectFuncs GfxShaderCombination_funcs={
.destroy = GfxShaderCombination_destroy,
.getMember = GfxShaderCombination_get_member,
.setMember = GfxShaderCombination_set_member
};
template <>
struct type_same<GfxShaderCombination>
{
static bool f(CTX ctx,const SV val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxShaderCombination_typeID;
else
 RET false;
}
};

SV GfxShaderCombination_setDefine(CTX ctx,const List<SV>&a);
SV GfxShaderCombination_getDefine(CTX ctx,const List<SV>&a);
SV GfxShaderCombination_removeDefine(CTX ctx,const List<SV>&a);
SV GfxShaderCombination_getShader(CTX ctx,const List<SV>&a);
SV GfxShaderCombination_setShader(CTX ctx,const List<SV>&a);
SV GfxShaderCombination_getCompiled(CTX ctx,const List<SV>&a);
SV GfxShaderCombination_getGLPipeline(CTX ctx,const List<SV>&a);
template <>
struct create_val<MCChunk *>
{
static SV f(CTX ctx,MCChunk*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(MCChunk_funcs,obj,EXT->MCChunk_typeID);
}
};
template <>
struct val_to_c<MCChunk *>
{
static MCChunk *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->MCChunk_typeID)
RET(MCChunk*)obj->data;
else
 CATE(TE,"Value is not a MCChunk."));
} else
 CATE(TE,"Value is not a MCChunk."));
}
};
template <>
struct type_same<MCChunk *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->MCChunk_typeID;
else
 RET false;
}
};
template <>
struct type_same<const MCChunk *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->MCChunk_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const MCChunk *>
{
static const MCChunk *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->MCChunk_typeID)
RET(MCChunk*)obj->data;
else
 CATE(TE,"Value is not a MCChunk."));
} else
 CATE(TE,"Value is not a MCChunk."));
}
};

template <>
struct create_val<GfxCompiledShader *>
{
static SV f(CTX ctx,GfxCompiledShader*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxCompiledShader_funcs,obj,EXT->GfxCompiledShader_typeID);
}
};
template <>
struct val_to_c<GfxCompiledShader *>
{
static GfxCompiledShader *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxCompiledShader_typeID)
RET(GfxCompiledShader*)obj->data;
else
 CATE(TE,"Value is not a GfxCompiledShader."));
} else
 CATE(TE,"Value is not a GfxCompiledShader."));
}
};
template <>
struct type_same<GfxCompiledShader *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxCompiledShader_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxCompiledShader *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxCompiledShader_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxCompiledShader *>
{
static const GfxCompiledShader *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxCompiledShader_typeID)
RET(GfxCompiledShader*)obj->data;
else
 CATE(TE,"Value is not a GfxCompiledShader."));
} else
 CATE(TE,"Value is not a GfxCompiledShader."));
}
};

template <>
struct create_val<RayCastResult *>
{
static SV f(CTX ctx,RayCastResult*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(RayCastResult_funcs,obj,EXT->RayCastResult_typeID);
}
};
template <>
struct val_to_c<RayCastResult *>
{
static RayCastResult *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RayCastResult_typeID)
RET(RayCastResult*)obj->data;
else
 CATE(TE,"Value is not a RayCastResult."));
} else
 CATE(TE,"Value is not a RayCastResult."));
}
};
template <>
struct type_same<RayCastResult *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RayCastResult_typeID;
else
 RET false;
}
};
template <>
struct type_same<const RayCastResult *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RayCastResult_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const RayCastResult *>
{
static const RayCastResult *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RayCastResult_typeID)
RET(RayCastResult*)obj->data;
else
 CATE(TE,"Value is not a RayCastResult."));
} else
 CATE(TE,"Value is not a RayCastResult."));
}
};

template <>
struct create_val<Entity *>
{
static SV f(CTX ctx,Entity*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Entity_funcs,obj,EXT->Entity_typeID);
}
};
template <>
struct val_to_c<Entity *>
{
static Entity *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Entity_typeID)
RET(Entity*)obj->data;
else
 CATE(TE,"Value is not a Entity."));
} else
 CATE(TE,"Value is not a Entity."));
}
};
template <>
struct type_same<Entity *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Entity_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Entity *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Entity_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Entity *>
{
static const Entity *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Entity_typeID)
RET(Entity*)obj->data;
else
 CATE(TE,"Value is not a Entity."));
} else
 CATE(TE,"Value is not a Entity."));
}
};

template <>
struct create_val<Stats *>
{
static SV f(CTX ctx,Stats*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Stats_funcs,obj,EXT->Stats_typeID);
}
};
template <>
struct val_to_c<Stats *>
{
static Stats *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Stats_typeID)
RET(Stats*)obj->data;
else
 CATE(TE,"Value is not a Stats."));
} else
 CATE(TE,"Value is not a Stats."));
}
};
template <>
struct type_same<Stats *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Stats_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Stats *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Stats_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Stats *>
{
static const Stats *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Stats_typeID)
RET(Stats*)obj->data;
else
 CATE(TE,"Value is not a Stats."));
} else
 CATE(TE,"Value is not a Stats."));
}
};

template <>
struct create_val<Camera *>
{
static SV f(CTX ctx,Camera*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Camera_funcs,obj,EXT->Camera_typeID);
}
};
template <>
struct val_to_c<Camera *>
{
static Camera *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Camera_typeID)
RET(Camera*)obj->data;
else
 CATE(TE,"Value is not a Camera."));
} else
 CATE(TE,"Value is not a Camera."));
}
};
template <>
struct type_same<Camera *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Camera_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Camera *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Camera_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Camera *>
{
static const Camera *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Camera_typeID)
RET(Camera*)obj->data;
else
 CATE(TE,"Value is not a Camera."));
} else
 CATE(TE,"Value is not a Camera."));
}
};

template <>
struct create_val<List<Entity*> *>
{
static SV f(CTX ctx,List<Entity*>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(EntityList_funcs,obj,EXT->EntityList_typeID);
}
};
template <>
struct val_to_c<List<Entity*> *>
{
static List<Entity*> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->EntityList_typeID)
RET(List<Entity*>*)obj->data;
else
 CATE(TE,"Value is not a EntityList."));
} else
 CATE(TE,"Value is not a EntityList."));
}
};
template <>
struct type_same<List<Entity*> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->EntityList_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<Entity*> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->EntityList_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<Entity*> *>
{
static const List<Entity*> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->EntityList_typeID)
RET(List<Entity*>*)obj->data;
else
 CATE(TE,"Value is not a EntityList."));
} else
 CATE(TE,"Value is not a EntityList."));
}
};

template <>
struct create_val<Light *>
{
static SV f(CTX ctx,Light*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Light_funcs,obj,EXT->Light_typeID);
}
};
template <>
struct val_to_c<Light *>
{
static Light *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Light_typeID)
RET(Light*)obj->data;
else
 CATE(TE,"Value is not a Light."));
} else
 CATE(TE,"Value is not a Light."));
}
};
template <>
struct type_same<Light *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Light_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Light *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Light_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Light *>
{
static const Light *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Light_typeID)
RET(Light*)obj->data;
else
 CATE(TE,"Value is not a Light."));
} else
 CATE(TE,"Value is not a Light."));
}
};

template <>
struct create_val<TextureSampler *>
{
static SV f(CTX ctx,TextureSampler*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(TextureSampler_funcs,obj,EXT->TextureSampler_typeID);
}
};
template <>
struct val_to_c<TextureSampler *>
{
static TextureSampler *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->TextureSampler_typeID)
RET(TextureSampler*)obj->data;
else
 CATE(TE,"Value is not a TextureSampler."));
} else
 CATE(TE,"Value is not a TextureSampler."));
}
};
template <>
struct type_same<TextureSampler *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->TextureSampler_typeID;
else
 RET false;
}
};
template <>
struct type_same<const TextureSampler *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->TextureSampler_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const TextureSampler *>
{
static const TextureSampler *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->TextureSampler_typeID)
RET(TextureSampler*)obj->data;
else
 CATE(TE,"Value is not a TextureSampler."));
} else
 CATE(TE,"Value is not a TextureSampler."));
}
};

template <>
struct create_val<GhostObject *>
{
static SV f(CTX ctx,GhostObject*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GhostObject_funcs,obj,EXT->GhostObject_typeID);
}
};
template <>
struct val_to_c<GhostObject *>
{
static GhostObject *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GhostObject_typeID)
RET(GhostObject*)obj->data;
else
 CATE(TE,"Value is not a GhostObject."));
} else
 CATE(TE,"Value is not a GhostObject."));
}
};
template <>
struct type_same<GhostObject *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GhostObject_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GhostObject *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GhostObject_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GhostObject *>
{
static const GhostObject *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GhostObject_typeID)
RET(GhostObject*)obj->data;
else
 CATE(TE,"Value is not a GhostObject."));
} else
 CATE(TE,"Value is not a GhostObject."));
}
};

template <>
struct create_val<List<RayCastResult> *>
{
static SV f(CTX ctx,List<RayCastResult>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(RayCastResultList_funcs,obj,EXT->RayCastResultList_typeID);
}
};
template <>
struct val_to_c<List<RayCastResult> *>
{
static List<RayCastResult> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RayCastResultList_typeID)
RET(List<RayCastResult>*)obj->data;
else
 CATE(TE,"Value is not a RayCastResultList."));
} else
 CATE(TE,"Value is not a RayCastResultList."));
}
};
template <>
struct type_same<List<RayCastResult> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RayCastResultList_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<RayCastResult> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RayCastResultList_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<RayCastResult> *>
{
static const List<RayCastResult> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RayCastResultList_typeID)
RET(List<RayCastResult>*)obj->data;
else
 CATE(TE,"Value is not a RayCastResultList."));
} else
 CATE(TE,"Value is not a RayCastResultList."));
}
};

template <>
struct create_val<RenderStats *>
{
static SV f(CTX ctx,RenderStats*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(RenderStats_funcs,obj,EXT->RenderStats_typeID);
}
};
template <>
struct val_to_c<RenderStats *>
{
static RenderStats *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RenderStats_typeID)
RET(RenderStats*)obj->data;
else
 CATE(TE,"Value is not a RenderStats."));
} else
 CATE(TE,"Value is not a RenderStats."));
}
};
template <>
struct type_same<RenderStats *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RenderStats_typeID;
else
 RET false;
}
};
template <>
struct type_same<const RenderStats *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RenderStats_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const RenderStats *>
{
static const RenderStats *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RenderStats_typeID)
RET(RenderStats*)obj->data;
else
 CATE(TE,"Value is not a RenderStats."));
} else
 CATE(TE,"Value is not a RenderStats."));
}
};

template <>
struct create_val<Quaternion *>
{
static SV f(CTX ctx,Quaternion*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Quaternion_funcs,obj,EXT->Quaternion_typeID);
}
};
template <>
struct val_to_c<Quaternion *>
{
static Quaternion *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Quaternion_typeID)
RET(Quaternion*)obj->data;
else
 CATE(TE,"Value is not a Quaternion."));
} else
 CATE(TE,"Value is not a Quaternion."));
}
};
template <>
struct type_same<Quaternion *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Quaternion_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Quaternion *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Quaternion_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Quaternion *>
{
static const Quaternion *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Quaternion_typeID)
RET(Quaternion*)obj->data;
else
 CATE(TE,"Value is not a Quaternion."));
} else
 CATE(TE,"Value is not a Quaternion."));
}
};

template <>
struct create_val<ImGui *>
{
static SV f(CTX ctx,ImGui*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(ImGui_funcs,obj,EXT->ImGui_typeID);
}
};
template <>
struct val_to_c<ImGui *>
{
static ImGui *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->ImGui_typeID)
RET(ImGui*)obj->data;
else
 CATE(TE,"Value is not a ImGui."));
} else
 CATE(TE,"Value is not a ImGui."));
}
};
template <>
struct type_same<ImGui *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ImGui_typeID;
else
 RET false;
}
};
template <>
struct type_same<const ImGui *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ImGui_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const ImGui *>
{
static const ImGui *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->ImGui_typeID)
RET(ImGui*)obj->data;
else
 CATE(TE,"Value is not a ImGui."));
} else
 CATE(TE,"Value is not a ImGui."));
}
};

template <>
struct create_val<LightDirectionalData *>
{
static SV f(CTX ctx,LightDirectionalData*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(LightDirectionalData_funcs,obj,EXT->LightDirectionalData_typeID);
}
};
template <>
struct val_to_c<LightDirectionalData *>
{
static LightDirectionalData *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->LightDirectionalData_typeID)
RET(LightDirectionalData*)obj->data;
else
 CATE(TE,"Value is not a LightDirectionalData."));
} else
 CATE(TE,"Value is not a LightDirectionalData."));
}
};
template <>
struct type_same<LightDirectionalData *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->LightDirectionalData_typeID;
else
 RET false;
}
};
template <>
struct type_same<const LightDirectionalData *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->LightDirectionalData_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const LightDirectionalData *>
{
static const LightDirectionalData *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->LightDirectionalData_typeID)
RET(LightDirectionalData*)obj->data;
else
 CATE(TE,"Value is not a LightDirectionalData."));
} else
 CATE(TE,"Value is not a LightDirectionalData."));
}
};

template <>
struct create_val<LightSpotData *>
{
static SV f(CTX ctx,LightSpotData*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(LightSpotData_funcs,obj,EXT->LightSpotData_typeID);
}
};
template <>
struct val_to_c<LightSpotData *>
{
static LightSpotData *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->LightSpotData_typeID)
RET(LightSpotData*)obj->data;
else
 CATE(TE,"Value is not a LightSpotData."));
} else
 CATE(TE,"Value is not a LightSpotData."));
}
};
template <>
struct type_same<LightSpotData *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->LightSpotData_typeID;
else
 RET false;
}
};
template <>
struct type_same<const LightSpotData *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->LightSpotData_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const LightSpotData *>
{
static const LightSpotData *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->LightSpotData_typeID)
RET(LightSpotData*)obj->data;
else
 CATE(TE,"Value is not a LightSpotData."));
} else
 CATE(TE,"Value is not a LightSpotData."));
}
};

template <>
struct create_val<List<float> *>
{
static SV f(CTX ctx,List<float>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(FloatList_funcs,obj,EXT->FloatList_typeID);
}
};
template <>
struct val_to_c<List<float> *>
{
static List<float> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->FloatList_typeID)
RET(List<float>*)obj->data;
else
 CATE(TE,"Value is not a FloatList."));
} else
 CATE(TE,"Value is not a FloatList."));
}
};
template <>
struct type_same<List<float> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->FloatList_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<float> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->FloatList_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<float> *>
{
static const List<float> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->FloatList_typeID)
RET(List<float>*)obj->data;
else
 CATE(TE,"Value is not a FloatList."));
} else
 CATE(TE,"Value is not a FloatList."));
}
};

template <>
struct create_val<GfxLOD *>
{
static SV f(CTX ctx,GfxLOD*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxLOD_funcs,obj,EXT->GfxLOD_typeID);
}
};
template <>
struct val_to_c<GfxLOD *>
{
static GfxLOD *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxLOD_typeID)
RET(GfxLOD*)obj->data;
else
 CATE(TE,"Value is not a GfxLOD."));
} else
 CATE(TE,"Value is not a GfxLOD."));
}
};
template <>
struct type_same<GfxLOD *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxLOD_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxLOD *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxLOD_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxLOD *>
{
static const GfxLOD *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxLOD_typeID)
RET(GfxLOD*)obj->data;
else
 CATE(TE,"Value is not a GfxLOD."));
} else
 CATE(TE,"Value is not a GfxLOD."));
}
};

template <>
struct create_val<List<AutoVal> *>
{
static SV f(CTX ctx,List<AutoVal>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(List_funcs,obj,EXT->List_typeID);
}
};
template <>
struct val_to_c<List<AutoVal> *>
{
static List<AutoVal> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->List_typeID)
RET(List<AutoVal>*)obj->data;
else
 CATE(TE,"Value is not a List."));
} else
 CATE(TE,"Value is not a List."));
}
};
template <>
struct type_same<List<AutoVal> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->List_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<AutoVal> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->List_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<AutoVal> *>
{
static const List<AutoVal> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->List_typeID)
RET(List<AutoVal>*)obj->data;
else
 CATE(TE,"Value is not a List."));
} else
 CATE(TE,"Value is not a List."));
}
};

template <>
struct create_val<File *>
{
static SV f(CTX ctx,File*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(File_funcs,obj,EXT->File_typeID);
}
};
template <>
struct val_to_c<File *>
{
static File *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->File_typeID)
RET(File*)obj->data;
else
 CATE(TE,"Value is not a File."));
} else
 CATE(TE,"Value is not a File."));
}
};
template <>
struct type_same<File *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->File_typeID;
else
 RET false;
}
};
template <>
struct type_same<const File *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->File_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const File *>
{
static const File *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->File_typeID)
RET(File*)obj->data;
else
 CATE(TE,"Value is not a File."));
} else
 CATE(TE,"Value is not a File."));
}
};

template <>
struct create_val<Matrix3x3 *>
{
static SV f(CTX ctx,Matrix3x3*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Matrix3x3_funcs,obj,EXT->Matrix3x3_typeID);
}
};
template <>
struct val_to_c<Matrix3x3 *>
{
static Matrix3x3 *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Matrix3x3_typeID)
RET(Matrix3x3*)obj->data;
else
 CATE(TE,"Value is not a Matrix3x3."));
} else
 CATE(TE,"Value is not a Matrix3x3."));
}
};
template <>
struct type_same<Matrix3x3 *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Matrix3x3_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Matrix3x3 *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Matrix3x3_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Matrix3x3 *>
{
static const Matrix3x3 *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Matrix3x3_typeID)
RET(Matrix3x3*)obj->data;
else
 CATE(TE,"Value is not a Matrix3x3."));
} else
 CATE(TE,"Value is not a Matrix3x3."));
}
};

template <>
struct create_val<GPUTimer *>
{
static SV f(CTX ctx,GPUTimer*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GPUTimer_funcs,obj,EXT->GPUTimer_typeID);
}
};
template <>
struct val_to_c<GPUTimer *>
{
static GPUTimer *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GPUTimer_typeID)
RET(GPUTimer*)obj->data;
else
 CATE(TE,"Value is not a GPUTimer."));
} else
 CATE(TE,"Value is not a GPUTimer."));
}
};
template <>
struct type_same<GPUTimer *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GPUTimer_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GPUTimer *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GPUTimer_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GPUTimer *>
{
static const GPUTimer *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GPUTimer_typeID)
RET(GPUTimer*)obj->data;
else
 CATE(TE,"Value is not a GPUTimer."));
} else
 CATE(TE,"Value is not a GPUTimer."));
}
};

template <>
struct create_val<Filesystem *>
{
static SV f(CTX ctx,Filesystem*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Filesystem_funcs,obj,EXT->Filesystem_typeID);
}
};
template <>
struct val_to_c<Filesystem *>
{
static Filesystem *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Filesystem_typeID)
RET(Filesystem*)obj->data;
else
 CATE(TE,"Value is not a Filesystem."));
} else
 CATE(TE,"Value is not a Filesystem."));
}
};
template <>
struct type_same<Filesystem *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Filesystem_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Filesystem *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Filesystem_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Filesystem *>
{
static const Filesystem *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Filesystem_typeID)
RET(Filesystem*)obj->data;
else
 CATE(TE,"Value is not a Filesystem."));
} else
 CATE(TE,"Value is not a Filesystem."));
}
};

template <>
struct create_val<GfxFramebuffer *>
{
static SV f(CTX ctx,GfxFramebuffer*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxFramebuffer_funcs,obj,EXT->GfxFramebuffer_typeID);
}
};
template <>
struct val_to_c<GfxFramebuffer *>
{
static GfxFramebuffer *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxFramebuffer_typeID)
RET(GfxFramebuffer*)obj->data;
else
 CATE(TE,"Value is not a GfxFramebuffer."));
} else
 CATE(TE,"Value is not a GfxFramebuffer."));
}
};
template <>
struct type_same<GfxFramebuffer *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxFramebuffer_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxFramebuffer *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxFramebuffer_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxFramebuffer *>
{
static const GfxFramebuffer *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxFramebuffer_typeID)
RET(GfxFramebuffer*)obj->data;
else
 CATE(TE,"Value is not a GfxFramebuffer."));
} else
 CATE(TE,"Value is not a GfxFramebuffer."));
}
};

template <>
struct create_val<Event *>
{
static SV f(CTX ctx,Event*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Event_funcs,obj,EXT->Event_typeID);
}
};
template <>
struct val_to_c<Event *>
{
static Event *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Event_typeID)
RET(Event*)obj->data;
else
 CATE(TE,"Value is not a Event."));
} else
 CATE(TE,"Value is not a Event."));
}
};
template <>
struct type_same<Event *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Event_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Event *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Event_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Event *>
{
static const Event *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Event_typeID)
RET(Event*)obj->data;
else
 CATE(TE,"Value is not a Event."));
} else
 CATE(TE,"Value is not a Event."));
}
};

template <>
struct create_val<Platform *>
{
static SV f(CTX ctx,Platform*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Platform_funcs,obj,EXT->Platform_typeID);
}
};
template <>
struct val_to_c<Platform *>
{
static Platform *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Platform_typeID)
RET(Platform*)obj->data;
else
 CATE(TE,"Value is not a Platform."));
} else
 CATE(TE,"Value is not a Platform."));
}
};
template <>
struct type_same<Platform *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Platform_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Platform *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Platform_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Platform *>
{
static const Platform *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Platform_typeID)
RET(Platform*)obj->data;
else
 CATE(TE,"Value is not a Platform."));
} else
 CATE(TE,"Value is not a Platform."));
}
};

template <>
struct create_val<GfxMesh *>
{
static SV f(CTX ctx,GfxMesh*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxMesh_funcs,obj,EXT->GfxMesh_typeID);
}
};
template <>
struct val_to_c<GfxMesh *>
{
static GfxMesh *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxMesh_typeID)
RET(GfxMesh*)obj->data;
else
 CATE(TE,"Value is not a GfxMesh."));
} else
 CATE(TE,"Value is not a GfxMesh."));
}
};
template <>
struct type_same<GfxMesh *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxMesh_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxMesh *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxMesh_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxMesh *>
{
static const GfxMesh *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxMesh_typeID)
RET(GfxMesh*)obj->data;
else
 CATE(TE,"Value is not a GfxMesh."));
} else
 CATE(TE,"Value is not a GfxMesh."));
}
};

template <>
struct create_val<GfxShader *>
{
static SV f(CTX ctx,GfxShader*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxShader_funcs,obj,EXT->GfxShader_typeID);
}
};
template <>
struct val_to_c<GfxShader *>
{
static GfxShader *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxShader_typeID)
RET(GfxShader*)obj->data;
else
 CATE(TE,"Value is not a GfxShader."));
} else
 CATE(TE,"Value is not a GfxShader."));
}
};
template <>
struct type_same<GfxShader *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxShader_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxShader *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxShader_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxShader *>
{
static const GfxShader *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxShader_typeID)
RET(GfxShader*)obj->data;
else
 CATE(TE,"Value is not a GfxShader."));
} else
 CATE(TE,"Value is not a GfxShader."));
}
};

template <>
struct create_val<GfxAnimationState *>
{
static SV f(CTX ctx,GfxAnimationState*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxAnimationState_funcs,obj,EXT->GfxAnimationState_typeID);
}
};
template <>
struct val_to_c<GfxAnimationState *>
{
static GfxAnimationState *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxAnimationState_typeID)
RET(GfxAnimationState*)obj->data;
else
 CATE(TE,"Value is not a GfxAnimationState."));
} else
 CATE(TE,"Value is not a GfxAnimationState."));
}
};
template <>
struct type_same<GfxAnimationState *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxAnimationState_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxAnimationState *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxAnimationState_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxAnimationState *>
{
static const GfxAnimationState *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxAnimationState_typeID)
RET(GfxAnimationState*)obj->data;
else
 CATE(TE,"Value is not a GfxAnimationState."));
} else
 CATE(TE,"Value is not a GfxAnimationState."));
}
};

template <>
struct create_val<List<Str> *>
{
static SV f(CTX ctx,List<Str>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(StringList_funcs,obj,EXT->StringList_typeID);
}
};
template <>
struct val_to_c<List<Str> *>
{
static List<Str> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->StringList_typeID)
RET(List<Str>*)obj->data;
else
 CATE(TE,"Value is not a StringList."));
} else
 CATE(TE,"Value is not a StringList."));
}
};
template <>
struct type_same<List<Str> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->StringList_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<Str> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->StringList_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<Str> *>
{
static const List<Str> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->StringList_typeID)
RET(List<Str>*)obj->data;
else
 CATE(TE,"Value is not a StringList."));
} else
 CATE(TE,"Value is not a StringList."));
}
};

template <>
struct create_val<GfxRenderer *>
{
static SV f(CTX ctx,GfxRenderer*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxRenderer_funcs,obj,EXT->GfxRenderer_typeID);
}
};
template <>
struct val_to_c<GfxRenderer *>
{
static GfxRenderer *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxRenderer_typeID)
RET(GfxRenderer*)obj->data;
else
 CATE(TE,"Value is not a GfxRenderer."));
} else
 CATE(TE,"Value is not a GfxRenderer."));
}
};
template <>
struct type_same<GfxRenderer *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxRenderer_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxRenderer *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxRenderer_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxRenderer *>
{
static const GfxRenderer *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxRenderer_typeID)
RET(GfxRenderer*)obj->data;
else
 CATE(TE,"Value is not a GfxRenderer."));
} else
 CATE(TE,"Value is not a GfxRenderer."));
}
};

template <>
struct create_val<T4<float> *>
{
static SV f(CTX ctx,T4<float>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Float4_funcs,obj,EXT->Float4_typeID);
}
};
template <>
struct val_to_c<T4<float> *>
{
static T4<float> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Float4_typeID)
RET(T4<float>*)obj->data;
else
 CATE(TE,"Value is not a Float4."));
} else
 CATE(TE,"Value is not a Float4."));
}
};
template <>
struct type_same<T4<float> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Float4_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T4<float> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Float4_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T4<float> *>
{
static const T4<float> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Float4_typeID)
RET(T4<float>*)obj->data;
else
 CATE(TE,"Value is not a Float4."));
} else
 CATE(TE,"Value is not a Float4."));
}
};

template <>
struct create_val<List<Light*> *>
{
static SV f(CTX ctx,List<Light*>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(LightList_funcs,obj,EXT->LightList_typeID);
}
};
template <>
struct val_to_c<List<Light*> *>
{
static List<Light*> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->LightList_typeID)
RET(List<Light*>*)obj->data;
else
 CATE(TE,"Value is not a LightList."));
} else
 CATE(TE,"Value is not a LightList."));
}
};
template <>
struct type_same<List<Light*> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->LightList_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<Light*> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->LightList_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<Light*> *>
{
static const List<Light*> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->LightList_typeID)
RET(List<Light*>*)obj->data;
else
 CATE(TE,"Value is not a LightList."));
} else
 CATE(TE,"Value is not a LightList."));
}
};

template <>
struct create_val<T2<float> *>
{
static SV f(CTX ctx,T2<float>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Float2_funcs,obj,EXT->Float2_typeID);
}
};
template <>
struct val_to_c<T2<float> *>
{
static T2<float> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Float2_typeID)
RET(T2<float>*)obj->data;
else
 CATE(TE,"Value is not a Float2."));
} else
 CATE(TE,"Value is not a Float2."));
}
};
template <>
struct type_same<T2<float> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Float2_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T2<float> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Float2_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T2<float> *>
{
static const T2<float> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Float2_typeID)
RET(T2<float>*)obj->data;
else
 CATE(TE,"Value is not a Float2."));
} else
 CATE(TE,"Value is not a Float2."));
}
};

template <>
struct create_val<T3<float> *>
{
static SV f(CTX ctx,T3<float>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Float3_funcs,obj,EXT->Float3_typeID);
}
};
template <>
struct val_to_c<T3<float> *>
{
static T3<float> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Float3_typeID)
RET(T3<float>*)obj->data;
else
 CATE(TE,"Value is not a Float3."));
} else
 CATE(TE,"Value is not a Float3."));
}
};
template <>
struct type_same<T3<float> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Float3_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T3<float> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Float3_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T3<float> *>
{
static const T3<float> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Float3_typeID)
RET(T3<float>*)obj->data;
else
 CATE(TE,"Value is not a Float3."));
} else
 CATE(TE,"Value is not a Float3."));
}
};

template <>
struct create_val<Container *>
{
static SV f(CTX ctx,Container*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Container_funcs,obj,EXT->Container_typeID);
}
};
template <>
struct val_to_c<Container *>
{
static Container *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Container_typeID)
RET(Container*)obj->data;
else
 CATE(TE,"Value is not a Container."));
} else
 CATE(TE,"Value is not a Container."));
}
};
template <>
struct type_same<Container *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Container_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Container *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Container_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Container *>
{
static const Container *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Container_typeID)
RET(Container*)obj->data;
else
 CATE(TE,"Value is not a Container."));
} else
 CATE(TE,"Value is not a Container."));
}
};

template <>
struct create_val<Frustum *>
{
static SV f(CTX ctx,Frustum*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Frustum_funcs,obj,EXT->Frustum_typeID);
}
};
template <>
struct val_to_c<Frustum *>
{
static Frustum *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Frustum_typeID)
RET(Frustum*)obj->data;
else
 CATE(TE,"Value is not a Frustum."));
} else
 CATE(TE,"Value is not a Frustum."));
}
};
template <>
struct type_same<Frustum *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Frustum_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Frustum *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Frustum_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Frustum *>
{
static const Frustum *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Frustum_typeID)
RET(Frustum*)obj->data;
else
 CATE(TE,"Value is not a Frustum."));
} else
 CATE(TE,"Value is not a Frustum."));
}
};

template <>
struct create_val<AudioDevice *>
{
static SV f(CTX ctx,AudioDevice*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(AudioDevice_funcs,obj,EXT->AudioDevice_typeID);
}
};
template <>
struct val_to_c<AudioDevice *>
{
static AudioDevice *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->AudioDevice_typeID)
RET(AudioDevice*)obj->data;
else
 CATE(TE,"Value is not a AudioDevice."));
} else
 CATE(TE,"Value is not a AudioDevice."));
}
};
template <>
struct type_same<AudioDevice *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->AudioDevice_typeID;
else
 RET false;
}
};
template <>
struct type_same<const AudioDevice *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->AudioDevice_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const AudioDevice *>
{
static const AudioDevice *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->AudioDevice_typeID)
RET(AudioDevice*)obj->data;
else
 CATE(TE,"Value is not a AudioDevice."));
} else
 CATE(TE,"Value is not a AudioDevice."));
}
};

template <>
struct create_val<T4<uint32_t> *>
{
static SV f(CTX ctx,T4<uint32_t>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(UInt4_funcs,obj,EXT->UInt4_typeID);
}
};
template <>
struct val_to_c<T4<uint32_t> *>
{
static T4<uint32_t> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->UInt4_typeID)
RET(T4<uint32_t>*)obj->data;
else
 CATE(TE,"Value is not a UInt4."));
} else
 CATE(TE,"Value is not a UInt4."));
}
};
template <>
struct type_same<T4<uint32_t> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->UInt4_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T4<uint32_t> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->UInt4_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T4<uint32_t> *>
{
static const T4<uint32_t> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->UInt4_typeID)
RET(T4<uint32_t>*)obj->data;
else
 CATE(TE,"Value is not a UInt4."));
} else
 CATE(TE,"Value is not a UInt4."));
}
};

template <>
struct create_val<T3<uint32_t> *>
{
static SV f(CTX ctx,T3<uint32_t>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(UInt3_funcs,obj,EXT->UInt3_typeID);
}
};
template <>
struct val_to_c<T3<uint32_t> *>
{
static T3<uint32_t> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->UInt3_typeID)
RET(T3<uint32_t>*)obj->data;
else
 CATE(TE,"Value is not a UInt3."));
} else
 CATE(TE,"Value is not a UInt3."));
}
};
template <>
struct type_same<T3<uint32_t> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->UInt3_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T3<uint32_t> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->UInt3_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T3<uint32_t> *>
{
static const T3<uint32_t> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->UInt3_typeID)
RET(T3<uint32_t>*)obj->data;
else
 CATE(TE,"Value is not a UInt3."));
} else
 CATE(TE,"Value is not a UInt3."));
}
};

template <>
struct create_val<T2<uint32_t> *>
{
static SV f(CTX ctx,T2<uint32_t>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(UInt2_funcs,obj,EXT->UInt2_typeID);
}
};
template <>
struct val_to_c<T2<uint32_t> *>
{
static T2<uint32_t> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->UInt2_typeID)
RET(T2<uint32_t>*)obj->data;
else
 CATE(TE,"Value is not a UInt2."));
} else
 CATE(TE,"Value is not a UInt2."));
}
};
template <>
struct type_same<T2<uint32_t> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->UInt2_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T2<uint32_t> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->UInt2_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T2<uint32_t> *>
{
static const T2<uint32_t> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->UInt2_typeID)
RET(T2<uint32_t>*)obj->data;
else
 CATE(TE,"Value is not a UInt2."));
} else
 CATE(TE,"Value is not a UInt2."));
}
};

template <>
struct create_val<AABB *>
{
static SV f(CTX ctx,AABB*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(AABB_funcs,obj,EXT->AABB_typeID);
}
};
template <>
struct val_to_c<AABB *>
{
static AABB *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->AABB_typeID)
RET(AABB*)obj->data;
else
 CATE(TE,"Value is not a AABB."));
} else
 CATE(TE,"Value is not a AABB."));
}
};
template <>
struct type_same<AABB *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->AABB_typeID;
else
 RET false;
}
};
template <>
struct type_same<const AABB *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->AABB_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const AABB *>
{
static const AABB *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->AABB_typeID)
RET(AABB*)obj->data;
else
 CATE(TE,"Value is not a AABB."));
} else
 CATE(TE,"Value is not a AABB."));
}
};

template <>
struct create_val<Scene *>
{
static SV f(CTX ctx,Scene*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Scene_funcs,obj,EXT->Scene_typeID);
}
};
template <>
struct val_to_c<Scene *>
{
static Scene *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Scene_typeID)
RET(Scene*)obj->data;
else
 CATE(TE,"Value is not a Scene."));
} else
 CATE(TE,"Value is not a Scene."));
}
};
template <>
struct type_same<Scene *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Scene_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Scene *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Scene_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Scene *>
{
static const Scene *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Scene_typeID)
RET(Scene*)obj->data;
else
 CATE(TE,"Value is not a Scene."));
} else
 CATE(TE,"Value is not a Scene."));
}
};

template <>
struct create_val<List<GfxModel::SubModel> *>
{
static SV f(CTX ctx,List<GfxModel::SubModel>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxSubModelList_funcs,obj,EXT->GfxSubModelList_typeID);
}
};
template <>
struct val_to_c<List<GfxModel::SubModel> *>
{
static List<GfxModel::SubModel> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxSubModelList_typeID)
RET(List<GfxModel::SubModel>*)obj->data;
else
 CATE(TE,"Value is not a GfxSubModelList."));
} else
 CATE(TE,"Value is not a GfxSubModelList."));
}
};
template <>
struct type_same<List<GfxModel::SubModel> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxSubModelList_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<GfxModel::SubModel> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxSubModelList_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<GfxModel::SubModel> *>
{
static const List<GfxModel::SubModel> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxSubModelList_typeID)
RET(List<GfxModel::SubModel>*)obj->data;
else
 CATE(TE,"Value is not a GfxSubModelList."));
} else
 CATE(TE,"Value is not a GfxSubModelList."));
}
};

template <>
struct create_val<GfxDebugDrawer *>
{
static SV f(CTX ctx,GfxDebugDrawer*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxDebugDrawer_funcs,obj,EXT->GfxDebugDrawer_typeID);
}
};
template <>
struct val_to_c<GfxDebugDrawer *>
{
static GfxDebugDrawer *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxDebugDrawer_typeID)
RET(GfxDebugDrawer*)obj->data;
else
 CATE(TE,"Value is not a GfxDebugDrawer."));
} else
 CATE(TE,"Value is not a GfxDebugDrawer."));
}
};
template <>
struct type_same<GfxDebugDrawer *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxDebugDrawer_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxDebugDrawer *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxDebugDrawer_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxDebugDrawer *>
{
static const GfxDebugDrawer *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxDebugDrawer_typeID)
RET(GfxDebugDrawer*)obj->data;
else
 CATE(TE,"Value is not a GfxDebugDrawer."));
} else
 CATE(TE,"Value is not a GfxDebugDrawer."));
}
};

template <>
struct create_val<GuiPlacer *>
{
static SV f(CTX ctx,GuiPlacer*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GuiPlacer_funcs,obj,EXT->GuiPlacer_typeID);
}
};
template <>
struct val_to_c<GuiPlacer *>
{
static GuiPlacer *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GuiPlacer_typeID)
RET(GuiPlacer*)obj->data;
else
 CATE(TE,"Value is not a GuiPlacer."));
} else
 CATE(TE,"Value is not a GuiPlacer."));
}
};
template <>
struct type_same<GuiPlacer *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GuiPlacer_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GuiPlacer *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GuiPlacer_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GuiPlacer *>
{
static const GuiPlacer *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GuiPlacer_typeID)
RET(GuiPlacer*)obj->data;
else
 CATE(TE,"Value is not a GuiPlacer."));
} else
 CATE(TE,"Value is not a GuiPlacer."));
}
};

template <>
struct create_val<List<GhostObject*> *>
{
static SV f(CTX ctx,List<GhostObject*>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GhostObjList_funcs,obj,EXT->GhostObjList_typeID);
}
};
template <>
struct val_to_c<List<GhostObject*> *>
{
static List<GhostObject*> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GhostObjList_typeID)
RET(List<GhostObject*>*)obj->data;
else
 CATE(TE,"Value is not a GhostObjList."));
} else
 CATE(TE,"Value is not a GhostObjList."));
}
};
template <>
struct type_same<List<GhostObject*> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GhostObjList_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<GhostObject*> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GhostObjList_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<GhostObject*> *>
{
static const List<GhostObject*> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GhostObjList_typeID)
RET(List<GhostObject*>*)obj->data;
else
 CATE(TE,"Value is not a GhostObjList."));
} else
 CATE(TE,"Value is not a GhostObjList."));
}
};

template <>
struct create_val<PhysicsWorld *>
{
static SV f(CTX ctx,PhysicsWorld*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(PhysicsWorld_funcs,obj,EXT->PhysicsWorld_typeID);
}
};
template <>
struct val_to_c<PhysicsWorld *>
{
static PhysicsWorld *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->PhysicsWorld_typeID)
RET(PhysicsWorld*)obj->data;
else
 CATE(TE,"Value is not a PhysicsWorld."));
} else
 CATE(TE,"Value is not a PhysicsWorld."));
}
};
template <>
struct type_same<PhysicsWorld *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->PhysicsWorld_typeID;
else
 RET false;
}
};
template <>
struct type_same<const PhysicsWorld *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->PhysicsWorld_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const PhysicsWorld *>
{
static const PhysicsWorld *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->PhysicsWorld_typeID)
RET(PhysicsWorld*)obj->data;
else
 CATE(TE,"Value is not a PhysicsWorld."));
} else
 CATE(TE,"Value is not a PhysicsWorld."));
}
};

template <>
struct create_val<Script *>
{
static SV f(CTX ctx,Script*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Script_funcs,obj,EXT->Script_typeID);
}
};
template <>
struct val_to_c<Script *>
{
static Script *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Script_typeID)
RET(Script*)obj->data;
else
 CATE(TE,"Value is not a Script."));
} else
 CATE(TE,"Value is not a Script."));
}
};
template <>
struct type_same<Script *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Script_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Script *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Script_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Script *>
{
static const Script *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Script_typeID)
RET(Script*)obj->data;
else
 CATE(TE,"Value is not a Script."));
} else
 CATE(TE,"Value is not a Script."));
}
};

template <>
struct create_val<MCWorld *>
{
static SV f(CTX ctx,MCWorld*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(MCWorld_funcs,obj,EXT->MCWorld_typeID);
}
};
template <>
struct val_to_c<MCWorld *>
{
static MCWorld *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->MCWorld_typeID)
RET(MCWorld*)obj->data;
else
 CATE(TE,"Value is not a MCWorld."));
} else
 CATE(TE,"Value is not a MCWorld."));
}
};
template <>
struct type_same<MCWorld *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->MCWorld_typeID;
else
 RET false;
}
};
template <>
struct type_same<const MCWorld *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->MCWorld_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const MCWorld *>
{
static const MCWorld *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->MCWorld_typeID)
RET(MCWorld*)obj->data;
else
 CATE(TE,"Value is not a MCWorld."));
} else
 CATE(TE,"Value is not a MCWorld."));
}
};

template <>
struct create_val<GfxObject *>
{
static SV f(CTX ctx,GfxObject*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxObject_funcs,obj,EXT->GfxObject_typeID);
}
};
template <>
struct val_to_c<GfxObject *>
{
static GfxObject *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxObject_typeID)
RET(GfxObject*)obj->data;
else
 CATE(TE,"Value is not a GfxObject."));
} else
 CATE(TE,"Value is not a GfxObject."));
}
};
template <>
struct type_same<GfxObject *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxObject_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxObject *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxObject_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxObject *>
{
static const GfxObject *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxObject_typeID)
RET(GfxObject*)obj->data;
else
 CATE(TE,"Value is not a GfxObject."));
} else
 CATE(TE,"Value is not a GfxObject."));
}
};

template <>
struct create_val<Transform *>
{
static SV f(CTX ctx,Transform*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Transform_funcs,obj,EXT->Transform_typeID);
}
};
template <>
struct val_to_c<Transform *>
{
static Transform *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Transform_typeID)
RET(Transform*)obj->data;
else
 CATE(TE,"Value is not a Transform."));
} else
 CATE(TE,"Value is not a Transform."));
}
};
template <>
struct type_same<Transform *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Transform_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Transform *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Transform_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Transform *>
{
static const Transform *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Transform_typeID)
RET(Transform*)obj->data;
else
 CATE(TE,"Value is not a Transform."));
} else
 CATE(TE,"Value is not a Transform."));
}
};

template <>
struct create_val<List<AudioSource*> *>
{
static SV f(CTX ctx,List<AudioSource*>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(AudioSourceList_funcs,obj,EXT->AudioSourceList_typeID);
}
};
template <>
struct val_to_c<List<AudioSource*> *>
{
static List<AudioSource*> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->AudioSourceList_typeID)
RET(List<AudioSource*>*)obj->data;
else
 CATE(TE,"Value is not a AudioSourceList."));
} else
 CATE(TE,"Value is not a AudioSourceList."));
}
};
template <>
struct type_same<List<AudioSource*> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->AudioSourceList_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<AudioSource*> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->AudioSourceList_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<AudioSource*> *>
{
static const List<AudioSource*> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->AudioSourceList_typeID)
RET(List<AudioSource*>*)obj->data;
else
 CATE(TE,"Value is not a AudioSourceList."));
} else
 CATE(TE,"Value is not a AudioSourceList."));
}
};

template <>
struct create_val<T4<int32_t> *>
{
static SV f(CTX ctx,T4<int32_t>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Int4_funcs,obj,EXT->Int4_typeID);
}
};
template <>
struct val_to_c<T4<int32_t> *>
{
static T4<int32_t> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Int4_typeID)
RET(T4<int32_t>*)obj->data;
else
 CATE(TE,"Value is not a Int4."));
} else
 CATE(TE,"Value is not a Int4."));
}
};
template <>
struct type_same<T4<int32_t> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Int4_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T4<int32_t> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Int4_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T4<int32_t> *>
{
static const T4<int32_t> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Int4_typeID)
RET(T4<int32_t>*)obj->data;
else
 CATE(TE,"Value is not a Int4."));
} else
 CATE(TE,"Value is not a Int4."));
}
};

template <>
struct create_val<ScrollBar *>
{
static SV f(CTX ctx,ScrollBar*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(ScrollBar_funcs,obj,EXT->ScrollBar_typeID);
}
};
template <>
struct val_to_c<ScrollBar *>
{
static ScrollBar *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->ScrollBar_typeID)
RET(ScrollBar*)obj->data;
else
 CATE(TE,"Value is not a ScrollBar."));
} else
 CATE(TE,"Value is not a ScrollBar."));
}
};
template <>
struct type_same<ScrollBar *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ScrollBar_typeID;
else
 RET false;
}
};
template <>
struct type_same<const ScrollBar *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ScrollBar_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const ScrollBar *>
{
static const ScrollBar *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->ScrollBar_typeID)
RET(ScrollBar*)obj->data;
else
 CATE(TE,"Value is not a ScrollBar."));
} else
 CATE(TE,"Value is not a ScrollBar."));
}
};

template <>
struct create_val<T3<int32_t> *>
{
static SV f(CTX ctx,T3<int32_t>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Int3_funcs,obj,EXT->Int3_typeID);
}
};
template <>
struct val_to_c<T3<int32_t> *>
{
static T3<int32_t> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Int3_typeID)
RET(T3<int32_t>*)obj->data;
else
 CATE(TE,"Value is not a Int3."));
} else
 CATE(TE,"Value is not a Int3."));
}
};
template <>
struct type_same<T3<int32_t> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Int3_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T3<int32_t> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Int3_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T3<int32_t> *>
{
static const T3<int32_t> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Int3_typeID)
RET(T3<int32_t>*)obj->data;
else
 CATE(TE,"Value is not a Int3."));
} else
 CATE(TE,"Value is not a Int3."));
}
};

template <>
struct create_val<ScriptInstance *>
{
static SV f(CTX ctx,ScriptInstance*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(ScriptInstance_funcs,obj,EXT->ScriptInstance_typeID);
}
};
template <>
struct val_to_c<ScriptInstance *>
{
static ScriptInstance *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->ScriptInstance_typeID)
RET(ScriptInstance*)obj->data;
else
 CATE(TE,"Value is not a ScriptInstance."));
} else
 CATE(TE,"Value is not a ScriptInstance."));
}
};
template <>
struct type_same<ScriptInstance *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ScriptInstance_typeID;
else
 RET false;
}
};
template <>
struct type_same<const ScriptInstance *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ScriptInstance_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const ScriptInstance *>
{
static const ScriptInstance *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->ScriptInstance_typeID)
RET(ScriptInstance*)obj->data;
else
 CATE(TE,"Value is not a ScriptInstance."));
} else
 CATE(TE,"Value is not a ScriptInstance."));
}
};

template <>
struct create_val<RenderComponent *>
{
static SV f(CTX ctx,RenderComponent*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(RenderComponent_funcs,obj,EXT->RenderComponent_typeID);
}
};
template <>
struct val_to_c<RenderComponent *>
{
static RenderComponent *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RenderComponent_typeID)
RET(RenderComponent*)obj->data;
else
 CATE(TE,"Value is not a RenderComponent."));
} else
 CATE(TE,"Value is not a RenderComponent."));
}
};
template <>
struct type_same<RenderComponent *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RenderComponent_typeID;
else
 RET false;
}
};
template <>
struct type_same<const RenderComponent *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RenderComponent_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const RenderComponent *>
{
static const RenderComponent *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RenderComponent_typeID)
RET(RenderComponent*)obj->data;
else
 CATE(TE,"Value is not a RenderComponent."));
} else
 CATE(TE,"Value is not a RenderComponent."));
}
};

template <>
struct create_val<RigidBody *>
{
static SV f(CTX ctx,RigidBody*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(RigidBody_funcs,obj,EXT->RigidBody_typeID);
}
};
template <>
struct val_to_c<RigidBody *>
{
static RigidBody *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RigidBody_typeID)
RET(RigidBody*)obj->data;
else
 CATE(TE,"Value is not a RigidBody."));
} else
 CATE(TE,"Value is not a RigidBody."));
}
};
template <>
struct type_same<RigidBody *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RigidBody_typeID;
else
 RET false;
}
};
template <>
struct type_same<const RigidBody *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RigidBody_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const RigidBody *>
{
static const RigidBody *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RigidBody_typeID)
RET(RigidBody*)obj->data;
else
 CATE(TE,"Value is not a RigidBody."));
} else
 CATE(TE,"Value is not a RigidBody."));
}
};

template <>
struct create_val<RenderList *>
{
static SV f(CTX ctx,RenderList*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(RenderList_funcs,obj,EXT->RenderList_typeID);
}
};
template <>
struct val_to_c<RenderList *>
{
static RenderList *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RenderList_typeID)
RET(RenderList*)obj->data;
else
 CATE(TE,"Value is not a RenderList."));
} else
 CATE(TE,"Value is not a RenderList."));
}
};
template <>
struct type_same<RenderList *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RenderList_typeID;
else
 RET false;
}
};
template <>
struct type_same<const RenderList *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RenderList_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const RenderList *>
{
static const RenderList *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RenderList_typeID)
RET(RenderList*)obj->data;
else
 CATE(TE,"Value is not a RenderList."));
} else
 CATE(TE,"Value is not a RenderList."));
}
};

template <>
struct create_val<Plane *>
{
static SV f(CTX ctx,Plane*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Plane_funcs,obj,EXT->Plane_typeID);
}
};
template <>
struct val_to_c<Plane *>
{
static Plane *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Plane_typeID)
RET(Plane*)obj->data;
else
 CATE(TE,"Value is not a Plane."));
} else
 CATE(TE,"Value is not a Plane."));
}
};
template <>
struct type_same<Plane *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Plane_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Plane *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Plane_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Plane *>
{
static const Plane *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Plane_typeID)
RET(Plane*)obj->data;
else
 CATE(TE,"Value is not a Plane."));
} else
 CATE(TE,"Value is not a Plane."));
}
};

template <>
struct create_val<PhysicsShape *>
{
static SV f(CTX ctx,PhysicsShape*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(PhysicsShape_funcs,obj,EXT->PhysicsShape_typeID);
}
};
template <>
struct val_to_c<PhysicsShape *>
{
static PhysicsShape *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->PhysicsShape_typeID)
RET(PhysicsShape*)obj->data;
else
 CATE(TE,"Value is not a PhysicsShape."));
} else
 CATE(TE,"Value is not a PhysicsShape."));
}
};
template <>
struct type_same<PhysicsShape *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->PhysicsShape_typeID;
else
 RET false;
}
};
template <>
struct type_same<const PhysicsShape *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->PhysicsShape_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const PhysicsShape *>
{
static const PhysicsShape *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->PhysicsShape_typeID)
RET(PhysicsShape*)obj->data;
else
 CATE(TE,"Value is not a PhysicsShape."));
} else
 CATE(TE,"Value is not a PhysicsShape."));
}
};

template <>
struct create_val<List<RigidBody*> *>
{
static SV f(CTX ctx,List<RigidBody*>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(RigidBodyList_funcs,obj,EXT->RigidBodyList_typeID);
}
};
template <>
struct val_to_c<List<RigidBody*> *>
{
static List<RigidBody*> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RigidBodyList_typeID)
RET(List<RigidBody*>*)obj->data;
else
 CATE(TE,"Value is not a RigidBodyList."));
} else
 CATE(TE,"Value is not a RigidBodyList."));
}
};
template <>
struct type_same<List<RigidBody*> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RigidBodyList_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<RigidBody*> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RigidBodyList_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<RigidBody*> *>
{
static const List<RigidBody*> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RigidBodyList_typeID)
RET(List<RigidBody*>*)obj->data;
else
 CATE(TE,"Value is not a RigidBodyList."));
} else
 CATE(TE,"Value is not a RigidBodyList."));
}
};

template <>
struct create_val<Resource *>
{
static SV f(CTX ctx,Resource*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Resource_funcs,obj,EXT->Resource_typeID);
}
};
template <>
struct val_to_c<Resource *>
{
static Resource *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Resource_typeID)
RET(Resource*)obj->data;
else
 CATE(TE,"Value is not a Resource."));
} else
 CATE(TE,"Value is not a Resource."));
}
};
template <>
struct type_same<Resource *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Resource_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Resource *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Resource_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Resource *>
{
static const Resource *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Resource_typeID)
RET(Resource*)obj->data;
else
 CATE(TE,"Value is not a Resource."));
} else
 CATE(TE,"Value is not a Resource."));
}
};

template <>
struct create_val<GfxTexture *>
{
static SV f(CTX ctx,GfxTexture*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxTexture_funcs,obj,EXT->GfxTexture_typeID);
}
};
template <>
struct val_to_c<GfxTexture *>
{
static GfxTexture *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxTexture_typeID)
RET(GfxTexture*)obj->data;
else
 CATE(TE,"Value is not a GfxTexture."));
} else
 CATE(TE,"Value is not a GfxTexture."));
}
};
template <>
struct type_same<GfxTexture *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxTexture_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxTexture *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxTexture_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxTexture *>
{
static const GfxTexture *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxTexture_typeID)
RET(GfxTexture*)obj->data;
else
 CATE(TE,"Value is not a GfxTexture."));
} else
 CATE(TE,"Value is not a GfxTexture."));
}
};

template <>
struct create_val<GfxModel *>
{
static SV f(CTX ctx,GfxModel*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxModel_funcs,obj,EXT->GfxModel_typeID);
}
};
template <>
struct val_to_c<GfxModel *>
{
static GfxModel *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxModel_typeID)
RET(GfxModel*)obj->data;
else
 CATE(TE,"Value is not a GfxModel."));
} else
 CATE(TE,"Value is not a GfxModel."));
}
};
template <>
struct type_same<GfxModel *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxModel_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxModel *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxModel_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxModel *>
{
static const GfxModel *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxModel_typeID)
RET(GfxModel*)obj->data;
else
 CATE(TE,"Value is not a GfxModel."));
} else
 CATE(TE,"Value is not a GfxModel."));
}
};

template <>
struct create_val<List<GfxLOD> *>
{
static SV f(CTX ctx,List<GfxLOD>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxLODList_funcs,obj,EXT->GfxLODList_typeID);
}
};
template <>
struct val_to_c<List<GfxLOD> *>
{
static List<GfxLOD> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxLODList_typeID)
RET(List<GfxLOD>*)obj->data;
else
 CATE(TE,"Value is not a GfxLODList."));
} else
 CATE(TE,"Value is not a GfxLODList."));
}
};
template <>
struct type_same<List<GfxLOD> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxLODList_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<GfxLOD> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxLODList_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<GfxLOD> *>
{
static const List<GfxLOD> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxLODList_typeID)
RET(List<GfxLOD>*)obj->data;
else
 CATE(TE,"Value is not a GfxLODList."));
} else
 CATE(TE,"Value is not a GfxLODList."));
}
};

template <>
struct create_val<RigidBodyConstructionInfo *>
{
static SV f(CTX ctx,RigidBodyConstructionInfo*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(RigidBodyConstructionInfo_funcs,obj,EXT->RigidBodyConstructionInfo_typeID);
}
};
template <>
struct val_to_c<RigidBodyConstructionInfo *>
{
static RigidBodyConstructionInfo *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RigidBodyConstructionInfo_typeID)
RET(RigidBodyConstructionInfo*)obj->data;
else
 CATE(TE,"Value is not a RigidBodyConstructionInfo."));
} else
 CATE(TE,"Value is not a RigidBodyConstructionInfo."));
}
};
template <>
struct type_same<RigidBodyConstructionInfo *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RigidBodyConstructionInfo_typeID;
else
 RET false;
}
};
template <>
struct type_same<const RigidBodyConstructionInfo *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->RigidBodyConstructionInfo_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const RigidBodyConstructionInfo *>
{
static const RigidBodyConstructionInfo *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->RigidBodyConstructionInfo_typeID)
RET(RigidBodyConstructionInfo*)obj->data;
else
 CATE(TE,"Value is not a RigidBodyConstructionInfo."));
} else
 CATE(TE,"Value is not a RigidBodyConstructionInfo."));
}
};

template <>
struct create_val<GfxApi *>
{
static SV f(CTX ctx,GfxApi*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxApi_funcs,obj,EXT->GfxApi_typeID);
}
};
template <>
struct val_to_c<GfxApi *>
{
static GfxApi *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxApi_typeID)
RET(GfxApi*)obj->data;
else
 CATE(TE,"Value is not a GfxApi."));
} else
 CATE(TE,"Value is not a GfxApi."));
}
};
template <>
struct type_same<GfxApi *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxApi_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxApi *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxApi_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxApi *>
{
static const GfxApi *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxApi_typeID)
RET(GfxApi*)obj->data;
else
 CATE(TE,"Value is not a GfxApi."));
} else
 CATE(TE,"Value is not a GfxApi."));
}
};

template <>
struct create_val<ResourceManager *>
{
static SV f(CTX ctx,ResourceManager*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(ResourceManager_funcs,obj,EXT->ResourceManager_typeID);
}
};
template <>
struct val_to_c<ResourceManager *>
{
static ResourceManager *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->ResourceManager_typeID)
RET(ResourceManager*)obj->data;
else
 CATE(TE,"Value is not a ResourceManager."));
} else
 CATE(TE,"Value is not a ResourceManager."));
}
};
template <>
struct type_same<ResourceManager *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ResourceManager_typeID;
else
 RET false;
}
};
template <>
struct type_same<const ResourceManager *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ResourceManager_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const ResourceManager *>
{
static const ResourceManager *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->ResourceManager_typeID)
RET(ResourceManager*)obj->data;
else
 CATE(TE,"Value is not a ResourceManager."));
} else
 CATE(TE,"Value is not a ResourceManager."));
}
};

template <>
struct create_val<Font *>
{
static SV f(CTX ctx,Font*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Font_funcs,obj,EXT->Font_typeID);
}
};
template <>
struct val_to_c<Font *>
{
static Font *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Font_typeID)
RET(Font*)obj->data;
else
 CATE(TE,"Value is not a Font."));
} else
 CATE(TE,"Value is not a Font."));
}
};
template <>
struct type_same<Font *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Font_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Font *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Font_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Font *>
{
static const Font *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Font_typeID)
RET(Font*)obj->data;
else
 CATE(TE,"Value is not a Font."));
} else
 CATE(TE,"Value is not a Font."));
}
};

template <>
struct create_val<AudioSource *>
{
static SV f(CTX ctx,AudioSource*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(AudioSource_funcs,obj,EXT->AudioSource_typeID);
}
};
template <>
struct val_to_c<AudioSource *>
{
static AudioSource *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->AudioSource_typeID)
RET(AudioSource*)obj->data;
else
 CATE(TE,"Value is not a AudioSource."));
} else
 CATE(TE,"Value is not a AudioSource."));
}
};
template <>
struct type_same<AudioSource *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->AudioSource_typeID;
else
 RET false;
}
};
template <>
struct type_same<const AudioSource *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->AudioSource_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const AudioSource *>
{
static const AudioSource *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->AudioSource_typeID)
RET(AudioSource*)obj->data;
else
 CATE(TE,"Value is not a AudioSource."));
} else
 CATE(TE,"Value is not a AudioSource."));
}
};

template <>
struct create_val<DrawCall *>
{
static SV f(CTX ctx,DrawCall*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(DrawCall_funcs,obj,EXT->DrawCall_typeID);
}
};
template <>
struct val_to_c<DrawCall *>
{
static DrawCall *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->DrawCall_typeID)
RET(DrawCall*)obj->data;
else
 CATE(TE,"Value is not a DrawCall."));
} else
 CATE(TE,"Value is not a DrawCall."));
}
};
template <>
struct type_same<DrawCall *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->DrawCall_typeID;
else
 RET false;
}
};
template <>
struct type_same<const DrawCall *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->DrawCall_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const DrawCall *>
{
static const DrawCall *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->DrawCall_typeID)
RET(DrawCall*)obj->data;
else
 CATE(TE,"Value is not a DrawCall."));
} else
 CATE(TE,"Value is not a DrawCall."));
}
};

template <>
struct create_val<Application *>
{
static SV f(CTX ctx,Application*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Application_funcs,obj,EXT->Application_typeID);
}
};
template <>
struct val_to_c<Application *>
{
static Application *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Application_typeID)
RET(Application*)obj->data;
else
 CATE(TE,"Value is not a Application."));
} else
 CATE(TE,"Value is not a Application."));
}
};
template <>
struct type_same<Application *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Application_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Application *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Application_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Application *>
{
static const Application *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Application_typeID)
RET(Application*)obj->data;
else
 CATE(TE,"Value is not a Application."));
} else
 CATE(TE,"Value is not a Application."));
}
};

template <>
struct create_val<ResizableData *>
{
static SV f(CTX ctx,ResizableData*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(ResizableData_funcs,obj,EXT->ResizableData_typeID);
}
};
template <>
struct val_to_c<ResizableData *>
{
static ResizableData *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->ResizableData_typeID)
RET(ResizableData*)obj->data;
else
 CATE(TE,"Value is not a ResizableData."));
} else
 CATE(TE,"Value is not a ResizableData."));
}
};
template <>
struct type_same<ResizableData *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ResizableData_typeID;
else
 RET false;
}
};
template <>
struct type_same<const ResizableData *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ResizableData_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const ResizableData *>
{
static const ResizableData *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->ResizableData_typeID)
RET(ResizableData*)obj->data;
else
 CATE(TE,"Value is not a ResizableData."));
} else
 CATE(TE,"Value is not a ResizableData."));
}
};

template <>
struct create_val<GfxBuffer *>
{
static SV f(CTX ctx,GfxBuffer*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxBuffer_funcs,obj,EXT->GfxBuffer_typeID);
}
};
template <>
struct val_to_c<GfxBuffer *>
{
static GfxBuffer *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxBuffer_typeID)
RET(GfxBuffer*)obj->data;
else
 CATE(TE,"Value is not a GfxBuffer."));
} else
 CATE(TE,"Value is not a GfxBuffer."));
}
};
template <>
struct type_same<GfxBuffer *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxBuffer_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxBuffer *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxBuffer_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxBuffer *>
{
static const GfxBuffer *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxBuffer_typeID)
RET(GfxBuffer*)obj->data;
else
 CATE(TE,"Value is not a GfxBuffer."));
} else
 CATE(TE,"Value is not a GfxBuffer."));
}
};

template <>
struct create_val<GfxMaterial *>
{
static SV f(CTX ctx,GfxMaterial*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxMaterial_funcs,obj,EXT->GfxMaterial_typeID);
}
};
template <>
struct val_to_c<GfxMaterial *>
{
static GfxMaterial *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxMaterial_typeID)
RET(GfxMaterial*)obj->data;
else
 CATE(TE,"Value is not a GfxMaterial."));
} else
 CATE(TE,"Value is not a GfxMaterial."));
}
};
template <>
struct type_same<GfxMaterial *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxMaterial_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxMaterial *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxMaterial_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxMaterial *>
{
static const GfxMaterial *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxMaterial_typeID)
RET(GfxMaterial*)obj->data;
else
 CATE(TE,"Value is not a GfxMaterial."));
} else
 CATE(TE,"Value is not a GfxMaterial."));
}
};

template <>
struct create_val<GfxMeshAttrib *>
{
static SV f(CTX ctx,GfxMeshAttrib*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxMeshAttrib_funcs,obj,EXT->GfxMeshAttrib_typeID);
}
};
template <>
struct val_to_c<GfxMeshAttrib *>
{
static GfxMeshAttrib *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxMeshAttrib_typeID)
RET(GfxMeshAttrib*)obj->data;
else
 CATE(TE,"Value is not a GfxMeshAttrib."));
} else
 CATE(TE,"Value is not a GfxMeshAttrib."));
}
};
template <>
struct type_same<GfxMeshAttrib *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxMeshAttrib_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxMeshAttrib *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxMeshAttrib_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxMeshAttrib *>
{
static const GfxMeshAttrib *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxMeshAttrib_typeID)
RET(GfxMeshAttrib*)obj->data;
else
 CATE(TE,"Value is not a GfxMeshAttrib."));
} else
 CATE(TE,"Value is not a GfxMeshAttrib."));
}
};

template <>
struct create_val<T2<int32_t> *>
{
static SV f(CTX ctx,T2<int32_t>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Int2_funcs,obj,EXT->Int2_typeID);
}
};
template <>
struct val_to_c<T2<int32_t> *>
{
static T2<int32_t> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Int2_typeID)
RET(T2<int32_t>*)obj->data;
else
 CATE(TE,"Value is not a Int2."));
} else
 CATE(TE,"Value is not a Int2."));
}
};
template <>
struct type_same<T2<int32_t> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Int2_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T2<int32_t> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Int2_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T2<int32_t> *>
{
static const T2<int32_t> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Int2_typeID)
RET(T2<int32_t>*)obj->data;
else
 CATE(TE,"Value is not a Int2."));
} else
 CATE(TE,"Value is not a Int2."));
}
};

template <>
struct create_val<HashMap<Str,Str> *>
{
static SV f(CTX ctx,HashMap<Str,Str>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(StrStrMap_funcs,obj,EXT->StrStrMap_typeID);
}
};
template <>
struct val_to_c<HashMap<Str,Str> *>
{
static HashMap<Str,Str> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->StrStrMap_typeID)
RET(HashMap<Str,Str>*)obj->data;
else
 CATE(TE,"Value is not a StrStrMap."));
} else
 CATE(TE,"Value is not a StrStrMap."));
}
};
template <>
struct type_same<HashMap<Str,Str> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->StrStrMap_typeID;
else
 RET false;
}
};
template <>
struct type_same<const HashMap<Str,Str> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->StrStrMap_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const HashMap<Str,Str> *>
{
static const HashMap<Str,Str> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->StrStrMap_typeID)
RET(HashMap<Str,Str>*)obj->data;
else
 CATE(TE,"Value is not a StrStrMap."));
} else
 CATE(TE,"Value is not a StrStrMap."));
}
};

template <>
struct create_val<LightPointData *>
{
static SV f(CTX ctx,LightPointData*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(LightPointData_funcs,obj,EXT->LightPointData_typeID);
}
};
template <>
struct val_to_c<LightPointData *>
{
static LightPointData *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->LightPointData_typeID)
RET(LightPointData*)obj->data;
else
 CATE(TE,"Value is not a LightPointData."));
} else
 CATE(TE,"Value is not a LightPointData."));
}
};
template <>
struct type_same<LightPointData *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->LightPointData_typeID;
else
 RET false;
}
};
template <>
struct type_same<const LightPointData *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->LightPointData_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const LightPointData *>
{
static const LightPointData *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->LightPointData_typeID)
RET(LightPointData*)obj->data;
else
 CATE(TE,"Value is not a LightPointData."));
} else
 CATE(TE,"Value is not a LightPointData."));
}
};

template <>
struct create_val<Matrix4x4 *>
{
static SV f(CTX ctx,Matrix4x4*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Matrix4x4_funcs,obj,EXT->Matrix4x4_typeID);
}
};
template <>
struct val_to_c<Matrix4x4 *>
{
static Matrix4x4 *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Matrix4x4_typeID)
RET(Matrix4x4*)obj->data;
else
 CATE(TE,"Value is not a Matrix4x4."));
} else
 CATE(TE,"Value is not a Matrix4x4."));
}
};
template <>
struct type_same<Matrix4x4 *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Matrix4x4_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Matrix4x4 *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Matrix4x4_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Matrix4x4 *>
{
static const Matrix4x4 *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Matrix4x4_typeID)
RET(Matrix4x4*)obj->data;
else
 CATE(TE,"Value is not a Matrix4x4."));
} else
 CATE(TE,"Value is not a Matrix4x4."));
}
};

template <>
struct create_val<HashMap<AutoVal,AutoVal> *>
{
static SV f(CTX ctx,HashMap<AutoVal,AutoVal>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Map_funcs,obj,EXT->Map_typeID);
}
};
template <>
struct val_to_c<HashMap<AutoVal,AutoVal> *>
{
static HashMap<AutoVal,AutoVal> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Map_typeID)
RET(HashMap<AutoVal,AutoVal>*)obj->data;
else
 CATE(TE,"Value is not a Map."));
} else
 CATE(TE,"Value is not a Map."));
}
};
template <>
struct type_same<HashMap<AutoVal,AutoVal> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Map_typeID;
else
 RET false;
}
};
template <>
struct type_same<const HashMap<AutoVal,AutoVal> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Map_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const HashMap<AutoVal,AutoVal> *>
{
static const HashMap<AutoVal,AutoVal> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Map_typeID)
RET(HashMap<AutoVal,AutoVal>*)obj->data;
else
 CATE(TE,"Value is not a Map."));
} else
 CATE(TE,"Value is not a Map."));
}
};

template <>
struct create_val<List<ScriptInstance*> *>
{
static SV f(CTX ctx,List<ScriptInstance*>*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(ScriptInstanceList_funcs,obj,EXT->ScriptInstanceList_typeID);
}
};
template <>
struct val_to_c<List<ScriptInstance*> *>
{
static List<ScriptInstance*> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->ScriptInstanceList_typeID)
RET(List<ScriptInstance*>*)obj->data;
else
 CATE(TE,"Value is not a ScriptInstanceList."));
} else
 CATE(TE,"Value is not a ScriptInstanceList."));
}
};
template <>
struct type_same<List<ScriptInstance*> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ScriptInstanceList_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<ScriptInstance*> *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->ScriptInstanceList_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<ScriptInstance*> *>
{
static const List<ScriptInstance*> *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->ScriptInstanceList_typeID)
RET(List<ScriptInstance*>*)obj->data;
else
 CATE(TE,"Value is not a ScriptInstanceList."));
} else
 CATE(TE,"Value is not a ScriptInstanceList."));
}
};

template <>
struct create_val<AudioWorld *>
{
static SV f(CTX ctx,AudioWorld*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(AudioWorld_funcs,obj,EXT->AudioWorld_typeID);
}
};
template <>
struct val_to_c<AudioWorld *>
{
static AudioWorld *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->AudioWorld_typeID)
RET(AudioWorld*)obj->data;
else
 CATE(TE,"Value is not a AudioWorld."));
} else
 CATE(TE,"Value is not a AudioWorld."));
}
};
template <>
struct type_same<AudioWorld *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->AudioWorld_typeID;
else
 RET false;
}
};
template <>
struct type_same<const AudioWorld *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->AudioWorld_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const AudioWorld *>
{
static const AudioWorld *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->AudioWorld_typeID)
RET(AudioWorld*)obj->data;
else
 CATE(TE,"Value is not a AudioWorld."));
} else
 CATE(TE,"Value is not a AudioWorld."));
}
};

template <>
struct create_val<Audio *>
{
static SV f(CTX ctx,Audio*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Audio_funcs,obj,EXT->Audio_typeID);
}
};
template <>
struct val_to_c<Audio *>
{
static Audio *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Audio_typeID)
RET(Audio*)obj->data;
else
 CATE(TE,"Value is not a Audio."));
} else
 CATE(TE,"Value is not a Audio."));
}
};
template <>
struct type_same<Audio *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Audio_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Audio *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->Audio_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Audio *>
{
static const Audio *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->Audio_typeID)
RET(Audio*)obj->data;
else
 CATE(TE,"Value is not a Audio."));
} else
 CATE(TE,"Value is not a Audio."));
}
};

template <>
struct create_val<GfxShaderCombination *>
{
static SV f(CTX ctx,GfxShaderCombination*obj)
{
if (obj == nullptr)
RET CN;
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxShaderCombination_funcs,obj,EXT->GfxShaderCombination_typeID);
}
};
template <>
struct val_to_c<GfxShaderCombination *>
{
static GfxShaderCombination *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxShaderCombination_typeID)
RET(GfxShaderCombination*)obj->data;
else
 CATE(TE,"Value is not a GfxShaderCombination."));
} else
 CATE(TE,"Value is not a GfxShaderCombination."));
}
};
template <>
struct type_same<GfxShaderCombination *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxShaderCombination_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxShaderCombination *>
{
static bool f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
RET((NO)val.p)->typeID==EXT->GfxShaderCombination_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxShaderCombination *>
{
static const GfxShaderCombination *f(CTX ctx,const SV& val)
{
if(val.type==STG::ValueType::NativeObject)
{
NO obj=(NO)val.p;
if(obj->typeID==EXT->GfxShaderCombination_typeID)
RET(GfxShaderCombination*)obj->data;
else
 CATE(TE,"Value is not a GfxShaderCombination."));
} else
 CATE(TE,"Value is not a GfxShaderCombination."));
}
};

SV Key___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("Key::__eq__")));
size_t f;
if(!TS(a[0],Key))
CATE(TE,FAE("Key::Key","Key")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],Key))
CATE(VE,UFOF("Key::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV Key_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Key");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(Key___eq__);
EI(keyStr.equals("ScrollLock", CPL_STR_HASH("ScrollLock")))RET STG::createNativeObject(Key_funcs,(void *)271,EXT->Key_typeID);
EI(keyStr.equals("RightBracket", CPL_STR_HASH("RightBracket")))RET STG::createNativeObject(Key_funcs,(void *)93,EXT->Key_typeID);
EI(keyStr.equals("Pause", CPL_STR_HASH("Pause")))RET STG::createNativeObject(Key_funcs,(void *)274,EXT->Key_typeID);
EI(keyStr.equals("Backslash", CPL_STR_HASH("Backslash")))RET STG::createNativeObject(Key_funcs,(void *)92,EXT->Key_typeID);
EI(keyStr.equals("LeftBracket", CPL_STR_HASH("LeftBracket")))RET STG::createNativeObject(Key_funcs,(void *)91,EXT->Key_typeID);
EI(keyStr.equals("Space", CPL_STR_HASH("Space")))RET STG::createNativeObject(Key_funcs,(void *)32,EXT->Key_typeID);
EI(keyStr.equals("Menu", CPL_STR_HASH("Menu")))RET STG::createNativeObject(Key_funcs,(void *)292,EXT->Key_typeID);
EI(keyStr.equals("Enter", CPL_STR_HASH("Enter")))RET STG::createNativeObject(Key_funcs,(void *)257,EXT->Key_typeID);
EI(keyStr.equals("F3", CPL_STR_HASH("F3")))RET STG::createNativeObject(Key_funcs,(void *)277,EXT->Key_typeID);
EI(keyStr.equals("_2", CPL_STR_HASH("_2")))RET STG::createNativeObject(Key_funcs,(void *)50,EXT->Key_typeID);
EI(keyStr.equals("RightControl", CPL_STR_HASH("RightControl")))RET STG::createNativeObject(Key_funcs,(void *)289,EXT->Key_typeID);
EI(keyStr.equals("Backspace", CPL_STR_HASH("Backspace")))RET STG::createNativeObject(Key_funcs,(void *)259,EXT->Key_typeID);
EI(keyStr.equals("Slash", CPL_STR_HASH("Slash")))RET STG::createNativeObject(Key_funcs,(void *)47,EXT->Key_typeID);
EI(keyStr.equals("X", CPL_STR_HASH("X")))RET STG::createNativeObject(Key_funcs,(void *)120,EXT->Key_typeID);
EI(keyStr.equals("End", CPL_STR_HASH("End")))RET STG::createNativeObject(Key_funcs,(void *)269,EXT->Key_typeID);
EI(keyStr.equals("Up", CPL_STR_HASH("Up")))RET STG::createNativeObject(Key_funcs,(void *)265,EXT->Key_typeID);
EI(keyStr.equals("RightSuper", CPL_STR_HASH("RightSuper")))RET STG::createNativeObject(Key_funcs,(void *)291,EXT->Key_typeID);
EI(keyStr.equals("F9", CPL_STR_HASH("F9")))RET STG::createNativeObject(Key_funcs,(void *)283,EXT->Key_typeID);
EI(keyStr.equals("LeftSuper", CPL_STR_HASH("LeftSuper")))RET STG::createNativeObject(Key_funcs,(void *)287,EXT->Key_typeID);
EI(keyStr.equals("PrintScreen", CPL_STR_HASH("PrintScreen")))RET STG::createNativeObject(Key_funcs,(void *)273,EXT->Key_typeID);
EI(keyStr.equals("Z", CPL_STR_HASH("Z")))RET STG::createNativeObject(Key_funcs,(void *)122,EXT->Key_typeID);
EI(keyStr.equals("RightAlt", CPL_STR_HASH("RightAlt")))RET STG::createNativeObject(Key_funcs,(void *)290,EXT->Key_typeID);
EI(keyStr.equals("F5", CPL_STR_HASH("F5")))RET STG::createNativeObject(Key_funcs,(void *)279,EXT->Key_typeID);
EI(keyStr.equals("PageUp", CPL_STR_HASH("PageUp")))RET STG::createNativeObject(Key_funcs,(void *)266,EXT->Key_typeID);
EI(keyStr.equals("LeftShift", CPL_STR_HASH("LeftShift")))RET STG::createNativeObject(Key_funcs,(void *)284,EXT->Key_typeID);
EI(keyStr.equals("F7", CPL_STR_HASH("F7")))RET STG::createNativeObject(Key_funcs,(void *)281,EXT->Key_typeID);
EI(keyStr.equals("LeftAlt", CPL_STR_HASH("LeftAlt")))RET STG::createNativeObject(Key_funcs,(void *)286,EXT->Key_typeID);
EI(keyStr.equals("LeftControl", CPL_STR_HASH("LeftControl")))RET STG::createNativeObject(Key_funcs,(void *)285,EXT->Key_typeID);
EI(keyStr.equals("Unknown", CPL_STR_HASH("Unknown")))RET STG::createNativeObject(Key_funcs,(void *)293,EXT->Key_typeID);
EI(keyStr.equals("Left", CPL_STR_HASH("Left")))RET STG::createNativeObject(Key_funcs,(void *)263,EXT->Key_typeID);
EI(keyStr.equals("A", CPL_STR_HASH("A")))RET STG::createNativeObject(Key_funcs,(void *)97,EXT->Key_typeID);
EI(keyStr.equals("Insert", CPL_STR_HASH("Insert")))RET STG::createNativeObject(Key_funcs,(void *)260,EXT->Key_typeID);
EI(keyStr.equals("C", CPL_STR_HASH("C")))RET STG::createNativeObject(Key_funcs,(void *)99,EXT->Key_typeID);
EI(keyStr.equals("B", CPL_STR_HASH("B")))RET STG::createNativeObject(Key_funcs,(void *)98,EXT->Key_typeID);
EI(keyStr.equals("E", CPL_STR_HASH("E")))RET STG::createNativeObject(Key_funcs,(void *)101,EXT->Key_typeID);
EI(keyStr.equals("D", CPL_STR_HASH("D")))RET STG::createNativeObject(Key_funcs,(void *)100,EXT->Key_typeID);
EI(keyStr.equals("G", CPL_STR_HASH("G")))RET STG::createNativeObject(Key_funcs,(void *)103,EXT->Key_typeID);
EI(keyStr.equals("F", CPL_STR_HASH("F")))RET STG::createNativeObject(Key_funcs,(void *)102,EXT->Key_typeID);
EI(keyStr.equals("I", CPL_STR_HASH("I")))RET STG::createNativeObject(Key_funcs,(void *)105,EXT->Key_typeID);
EI(keyStr.equals("H", CPL_STR_HASH("H")))RET STG::createNativeObject(Key_funcs,(void *)104,EXT->Key_typeID);
EI(keyStr.equals("K", CPL_STR_HASH("K")))RET STG::createNativeObject(Key_funcs,(void *)107,EXT->Key_typeID);
EI(keyStr.equals("J", CPL_STR_HASH("J")))RET STG::createNativeObject(Key_funcs,(void *)106,EXT->Key_typeID);
EI(keyStr.equals("M", CPL_STR_HASH("M")))RET STG::createNativeObject(Key_funcs,(void *)109,EXT->Key_typeID);
EI(keyStr.equals("Equal", CPL_STR_HASH("Equal")))RET STG::createNativeObject(Key_funcs,(void *)61,EXT->Key_typeID);
EI(keyStr.equals("O", CPL_STR_HASH("O")))RET STG::createNativeObject(Key_funcs,(void *)111,EXT->Key_typeID);
EI(keyStr.equals("L", CPL_STR_HASH("L")))RET STG::createNativeObject(Key_funcs,(void *)108,EXT->Key_typeID);
EI(keyStr.equals("Q", CPL_STR_HASH("Q")))RET STG::createNativeObject(Key_funcs,(void *)113,EXT->Key_typeID);
EI(keyStr.equals("P", CPL_STR_HASH("P")))RET STG::createNativeObject(Key_funcs,(void *)112,EXT->Key_typeID);
EI(keyStr.equals("S", CPL_STR_HASH("S")))RET STG::createNativeObject(Key_funcs,(void *)115,EXT->Key_typeID);
EI(keyStr.equals("R", CPL_STR_HASH("R")))RET STG::createNativeObject(Key_funcs,(void *)114,EXT->Key_typeID);
EI(keyStr.equals("U", CPL_STR_HASH("U")))RET STG::createNativeObject(Key_funcs,(void *)117,EXT->Key_typeID);
EI(keyStr.equals("T", CPL_STR_HASH("T")))RET STG::createNativeObject(Key_funcs,(void *)116,EXT->Key_typeID);
EI(keyStr.equals("W", CPL_STR_HASH("W")))RET STG::createNativeObject(Key_funcs,(void *)119,EXT->Key_typeID);
EI(keyStr.equals("V", CPL_STR_HASH("V")))RET STG::createNativeObject(Key_funcs,(void *)118,EXT->Key_typeID);
EI(keyStr.equals("Y", CPL_STR_HASH("Y")))RET STG::createNativeObject(Key_funcs,(void *)121,EXT->Key_typeID);
EI(keyStr.equals("Apostrophe", CPL_STR_HASH("Apostrophe")))RET STG::createNativeObject(Key_funcs,(void *)39,EXT->Key_typeID);
EI(keyStr.equals("NumLock", CPL_STR_HASH("NumLock")))RET STG::createNativeObject(Key_funcs,(void *)272,EXT->Key_typeID);
EI(keyStr.equals("N", CPL_STR_HASH("N")))RET STG::createNativeObject(Key_funcs,(void *)110,EXT->Key_typeID);
EI(keyStr.equals("CapsLock", CPL_STR_HASH("CapsLock")))RET STG::createNativeObject(Key_funcs,(void *)270,EXT->Key_typeID);
EI(keyStr.equals("Minus", CPL_STR_HASH("Minus")))RET STG::createNativeObject(Key_funcs,(void *)45,EXT->Key_typeID);
EI(keyStr.equals("Delete", CPL_STR_HASH("Delete")))RET STG::createNativeObject(Key_funcs,(void *)261,EXT->Key_typeID);
EI(keyStr.equals("F1", CPL_STR_HASH("F1")))RET STG::createNativeObject(Key_funcs,(void *)275,EXT->Key_typeID);
EI(keyStr.equals("F2", CPL_STR_HASH("F2")))RET STG::createNativeObject(Key_funcs,(void *)276,EXT->Key_typeID);
EI(keyStr.equals("Right", CPL_STR_HASH("Right")))RET STG::createNativeObject(Key_funcs,(void *)262,EXT->Key_typeID);
EI(keyStr.equals("F4", CPL_STR_HASH("F4")))RET STG::createNativeObject(Key_funcs,(void *)278,EXT->Key_typeID);
EI(keyStr.equals("_9", CPL_STR_HASH("_9")))RET STG::createNativeObject(Key_funcs,(void *)57,EXT->Key_typeID);
EI(keyStr.equals("Semicolon", CPL_STR_HASH("Semicolon")))RET STG::createNativeObject(Key_funcs,(void *)59,EXT->Key_typeID);
EI(keyStr.equals("_8", CPL_STR_HASH("_8")))RET STG::createNativeObject(Key_funcs,(void *)56,EXT->Key_typeID);
EI(keyStr.equals("_7", CPL_STR_HASH("_7")))RET STG::createNativeObject(Key_funcs,(void *)55,EXT->Key_typeID);
EI(keyStr.equals("_6", CPL_STR_HASH("_6")))RET STG::createNativeObject(Key_funcs,(void *)54,EXT->Key_typeID);
EI(keyStr.equals("_5", CPL_STR_HASH("_5")))RET STG::createNativeObject(Key_funcs,(void *)53,EXT->Key_typeID);
EI(keyStr.equals("_4", CPL_STR_HASH("_4")))RET STG::createNativeObject(Key_funcs,(void *)52,EXT->Key_typeID);
EI(keyStr.equals("_3", CPL_STR_HASH("_3")))RET STG::createNativeObject(Key_funcs,(void *)51,EXT->Key_typeID);
EI(keyStr.equals("Period", CPL_STR_HASH("Period")))RET STG::createNativeObject(Key_funcs,(void *)46,EXT->Key_typeID);
EI(keyStr.equals("_1", CPL_STR_HASH("_1")))RET STG::createNativeObject(Key_funcs,(void *)49,EXT->Key_typeID);
EI(keyStr.equals("_0", CPL_STR_HASH("_0")))RET STG::createNativeObject(Key_funcs,(void *)48,EXT->Key_typeID);
EI(keyStr.equals("Down", CPL_STR_HASH("Down")))RET STG::createNativeObject(Key_funcs,(void *)264,EXT->Key_typeID);
EI(keyStr.equals("F8", CPL_STR_HASH("F8")))RET STG::createNativeObject(Key_funcs,(void *)282,EXT->Key_typeID);
EI(keyStr.equals("Comma", CPL_STR_HASH("Comma")))RET STG::createNativeObject(Key_funcs,(void *)44,EXT->Key_typeID);
EI(keyStr.equals("PageDown", CPL_STR_HASH("PageDown")))RET STG::createNativeObject(Key_funcs,(void *)267,EXT->Key_typeID);
EI(keyStr.equals("Tab", CPL_STR_HASH("Tab")))RET STG::createNativeObject(Key_funcs,(void *)258,EXT->Key_typeID);
EI(keyStr.equals("Escape", CPL_STR_HASH("Escape")))RET STG::createNativeObject(Key_funcs,(void *)256,EXT->Key_typeID);
EI(keyStr.equals("Home", CPL_STR_HASH("Home")))RET STG::createNativeObject(Key_funcs,(void *)268,EXT->Key_typeID);
EI(keyStr.equals("F6", CPL_STR_HASH("F6")))RET STG::createNativeObject(Key_funcs,(void *)280,EXT->Key_typeID);
EI(keyStr.equals("RightShift", CPL_STR_HASH("RightShift")))RET STG::createNativeObject(Key_funcs,(void *)288,EXT->Key_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Key");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(Key___eq__);
EI(keyStr.equals("ScrollLock", CPL_STR_HASH("ScrollLock")))RET STG::createNativeObject(Key_funcs,(void *)271,EXT->Key_typeID);
EI(keyStr.equals("RightBracket", CPL_STR_HASH("RightBracket")))RET STG::createNativeObject(Key_funcs,(void *)93,EXT->Key_typeID);
EI(keyStr.equals("Pause", CPL_STR_HASH("Pause")))RET STG::createNativeObject(Key_funcs,(void *)274,EXT->Key_typeID);
EI(keyStr.equals("Backslash", CPL_STR_HASH("Backslash")))RET STG::createNativeObject(Key_funcs,(void *)92,EXT->Key_typeID);
EI(keyStr.equals("LeftBracket", CPL_STR_HASH("LeftBracket")))RET STG::createNativeObject(Key_funcs,(void *)91,EXT->Key_typeID);
EI(keyStr.equals("Space", CPL_STR_HASH("Space")))RET STG::createNativeObject(Key_funcs,(void *)32,EXT->Key_typeID);
EI(keyStr.equals("Menu", CPL_STR_HASH("Menu")))RET STG::createNativeObject(Key_funcs,(void *)292,EXT->Key_typeID);
EI(keyStr.equals("Enter", CPL_STR_HASH("Enter")))RET STG::createNativeObject(Key_funcs,(void *)257,EXT->Key_typeID);
EI(keyStr.equals("F3", CPL_STR_HASH("F3")))RET STG::createNativeObject(Key_funcs,(void *)277,EXT->Key_typeID);
EI(keyStr.equals("_2", CPL_STR_HASH("_2")))RET STG::createNativeObject(Key_funcs,(void *)50,EXT->Key_typeID);
EI(keyStr.equals("RightControl", CPL_STR_HASH("RightControl")))RET STG::createNativeObject(Key_funcs,(void *)289,EXT->Key_typeID);
EI(keyStr.equals("Backspace", CPL_STR_HASH("Backspace")))RET STG::createNativeObject(Key_funcs,(void *)259,EXT->Key_typeID);
EI(keyStr.equals("Slash", CPL_STR_HASH("Slash")))RET STG::createNativeObject(Key_funcs,(void *)47,EXT->Key_typeID);
EI(keyStr.equals("X", CPL_STR_HASH("X")))RET STG::createNativeObject(Key_funcs,(void *)120,EXT->Key_typeID);
EI(keyStr.equals("End", CPL_STR_HASH("End")))RET STG::createNativeObject(Key_funcs,(void *)269,EXT->Key_typeID);
EI(keyStr.equals("Up", CPL_STR_HASH("Up")))RET STG::createNativeObject(Key_funcs,(void *)265,EXT->Key_typeID);
EI(keyStr.equals("RightSuper", CPL_STR_HASH("RightSuper")))RET STG::createNativeObject(Key_funcs,(void *)291,EXT->Key_typeID);
EI(keyStr.equals("F9", CPL_STR_HASH("F9")))RET STG::createNativeObject(Key_funcs,(void *)283,EXT->Key_typeID);
EI(keyStr.equals("LeftSuper", CPL_STR_HASH("LeftSuper")))RET STG::createNativeObject(Key_funcs,(void *)287,EXT->Key_typeID);
EI(keyStr.equals("PrintScreen", CPL_STR_HASH("PrintScreen")))RET STG::createNativeObject(Key_funcs,(void *)273,EXT->Key_typeID);
EI(keyStr.equals("Z", CPL_STR_HASH("Z")))RET STG::createNativeObject(Key_funcs,(void *)122,EXT->Key_typeID);
EI(keyStr.equals("RightAlt", CPL_STR_HASH("RightAlt")))RET STG::createNativeObject(Key_funcs,(void *)290,EXT->Key_typeID);
EI(keyStr.equals("F5", CPL_STR_HASH("F5")))RET STG::createNativeObject(Key_funcs,(void *)279,EXT->Key_typeID);
EI(keyStr.equals("PageUp", CPL_STR_HASH("PageUp")))RET STG::createNativeObject(Key_funcs,(void *)266,EXT->Key_typeID);
EI(keyStr.equals("LeftShift", CPL_STR_HASH("LeftShift")))RET STG::createNativeObject(Key_funcs,(void *)284,EXT->Key_typeID);
EI(keyStr.equals("F7", CPL_STR_HASH("F7")))RET STG::createNativeObject(Key_funcs,(void *)281,EXT->Key_typeID);
EI(keyStr.equals("LeftAlt", CPL_STR_HASH("LeftAlt")))RET STG::createNativeObject(Key_funcs,(void *)286,EXT->Key_typeID);
EI(keyStr.equals("LeftControl", CPL_STR_HASH("LeftControl")))RET STG::createNativeObject(Key_funcs,(void *)285,EXT->Key_typeID);
EI(keyStr.equals("Unknown", CPL_STR_HASH("Unknown")))RET STG::createNativeObject(Key_funcs,(void *)293,EXT->Key_typeID);
EI(keyStr.equals("Left", CPL_STR_HASH("Left")))RET STG::createNativeObject(Key_funcs,(void *)263,EXT->Key_typeID);
EI(keyStr.equals("A", CPL_STR_HASH("A")))RET STG::createNativeObject(Key_funcs,(void *)97,EXT->Key_typeID);
EI(keyStr.equals("Insert", CPL_STR_HASH("Insert")))RET STG::createNativeObject(Key_funcs,(void *)260,EXT->Key_typeID);
EI(keyStr.equals("C", CPL_STR_HASH("C")))RET STG::createNativeObject(Key_funcs,(void *)99,EXT->Key_typeID);
EI(keyStr.equals("B", CPL_STR_HASH("B")))RET STG::createNativeObject(Key_funcs,(void *)98,EXT->Key_typeID);
EI(keyStr.equals("E", CPL_STR_HASH("E")))RET STG::createNativeObject(Key_funcs,(void *)101,EXT->Key_typeID);
EI(keyStr.equals("D", CPL_STR_HASH("D")))RET STG::createNativeObject(Key_funcs,(void *)100,EXT->Key_typeID);
EI(keyStr.equals("G", CPL_STR_HASH("G")))RET STG::createNativeObject(Key_funcs,(void *)103,EXT->Key_typeID);
EI(keyStr.equals("F", CPL_STR_HASH("F")))RET STG::createNativeObject(Key_funcs,(void *)102,EXT->Key_typeID);
EI(keyStr.equals("I", CPL_STR_HASH("I")))RET STG::createNativeObject(Key_funcs,(void *)105,EXT->Key_typeID);
EI(keyStr.equals("H", CPL_STR_HASH("H")))RET STG::createNativeObject(Key_funcs,(void *)104,EXT->Key_typeID);
EI(keyStr.equals("K", CPL_STR_HASH("K")))RET STG::createNativeObject(Key_funcs,(void *)107,EXT->Key_typeID);
EI(keyStr.equals("J", CPL_STR_HASH("J")))RET STG::createNativeObject(Key_funcs,(void *)106,EXT->Key_typeID);
EI(keyStr.equals("M", CPL_STR_HASH("M")))RET STG::createNativeObject(Key_funcs,(void *)109,EXT->Key_typeID);
EI(keyStr.equals("Equal", CPL_STR_HASH("Equal")))RET STG::createNativeObject(Key_funcs,(void *)61,EXT->Key_typeID);
EI(keyStr.equals("O", CPL_STR_HASH("O")))RET STG::createNativeObject(Key_funcs,(void *)111,EXT->Key_typeID);
EI(keyStr.equals("L", CPL_STR_HASH("L")))RET STG::createNativeObject(Key_funcs,(void *)108,EXT->Key_typeID);
EI(keyStr.equals("Q", CPL_STR_HASH("Q")))RET STG::createNativeObject(Key_funcs,(void *)113,EXT->Key_typeID);
EI(keyStr.equals("P", CPL_STR_HASH("P")))RET STG::createNativeObject(Key_funcs,(void *)112,EXT->Key_typeID);
EI(keyStr.equals("S", CPL_STR_HASH("S")))RET STG::createNativeObject(Key_funcs,(void *)115,EXT->Key_typeID);
EI(keyStr.equals("R", CPL_STR_HASH("R")))RET STG::createNativeObject(Key_funcs,(void *)114,EXT->Key_typeID);
EI(keyStr.equals("U", CPL_STR_HASH("U")))RET STG::createNativeObject(Key_funcs,(void *)117,EXT->Key_typeID);
EI(keyStr.equals("T", CPL_STR_HASH("T")))RET STG::createNativeObject(Key_funcs,(void *)116,EXT->Key_typeID);
EI(keyStr.equals("W", CPL_STR_HASH("W")))RET STG::createNativeObject(Key_funcs,(void *)119,EXT->Key_typeID);
EI(keyStr.equals("V", CPL_STR_HASH("V")))RET STG::createNativeObject(Key_funcs,(void *)118,EXT->Key_typeID);
EI(keyStr.equals("Y", CPL_STR_HASH("Y")))RET STG::createNativeObject(Key_funcs,(void *)121,EXT->Key_typeID);
EI(keyStr.equals("Apostrophe", CPL_STR_HASH("Apostrophe")))RET STG::createNativeObject(Key_funcs,(void *)39,EXT->Key_typeID);
EI(keyStr.equals("NumLock", CPL_STR_HASH("NumLock")))RET STG::createNativeObject(Key_funcs,(void *)272,EXT->Key_typeID);
EI(keyStr.equals("N", CPL_STR_HASH("N")))RET STG::createNativeObject(Key_funcs,(void *)110,EXT->Key_typeID);
EI(keyStr.equals("CapsLock", CPL_STR_HASH("CapsLock")))RET STG::createNativeObject(Key_funcs,(void *)270,EXT->Key_typeID);
EI(keyStr.equals("Minus", CPL_STR_HASH("Minus")))RET STG::createNativeObject(Key_funcs,(void *)45,EXT->Key_typeID);
EI(keyStr.equals("Delete", CPL_STR_HASH("Delete")))RET STG::createNativeObject(Key_funcs,(void *)261,EXT->Key_typeID);
EI(keyStr.equals("F1", CPL_STR_HASH("F1")))RET STG::createNativeObject(Key_funcs,(void *)275,EXT->Key_typeID);
EI(keyStr.equals("F2", CPL_STR_HASH("F2")))RET STG::createNativeObject(Key_funcs,(void *)276,EXT->Key_typeID);
EI(keyStr.equals("Right", CPL_STR_HASH("Right")))RET STG::createNativeObject(Key_funcs,(void *)262,EXT->Key_typeID);
EI(keyStr.equals("F4", CPL_STR_HASH("F4")))RET STG::createNativeObject(Key_funcs,(void *)278,EXT->Key_typeID);
EI(keyStr.equals("_9", CPL_STR_HASH("_9")))RET STG::createNativeObject(Key_funcs,(void *)57,EXT->Key_typeID);
EI(keyStr.equals("Semicolon", CPL_STR_HASH("Semicolon")))RET STG::createNativeObject(Key_funcs,(void *)59,EXT->Key_typeID);
EI(keyStr.equals("_8", CPL_STR_HASH("_8")))RET STG::createNativeObject(Key_funcs,(void *)56,EXT->Key_typeID);
EI(keyStr.equals("_7", CPL_STR_HASH("_7")))RET STG::createNativeObject(Key_funcs,(void *)55,EXT->Key_typeID);
EI(keyStr.equals("_6", CPL_STR_HASH("_6")))RET STG::createNativeObject(Key_funcs,(void *)54,EXT->Key_typeID);
EI(keyStr.equals("_5", CPL_STR_HASH("_5")))RET STG::createNativeObject(Key_funcs,(void *)53,EXT->Key_typeID);
EI(keyStr.equals("_4", CPL_STR_HASH("_4")))RET STG::createNativeObject(Key_funcs,(void *)52,EXT->Key_typeID);
EI(keyStr.equals("_3", CPL_STR_HASH("_3")))RET STG::createNativeObject(Key_funcs,(void *)51,EXT->Key_typeID);
EI(keyStr.equals("Period", CPL_STR_HASH("Period")))RET STG::createNativeObject(Key_funcs,(void *)46,EXT->Key_typeID);
EI(keyStr.equals("_1", CPL_STR_HASH("_1")))RET STG::createNativeObject(Key_funcs,(void *)49,EXT->Key_typeID);
EI(keyStr.equals("_0", CPL_STR_HASH("_0")))RET STG::createNativeObject(Key_funcs,(void *)48,EXT->Key_typeID);
EI(keyStr.equals("Down", CPL_STR_HASH("Down")))RET STG::createNativeObject(Key_funcs,(void *)264,EXT->Key_typeID);
EI(keyStr.equals("F8", CPL_STR_HASH("F8")))RET STG::createNativeObject(Key_funcs,(void *)282,EXT->Key_typeID);
EI(keyStr.equals("Comma", CPL_STR_HASH("Comma")))RET STG::createNativeObject(Key_funcs,(void *)44,EXT->Key_typeID);
EI(keyStr.equals("PageDown", CPL_STR_HASH("PageDown")))RET STG::createNativeObject(Key_funcs,(void *)267,EXT->Key_typeID);
EI(keyStr.equals("Tab", CPL_STR_HASH("Tab")))RET STG::createNativeObject(Key_funcs,(void *)258,EXT->Key_typeID);
EI(keyStr.equals("Escape", CPL_STR_HASH("Escape")))RET STG::createNativeObject(Key_funcs,(void *)256,EXT->Key_typeID);
EI(keyStr.equals("Home", CPL_STR_HASH("Home")))RET STG::createNativeObject(Key_funcs,(void *)268,EXT->Key_typeID);
EI(keyStr.equals("F6", CPL_STR_HASH("F6")))RET STG::createNativeObject(Key_funcs,(void *)280,EXT->Key_typeID);
EI(keyStr.equals("RightShift", CPL_STR_HASH("RightShift")))RET STG::createNativeObject(Key_funcs,(void *)288,EXT->Key_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void Key_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV MouseButton___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("MouseButton::__eq__")));
size_t f;
if(!TS(a[0],MouseButton))
CATE(TE,FAE("MouseButton::MouseButton","MouseButton")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],MouseButton))
CATE(VE,UFOF("MouseButton::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV MouseButton_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("MouseButton");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(MouseButton___eq__);
EI(keyStr.equals("Middle", CPL_STR_HASH("Middle")))RET STG::createNativeObject(MouseButton_funcs,(void *)1,EXT->MouseButton_typeID);
EI(keyStr.equals("Right", CPL_STR_HASH("Right")))RET STG::createNativeObject(MouseButton_funcs,(void *)2,EXT->MouseButton_typeID);
EI(keyStr.equals("Unknown", CPL_STR_HASH("Unknown")))RET STG::createNativeObject(MouseButton_funcs,(void *)3,EXT->MouseButton_typeID);
EI(keyStr.equals("Left", CPL_STR_HASH("Left")))RET STG::createNativeObject(MouseButton_funcs,(void *)0,EXT->MouseButton_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("MouseButton");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(MouseButton___eq__);
EI(keyStr.equals("Middle", CPL_STR_HASH("Middle")))RET STG::createNativeObject(MouseButton_funcs,(void *)1,EXT->MouseButton_typeID);
EI(keyStr.equals("Right", CPL_STR_HASH("Right")))RET STG::createNativeObject(MouseButton_funcs,(void *)2,EXT->MouseButton_typeID);
EI(keyStr.equals("Unknown", CPL_STR_HASH("Unknown")))RET STG::createNativeObject(MouseButton_funcs,(void *)3,EXT->MouseButton_typeID);
EI(keyStr.equals("Left", CPL_STR_HASH("Left")))RET STG::createNativeObject(MouseButton_funcs,(void *)0,EXT->MouseButton_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void MouseButton_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV EventType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("EventType::__eq__")));
size_t f;
if(!TS(a[0],EventType))
CATE(TE,FAE("EventType::EventType","EventType")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],EventType))
CATE(VE,UFOF("EventType::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV EventType_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("EventType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(EventType___eq__);
EI(keyStr.equals("WindowResize", CPL_STR_HASH("WindowResize")))RET STG::createNativeObject(EventType_funcs,(void *)1,EXT->EventType_typeID);
EI(keyStr.equals("Quit", CPL_STR_HASH("Quit")))RET STG::createNativeObject(EventType_funcs,(void *)0,EXT->EventType_typeID);
EI(keyStr.equals("MouseWheel", CPL_STR_HASH("MouseWheel")))RET STG::createNativeObject(EventType_funcs,(void *)7,EXT->EventType_typeID);
EI(keyStr.equals("MouseMotion", CPL_STR_HASH("MouseMotion")))RET STG::createNativeObject(EventType_funcs,(void *)4,EXT->EventType_typeID);
EI(keyStr.equals("Unknown", CPL_STR_HASH("Unknown")))RET STG::createNativeObject(EventType_funcs,(void *)8,EXT->EventType_typeID);
EI(keyStr.equals("MouseButtonDown", CPL_STR_HASH("MouseButtonDown")))RET STG::createNativeObject(EventType_funcs,(void *)5,EXT->EventType_typeID);
EI(keyStr.equals("KeyUp", CPL_STR_HASH("KeyUp")))RET STG::createNativeObject(EventType_funcs,(void *)3,EXT->EventType_typeID);
EI(keyStr.equals("KeyDown", CPL_STR_HASH("KeyDown")))RET STG::createNativeObject(EventType_funcs,(void *)2,EXT->EventType_typeID);
EI(keyStr.equals("MouseButtonUp", CPL_STR_HASH("MouseButtonUp")))RET STG::createNativeObject(EventType_funcs,(void *)6,EXT->EventType_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("EventType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(EventType___eq__);
EI(keyStr.equals("WindowResize", CPL_STR_HASH("WindowResize")))RET STG::createNativeObject(EventType_funcs,(void *)1,EXT->EventType_typeID);
EI(keyStr.equals("Quit", CPL_STR_HASH("Quit")))RET STG::createNativeObject(EventType_funcs,(void *)0,EXT->EventType_typeID);
EI(keyStr.equals("MouseWheel", CPL_STR_HASH("MouseWheel")))RET STG::createNativeObject(EventType_funcs,(void *)7,EXT->EventType_typeID);
EI(keyStr.equals("MouseMotion", CPL_STR_HASH("MouseMotion")))RET STG::createNativeObject(EventType_funcs,(void *)4,EXT->EventType_typeID);
EI(keyStr.equals("Unknown", CPL_STR_HASH("Unknown")))RET STG::createNativeObject(EventType_funcs,(void *)8,EXT->EventType_typeID);
EI(keyStr.equals("MouseButtonDown", CPL_STR_HASH("MouseButtonDown")))RET STG::createNativeObject(EventType_funcs,(void *)5,EXT->EventType_typeID);
EI(keyStr.equals("KeyUp", CPL_STR_HASH("KeyUp")))RET STG::createNativeObject(EventType_funcs,(void *)3,EXT->EventType_typeID);
EI(keyStr.equals("KeyDown", CPL_STR_HASH("KeyDown")))RET STG::createNativeObject(EventType_funcs,(void *)2,EXT->EventType_typeID);
EI(keyStr.equals("MouseButtonUp", CPL_STR_HASH("MouseButtonUp")))RET STG::createNativeObject(EventType_funcs,(void *)6,EXT->EventType_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void EventType_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV FileOrigin___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("FileOrigin::__eq__")));
size_t f;
if(!TS(a[0],FileOrigin))
CATE(TE,FAE("FileOrigin::FileOrigin","FileOrigin")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],FileOrigin))
CATE(VE,UFOF("FileOrigin::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV FileOrigin_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("FileOrigin");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(FileOrigin___eq__);
EI(keyStr.equals("Current", CPL_STR_HASH("Current")))RET STG::createNativeObject(FileOrigin_funcs,(void *)1,EXT->FileOrigin_typeID);
EI(keyStr.equals("Set", CPL_STR_HASH("Set")))RET STG::createNativeObject(FileOrigin_funcs,(void *)0,EXT->FileOrigin_typeID);
EI(keyStr.equals("End", CPL_STR_HASH("End")))RET STG::createNativeObject(FileOrigin_funcs,(void *)2,EXT->FileOrigin_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("FileOrigin");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(FileOrigin___eq__);
EI(keyStr.equals("Current", CPL_STR_HASH("Current")))RET STG::createNativeObject(FileOrigin_funcs,(void *)1,EXT->FileOrigin_typeID);
EI(keyStr.equals("Set", CPL_STR_HASH("Set")))RET STG::createNativeObject(FileOrigin_funcs,(void *)0,EXT->FileOrigin_typeID);
EI(keyStr.equals("End", CPL_STR_HASH("End")))RET STG::createNativeObject(FileOrigin_funcs,(void *)2,EXT->FileOrigin_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void FileOrigin_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV ResType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("ResType::__eq__")));
size_t f;
if(!TS(a[0],ResType))
CATE(TE,FAE("ResType::ResType","ResType")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],ResType))
CATE(VE,UFOF("ResType::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV ResType_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("ResType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(ResType___eq__);
EI(keyStr.equals("GfxMaterialType", CPL_STR_HASH("GfxMaterialType")))RET STG::createNativeObject(ResType_funcs,(void *)3,EXT->ResType_typeID);
EI(keyStr.equals("ScriptType", CPL_STR_HASH("ScriptType")))RET STG::createNativeObject(ResType_funcs,(void *)6,EXT->ResType_typeID);
EI(keyStr.equals("GfxTextureType", CPL_STR_HASH("GfxTextureType")))RET STG::createNativeObject(ResType_funcs,(void *)1,EXT->ResType_typeID);
EI(keyStr.equals("GfxMeshType", CPL_STR_HASH("GfxMeshType")))RET STG::createNativeObject(ResType_funcs,(void *)2,EXT->ResType_typeID);
EI(keyStr.equals("AudioType", CPL_STR_HASH("AudioType")))RET STG::createNativeObject(ResType_funcs,(void *)8,EXT->ResType_typeID);
EI(keyStr.equals("FontType", CPL_STR_HASH("FontType")))RET STG::createNativeObject(ResType_funcs,(void *)9,EXT->ResType_typeID);
EI(keyStr.equals("GfxModelType", CPL_STR_HASH("GfxModelType")))RET STG::createNativeObject(ResType_funcs,(void *)4,EXT->ResType_typeID);
EI(keyStr.equals("PhysicsShapeType", CPL_STR_HASH("PhysicsShapeType")))RET STG::createNativeObject(ResType_funcs,(void *)7,EXT->ResType_typeID);
EI(keyStr.equals("GfxShaderType", CPL_STR_HASH("GfxShaderType")))RET STG::createNativeObject(ResType_funcs,(void *)0,EXT->ResType_typeID);
EI(keyStr.equals("SceneType", CPL_STR_HASH("SceneType")))RET STG::createNativeObject(ResType_funcs,(void *)5,EXT->ResType_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("ResType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(ResType___eq__);
EI(keyStr.equals("GfxMaterialType", CPL_STR_HASH("GfxMaterialType")))RET STG::createNativeObject(ResType_funcs,(void *)3,EXT->ResType_typeID);
EI(keyStr.equals("ScriptType", CPL_STR_HASH("ScriptType")))RET STG::createNativeObject(ResType_funcs,(void *)6,EXT->ResType_typeID);
EI(keyStr.equals("GfxTextureType", CPL_STR_HASH("GfxTextureType")))RET STG::createNativeObject(ResType_funcs,(void *)1,EXT->ResType_typeID);
EI(keyStr.equals("GfxMeshType", CPL_STR_HASH("GfxMeshType")))RET STG::createNativeObject(ResType_funcs,(void *)2,EXT->ResType_typeID);
EI(keyStr.equals("AudioType", CPL_STR_HASH("AudioType")))RET STG::createNativeObject(ResType_funcs,(void *)8,EXT->ResType_typeID);
EI(keyStr.equals("FontType", CPL_STR_HASH("FontType")))RET STG::createNativeObject(ResType_funcs,(void *)9,EXT->ResType_typeID);
EI(keyStr.equals("GfxModelType", CPL_STR_HASH("GfxModelType")))RET STG::createNativeObject(ResType_funcs,(void *)4,EXT->ResType_typeID);
EI(keyStr.equals("PhysicsShapeType", CPL_STR_HASH("PhysicsShapeType")))RET STG::createNativeObject(ResType_funcs,(void *)7,EXT->ResType_typeID);
EI(keyStr.equals("GfxShaderType", CPL_STR_HASH("GfxShaderType")))RET STG::createNativeObject(ResType_funcs,(void *)0,EXT->ResType_typeID);
EI(keyStr.equals("SceneType", CPL_STR_HASH("SceneType")))RET STG::createNativeObject(ResType_funcs,(void *)5,EXT->ResType_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void ResType_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxTextureType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxTextureType::__eq__")));
size_t f;
if(!TS(a[0],GfxTextureType))
CATE(TE,FAE("GfxTextureType::GfxTextureType","GfxTextureType")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxTextureType))
CATE(VE,UFOF("GfxTextureType::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxTextureType_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxTextureType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxTextureType___eq__);
EI(keyStr.equals("Texture2DArray", CPL_STR_HASH("Texture2DArray")))RET STG::createNativeObject(GfxTextureType_funcs,(void *)3,EXT->GfxTextureType_typeID);
EI(keyStr.equals("CubeMap", CPL_STR_HASH("CubeMap")))RET STG::createNativeObject(GfxTextureType_funcs,(void *)1,EXT->GfxTextureType_typeID);
EI(keyStr.equals("Texture3D", CPL_STR_HASH("Texture3D")))RET STG::createNativeObject(GfxTextureType_funcs,(void *)2,EXT->GfxTextureType_typeID);
EI(keyStr.equals("Texture2D", CPL_STR_HASH("Texture2D")))RET STG::createNativeObject(GfxTextureType_funcs,(void *)0,EXT->GfxTextureType_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxTextureType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxTextureType___eq__);
EI(keyStr.equals("Texture2DArray", CPL_STR_HASH("Texture2DArray")))RET STG::createNativeObject(GfxTextureType_funcs,(void *)3,EXT->GfxTextureType_typeID);
EI(keyStr.equals("CubeMap", CPL_STR_HASH("CubeMap")))RET STG::createNativeObject(GfxTextureType_funcs,(void *)1,EXT->GfxTextureType_typeID);
EI(keyStr.equals("Texture3D", CPL_STR_HASH("Texture3D")))RET STG::createNativeObject(GfxTextureType_funcs,(void *)2,EXT->GfxTextureType_typeID);
EI(keyStr.equals("Texture2D", CPL_STR_HASH("Texture2D")))RET STG::createNativeObject(GfxTextureType_funcs,(void *)0,EXT->GfxTextureType_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxTextureType_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxFilter___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxFilter::__eq__")));
size_t f;
if(!TS(a[0],GfxFilter))
CATE(TE,FAE("GfxFilter::GfxFilter","GfxFilter")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxFilter))
CATE(VE,UFOF("GfxFilter::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxFilter_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxFilter");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxFilter___eq__);
EI(keyStr.equals("Bilinear", CPL_STR_HASH("Bilinear")))RET STG::createNativeObject(GfxFilter_funcs,(void *)1,EXT->GfxFilter_typeID);
EI(keyStr.equals("Nearest", CPL_STR_HASH("Nearest")))RET STG::createNativeObject(GfxFilter_funcs,(void *)0,EXT->GfxFilter_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxFilter");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxFilter___eq__);
EI(keyStr.equals("Bilinear", CPL_STR_HASH("Bilinear")))RET STG::createNativeObject(GfxFilter_funcs,(void *)1,EXT->GfxFilter_typeID);
EI(keyStr.equals("Nearest", CPL_STR_HASH("Nearest")))RET STG::createNativeObject(GfxFilter_funcs,(void *)0,EXT->GfxFilter_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxFilter_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxMipmapMode___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxMipmapMode::__eq__")));
size_t f;
if(!TS(a[0],GfxMipmapMode))
CATE(TE,FAE("GfxMipmapMode::GfxMipmapMode","GfxMipmapMode")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxMipmapMode))
CATE(VE,UFOF("GfxMipmapMode::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxMipmapMode_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxMipmapMode");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxMipmapMode___eq__);
EI(keyStr.equals("Nearest", CPL_STR_HASH("Nearest")))RET STG::createNativeObject(GfxMipmapMode_funcs,(void *)1,EXT->GfxMipmapMode_typeID);
EI(keyStr.equals("None", CPL_STR_HASH("None")))RET STG::createNativeObject(GfxMipmapMode_funcs,(void *)0,EXT->GfxMipmapMode_typeID);
EI(keyStr.equals("Linear", CPL_STR_HASH("Linear")))RET STG::createNativeObject(GfxMipmapMode_funcs,(void *)2,EXT->GfxMipmapMode_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxMipmapMode");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxMipmapMode___eq__);
EI(keyStr.equals("Nearest", CPL_STR_HASH("Nearest")))RET STG::createNativeObject(GfxMipmapMode_funcs,(void *)1,EXT->GfxMipmapMode_typeID);
EI(keyStr.equals("None", CPL_STR_HASH("None")))RET STG::createNativeObject(GfxMipmapMode_funcs,(void *)0,EXT->GfxMipmapMode_typeID);
EI(keyStr.equals("Linear", CPL_STR_HASH("Linear")))RET STG::createNativeObject(GfxMipmapMode_funcs,(void *)2,EXT->GfxMipmapMode_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxMipmapMode_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxWrapMode___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxWrapMode::__eq__")));
size_t f;
if(!TS(a[0],GfxWrapMode))
CATE(TE,FAE("GfxWrapMode::GfxWrapMode","GfxWrapMode")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxWrapMode))
CATE(VE,UFOF("GfxWrapMode::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxWrapMode_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxWrapMode");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxWrapMode___eq__);
EI(keyStr.equals("Stretch", CPL_STR_HASH("Stretch")))RET STG::createNativeObject(GfxWrapMode_funcs,(void *)0,EXT->GfxWrapMode_typeID);
EI(keyStr.equals("Repeat", CPL_STR_HASH("Repeat")))RET STG::createNativeObject(GfxWrapMode_funcs,(void *)1,EXT->GfxWrapMode_typeID);
EI(keyStr.equals("Mirror", CPL_STR_HASH("Mirror")))RET STG::createNativeObject(GfxWrapMode_funcs,(void *)2,EXT->GfxWrapMode_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxWrapMode");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxWrapMode___eq__);
EI(keyStr.equals("Stretch", CPL_STR_HASH("Stretch")))RET STG::createNativeObject(GfxWrapMode_funcs,(void *)0,EXT->GfxWrapMode_typeID);
EI(keyStr.equals("Repeat", CPL_STR_HASH("Repeat")))RET STG::createNativeObject(GfxWrapMode_funcs,(void *)1,EXT->GfxWrapMode_typeID);
EI(keyStr.equals("Mirror", CPL_STR_HASH("Mirror")))RET STG::createNativeObject(GfxWrapMode_funcs,(void *)2,EXT->GfxWrapMode_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxWrapMode_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxTexFormat___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxTexFormat::__eq__")));
size_t f;
if(!TS(a[0],GfxTexFormat))
CATE(TE,FAE("GfxTexFormat::GfxTexFormat","GfxTexFormat")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxTexFormat))
CATE(VE,UFOF("GfxTexFormat::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxTexFormat_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxTexFormat");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxTexFormat___eq__);
EI(keyStr.equals("RGBAF32_F16", CPL_STR_HASH("RGBAF32_F16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)29,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceAlphaI8", CPL_STR_HASH("LuminanceAlphaI8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)13,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceI16", CPL_STR_HASH("LuminanceI16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)9,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("AlphaI8", CPL_STR_HASH("AlphaI8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)1,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int2_8", CPL_STR_HASH("Int2_8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)36,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedF32_F16", CPL_STR_HASH("RedF32_F16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)70,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int_32", CPL_STR_HASH("Int_32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)34,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt2_16", CPL_STR_HASH("UInt2_16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)39,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceAlphaU8", CPL_STR_HASH("LuminanceAlphaU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)12,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt2_32", CPL_STR_HASH("UInt2_32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)41,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBI8", CPL_STR_HASH("RGBI8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)19,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedI16", CPL_STR_HASH("RedI16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)68,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedU16", CPL_STR_HASH("RedU16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)67,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceI8", CPL_STR_HASH("LuminanceI8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)7,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int2_16", CPL_STR_HASH("Int2_16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)38,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBAU16", CPL_STR_HASH("RGBAU16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)26,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBF32_F16", CPL_STR_HASH("RGBF32_F16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)23,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedGreenI16", CPL_STR_HASH("RedGreenI16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)62,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedU8", CPL_STR_HASH("RedU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)65,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int3_8", CPL_STR_HASH("Int3_8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)42,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int_8", CPL_STR_HASH("Int_8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)30,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceU16", CPL_STR_HASH("LuminanceU16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)8,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("AlphaI16", CPL_STR_HASH("AlphaI16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)3,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBI16", CPL_STR_HASH("RGBI16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)21,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceF32_F16", CPL_STR_HASH("LuminanceF32_F16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)11,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceU8", CPL_STR_HASH("LuminanceU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)6,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt_8", CPL_STR_HASH("UInt_8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)31,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt2_8", CPL_STR_HASH("UInt2_8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)37,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int3_16", CPL_STR_HASH("Int3_16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)44,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBAU8", CPL_STR_HASH("RGBAU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)24,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBU16", CPL_STR_HASH("RGBU16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)20,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceAlphaF32", CPL_STR_HASH("LuminanceAlphaF32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)16,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBAF32", CPL_STR_HASH("RGBAF32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)28,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt3_8", CPL_STR_HASH("UInt3_8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)43,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int4_8", CPL_STR_HASH("Int4_8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)48,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceAlphaU16", CPL_STR_HASH("LuminanceAlphaU16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)14,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int2_32", CPL_STR_HASH("Int2_32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)40,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt_16", CPL_STR_HASH("UInt_16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)33,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt4_8", CPL_STR_HASH("UInt4_8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)49,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("AlphaU16", CPL_STR_HASH("AlphaU16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)2,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedGreenI8", CPL_STR_HASH("RedGreenI8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)60,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceAlphaF32_F16", CPL_STR_HASH("LuminanceAlphaF32_F16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)17,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int3_32", CPL_STR_HASH("Int3_32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)46,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedGreenF32_F16", CPL_STR_HASH("RedGreenF32_F16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)64,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBU8", CPL_STR_HASH("RGBU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)18,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("SRGBU8", CPL_STR_HASH("SRGBU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)54,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedGreenU8", CPL_STR_HASH("RedGreenU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)59,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("DepthF32", CPL_STR_HASH("DepthF32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)58,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("AlphaF32", CPL_STR_HASH("AlphaF32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)4,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt_32", CPL_STR_HASH("UInt_32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)35,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("AlphaU8", CPL_STR_HASH("AlphaU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)0,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("DepthF32_F24", CPL_STR_HASH("DepthF32_F24")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)57,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedF32", CPL_STR_HASH("RedF32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)69,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedGreenF32", CPL_STR_HASH("RedGreenF32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)63,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int4_16", CPL_STR_HASH("Int4_16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)50,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBAI8", CPL_STR_HASH("RGBAI8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)25,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt4_32", CPL_STR_HASH("UInt4_32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)53,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt4_16", CPL_STR_HASH("UInt4_16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)51,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt3_16", CPL_STR_HASH("UInt3_16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)45,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt3_32", CPL_STR_HASH("UInt3_32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)47,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedI8", CPL_STR_HASH("RedI8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)66,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int4_32", CPL_STR_HASH("Int4_32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)52,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("SRGBAU8", CPL_STR_HASH("SRGBAU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)55,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceF32", CPL_STR_HASH("LuminanceF32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)10,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBF32", CPL_STR_HASH("RGBF32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)22,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int_16", CPL_STR_HASH("Int_16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)32,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedGreenU16", CPL_STR_HASH("RedGreenU16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)61,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceAlphaI16", CPL_STR_HASH("LuminanceAlphaI16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)15,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBAI16", CPL_STR_HASH("RGBAI16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)27,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("DepthF32_F16", CPL_STR_HASH("DepthF32_F16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)56,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("AlphaF32_F16", CPL_STR_HASH("AlphaF32_F16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)5,EXT->GfxTexFormat_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxTexFormat");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxTexFormat___eq__);
EI(keyStr.equals("RGBAF32_F16", CPL_STR_HASH("RGBAF32_F16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)29,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceAlphaI8", CPL_STR_HASH("LuminanceAlphaI8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)13,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceI16", CPL_STR_HASH("LuminanceI16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)9,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("AlphaI8", CPL_STR_HASH("AlphaI8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)1,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int2_8", CPL_STR_HASH("Int2_8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)36,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedF32_F16", CPL_STR_HASH("RedF32_F16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)70,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int_32", CPL_STR_HASH("Int_32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)34,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt2_16", CPL_STR_HASH("UInt2_16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)39,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceAlphaU8", CPL_STR_HASH("LuminanceAlphaU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)12,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt2_32", CPL_STR_HASH("UInt2_32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)41,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBI8", CPL_STR_HASH("RGBI8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)19,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedI16", CPL_STR_HASH("RedI16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)68,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedU16", CPL_STR_HASH("RedU16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)67,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceI8", CPL_STR_HASH("LuminanceI8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)7,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int2_16", CPL_STR_HASH("Int2_16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)38,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBAU16", CPL_STR_HASH("RGBAU16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)26,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBF32_F16", CPL_STR_HASH("RGBF32_F16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)23,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedGreenI16", CPL_STR_HASH("RedGreenI16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)62,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedU8", CPL_STR_HASH("RedU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)65,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int3_8", CPL_STR_HASH("Int3_8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)42,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int_8", CPL_STR_HASH("Int_8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)30,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceU16", CPL_STR_HASH("LuminanceU16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)8,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("AlphaI16", CPL_STR_HASH("AlphaI16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)3,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBI16", CPL_STR_HASH("RGBI16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)21,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceF32_F16", CPL_STR_HASH("LuminanceF32_F16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)11,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceU8", CPL_STR_HASH("LuminanceU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)6,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt_8", CPL_STR_HASH("UInt_8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)31,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt2_8", CPL_STR_HASH("UInt2_8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)37,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int3_16", CPL_STR_HASH("Int3_16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)44,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBAU8", CPL_STR_HASH("RGBAU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)24,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBU16", CPL_STR_HASH("RGBU16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)20,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceAlphaF32", CPL_STR_HASH("LuminanceAlphaF32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)16,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBAF32", CPL_STR_HASH("RGBAF32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)28,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt3_8", CPL_STR_HASH("UInt3_8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)43,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int4_8", CPL_STR_HASH("Int4_8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)48,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceAlphaU16", CPL_STR_HASH("LuminanceAlphaU16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)14,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int2_32", CPL_STR_HASH("Int2_32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)40,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt_16", CPL_STR_HASH("UInt_16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)33,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt4_8", CPL_STR_HASH("UInt4_8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)49,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("AlphaU16", CPL_STR_HASH("AlphaU16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)2,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedGreenI8", CPL_STR_HASH("RedGreenI8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)60,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceAlphaF32_F16", CPL_STR_HASH("LuminanceAlphaF32_F16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)17,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int3_32", CPL_STR_HASH("Int3_32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)46,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedGreenF32_F16", CPL_STR_HASH("RedGreenF32_F16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)64,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBU8", CPL_STR_HASH("RGBU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)18,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("SRGBU8", CPL_STR_HASH("SRGBU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)54,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedGreenU8", CPL_STR_HASH("RedGreenU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)59,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("DepthF32", CPL_STR_HASH("DepthF32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)58,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("AlphaF32", CPL_STR_HASH("AlphaF32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)4,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt_32", CPL_STR_HASH("UInt_32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)35,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("AlphaU8", CPL_STR_HASH("AlphaU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)0,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("DepthF32_F24", CPL_STR_HASH("DepthF32_F24")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)57,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedF32", CPL_STR_HASH("RedF32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)69,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedGreenF32", CPL_STR_HASH("RedGreenF32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)63,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int4_16", CPL_STR_HASH("Int4_16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)50,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBAI8", CPL_STR_HASH("RGBAI8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)25,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt4_32", CPL_STR_HASH("UInt4_32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)53,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt4_16", CPL_STR_HASH("UInt4_16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)51,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt3_16", CPL_STR_HASH("UInt3_16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)45,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("UInt3_32", CPL_STR_HASH("UInt3_32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)47,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedI8", CPL_STR_HASH("RedI8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)66,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int4_32", CPL_STR_HASH("Int4_32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)52,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("SRGBAU8", CPL_STR_HASH("SRGBAU8")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)55,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceF32", CPL_STR_HASH("LuminanceF32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)10,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBF32", CPL_STR_HASH("RGBF32")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)22,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("Int_16", CPL_STR_HASH("Int_16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)32,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RedGreenU16", CPL_STR_HASH("RedGreenU16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)61,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("LuminanceAlphaI16", CPL_STR_HASH("LuminanceAlphaI16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)15,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("RGBAI16", CPL_STR_HASH("RGBAI16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)27,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("DepthF32_F16", CPL_STR_HASH("DepthF32_F16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)56,EXT->GfxTexFormat_typeID);
EI(keyStr.equals("AlphaF32_F16", CPL_STR_HASH("AlphaF32_F16")))RET STG::createNativeObject(GfxTexFormat_funcs,(void *)5,EXT->GfxTexFormat_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxTexFormat_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxFace___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxFace::__eq__")));
size_t f;
if(!TS(a[0],GfxFace))
CATE(TE,FAE("GfxFace::GfxFace","GfxFace")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxFace))
CATE(VE,UFOF("GfxFace::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxFace_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxFace");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxFace___eq__);
EI(keyStr.equals("PositiveZ", CPL_STR_HASH("PositiveZ")))RET STG::createNativeObject(GfxFace_funcs,(void *)4,EXT->GfxFace_typeID);
EI(keyStr.equals("PositiveX", CPL_STR_HASH("PositiveX")))RET STG::createNativeObject(GfxFace_funcs,(void *)0,EXT->GfxFace_typeID);
EI(keyStr.equals("PositiveY", CPL_STR_HASH("PositiveY")))RET STG::createNativeObject(GfxFace_funcs,(void *)2,EXT->GfxFace_typeID);
EI(keyStr.equals("NegativeZ", CPL_STR_HASH("NegativeZ")))RET STG::createNativeObject(GfxFace_funcs,(void *)5,EXT->GfxFace_typeID);
EI(keyStr.equals("NegativeX", CPL_STR_HASH("NegativeX")))RET STG::createNativeObject(GfxFace_funcs,(void *)1,EXT->GfxFace_typeID);
EI(keyStr.equals("NegativeY", CPL_STR_HASH("NegativeY")))RET STG::createNativeObject(GfxFace_funcs,(void *)3,EXT->GfxFace_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxFace");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxFace___eq__);
EI(keyStr.equals("PositiveZ", CPL_STR_HASH("PositiveZ")))RET STG::createNativeObject(GfxFace_funcs,(void *)4,EXT->GfxFace_typeID);
EI(keyStr.equals("PositiveX", CPL_STR_HASH("PositiveX")))RET STG::createNativeObject(GfxFace_funcs,(void *)0,EXT->GfxFace_typeID);
EI(keyStr.equals("PositiveY", CPL_STR_HASH("PositiveY")))RET STG::createNativeObject(GfxFace_funcs,(void *)2,EXT->GfxFace_typeID);
EI(keyStr.equals("NegativeZ", CPL_STR_HASH("NegativeZ")))RET STG::createNativeObject(GfxFace_funcs,(void *)5,EXT->GfxFace_typeID);
EI(keyStr.equals("NegativeX", CPL_STR_HASH("NegativeX")))RET STG::createNativeObject(GfxFace_funcs,(void *)1,EXT->GfxFace_typeID);
EI(keyStr.equals("NegativeY", CPL_STR_HASH("NegativeY")))RET STG::createNativeObject(GfxFace_funcs,(void *)3,EXT->GfxFace_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxFace_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxBufferUsage___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxBufferUsage::__eq__")));
size_t f;
if(!TS(a[0],GfxBufferUsage))
CATE(TE,FAE("GfxBufferUsage::GfxBufferUsage","GfxBufferUsage")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxBufferUsage))
CATE(VE,UFOF("GfxBufferUsage::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxBufferUsage_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxBufferUsage");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxBufferUsage___eq__);
EI(keyStr.equals("Dynamic", CPL_STR_HASH("Dynamic")))RET STG::createNativeObject(GfxBufferUsage_funcs,(void *)2,EXT->GfxBufferUsage_typeID);
EI(keyStr.equals("Static", CPL_STR_HASH("Static")))RET STG::createNativeObject(GfxBufferUsage_funcs,(void *)1,EXT->GfxBufferUsage_typeID);
EI(keyStr.equals("Stream", CPL_STR_HASH("Stream")))RET STG::createNativeObject(GfxBufferUsage_funcs,(void *)0,EXT->GfxBufferUsage_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxBufferUsage");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxBufferUsage___eq__);
EI(keyStr.equals("Dynamic", CPL_STR_HASH("Dynamic")))RET STG::createNativeObject(GfxBufferUsage_funcs,(void *)2,EXT->GfxBufferUsage_typeID);
EI(keyStr.equals("Static", CPL_STR_HASH("Static")))RET STG::createNativeObject(GfxBufferUsage_funcs,(void *)1,EXT->GfxBufferUsage_typeID);
EI(keyStr.equals("Stream", CPL_STR_HASH("Stream")))RET STG::createNativeObject(GfxBufferUsage_funcs,(void *)0,EXT->GfxBufferUsage_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxBufferUsage_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxShaderType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxShaderType::__eq__")));
size_t f;
if(!TS(a[0],GfxShaderType))
CATE(TE,FAE("GfxShaderType::GfxShaderType","GfxShaderType")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxShaderType))
CATE(VE,UFOF("GfxShaderType::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxShaderType_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxShaderType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxShaderType___eq__);
EI(keyStr.equals("Compute", CPL_STR_HASH("Compute")))RET STG::createNativeObject(GfxShaderType_funcs,(void *)5,EXT->GfxShaderType_typeID);
EI(keyStr.equals("Geometry", CPL_STR_HASH("Geometry")))RET STG::createNativeObject(GfxShaderType_funcs,(void *)3,EXT->GfxShaderType_typeID);
EI(keyStr.equals("Vertex", CPL_STR_HASH("Vertex")))RET STG::createNativeObject(GfxShaderType_funcs,(void *)0,EXT->GfxShaderType_typeID);
EI(keyStr.equals("Fragment", CPL_STR_HASH("Fragment")))RET STG::createNativeObject(GfxShaderType_funcs,(void *)4,EXT->GfxShaderType_typeID);
EI(keyStr.equals("TessControl", CPL_STR_HASH("TessControl")))RET STG::createNativeObject(GfxShaderType_funcs,(void *)1,EXT->GfxShaderType_typeID);
EI(keyStr.equals("TessEval", CPL_STR_HASH("TessEval")))RET STG::createNativeObject(GfxShaderType_funcs,(void *)2,EXT->GfxShaderType_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxShaderType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxShaderType___eq__);
EI(keyStr.equals("Compute", CPL_STR_HASH("Compute")))RET STG::createNativeObject(GfxShaderType_funcs,(void *)5,EXT->GfxShaderType_typeID);
EI(keyStr.equals("Geometry", CPL_STR_HASH("Geometry")))RET STG::createNativeObject(GfxShaderType_funcs,(void *)3,EXT->GfxShaderType_typeID);
EI(keyStr.equals("Vertex", CPL_STR_HASH("Vertex")))RET STG::createNativeObject(GfxShaderType_funcs,(void *)0,EXT->GfxShaderType_typeID);
EI(keyStr.equals("Fragment", CPL_STR_HASH("Fragment")))RET STG::createNativeObject(GfxShaderType_funcs,(void *)4,EXT->GfxShaderType_typeID);
EI(keyStr.equals("TessControl", CPL_STR_HASH("TessControl")))RET STG::createNativeObject(GfxShaderType_funcs,(void *)1,EXT->GfxShaderType_typeID);
EI(keyStr.equals("TessEval", CPL_STR_HASH("TessEval")))RET STG::createNativeObject(GfxShaderType_funcs,(void *)2,EXT->GfxShaderType_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxShaderType_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxPrimitive___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxPrimitive::__eq__")));
size_t f;
if(!TS(a[0],GfxPrimitive))
CATE(TE,FAE("GfxPrimitive::GfxPrimitive","GfxPrimitive")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxPrimitive))
CATE(VE,UFOF("GfxPrimitive::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxPrimitive_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxPrimitive");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxPrimitive___eq__);
EI(keyStr.equals("GfxLineStrip", CPL_STR_HASH("GfxLineStrip")))RET STG::createNativeObject(GfxPrimitive_funcs,(void *)1,EXT->GfxPrimitive_typeID);
EI(keyStr.equals("GfxTriangleFan", CPL_STR_HASH("GfxTriangleFan")))RET STG::createNativeObject(GfxPrimitive_funcs,(void *)5,EXT->GfxPrimitive_typeID);
EI(keyStr.equals("GfxTriangles", CPL_STR_HASH("GfxTriangles")))RET STG::createNativeObject(GfxPrimitive_funcs,(void *)6,EXT->GfxPrimitive_typeID);
EI(keyStr.equals("GfxPoints", CPL_STR_HASH("GfxPoints")))RET STG::createNativeObject(GfxPrimitive_funcs,(void *)0,EXT->GfxPrimitive_typeID);
EI(keyStr.equals("GfxLines", CPL_STR_HASH("GfxLines")))RET STG::createNativeObject(GfxPrimitive_funcs,(void *)3,EXT->GfxPrimitive_typeID);
EI(keyStr.equals("GfxLineLoop", CPL_STR_HASH("GfxLineLoop")))RET STG::createNativeObject(GfxPrimitive_funcs,(void *)2,EXT->GfxPrimitive_typeID);
EI(keyStr.equals("GfxTriangleStrip", CPL_STR_HASH("GfxTriangleStrip")))RET STG::createNativeObject(GfxPrimitive_funcs,(void *)4,EXT->GfxPrimitive_typeID);
EI(keyStr.equals("GfxPatches", CPL_STR_HASH("GfxPatches")))RET STG::createNativeObject(GfxPrimitive_funcs,(void *)7,EXT->GfxPrimitive_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxPrimitive");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxPrimitive___eq__);
EI(keyStr.equals("GfxLineStrip", CPL_STR_HASH("GfxLineStrip")))RET STG::createNativeObject(GfxPrimitive_funcs,(void *)1,EXT->GfxPrimitive_typeID);
EI(keyStr.equals("GfxTriangleFan", CPL_STR_HASH("GfxTriangleFan")))RET STG::createNativeObject(GfxPrimitive_funcs,(void *)5,EXT->GfxPrimitive_typeID);
EI(keyStr.equals("GfxTriangles", CPL_STR_HASH("GfxTriangles")))RET STG::createNativeObject(GfxPrimitive_funcs,(void *)6,EXT->GfxPrimitive_typeID);
EI(keyStr.equals("GfxPoints", CPL_STR_HASH("GfxPoints")))RET STG::createNativeObject(GfxPrimitive_funcs,(void *)0,EXT->GfxPrimitive_typeID);
EI(keyStr.equals("GfxLines", CPL_STR_HASH("GfxLines")))RET STG::createNativeObject(GfxPrimitive_funcs,(void *)3,EXT->GfxPrimitive_typeID);
EI(keyStr.equals("GfxLineLoop", CPL_STR_HASH("GfxLineLoop")))RET STG::createNativeObject(GfxPrimitive_funcs,(void *)2,EXT->GfxPrimitive_typeID);
EI(keyStr.equals("GfxTriangleStrip", CPL_STR_HASH("GfxTriangleStrip")))RET STG::createNativeObject(GfxPrimitive_funcs,(void *)4,EXT->GfxPrimitive_typeID);
EI(keyStr.equals("GfxPatches", CPL_STR_HASH("GfxPatches")))RET STG::createNativeObject(GfxPrimitive_funcs,(void *)7,EXT->GfxPrimitive_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxPrimitive_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxDepthFunction___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxDepthFunction::__eq__")));
size_t f;
if(!TS(a[0],GfxDepthFunction))
CATE(TE,FAE("GfxDepthFunction::GfxDepthFunction","GfxDepthFunction")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxDepthFunction))
CATE(VE,UFOF("GfxDepthFunction::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxDepthFunction_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxDepthFunction");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxDepthFunction___eq__);
EI(keyStr.equals("GfxGreaterEqual", CPL_STR_HASH("GfxGreaterEqual")))RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)6,EXT->GfxDepthFunction_typeID);
EI(keyStr.equals("GfxNever", CPL_STR_HASH("GfxNever")))RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)0,EXT->GfxDepthFunction_typeID);
EI(keyStr.equals("GfxLessEqual", CPL_STR_HASH("GfxLessEqual")))RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)3,EXT->GfxDepthFunction_typeID);
EI(keyStr.equals("GfxAlways", CPL_STR_HASH("GfxAlways")))RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)7,EXT->GfxDepthFunction_typeID);
EI(keyStr.equals("GfxLess", CPL_STR_HASH("GfxLess")))RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)1,EXT->GfxDepthFunction_typeID);
EI(keyStr.equals("GfxGreater", CPL_STR_HASH("GfxGreater")))RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)4,EXT->GfxDepthFunction_typeID);
EI(keyStr.equals("GfxEqual", CPL_STR_HASH("GfxEqual")))RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)2,EXT->GfxDepthFunction_typeID);
EI(keyStr.equals("GfxNotEqual", CPL_STR_HASH("GfxNotEqual")))RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)5,EXT->GfxDepthFunction_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxDepthFunction");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxDepthFunction___eq__);
EI(keyStr.equals("GfxGreaterEqual", CPL_STR_HASH("GfxGreaterEqual")))RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)6,EXT->GfxDepthFunction_typeID);
EI(keyStr.equals("GfxNever", CPL_STR_HASH("GfxNever")))RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)0,EXT->GfxDepthFunction_typeID);
EI(keyStr.equals("GfxLessEqual", CPL_STR_HASH("GfxLessEqual")))RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)3,EXT->GfxDepthFunction_typeID);
EI(keyStr.equals("GfxAlways", CPL_STR_HASH("GfxAlways")))RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)7,EXT->GfxDepthFunction_typeID);
EI(keyStr.equals("GfxLess", CPL_STR_HASH("GfxLess")))RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)1,EXT->GfxDepthFunction_typeID);
EI(keyStr.equals("GfxGreater", CPL_STR_HASH("GfxGreater")))RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)4,EXT->GfxDepthFunction_typeID);
EI(keyStr.equals("GfxEqual", CPL_STR_HASH("GfxEqual")))RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)2,EXT->GfxDepthFunction_typeID);
EI(keyStr.equals("GfxNotEqual", CPL_STR_HASH("GfxNotEqual")))RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)5,EXT->GfxDepthFunction_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxDepthFunction_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxBlendMode___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxBlendMode::__eq__")));
size_t f;
if(!TS(a[0],GfxBlendMode))
CATE(TE,FAE("GfxBlendMode::GfxBlendMode","GfxBlendMode")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxBlendMode))
CATE(VE,UFOF("GfxBlendMode::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxBlendMode_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxBlendMode");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxBlendMode___eq__);
EI(keyStr.equals("GfxReverseSubtract", CPL_STR_HASH("GfxReverseSubtract")))RET STG::createNativeObject(GfxBlendMode_funcs,(void *)2,EXT->GfxBlendMode_typeID);
EI(keyStr.equals("GfxAdd", CPL_STR_HASH("GfxAdd")))RET STG::createNativeObject(GfxBlendMode_funcs,(void *)0,EXT->GfxBlendMode_typeID);
EI(keyStr.equals("GfxSubtract", CPL_STR_HASH("GfxSubtract")))RET STG::createNativeObject(GfxBlendMode_funcs,(void *)1,EXT->GfxBlendMode_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxBlendMode");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxBlendMode___eq__);
EI(keyStr.equals("GfxReverseSubtract", CPL_STR_HASH("GfxReverseSubtract")))RET STG::createNativeObject(GfxBlendMode_funcs,(void *)2,EXT->GfxBlendMode_typeID);
EI(keyStr.equals("GfxAdd", CPL_STR_HASH("GfxAdd")))RET STG::createNativeObject(GfxBlendMode_funcs,(void *)0,EXT->GfxBlendMode_typeID);
EI(keyStr.equals("GfxSubtract", CPL_STR_HASH("GfxSubtract")))RET STG::createNativeObject(GfxBlendMode_funcs,(void *)1,EXT->GfxBlendMode_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxBlendMode_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxBlendFactor___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxBlendFactor::__eq__")));
size_t f;
if(!TS(a[0],GfxBlendFactor))
CATE(TE,FAE("GfxBlendFactor::GfxBlendFactor","GfxBlendFactor")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxBlendFactor))
CATE(VE,UFOF("GfxBlendFactor::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxBlendFactor_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxBlendFactor");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxBlendFactor___eq__);
EI(keyStr.equals("GfxZero", CPL_STR_HASH("GfxZero")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)0,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxSrcColor", CPL_STR_HASH("GfxSrcColor")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)2,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxOneMinusSrcAlpha", CPL_STR_HASH("GfxOneMinusSrcAlpha")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)7,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxConstantAlpha", CPL_STR_HASH("GfxConstantAlpha")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)12,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxDstAlpha", CPL_STR_HASH("GfxDstAlpha")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)8,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxSrcAlpha", CPL_STR_HASH("GfxSrcAlpha")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)6,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxOneMinusDstColor", CPL_STR_HASH("GfxOneMinusDstColor")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)5,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxDstColor", CPL_STR_HASH("GfxDstColor")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)4,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxOneMinusConstantColor", CPL_STR_HASH("GfxOneMinusConstantColor")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)11,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxOneMinusSrcColor", CPL_STR_HASH("GfxOneMinusSrcColor")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)3,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxConstantColor", CPL_STR_HASH("GfxConstantColor")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)10,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxOneMinusConstantAlpha", CPL_STR_HASH("GfxOneMinusConstantAlpha")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)13,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxOne", CPL_STR_HASH("GfxOne")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)1,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxOneMinusDstAlpha", CPL_STR_HASH("GfxOneMinusDstAlpha")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)9,EXT->GfxBlendFactor_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxBlendFactor");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxBlendFactor___eq__);
EI(keyStr.equals("GfxZero", CPL_STR_HASH("GfxZero")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)0,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxSrcColor", CPL_STR_HASH("GfxSrcColor")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)2,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxOneMinusSrcAlpha", CPL_STR_HASH("GfxOneMinusSrcAlpha")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)7,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxConstantAlpha", CPL_STR_HASH("GfxConstantAlpha")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)12,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxDstAlpha", CPL_STR_HASH("GfxDstAlpha")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)8,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxSrcAlpha", CPL_STR_HASH("GfxSrcAlpha")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)6,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxOneMinusDstColor", CPL_STR_HASH("GfxOneMinusDstColor")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)5,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxDstColor", CPL_STR_HASH("GfxDstColor")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)4,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxOneMinusConstantColor", CPL_STR_HASH("GfxOneMinusConstantColor")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)11,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxOneMinusSrcColor", CPL_STR_HASH("GfxOneMinusSrcColor")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)3,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxConstantColor", CPL_STR_HASH("GfxConstantColor")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)10,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxOneMinusConstantAlpha", CPL_STR_HASH("GfxOneMinusConstantAlpha")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)13,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxOne", CPL_STR_HASH("GfxOne")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)1,EXT->GfxBlendFactor_typeID);
EI(keyStr.equals("GfxOneMinusDstAlpha", CPL_STR_HASH("GfxOneMinusDstAlpha")))RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)9,EXT->GfxBlendFactor_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxBlendFactor_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxCullMode___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxCullMode::__eq__")));
size_t f;
if(!TS(a[0],GfxCullMode))
CATE(TE,FAE("GfxCullMode::GfxCullMode","GfxCullMode")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxCullMode))
CATE(VE,UFOF("GfxCullMode::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxCullMode_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxCullMode");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxCullMode___eq__);
EI(keyStr.equals("GfxCullNone", CPL_STR_HASH("GfxCullNone")))RET STG::createNativeObject(GfxCullMode_funcs,(void *)0,EXT->GfxCullMode_typeID);
EI(keyStr.equals("GfxCullBack", CPL_STR_HASH("GfxCullBack")))RET STG::createNativeObject(GfxCullMode_funcs,(void *)2,EXT->GfxCullMode_typeID);
EI(keyStr.equals("GfxCullFront", CPL_STR_HASH("GfxCullFront")))RET STG::createNativeObject(GfxCullMode_funcs,(void *)1,EXT->GfxCullMode_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxCullMode");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxCullMode___eq__);
EI(keyStr.equals("GfxCullNone", CPL_STR_HASH("GfxCullNone")))RET STG::createNativeObject(GfxCullMode_funcs,(void *)0,EXT->GfxCullMode_typeID);
EI(keyStr.equals("GfxCullBack", CPL_STR_HASH("GfxCullBack")))RET STG::createNativeObject(GfxCullMode_funcs,(void *)2,EXT->GfxCullMode_typeID);
EI(keyStr.equals("GfxCullFront", CPL_STR_HASH("GfxCullFront")))RET STG::createNativeObject(GfxCullMode_funcs,(void *)1,EXT->GfxCullMode_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxCullMode_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxWinding___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxWinding::__eq__")));
size_t f;
if(!TS(a[0],GfxWinding))
CATE(TE,FAE("GfxWinding::GfxWinding","GfxWinding")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxWinding))
CATE(VE,UFOF("GfxWinding::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxWinding_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxWinding");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxWinding___eq__);
EI(keyStr.equals("GfxCCW", CPL_STR_HASH("GfxCCW")))RET STG::createNativeObject(GfxWinding_funcs,(void *)1,EXT->GfxWinding_typeID);
EI(keyStr.equals("GfxCW", CPL_STR_HASH("GfxCW")))RET STG::createNativeObject(GfxWinding_funcs,(void *)0,EXT->GfxWinding_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxWinding");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxWinding___eq__);
EI(keyStr.equals("GfxCCW", CPL_STR_HASH("GfxCCW")))RET STG::createNativeObject(GfxWinding_funcs,(void *)1,EXT->GfxWinding_typeID);
EI(keyStr.equals("GfxCW", CPL_STR_HASH("GfxCW")))RET STG::createNativeObject(GfxWinding_funcs,(void *)0,EXT->GfxWinding_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxWinding_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxVertexAttribPurpose___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxVertexAttribPurpose::__eq__")));
size_t f;
if(!TS(a[0],GfxVertexAttribPurpose))
CATE(TE,FAE("GfxVertexAttribPurpose::GfxVertexAttribPurpose","GfxVertexAttribPurpose")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxVertexAttribPurpose))
CATE(VE,UFOF("GfxVertexAttribPurpose::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxVertexAttribPurpose_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxVertexAttribPurpose");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxVertexAttribPurpose___eq__);
EI(keyStr.equals("GfxTexCoord", CPL_STR_HASH("GfxTexCoord")))RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)4,EXT->GfxVertexAttribPurpose_typeID);
EI(keyStr.equals("GfxTangent", CPL_STR_HASH("GfxTangent")))RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)2,EXT->GfxVertexAttribPurpose_typeID);
EI(keyStr.equals("GfxPosition", CPL_STR_HASH("GfxPosition")))RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)0,EXT->GfxVertexAttribPurpose_typeID);
EI(keyStr.equals("GfxNormal", CPL_STR_HASH("GfxNormal")))RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)1,EXT->GfxVertexAttribPurpose_typeID);
EI(keyStr.equals("GfxColor", CPL_STR_HASH("GfxColor")))RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)3,EXT->GfxVertexAttribPurpose_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxVertexAttribPurpose");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxVertexAttribPurpose___eq__);
EI(keyStr.equals("GfxTexCoord", CPL_STR_HASH("GfxTexCoord")))RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)4,EXT->GfxVertexAttribPurpose_typeID);
EI(keyStr.equals("GfxTangent", CPL_STR_HASH("GfxTangent")))RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)2,EXT->GfxVertexAttribPurpose_typeID);
EI(keyStr.equals("GfxPosition", CPL_STR_HASH("GfxPosition")))RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)0,EXT->GfxVertexAttribPurpose_typeID);
EI(keyStr.equals("GfxNormal", CPL_STR_HASH("GfxNormal")))RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)1,EXT->GfxVertexAttribPurpose_typeID);
EI(keyStr.equals("GfxColor", CPL_STR_HASH("GfxColor")))RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)3,EXT->GfxVertexAttribPurpose_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxVertexAttribPurpose_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxVertexAttribType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxVertexAttribType::__eq__")));
size_t f;
if(!TS(a[0],GfxVertexAttribType))
CATE(TE,FAE("GfxVertexAttribType::GfxVertexAttribType","GfxVertexAttribType")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxVertexAttribType))
CATE(VE,UFOF("GfxVertexAttribType::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxVertexAttribType_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxVertexAttribType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxVertexAttribType___eq__);
EI(keyStr.equals("GfxUnsignedInteger", CPL_STR_HASH("GfxUnsignedInteger")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)8,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxNormalizedUnsignedByte", CPL_STR_HASH("GfxNormalizedUnsignedByte")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)10,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxFloat", CPL_STR_HASH("GfxFloat")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)1,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxNormalizedUnsignedInteger", CPL_STR_HASH("GfxNormalizedUnsignedInteger")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)14,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxShort", CPL_STR_HASH("GfxShort")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)5,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxInteger", CPL_STR_HASH("GfxInteger")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)7,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxByte", CPL_STR_HASH("GfxByte")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)3,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxNormalizedByte", CPL_STR_HASH("GfxNormalizedByte")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)9,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxUnsignedShort", CPL_STR_HASH("GfxUnsignedShort")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)6,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxDouble", CPL_STR_HASH("GfxDouble")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)2,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxHalfFloat", CPL_STR_HASH("GfxHalfFloat")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)0,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxNormalizedShort", CPL_STR_HASH("GfxNormalizedShort")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)11,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxNormalizedInteger", CPL_STR_HASH("GfxNormalizedInteger")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)13,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxUnsignedByte", CPL_STR_HASH("GfxUnsignedByte")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)4,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxNormalizedUnsignedShort", CPL_STR_HASH("GfxNormalizedUnsignedShort")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)12,EXT->GfxVertexAttribType_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxVertexAttribType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxVertexAttribType___eq__);
EI(keyStr.equals("GfxUnsignedInteger", CPL_STR_HASH("GfxUnsignedInteger")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)8,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxNormalizedUnsignedByte", CPL_STR_HASH("GfxNormalizedUnsignedByte")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)10,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxFloat", CPL_STR_HASH("GfxFloat")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)1,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxNormalizedUnsignedInteger", CPL_STR_HASH("GfxNormalizedUnsignedInteger")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)14,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxShort", CPL_STR_HASH("GfxShort")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)5,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxInteger", CPL_STR_HASH("GfxInteger")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)7,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxByte", CPL_STR_HASH("GfxByte")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)3,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxNormalizedByte", CPL_STR_HASH("GfxNormalizedByte")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)9,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxUnsignedShort", CPL_STR_HASH("GfxUnsignedShort")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)6,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxDouble", CPL_STR_HASH("GfxDouble")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)2,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxHalfFloat", CPL_STR_HASH("GfxHalfFloat")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)0,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxNormalizedShort", CPL_STR_HASH("GfxNormalizedShort")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)11,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxNormalizedInteger", CPL_STR_HASH("GfxNormalizedInteger")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)13,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxUnsignedByte", CPL_STR_HASH("GfxUnsignedByte")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)4,EXT->GfxVertexAttribType_typeID);
EI(keyStr.equals("GfxNormalizedUnsignedShort", CPL_STR_HASH("GfxNormalizedUnsignedShort")))RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)12,EXT->GfxVertexAttribType_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxVertexAttribType_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxMeshIndexDataType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxMeshIndexDataType::__eq__")));
size_t f;
if(!TS(a[0],GfxMeshIndexDataType))
CATE(TE,FAE("GfxMeshIndexDataType::GfxMeshIndexDataType","GfxMeshIndexDataType")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxMeshIndexDataType))
CATE(VE,UFOF("GfxMeshIndexDataType::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxMeshIndexDataType_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxMeshIndexDataType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxMeshIndexDataType___eq__);
EI(keyStr.equals("U32", CPL_STR_HASH("U32")))RET STG::createNativeObject(GfxMeshIndexDataType_funcs,(void *)2,EXT->GfxMeshIndexDataType_typeID);
EI(keyStr.equals("U8", CPL_STR_HASH("U8")))RET STG::createNativeObject(GfxMeshIndexDataType_funcs,(void *)0,EXT->GfxMeshIndexDataType_typeID);
EI(keyStr.equals("U16", CPL_STR_HASH("U16")))RET STG::createNativeObject(GfxMeshIndexDataType_funcs,(void *)1,EXT->GfxMeshIndexDataType_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxMeshIndexDataType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxMeshIndexDataType___eq__);
EI(keyStr.equals("U32", CPL_STR_HASH("U32")))RET STG::createNativeObject(GfxMeshIndexDataType_funcs,(void *)2,EXT->GfxMeshIndexDataType_typeID);
EI(keyStr.equals("U8", CPL_STR_HASH("U8")))RET STG::createNativeObject(GfxMeshIndexDataType_funcs,(void *)0,EXT->GfxMeshIndexDataType_typeID);
EI(keyStr.equals("U16", CPL_STR_HASH("U16")))RET STG::createNativeObject(GfxMeshIndexDataType_funcs,(void *)1,EXT->GfxMeshIndexDataType_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxMeshIndexDataType_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxMeshAttribType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxMeshAttribType::__eq__")));
size_t f;
if(!TS(a[0],GfxMeshAttribType))
CATE(TE,FAE("GfxMeshAttribType::GfxMeshAttribType","GfxMeshAttribType")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxMeshAttribType))
CATE(VE,UFOF("GfxMeshAttribType::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxMeshAttribType_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxMeshAttribType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxMeshAttribType___eq__);
EI(keyStr.equals("Normal", CPL_STR_HASH("Normal")))RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)1,EXT->GfxMeshAttribType_typeID);
EI(keyStr.equals("Color", CPL_STR_HASH("Color")))RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)3,EXT->GfxMeshAttribType_typeID);
EI(keyStr.equals("TexCoord", CPL_STR_HASH("TexCoord")))RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)4,EXT->GfxMeshAttribType_typeID);
EI(keyStr.equals("Tangent", CPL_STR_HASH("Tangent")))RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)2,EXT->GfxMeshAttribType_typeID);
EI(keyStr.equals("BoneWeight", CPL_STR_HASH("BoneWeight")))RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)6,EXT->GfxMeshAttribType_typeID);
EI(keyStr.equals("Position", CPL_STR_HASH("Position")))RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)0,EXT->GfxMeshAttribType_typeID);
EI(keyStr.equals("BoneIndex", CPL_STR_HASH("BoneIndex")))RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)5,EXT->GfxMeshAttribType_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxMeshAttribType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxMeshAttribType___eq__);
EI(keyStr.equals("Normal", CPL_STR_HASH("Normal")))RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)1,EXT->GfxMeshAttribType_typeID);
EI(keyStr.equals("Color", CPL_STR_HASH("Color")))RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)3,EXT->GfxMeshAttribType_typeID);
EI(keyStr.equals("TexCoord", CPL_STR_HASH("TexCoord")))RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)4,EXT->GfxMeshAttribType_typeID);
EI(keyStr.equals("Tangent", CPL_STR_HASH("Tangent")))RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)2,EXT->GfxMeshAttribType_typeID);
EI(keyStr.equals("BoneWeight", CPL_STR_HASH("BoneWeight")))RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)6,EXT->GfxMeshAttribType_typeID);
EI(keyStr.equals("Position", CPL_STR_HASH("Position")))RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)0,EXT->GfxMeshAttribType_typeID);
EI(keyStr.equals("BoneIndex", CPL_STR_HASH("BoneIndex")))RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)5,EXT->GfxMeshAttribType_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxMeshAttribType_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxMeshAttribDataType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxMeshAttribDataType::__eq__")));
size_t f;
if(!TS(a[0],GfxMeshAttribDataType))
CATE(TE,FAE("GfxMeshAttribDataType::GfxMeshAttribDataType","GfxMeshAttribDataType")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxMeshAttribDataType))
CATE(VE,UFOF("GfxMeshAttribDataType::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxMeshAttribDataType_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxMeshAttribDataType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxMeshAttribDataType___eq__);
EI(keyStr.equals("S32_3Norm", CPL_STR_HASH("S32_3Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)54,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S16_2", CPL_STR_HASH("S16_2")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)21,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S16_3", CPL_STR_HASH("S16_3")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)22,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S16_1", CPL_STR_HASH("S16_1")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)20,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S8_2Norm", CPL_STR_HASH("S8_2Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)37,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S16_4", CPL_STR_HASH("S16_4")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)23,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S32_2Norm", CPL_STR_HASH("S32_2Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)53,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U16_3Norm", CPL_STR_HASH("U16_3Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)42,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S32_4Norm", CPL_STR_HASH("S32_4Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)55,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S8_3Norm", CPL_STR_HASH("S8_3Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)38,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U32_2", CPL_STR_HASH("U32_2")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)25,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U32_3", CPL_STR_HASH("U32_3")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)26,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U32_1", CPL_STR_HASH("U32_1")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)24,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U32_4", CPL_STR_HASH("U32_4")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)27,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S8_1Norm", CPL_STR_HASH("S8_1Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)36,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U8_2", CPL_STR_HASH("U8_2")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)9,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U8_3", CPL_STR_HASH("U8_3")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)10,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U8_1", CPL_STR_HASH("U8_1")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)8,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S8_4Norm", CPL_STR_HASH("S8_4Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)39,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U8_4", CPL_STR_HASH("U8_4")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)11,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U8_3Norm", CPL_STR_HASH("U8_3Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)34,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("F16_3", CPL_STR_HASH("F16_3")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)2,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("F16_2", CPL_STR_HASH("F16_2")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)1,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("F16_1", CPL_STR_HASH("F16_1")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)0,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S32_1Norm", CPL_STR_HASH("S32_1Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)52,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("F16_4", CPL_STR_HASH("F16_4")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)3,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U32_3Norm", CPL_STR_HASH("U32_3Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)50,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U16_2Norm", CPL_STR_HASH("U16_2Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)41,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U16_1Norm", CPL_STR_HASH("U16_1Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)40,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U8_2Norm", CPL_STR_HASH("U8_2Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)33,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U8_4Norm", CPL_STR_HASH("U8_4Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)35,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U32_4Norm", CPL_STR_HASH("U32_4Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)51,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U32_1Norm", CPL_STR_HASH("U32_1Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)48,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S16_2Norm", CPL_STR_HASH("S16_2Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)45,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U16_4", CPL_STR_HASH("U16_4")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)19,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U16_1", CPL_STR_HASH("U16_1")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)16,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U16_2", CPL_STR_HASH("U16_2")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)17,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U16_3", CPL_STR_HASH("U16_3")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)18,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S16_4Norm", CPL_STR_HASH("S16_4Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)47,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U8_1Norm", CPL_STR_HASH("U8_1Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)32,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S32_4", CPL_STR_HASH("S32_4")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)31,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S8_1", CPL_STR_HASH("S8_1")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)12,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S8_2", CPL_STR_HASH("S8_2")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)13,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S8_3", CPL_STR_HASH("S8_3")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)14,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S8_4", CPL_STR_HASH("S8_4")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)15,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S32_1", CPL_STR_HASH("S32_1")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)28,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S32_2", CPL_STR_HASH("S32_2")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)29,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S32_3", CPL_STR_HASH("S32_3")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)30,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U32_2Norm", CPL_STR_HASH("U32_2Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)49,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S16_3Norm", CPL_STR_HASH("S16_3Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)46,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("F32_1", CPL_STR_HASH("F32_1")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)4,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("F32_3", CPL_STR_HASH("F32_3")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)6,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("F32_2", CPL_STR_HASH("F32_2")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)5,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("F32_4", CPL_STR_HASH("F32_4")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)7,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U16_4Norm", CPL_STR_HASH("U16_4Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)43,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S16_1Norm", CPL_STR_HASH("S16_1Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)44,EXT->GfxMeshAttribDataType_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxMeshAttribDataType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxMeshAttribDataType___eq__);
EI(keyStr.equals("S32_3Norm", CPL_STR_HASH("S32_3Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)54,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S16_2", CPL_STR_HASH("S16_2")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)21,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S16_3", CPL_STR_HASH("S16_3")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)22,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S16_1", CPL_STR_HASH("S16_1")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)20,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S8_2Norm", CPL_STR_HASH("S8_2Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)37,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S16_4", CPL_STR_HASH("S16_4")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)23,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S32_2Norm", CPL_STR_HASH("S32_2Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)53,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U16_3Norm", CPL_STR_HASH("U16_3Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)42,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S32_4Norm", CPL_STR_HASH("S32_4Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)55,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S8_3Norm", CPL_STR_HASH("S8_3Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)38,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U32_2", CPL_STR_HASH("U32_2")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)25,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U32_3", CPL_STR_HASH("U32_3")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)26,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U32_1", CPL_STR_HASH("U32_1")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)24,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U32_4", CPL_STR_HASH("U32_4")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)27,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S8_1Norm", CPL_STR_HASH("S8_1Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)36,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U8_2", CPL_STR_HASH("U8_2")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)9,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U8_3", CPL_STR_HASH("U8_3")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)10,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U8_1", CPL_STR_HASH("U8_1")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)8,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S8_4Norm", CPL_STR_HASH("S8_4Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)39,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U8_4", CPL_STR_HASH("U8_4")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)11,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U8_3Norm", CPL_STR_HASH("U8_3Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)34,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("F16_3", CPL_STR_HASH("F16_3")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)2,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("F16_2", CPL_STR_HASH("F16_2")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)1,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("F16_1", CPL_STR_HASH("F16_1")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)0,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S32_1Norm", CPL_STR_HASH("S32_1Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)52,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("F16_4", CPL_STR_HASH("F16_4")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)3,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U32_3Norm", CPL_STR_HASH("U32_3Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)50,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U16_2Norm", CPL_STR_HASH("U16_2Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)41,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U16_1Norm", CPL_STR_HASH("U16_1Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)40,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U8_2Norm", CPL_STR_HASH("U8_2Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)33,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U8_4Norm", CPL_STR_HASH("U8_4Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)35,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U32_4Norm", CPL_STR_HASH("U32_4Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)51,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U32_1Norm", CPL_STR_HASH("U32_1Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)48,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S16_2Norm", CPL_STR_HASH("S16_2Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)45,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U16_4", CPL_STR_HASH("U16_4")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)19,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U16_1", CPL_STR_HASH("U16_1")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)16,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U16_2", CPL_STR_HASH("U16_2")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)17,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U16_3", CPL_STR_HASH("U16_3")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)18,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S16_4Norm", CPL_STR_HASH("S16_4Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)47,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U8_1Norm", CPL_STR_HASH("U8_1Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)32,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S32_4", CPL_STR_HASH("S32_4")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)31,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S8_1", CPL_STR_HASH("S8_1")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)12,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S8_2", CPL_STR_HASH("S8_2")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)13,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S8_3", CPL_STR_HASH("S8_3")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)14,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S8_4", CPL_STR_HASH("S8_4")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)15,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S32_1", CPL_STR_HASH("S32_1")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)28,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S32_2", CPL_STR_HASH("S32_2")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)29,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S32_3", CPL_STR_HASH("S32_3")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)30,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U32_2Norm", CPL_STR_HASH("U32_2Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)49,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S16_3Norm", CPL_STR_HASH("S16_3Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)46,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("F32_1", CPL_STR_HASH("F32_1")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)4,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("F32_3", CPL_STR_HASH("F32_3")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)6,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("F32_2", CPL_STR_HASH("F32_2")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)5,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("F32_4", CPL_STR_HASH("F32_4")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)7,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("U16_4Norm", CPL_STR_HASH("U16_4Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)43,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr.equals("S16_1Norm", CPL_STR_HASH("S16_1Norm")))RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)44,EXT->GfxMeshAttribDataType_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxMeshAttribDataType_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV XOrigin___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("XOrigin::__eq__")));
size_t f;
if(!TS(a[0],XOrigin))
CATE(TE,FAE("XOrigin::XOrigin","XOrigin")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],XOrigin))
CATE(VE,UFOF("XOrigin::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV XOrigin_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("XOrigin");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(XOrigin___eq__);
EI(keyStr.equals("Right", CPL_STR_HASH("Right")))RET STG::createNativeObject(XOrigin_funcs,(void *)1,EXT->XOrigin_typeID);
EI(keyStr.equals("Left", CPL_STR_HASH("Left")))RET STG::createNativeObject(XOrigin_funcs,(void *)0,EXT->XOrigin_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("XOrigin");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(XOrigin___eq__);
EI(keyStr.equals("Right", CPL_STR_HASH("Right")))RET STG::createNativeObject(XOrigin_funcs,(void *)1,EXT->XOrigin_typeID);
EI(keyStr.equals("Left", CPL_STR_HASH("Left")))RET STG::createNativeObject(XOrigin_funcs,(void *)0,EXT->XOrigin_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void XOrigin_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxShadowmapPrecision___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxShadowmapPrecision::__eq__")));
size_t f;
if(!TS(a[0],GfxShadowmapPrecision))
CATE(TE,FAE("GfxShadowmapPrecision::GfxShadowmapPrecision","GfxShadowmapPrecision")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxShadowmapPrecision))
CATE(VE,UFOF("GfxShadowmapPrecision::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxShadowmapPrecision_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxShadowmapPrecision");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxShadowmapPrecision___eq__);
EI(keyStr.equals("High", CPL_STR_HASH("High")))RET STG::createNativeObject(GfxShadowmapPrecision_funcs,(void *)2,EXT->GfxShadowmapPrecision_typeID);
EI(keyStr.equals("Medium", CPL_STR_HASH("Medium")))RET STG::createNativeObject(GfxShadowmapPrecision_funcs,(void *)1,EXT->GfxShadowmapPrecision_typeID);
EI(keyStr.equals("Low", CPL_STR_HASH("Low")))RET STG::createNativeObject(GfxShadowmapPrecision_funcs,(void *)0,EXT->GfxShadowmapPrecision_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxShadowmapPrecision");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxShadowmapPrecision___eq__);
EI(keyStr.equals("High", CPL_STR_HASH("High")))RET STG::createNativeObject(GfxShadowmapPrecision_funcs,(void *)2,EXT->GfxShadowmapPrecision_typeID);
EI(keyStr.equals("Medium", CPL_STR_HASH("Medium")))RET STG::createNativeObject(GfxShadowmapPrecision_funcs,(void *)1,EXT->GfxShadowmapPrecision_typeID);
EI(keyStr.equals("Low", CPL_STR_HASH("Low")))RET STG::createNativeObject(GfxShadowmapPrecision_funcs,(void *)0,EXT->GfxShadowmapPrecision_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxShadowmapPrecision_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxLightType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxLightType::__eq__")));
size_t f;
if(!TS(a[0],GfxLightType))
CATE(TE,FAE("GfxLightType::GfxLightType","GfxLightType")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxLightType))
CATE(VE,UFOF("GfxLightType::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxLightType_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxLightType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxLightType___eq__);
EI(keyStr.equals("Point", CPL_STR_HASH("Point")))RET STG::createNativeObject(GfxLightType_funcs,(void *)2,EXT->GfxLightType_typeID);
EI(keyStr.equals("Spot", CPL_STR_HASH("Spot")))RET STG::createNativeObject(GfxLightType_funcs,(void *)1,EXT->GfxLightType_typeID);
EI(keyStr.equals("Directional", CPL_STR_HASH("Directional")))RET STG::createNativeObject(GfxLightType_funcs,(void *)0,EXT->GfxLightType_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxLightType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxLightType___eq__);
EI(keyStr.equals("Point", CPL_STR_HASH("Point")))RET STG::createNativeObject(GfxLightType_funcs,(void *)2,EXT->GfxLightType_typeID);
EI(keyStr.equals("Spot", CPL_STR_HASH("Spot")))RET STG::createNativeObject(GfxLightType_funcs,(void *)1,EXT->GfxLightType_typeID);
EI(keyStr.equals("Directional", CPL_STR_HASH("Directional")))RET STG::createNativeObject(GfxLightType_funcs,(void *)0,EXT->GfxLightType_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxLightType_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV GfxDriver___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxDriver::__eq__")));
size_t f;
if(!TS(a[0],GfxDriver))
CATE(TE,FAE("GfxDriver::GfxDriver","GfxDriver")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],GfxDriver))
CATE(VE,UFOF("GfxDriver::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV GfxDriver_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxDriver");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxDriver___eq__);
EI(keyStr.equals("Unknown", CPL_STR_HASH("Unknown")))RET STG::createNativeObject(GfxDriver_funcs,(void *)2,EXT->GfxDriver_typeID);
EI(keyStr.equals("Mesa", CPL_STR_HASH("Mesa")))RET STG::createNativeObject(GfxDriver_funcs,(void *)1,EXT->GfxDriver_typeID);
EI(keyStr.equals("Nvidia", CPL_STR_HASH("Nvidia")))RET STG::createNativeObject(GfxDriver_funcs,(void *)0,EXT->GfxDriver_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxDriver");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxDriver___eq__);
EI(keyStr.equals("Unknown", CPL_STR_HASH("Unknown")))RET STG::createNativeObject(GfxDriver_funcs,(void *)2,EXT->GfxDriver_typeID);
EI(keyStr.equals("Mesa", CPL_STR_HASH("Mesa")))RET STG::createNativeObject(GfxDriver_funcs,(void *)1,EXT->GfxDriver_typeID);
EI(keyStr.equals("Nvidia", CPL_STR_HASH("Nvidia")))RET STG::createNativeObject(GfxDriver_funcs,(void *)0,EXT->GfxDriver_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void GfxDriver_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV CameraType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("CameraType::__eq__")));
size_t f;
if(!TS(a[0],CameraType))
CATE(TE,FAE("CameraType::CameraType","CameraType")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],CameraType))
CATE(VE,UFOF("CameraType::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV CameraType_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("CameraType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(CameraType___eq__);
EI(keyStr.equals("Matrices", CPL_STR_HASH("Matrices")))RET STG::createNativeObject(CameraType_funcs,(void *)2,EXT->CameraType_typeID);
EI(keyStr.equals("Perspective", CPL_STR_HASH("Perspective")))RET STG::createNativeObject(CameraType_funcs,(void *)0,EXT->CameraType_typeID);
EI(keyStr.equals("Orthographic", CPL_STR_HASH("Orthographic")))RET STG::createNativeObject(CameraType_funcs,(void *)1,EXT->CameraType_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("CameraType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(CameraType___eq__);
EI(keyStr.equals("Matrices", CPL_STR_HASH("Matrices")))RET STG::createNativeObject(CameraType_funcs,(void *)2,EXT->CameraType_typeID);
EI(keyStr.equals("Perspective", CPL_STR_HASH("Perspective")))RET STG::createNativeObject(CameraType_funcs,(void *)0,EXT->CameraType_typeID);
EI(keyStr.equals("Orthographic", CPL_STR_HASH("Orthographic")))RET STG::createNativeObject(CameraType_funcs,(void *)1,EXT->CameraType_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void CameraType_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV Axis___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("Axis::__eq__")));
size_t f;
if(!TS(a[0],Axis))
CATE(TE,FAE("Axis::Axis","Axis")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],Axis))
CATE(VE,UFOF("Axis::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV Axis_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Axis");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(Axis___eq__);
EI(keyStr.equals("Y", CPL_STR_HASH("Y")))RET STG::createNativeObject(Axis_funcs,(void *)1,EXT->Axis_typeID);
EI(keyStr.equals("X", CPL_STR_HASH("X")))RET STG::createNativeObject(Axis_funcs,(void *)0,EXT->Axis_typeID);
EI(keyStr.equals("Z", CPL_STR_HASH("Z")))RET STG::createNativeObject(Axis_funcs,(void *)2,EXT->Axis_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Axis");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(Axis___eq__);
EI(keyStr.equals("Y", CPL_STR_HASH("Y")))RET STG::createNativeObject(Axis_funcs,(void *)1,EXT->Axis_typeID);
EI(keyStr.equals("X", CPL_STR_HASH("X")))RET STG::createNativeObject(Axis_funcs,(void *)0,EXT->Axis_typeID);
EI(keyStr.equals("Z", CPL_STR_HASH("Z")))RET STG::createNativeObject(Axis_funcs,(void *)2,EXT->Axis_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void Axis_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV RigidBodyType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("RigidBodyType::__eq__")));
size_t f;
if(!TS(a[0],RigidBodyType))
CATE(TE,FAE("RigidBodyType::RigidBodyType","RigidBodyType")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],RigidBodyType))
CATE(VE,UFOF("RigidBodyType::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV RigidBodyType_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("RigidBodyType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(RigidBodyType___eq__);
EI(keyStr.equals("Dynamic", CPL_STR_HASH("Dynamic")))RET STG::createNativeObject(RigidBodyType_funcs,(void *)1,EXT->RigidBodyType_typeID);
EI(keyStr.equals("Static", CPL_STR_HASH("Static")))RET STG::createNativeObject(RigidBodyType_funcs,(void *)0,EXT->RigidBodyType_typeID);
EI(keyStr.equals("Kinematic", CPL_STR_HASH("Kinematic")))RET STG::createNativeObject(RigidBodyType_funcs,(void *)2,EXT->RigidBodyType_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("RigidBodyType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(RigidBodyType___eq__);
EI(keyStr.equals("Dynamic", CPL_STR_HASH("Dynamic")))RET STG::createNativeObject(RigidBodyType_funcs,(void *)1,EXT->RigidBodyType_typeID);
EI(keyStr.equals("Static", CPL_STR_HASH("Static")))RET STG::createNativeObject(RigidBodyType_funcs,(void *)0,EXT->RigidBodyType_typeID);
EI(keyStr.equals("Kinematic", CPL_STR_HASH("Kinematic")))RET STG::createNativeObject(RigidBodyType_funcs,(void *)2,EXT->RigidBodyType_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void RigidBodyType_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV PhysicsObjectType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("PhysicsObjectType::__eq__")));
size_t f;
if(!TS(a[0],PhysicsObjectType))
CATE(TE,FAE("PhysicsObjectType::PhysicsObjectType","PhysicsObjectType")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],PhysicsObjectType))
CATE(VE,UFOF("PhysicsObjectType::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV PhysicsObjectType_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("PhysicsObjectType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(PhysicsObjectType___eq__);
EI(keyStr.equals("Body", CPL_STR_HASH("Body")))RET STG::createNativeObject(PhysicsObjectType_funcs,(void *)0,EXT->PhysicsObjectType_typeID);
EI(keyStr.equals("Ghost", CPL_STR_HASH("Ghost")))RET STG::createNativeObject(PhysicsObjectType_funcs,(void *)1,EXT->PhysicsObjectType_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("PhysicsObjectType");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(PhysicsObjectType___eq__);
EI(keyStr.equals("Body", CPL_STR_HASH("Body")))RET STG::createNativeObject(PhysicsObjectType_funcs,(void *)0,EXT->PhysicsObjectType_typeID);
EI(keyStr.equals("Ghost", CPL_STR_HASH("Ghost")))RET STG::createNativeObject(PhysicsObjectType_funcs,(void *)1,EXT->PhysicsObjectType_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void PhysicsObjectType_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
SV RenderMode___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("RenderMode::__eq__")));
size_t f;
if(!TS(a[0],RenderMode))
CATE(TE,FAE("RenderMode::RenderMode","RenderMode")));
else
 f=(size_t)((NO)a[0].p)->data;
size_t other;
if(!TS(a[1],RenderMode))
CATE(VE,UFOF("RenderMode::__eq__")));
else
 other=(size_t)((NO)a[1].p)->data;
return STG::createBoolean(f == other);
}SV RenderMode_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("RenderMode");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(RenderMode___eq__);
EI(keyStr.equals("Nothing", CPL_STR_HASH("Nothing")))RET STG::createNativeObject(RenderMode_funcs,(void *)0,EXT->RenderMode_typeID);
EI(keyStr.equals("Model", CPL_STR_HASH("Model")))RET STG::createNativeObject(RenderMode_funcs,(void *)1,EXT->RenderMode_typeID);
EI(keyStr.equals("Overlay", CPL_STR_HASH("Overlay")))RET STG::createNativeObject(RenderMode_funcs,(void *)2,EXT->RenderMode_typeID);

else
 CATE(KE,"Unknown enum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("RenderMode");
EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(RenderMode___eq__);
EI(keyStr.equals("Nothing", CPL_STR_HASH("Nothing")))RET STG::createNativeObject(RenderMode_funcs,(void *)0,EXT->RenderMode_typeID);
EI(keyStr.equals("Model", CPL_STR_HASH("Model")))RET STG::createNativeObject(RenderMode_funcs,(void *)1,EXT->RenderMode_typeID);
EI(keyStr.equals("Overlay", CPL_STR_HASH("Overlay")))RET STG::createNativeObject(RenderMode_funcs,(void *)2,EXT->RenderMode_typeID);

else
 CATE(KE,"Unknown enum."));
}
}
}
void RenderMode_set_member(CTX ctx,const SV&,const SV&,const SV&){CATE(KE,"Enums are read-only."));}
void MCChunk_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,MCChunk))
CATE(TE,"MCChunk::__del__ expects MCChunk as first argument."));

SCRIPT_DELETE((MCChunk*)f->data);
}SV MCChunk_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCChunk's constructor" EAOE));
if(!TS(a[0],MCChunk))
CATE(TE,"MCChunk's constructor expects MCChunk as first argument."));
if(a.getCount()==2)
if(true&&TS(a[1],MCWorld *)){
void *p = (void *)NEW(TYPE(MCChunk),val_to_c<MCWorld *>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(MCChunk_funcs,p,EXT->MCChunk_typeID);
}CATE(TE,UFOF("MCChunk's constructor.")));
RET CN;
}

SV MCChunk_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("MCChunk");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(MCChunk_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(MCChunk_new);
else
 CATE(KE,"Unknown member for MCChunk."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(MCChunk_new);
 EI(keyStr.equals("updateMeshes", CPL_STR_HASH("updateMeshes")))
RET CNF(MCChunk_updateMeshes);
 EI(keyStr.equals("updateRigidBodies", CPL_STR_HASH("updateRigidBodies")))
RET CNF(MCChunk_updateRigidBodies);
 EI(keyStr.equals("getMesh", CPL_STR_HASH("getMesh")))
RET CNF(MCChunk_getMesh);
 EI(keyStr.equals("getCube", CPL_STR_HASH("getCube")))
RET CNF(MCChunk_getCube);
 EI(keyStr.equals("setCube", CPL_STR_HASH("setCube")))
RET CNF(MCChunk_setCube);
 EI(keyStr.equals("render", CPL_STR_HASH("render")))
RET CNF(MCChunk_render);
 EI(keyStr.equals("getData", CPL_STR_HASH("getData")))
RET CNF(MCChunk_getData);
 else
 CATE(KE,"Unknown member for MCChunk."));
}
}
RET CN;
}

void MCChunk_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for MCChunk."));
}
}
}

SV MCChunk_setCube(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCChunk::setCube" EAOE));
MCChunk*f;
f=(MCChunk*)((NO)a[0].p)->data;

if(a.getCount()==5)
if(1&&TS(a[1],int)&&TS(a[2],int)&&TS(a[3],int)&&TS(a[4],uint8_t))
{
( f->setCube(val_to_c<std::remove_reference<int>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[4])));
RET CN;
}
CATE(TE,UFOF("MCChunk::setCube.")));
RET CN;
}

SV MCChunk_render(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCChunk::render" EAOE));
MCChunk*f;
f=(MCChunk*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],GfxRenderer *)&&TS(a[2],const Matrix4x4 &))
{
( f->render(val_to_c<std::remove_reference<GfxRenderer *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Matrix4x4 &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("MCChunk::render.")));
RET CN;
}

SV MCChunk_updateRigidBodies(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCChunk::updateRigidBodies" EAOE));
MCChunk*f;
f=(MCChunk*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Matrix4x4 &))
{
( f->updateRigidBodies(val_to_c<std::remove_reference<const Matrix4x4 &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("MCChunk::updateRigidBodies.")));
RET CN;
}

SV MCChunk_getMesh(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCChunk::getMesh" EAOE));
MCChunk*f;
f=(MCChunk*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],uint8_t))
{
RET CV( f->getMesh(val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("MCChunk::getMesh.")));
RET CN;
}

SV MCChunk_updateMeshes(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCChunk::updateMeshes" EAOE));
MCChunk*f;
f=(MCChunk*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->updateMeshes());
RET CN;
}
CATE(TE,UFOF("MCChunk::updateMeshes.")));
RET CN;
}

SV MCChunk_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCChunk::getData" EAOE));
MCChunk*f;
f=(MCChunk*)((NO)a[0].p)->data;

CATE(TE,UFOF("MCChunk::getData.")));
RET CN;
}

SV MCChunk_getCube(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCChunk::getCube" EAOE));
MCChunk*f;
f=(MCChunk*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],int)&&TS(a[2],int)&&TS(a[3],int))
{
RET CV( f->getCube(val_to_c<std::remove_reference<int>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[3])));
;
}
CATE(TE,UFOF("MCChunk::getCube.")));
RET CN;
}

void GfxCompiledShader_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GfxCompiledShader))
CATE(TE,"GfxCompiledShader::__del__ expects GfxCompiledShader as first argument."));

SCRIPT_DELETE((GfxCompiledShader*)f->data);
}SV GfxCompiledShader_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxCompiledShader's constructor" EAOE));
if(!TS(a[0],GfxCompiledShader))
CATE(TE,"GfxCompiledShader's constructor expects GfxCompiledShader as first argument."));
CATE(TE,UFOF("GfxCompiledShader's constructor.")));
}

SV GfxCompiledShader_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxCompiledShader");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxCompiledShader_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxCompiledShader_new);
else
 CATE(KE,"Unknown member for GfxCompiledShader."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxCompiledShader_new);
 EI(keyStr.equals("getShader", CPL_STR_HASH("getShader")))
RET CNF(GfxCompiledShader_getShader);
 EI(keyStr.equals("getGLProgram", CPL_STR_HASH("getGLProgram")))
RET CNF(GfxCompiledShader_getGLProgram);
 EI(keyStr.equals("getGLShader", CPL_STR_HASH("getGLShader")))
RET CNF(GfxCompiledShader_getGLShader);
 else
 CATE(KE,"Unknown member for GfxCompiledShader."));
}
}
RET CN;
}

void GfxCompiledShader_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for GfxCompiledShader."));
}
}
}

SV GfxCompiledShader_getGLShader(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxCompiledShader::getGLShader" EAOE));
GfxCompiledShader*f;
f=(GfxCompiledShader*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGLShader());
;
}
CATE(TE,UFOF("GfxCompiledShader::getGLShader.")));
RET CN;
}

SV GfxCompiledShader_getShader(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxCompiledShader::getShader" EAOE));
GfxCompiledShader*f;
f=(GfxCompiledShader*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShader());
;
}
CATE(TE,UFOF("GfxCompiledShader::getShader.")));
RET CN;
}

SV GfxCompiledShader_getGLProgram(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxCompiledShader::getGLProgram" EAOE));
GfxCompiledShader*f;
f=(GfxCompiledShader*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGLProgram());
;
}
CATE(TE,UFOF("GfxCompiledShader::getGLProgram.")));
RET CN;
}

void RayCastResult_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,RayCastResult))
CATE(TE,"RayCastResult::__del__ expects RayCastResult as first argument."));

SCRIPT_DELETE((RayCastResult*)f->data);
}SV RayCastResult_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResult's constructor" EAOE));
if(!TS(a[0],RayCastResult))
CATE(TE,"RayCastResult's constructor expects RayCastResult as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(RayCastResult));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(RayCastResult_funcs,p,EXT->RayCastResult_typeID);
}CATE(TE,UFOF("RayCastResult's constructor.")));
RET CN;
}

SV RayCastResult_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("RayCastResult");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(RayCastResult_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(RayCastResult_new);
else
 CATE(KE,"Unknown member for RayCastResult."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(RayCastResult_new);
 EI(keyStr.equals("getRigidBody", CPL_STR_HASH("getRigidBody")))
RET CNF(RayCastResult_getRigidBody);
 EI(keyStr.equals("getGhost", CPL_STR_HASH("getGhost")))
RET CNF(RayCastResult_getGhost);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(RayCastResult___eq__);
 EI(keyStr.equals("distance", CPL_STR_HASH("distance")))
{
RayCastResult*obj=(RayCastResult*)f->data;
RET CV(obj->distance);
} EI(keyStr.equals("normal", CPL_STR_HASH("normal")))
{
RayCastResult*obj=(RayCastResult*)f->data;
RET CV(obj->normal);
} EI(keyStr.equals("objType", CPL_STR_HASH("objType")))
{
RayCastResult*obj=(RayCastResult*)f->data;
RET CV(obj->objType);
} else
 CATE(KE,"Unknown member for RayCastResult."));
}
}
RET CN;
}

void RayCastResult_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("distance", CPL_STR_HASH("distance")))
{
RayCastResult*obj=(RayCastResult*)f->data;
obj->distance=val_to_c<decltype(obj->distance)>::f(ctx,value);
} EI(keyStr.equals("normal", CPL_STR_HASH("normal")))
{
RayCastResult*obj=(RayCastResult*)f->data;
obj->normal=val_to_c<decltype(obj->normal)>::f(ctx,value);
} EI(keyStr.equals("objType", CPL_STR_HASH("objType")))
{
RayCastResult*obj=(RayCastResult*)f->data;
obj->objType=val_to_c<decltype(obj->objType)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for RayCastResult."));
}
}
}

SV RayCastResult_getRigidBody(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResult::getRigidBody" EAOE));
RayCastResult*f;
f=(RayCastResult*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRigidBody());
;
}
CATE(TE,UFOF("RayCastResult::getRigidBody.")));
RET CN;
}

SV RayCastResult___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResult::__eq__" EAOE));
RayCastResult*f;
f=(RayCastResult*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const RayCastResult &))
{
auto v=val_to_c<std::remove_reference<const RayCastResult &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("RayCastResult::__eq__.")));
RET CN;
}

SV RayCastResult_getGhost(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResult::getGhost" EAOE));
RayCastResult*f;
f=(RayCastResult*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGhost());
;
}
CATE(TE,UFOF("RayCastResult::getGhost.")));
RET CN;
}

void Entity_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Entity))
CATE(TE,"Entity::__del__ expects Entity as first argument."));

}SV Entity_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Entity's constructor" EAOE));
if(!TS(a[0],Entity))
CATE(TE,"Entity's constructor expects Entity as first argument."));
CATE(TE,UFOF("Entity's constructor.")));
}

SV Entity_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Entity");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Entity_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Entity_new);
else
 CATE(KE,"Unknown member for Entity."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Entity_new);
 EI(keyStr.equals("addScript", CPL_STR_HASH("addScript")))
RET CNF(Entity_addScript);
 EI(keyStr.equals("removeScript", CPL_STR_HASH("removeScript")))
RET CNF(Entity_removeScript);
 EI(keyStr.equals("getScripts", CPL_STR_HASH("getScripts")))
RET CNF(Entity_getScripts);
 EI(keyStr.equals("findScriptInstance", CPL_STR_HASH("findScriptInstance")))
RET CNF(Entity_findScriptInstance);
 EI(keyStr.equals("findScriptInstanceObj", CPL_STR_HASH("findScriptInstanceObj")))
RET CNF(Entity_findScriptInstanceObj);
 EI(keyStr.equals("addRigidBody", CPL_STR_HASH("addRigidBody")))
RET CNF(Entity_addRigidBody);
 EI(keyStr.equals("getRigidBody", CPL_STR_HASH("getRigidBody")))
RET CNF(Entity_getRigidBody);
 EI(keyStr.equals("removeRigidBody", CPL_STR_HASH("removeRigidBody")))
RET CNF(Entity_removeRigidBody);
 EI(keyStr.equals("hasRigidBody", CPL_STR_HASH("hasRigidBody")))
RET CNF(Entity_hasRigidBody);
 EI(keyStr.equals("addModel", CPL_STR_HASH("addModel")))
RET CNF(Entity_addModel);
 EI(keyStr.equals("addOverlay", CPL_STR_HASH("addOverlay")))
RET CNF(Entity_addOverlay);
 EI(keyStr.equals("removeRenderComponent", CPL_STR_HASH("removeRenderComponent")))
RET CNF(Entity_removeRenderComponent);
 EI(keyStr.equals("getRenderComponent", CPL_STR_HASH("getRenderComponent")))
RET CNF(Entity_getRenderComponent);
 EI(keyStr.equals("hasRenderComponent", CPL_STR_HASH("hasRenderComponent")))
RET CNF(Entity_hasRenderComponent);
 EI(keyStr.equals("getScene", CPL_STR_HASH("getScene")))
RET CNF(Entity_getScene);
 EI(keyStr.equals("createEntity", CPL_STR_HASH("createEntity")))
RET CNF(Entity_createEntity);
 EI(keyStr.equals("removeEntity", CPL_STR_HASH("removeEntity")))
RET CNF(Entity_removeEntity);
 EI(keyStr.equals("findEntity", CPL_STR_HASH("findEntity")))
RET CNF(Entity_findEntity);
 EI(keyStr.equals("getEntities", CPL_STR_HASH("getEntities")))
RET CNF(Entity_getEntities);
 EI(keyStr.equals("getParent", CPL_STR_HASH("getParent")))
RET CNF(Entity_getParent);
 EI(keyStr.equals("updateFinalTransform", CPL_STR_HASH("updateFinalTransform")))
RET CNF(Entity_updateFinalTransform);
 EI(keyStr.equals("getFinalTransform", CPL_STR_HASH("getFinalTransform")))
RET CNF(Entity_getFinalTransform);
 EI(keyStr.equals("getFinalTransformNoScale", CPL_STR_HASH("getFinalTransformNoScale")))
RET CNF(Entity_getFinalTransformNoScale);
 EI(keyStr.equals("getAudioSources", CPL_STR_HASH("getAudioSources")))
RET CNF(Entity_getAudioSources);
 EI(keyStr.equals("addAudioSource", CPL_STR_HASH("addAudioSource")))
RET CNF(Entity_addAudioSource);
 EI(keyStr.equals("removeAudioSource", CPL_STR_HASH("removeAudioSource")))
RET CNF(Entity_removeAudioSource);
 EI(keyStr.equals("name", CPL_STR_HASH("name")))
{
Entity*obj=(Entity*)f->data;
RET CV(obj->name);
} EI(keyStr.equals("transform", CPL_STR_HASH("transform")))
{
Entity*obj=(Entity*)f->data;
RET CV(obj->transform);
} else
 CATE(KE,"Unknown member for Entity."));
}
}
RET CN;
}

void Entity_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("name", CPL_STR_HASH("name")))
{
Entity*obj=(Entity*)f->data;
obj->name=val_to_c<decltype(obj->name)>::f(ctx,value);
} EI(keyStr.equals("transform", CPL_STR_HASH("transform")))
{
Entity*obj=(Entity*)f->data;
obj->transform=val_to_c<decltype(obj->transform)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for Entity."));
}
}
}

SV Entity_getFinalTransform(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::getFinalTransform" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFinalTransform());
;
}
CATE(TE,UFOF("Entity::getFinalTransform.")));
RET CN;
}

SV Entity_removeAudioSource(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::removeAudioSource" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->removeAudioSource(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Entity::removeAudioSource.")));
RET CN;
}

SV Entity_getAudioSources(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::getAudioSources" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAudioSources());
;
}
CATE(TE,UFOF("Entity::getAudioSources.")));
RET CN;
}

SV Entity_getRigidBody(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::getRigidBody" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRigidBody());
;
}
CATE(TE,UFOF("Entity::getRigidBody.")));
RET CN;
}

SV Entity_getFinalTransformNoScale(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::getFinalTransformNoScale" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFinalTransformNoScale());
;
}
CATE(TE,UFOF("Entity::getFinalTransformNoScale.")));
RET CN;
}

SV Entity_addOverlay(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::addOverlay" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxTexture *))
{
( f->addOverlay(val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Entity::addOverlay.")));
RET CN;
}

SV Entity_addRigidBody(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::addRigidBody" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],const RigidBodyConstructionInfo &)&&TS(a[2],PhysicsShape *))
{
RET CV( f->addRigidBody(val_to_c<std::remove_reference<const RigidBodyConstructionInfo &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<PhysicsShape *>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("Entity::addRigidBody.")));
RET CN;
}

SV Entity_removeScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::removeScript" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],ScriptInstance *))
{
( f->removeScript(val_to_c<std::remove_reference<ScriptInstance *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Entity::removeScript.")));
RET CN;
}

SV Entity_findEntity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::findEntity" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
RET CV( f->findEntity(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Entity::findEntity.")));
RET CN;
}

SV Entity_createEntity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::createEntity" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
RET CV( f->createEntity(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Entity::createEntity.")));
RET CN;
}

SV Entity_hasRigidBody(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::hasRigidBody" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->hasRigidBody());
;
}
CATE(TE,UFOF("Entity::hasRigidBody.")));
RET CN;
}

SV Entity_findScriptInstanceObj(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::findScriptInstanceObj" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
RET CV( f->findScriptInstanceObj(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Entity::findScriptInstanceObj.")));
RET CN;
}

SV Entity_updateFinalTransform(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::updateFinalTransform" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->updateFinalTransform());
RET CN;
}
CATE(TE,UFOF("Entity::updateFinalTransform.")));
RET CN;
}

SV Entity_removeRenderComponent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::removeRenderComponent" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeRenderComponent());
RET CN;
}
CATE(TE,UFOF("Entity::removeRenderComponent.")));
RET CN;
}

SV Entity_removeEntity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::removeEntity" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->removeEntity(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Entity::removeEntity.")));
RET CN;
}

SV Entity_removeRigidBody(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::removeRigidBody" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeRigidBody());
RET CN;
}
CATE(TE,UFOF("Entity::removeRigidBody.")));
RET CN;
}

SV Entity_findScriptInstance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::findScriptInstance" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
RET CV( f->findScriptInstance(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Entity::findScriptInstance.")));
RET CN;
}

SV Entity_addScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::addScript" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Script *))
{
RET CV( f->addScript(val_to_c<std::remove_reference<Script *>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Entity::addScript.")));
RET CN;
}

SV Entity_getEntities(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::getEntities" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getEntities());
;
}
CATE(TE,UFOF("Entity::getEntities.")));
RET CN;
}

SV Entity_hasRenderComponent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::hasRenderComponent" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->hasRenderComponent());
;
}
CATE(TE,UFOF("Entity::hasRenderComponent.")));
RET CN;
}

SV Entity_addAudioSource(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::addAudioSource" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Audio *))
{
RET CV( f->addAudioSource(val_to_c<std::remove_reference<Audio *>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Entity::addAudioSource.")));
RET CN;
}

SV Entity_getRenderComponent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::getRenderComponent" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRenderComponent());
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->getRenderComponent());
;
}
CATE(TE,UFOF("Entity::getRenderComponent.")));
RET CN;
}

SV Entity_addModel(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::addModel" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],GfxModel *)&&TS(a[2],bool))
{
( f->addModel(val_to_c<std::remove_reference<GfxModel *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<bool>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("Entity::addModel.")));
RET CN;
}

SV Entity_getParent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::getParent" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getParent());
;
}
CATE(TE,UFOF("Entity::getParent.")));
RET CN;
}

SV Entity_getScripts(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::getScripts" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScripts());
;
}
CATE(TE,UFOF("Entity::getScripts.")));
RET CN;
}

SV Entity_getScene(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::getScene" EAOE));
Entity*f;
f=(Entity*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScene());
;
}
CATE(TE,UFOF("Entity::getScene.")));
RET CN;
}

void Stats_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Stats))
CATE(TE,"Stats::__del__ expects Stats as first argument."));

SCRIPT_DELETE((Stats*)f->data);
}SV Stats_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Stats's constructor" EAOE));
if(!TS(a[0],Stats))
CATE(TE,"Stats's constructor expects Stats as first argument."));
RET STG::createNativeObject(Stats_funcs,NEW(TYPE(Stats)),EXT->Stats_typeID);
}

SV Stats_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Stats");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Stats_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Stats_new);
else
 CATE(KE,"Unknown member for Stats."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Stats_new);
 EI(keyStr.equals("handleInput", CPL_STR_HASH("handleInput")))
{
Stats*obj=(Stats*)f->data;
RET CV(obj->handleInput);
} EI(keyStr.equals("update", CPL_STR_HASH("update")))
{
Stats*obj=(Stats*)f->data;
RET CV(obj->update);
} EI(keyStr.equals("fixedUpdate", CPL_STR_HASH("fixedUpdate")))
{
Stats*obj=(Stats*)f->data;
RET CV(obj->fixedUpdate);
} EI(keyStr.equals("preRender", CPL_STR_HASH("preRender")))
{
Stats*obj=(Stats*)f->data;
RET CV(obj->preRender);
} EI(keyStr.equals("postRender", CPL_STR_HASH("postRender")))
{
Stats*obj=(Stats*)f->data;
RET CV(obj->postRender);
} EI(keyStr.equals("audio", CPL_STR_HASH("audio")))
{
Stats*obj=(Stats*)f->data;
RET CV(obj->audio);
} else
 CATE(KE,"Unknown member for Stats."));
}
}
RET CN;
}

void Stats_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("handleInput", CPL_STR_HASH("handleInput")))
{
Stats*obj=(Stats*)f->data;
obj->handleInput=val_to_c<decltype(obj->handleInput)>::f(ctx,value);
} EI(keyStr.equals("update", CPL_STR_HASH("update")))
{
Stats*obj=(Stats*)f->data;
obj->update=val_to_c<decltype(obj->update)>::f(ctx,value);
} EI(keyStr.equals("fixedUpdate", CPL_STR_HASH("fixedUpdate")))
{
Stats*obj=(Stats*)f->data;
obj->fixedUpdate=val_to_c<decltype(obj->fixedUpdate)>::f(ctx,value);
} EI(keyStr.equals("preRender", CPL_STR_HASH("preRender")))
{
Stats*obj=(Stats*)f->data;
obj->preRender=val_to_c<decltype(obj->preRender)>::f(ctx,value);
} EI(keyStr.equals("postRender", CPL_STR_HASH("postRender")))
{
Stats*obj=(Stats*)f->data;
obj->postRender=val_to_c<decltype(obj->postRender)>::f(ctx,value);
} EI(keyStr.equals("audio", CPL_STR_HASH("audio")))
{
Stats*obj=(Stats*)f->data;
obj->audio=val_to_c<decltype(obj->audio)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for Stats."));
}
}
}

void Camera_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Camera))
CATE(TE,"Camera::__del__ expects Camera as first argument."));

SCRIPT_DELETE((Camera*)f->data);
}SV Camera_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera's constructor" EAOE));
if(!TS(a[0],Camera))
CATE(TE,"Camera's constructor expects Camera as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(Camera));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Camera_funcs,p,EXT->Camera_typeID);
}CATE(TE,UFOF("Camera's constructor.")));
RET CN;
}

SV Camera_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Camera");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Camera_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Camera_new);
else
 CATE(KE,"Unknown member for Camera."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Camera_new);
 EI(keyStr.equals("setType", CPL_STR_HASH("setType")))
RET CNF(Camera_setType);
 EI(keyStr.equals("setPosition", CPL_STR_HASH("setPosition")))
RET CNF(Camera_setPosition);
 EI(keyStr.equals("setDirection", CPL_STR_HASH("setDirection")))
RET CNF(Camera_setDirection);
 EI(keyStr.equals("setUp", CPL_STR_HASH("setUp")))
RET CNF(Camera_setUp);
 EI(keyStr.equals("setWidth", CPL_STR_HASH("setWidth")))
RET CNF(Camera_setWidth);
 EI(keyStr.equals("setHeight", CPL_STR_HASH("setHeight")))
RET CNF(Camera_setHeight);
 EI(keyStr.equals("setFieldOfView", CPL_STR_HASH("setFieldOfView")))
RET CNF(Camera_setFieldOfView);
 EI(keyStr.equals("setLeft", CPL_STR_HASH("setLeft")))
RET CNF(Camera_setLeft);
 EI(keyStr.equals("setRight", CPL_STR_HASH("setRight")))
RET CNF(Camera_setRight);
 EI(keyStr.equals("setBottom", CPL_STR_HASH("setBottom")))
RET CNF(Camera_setBottom);
 EI(keyStr.equals("setTop", CPL_STR_HASH("setTop")))
RET CNF(Camera_setTop);
 EI(keyStr.equals("setNear", CPL_STR_HASH("setNear")))
RET CNF(Camera_setNear);
 EI(keyStr.equals("setFar", CPL_STR_HASH("setFar")))
RET CNF(Camera_setFar);
 EI(keyStr.equals("setViewMatrix", CPL_STR_HASH("setViewMatrix")))
RET CNF(Camera_setViewMatrix);
 EI(keyStr.equals("setProjectionMatrix", CPL_STR_HASH("setProjectionMatrix")))
RET CNF(Camera_setProjectionMatrix);
 EI(keyStr.equals("getType", CPL_STR_HASH("getType")))
RET CNF(Camera_getType);
 EI(keyStr.equals("getPosition", CPL_STR_HASH("getPosition")))
RET CNF(Camera_getPosition);
 EI(keyStr.equals("getDirection", CPL_STR_HASH("getDirection")))
RET CNF(Camera_getDirection);
 EI(keyStr.equals("getUp", CPL_STR_HASH("getUp")))
RET CNF(Camera_getUp);
 EI(keyStr.equals("getWidth", CPL_STR_HASH("getWidth")))
RET CNF(Camera_getWidth);
 EI(keyStr.equals("getHeight", CPL_STR_HASH("getHeight")))
RET CNF(Camera_getHeight);
 EI(keyStr.equals("getFieldOfView", CPL_STR_HASH("getFieldOfView")))
RET CNF(Camera_getFieldOfView);
 EI(keyStr.equals("getLeft", CPL_STR_HASH("getLeft")))
RET CNF(Camera_getLeft);
 EI(keyStr.equals("getRight", CPL_STR_HASH("getRight")))
RET CNF(Camera_getRight);
 EI(keyStr.equals("getBottom", CPL_STR_HASH("getBottom")))
RET CNF(Camera_getBottom);
 EI(keyStr.equals("getTop", CPL_STR_HASH("getTop")))
RET CNF(Camera_getTop);
 EI(keyStr.equals("getNear", CPL_STR_HASH("getNear")))
RET CNF(Camera_getNear);
 EI(keyStr.equals("getFar", CPL_STR_HASH("getFar")))
RET CNF(Camera_getFar);
 EI(keyStr.equals("getViewMatrix", CPL_STR_HASH("getViewMatrix")))
RET CNF(Camera_getViewMatrix);
 EI(keyStr.equals("getProjectionMatrix", CPL_STR_HASH("getProjectionMatrix")))
RET CNF(Camera_getProjectionMatrix);
 EI(keyStr.equals("getFrustum", CPL_STR_HASH("getFrustum")))
RET CNF(Camera_getFrustum);
 else
 CATE(KE,"Unknown member for Camera."));
}
}
RET CN;
}

void Camera_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for Camera."));
}
}
}

SV Camera_setBottom(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setBottom" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setBottom(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setBottom.")));
RET CN;
}

SV Camera_getRight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getRight" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRight());
;
}
CATE(TE,UFOF("Camera::getRight.")));
RET CN;
}

SV Camera_setTop(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setTop" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setTop(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setTop.")));
RET CN;
}

SV Camera_getWidth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getWidth" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWidth());
;
}
CATE(TE,UFOF("Camera::getWidth.")));
RET CN;
}

SV Camera_getDirection(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getDirection" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDirection());
;
}
CATE(TE,UFOF("Camera::getDirection.")));
RET CN;
}

SV Camera_getFieldOfView(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getFieldOfView" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFieldOfView());
;
}
CATE(TE,UFOF("Camera::getFieldOfView.")));
RET CN;
}

SV Camera_setWidth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setWidth" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setWidth(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setWidth.")));
RET CN;
}

SV Camera_setType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setType" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],CameraType))
{
( f->setType(val_to_c<std::remove_reference<CameraType>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setType.")));
RET CN;
}

SV Camera_setDirection(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setDirection" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Direction3D &))
{
( f->setDirection(val_to_c<std::remove_reference<const Direction3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setDirection.")));
RET CN;
}

SV Camera_getLeft(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getLeft" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getLeft());
;
}
CATE(TE,UFOF("Camera::getLeft.")));
RET CN;
}

SV Camera_getProjectionMatrix(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getProjectionMatrix" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getProjectionMatrix());
;
}
CATE(TE,UFOF("Camera::getProjectionMatrix.")));
RET CN;
}

SV Camera_getHeight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getHeight" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getHeight());
;
}
CATE(TE,UFOF("Camera::getHeight.")));
RET CN;
}

SV Camera_setFar(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setFar" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setFar(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setFar.")));
RET CN;
}

SV Camera_setFieldOfView(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setFieldOfView" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setFieldOfView(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setFieldOfView.")));
RET CN;
}

SV Camera_getTop(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getTop" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getTop());
;
}
CATE(TE,UFOF("Camera::getTop.")));
RET CN;
}

SV Camera_getBottom(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getBottom" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBottom());
;
}
CATE(TE,UFOF("Camera::getBottom.")));
RET CN;
}

SV Camera_getFar(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getFar" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFar());
;
}
CATE(TE,UFOF("Camera::getFar.")));
RET CN;
}

SV Camera_setUp(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setUp" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Direction3D &))
{
( f->setUp(val_to_c<std::remove_reference<const Direction3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setUp.")));
RET CN;
}

SV Camera_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getType" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("Camera::getType.")));
RET CN;
}

SV Camera_setProjectionMatrix(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setProjectionMatrix" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Matrix4x4 &))
{
( f->setProjectionMatrix(val_to_c<std::remove_reference<const Matrix4x4 &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setProjectionMatrix.")));
RET CN;
}

SV Camera_setNear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setNear" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setNear(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setNear.")));
RET CN;
}

SV Camera_setPosition(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setPosition" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Position3D &))
{
( f->setPosition(val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setPosition.")));
RET CN;
}

SV Camera_setLeft(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setLeft" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setLeft(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setLeft.")));
RET CN;
}

SV Camera_getPosition(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getPosition" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getPosition());
;
}
CATE(TE,UFOF("Camera::getPosition.")));
RET CN;
}

SV Camera_setHeight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setHeight" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setHeight(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setHeight.")));
RET CN;
}

SV Camera_setViewMatrix(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setViewMatrix" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Matrix4x4 &))
{
( f->setViewMatrix(val_to_c<std::remove_reference<const Matrix4x4 &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setViewMatrix.")));
RET CN;
}

SV Camera_getViewMatrix(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getViewMatrix" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getViewMatrix());
;
}
CATE(TE,UFOF("Camera::getViewMatrix.")));
RET CN;
}

SV Camera_getNear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getNear" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getNear());
;
}
CATE(TE,UFOF("Camera::getNear.")));
RET CN;
}

SV Camera_setRight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setRight" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setRight(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setRight.")));
RET CN;
}

SV Camera_getFrustum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getFrustum" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFrustum());
;
}
CATE(TE,UFOF("Camera::getFrustum.")));
RET CN;
}

SV Camera_getUp(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getUp" EAOE));
Camera*f;
f=(Camera*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getUp());
;
}
CATE(TE,UFOF("Camera::getUp.")));
RET CN;
}

void EntityList_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,List<Entity*>))
CATE(TE,"EntityList::__del__ expects EntityList as first argument."));

SCRIPT_DELETE((List<Entity*>*)f->data);
}SV EntityList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList's constructor" EAOE));
if(!TS(a[0],List<Entity*>))
CATE(TE,"EntityList's constructor expects EntityList as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(List<Entity*>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(EntityList_funcs,p,EXT->EntityList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],std::size_t)){
void *p = (void *)NEW(TYPE(List<Entity*>),val_to_c<std::size_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(EntityList_funcs,p,EXT->EntityList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const List<Entity*> &)){
void *p = (void *)NEW(TYPE(List<Entity*>),val_to_c<const List<Entity*> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(EntityList_funcs,p,EXT->EntityList_typeID);
}CATE(TE,UFOF("EntityList's constructor.")));
RET CN;
}

SV EntityList_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("EntityList");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(EntityList_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(EntityList_new);
else
 CATE(KE,"Unknown member for EntityList."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(EntityList_new);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(EntityList___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(EntityList___neq__);
 EI(keyStr.equals("get", CPL_STR_HASH("get")))
RET CNF(EntityList_get);
 EI(keyStr.equals("set", CPL_STR_HASH("set")))
RET CNF(EntityList_set);
 EI(keyStr.equals("getCount", CPL_STR_HASH("getCount")))
RET CNF(EntityList_getCount);
 EI(keyStr.equals("getData", CPL_STR_HASH("getData")))
RET CNF(EntityList_getData);
 EI(keyStr.equals("append", CPL_STR_HASH("append")))
RET CNF(EntityList_append);
 EI(keyStr.equals("insert", CPL_STR_HASH("insert")))
RET CNF(EntityList_insert);
 EI(keyStr.equals("remove", CPL_STR_HASH("remove")))
RET CNF(EntityList_remove);
 EI(keyStr.equals("clear", CPL_STR_HASH("clear")))
RET CNF(EntityList_clear);
 EI(keyStr.equals("find", CPL_STR_HASH("find")))
RET CNF(EntityList_find);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(EntityList_copy);
 EI(keyStr.equals("in", CPL_STR_HASH("in")))
RET CNF(EntityList_in);
 EI(keyStr.equals("reserve", CPL_STR_HASH("reserve")))
RET CNF(EntityList_reserve);
 EI(keyStr.equals("begin", CPL_STR_HASH("begin")))
RET CNF(EntityList_begin);
 EI(keyStr.equals("end", CPL_STR_HASH("end")))
RET CNF(EntityList_end);
 else
 CATE(KE,"Unknown member for EntityList."));
}
}
RET CN;
}

void EntityList_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for EntityList."));
}
}
}

SV EntityList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::insert" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],Entity*))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<Entity*>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<Entity*> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<Entity*> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("EntityList::insert.")));
RET CN;
}

SV EntityList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::begin" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("EntityList::begin.")));
RET CN;
}

SV EntityList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::set" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],Entity*))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<Entity*>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("EntityList::set.")));
RET CN;
}

SV EntityList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::end" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("EntityList::end.")));
RET CN;
}

SV EntityList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::get" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("EntityList::get.")));
RET CN;
}

SV EntityList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::clear" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("EntityList::clear.")));
RET CN;
}

SV EntityList_reserve(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::reserve" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->reserve(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("EntityList::reserve.")));
RET CN;
}

SV EntityList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::copy" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("EntityList::copy.")));
RET CN;
}

SV EntityList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::remove" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("EntityList::remove.")));
RET CN;
}

SV EntityList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::in" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Entity*))
{
RET CV( f->in(val_to_c<std::remove_reference<Entity*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("EntityList::in.")));
RET CN;
}

SV EntityList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::getCount" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("EntityList::getCount.")));
RET CN;
}

SV EntityList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::getData" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("EntityList::getData.")));
RET CN;
}

SV EntityList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::__eq__" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<Entity*> &))
{
auto v=val_to_c<std::remove_reference<const List<Entity*> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("EntityList::__eq__.")));
RET CN;
}

SV EntityList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::find" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Entity*))
{
RET CV( f->find(val_to_c<std::remove_reference<Entity*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("EntityList::find.")));
RET CN;
}

SV EntityList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::append" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Entity*))
{
( f->append(val_to_c<std::remove_reference<Entity*>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<Entity*> &))
{
( f->append(val_to_c<std::remove_reference<const List<Entity*> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("EntityList::append.")));
RET CN;
}

SV EntityList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::__neq__" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<Entity*> &))
{
auto v=val_to_c<std::remove_reference<const List<Entity*> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("EntityList::__neq__.")));
RET CN;
}

void Light_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Light))
CATE(TE,"Light::__del__ expects Light as first argument."));

SCRIPT_DELETE((Light*)f->data);
}SV Light_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light's constructor" EAOE));
if(!TS(a[0],Light))
CATE(TE,"Light's constructor expects Light as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(Light));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Light_funcs,p,EXT->Light_typeID);
}CATE(TE,UFOF("Light's constructor.")));
RET CN;
}

SV Light_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Light");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Light_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Light_new);
else
 CATE(KE,"Unknown member for Light."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Light_new);
 EI(keyStr.equals("addShadowmap", CPL_STR_HASH("addShadowmap")))
RET CNF(Light_addShadowmap);
 EI(keyStr.equals("removeShadowmap", CPL_STR_HASH("removeShadowmap")))
RET CNF(Light_removeShadowmap);
 EI(keyStr.equals("getShadowmap", CPL_STR_HASH("getShadowmap")))
RET CNF(Light_getShadowmap);
 EI(keyStr.equals("getFramebuffers", CPL_STR_HASH("getFramebuffers")))
RET CNF(Light_getFramebuffers);
 EI(keyStr.equals("getShadowmapResolution", CPL_STR_HASH("getShadowmapResolution")))
RET CNF(Light_getShadowmapResolution);
 EI(keyStr.equals("getShadowmapPrecision", CPL_STR_HASH("getShadowmapPrecision")))
RET CNF(Light_getShadowmapPrecision);
 EI(keyStr.equals("getPointLightInfluence", CPL_STR_HASH("getPointLightInfluence")))
RET CNF(Light_getPointLightInfluence);
 EI(keyStr.equals("getSpotLightInfluence", CPL_STR_HASH("getSpotLightInfluence")))
RET CNF(Light_getSpotLightInfluence);
 EI(keyStr.equals("updateMatrices", CPL_STR_HASH("updateMatrices")))
RET CNF(Light_updateMatrices);
 EI(keyStr.equals("getViewMatrix", CPL_STR_HASH("getViewMatrix")))
RET CNF(Light_getViewMatrix);
 EI(keyStr.equals("getProjectionMatrix", CPL_STR_HASH("getProjectionMatrix")))
RET CNF(Light_getProjectionMatrix);
 EI(keyStr.equals("getCascadeViewMatrix", CPL_STR_HASH("getCascadeViewMatrix")))
RET CNF(Light_getCascadeViewMatrix);
 EI(keyStr.equals("getCascadeProjectionMatrix", CPL_STR_HASH("getCascadeProjectionMatrix")))
RET CNF(Light_getCascadeProjectionMatrix);
 EI(keyStr.equals("type", CPL_STR_HASH("type")))
{
Light*obj=(Light*)f->data;
RET CV(obj->type);
} EI(keyStr.equals("power", CPL_STR_HASH("power")))
{
Light*obj=(Light*)f->data;
RET CV(obj->power);
} EI(keyStr.equals("color", CPL_STR_HASH("color")))
{
Light*obj=(Light*)f->data;
RET CV(obj->color);
} EI(keyStr.equals("ambientStrength", CPL_STR_HASH("ambientStrength")))
{
Light*obj=(Light*)f->data;
RET CV(obj->ambientStrength);
} EI(keyStr.equals("shadowmapNear", CPL_STR_HASH("shadowmapNear")))
{
Light*obj=(Light*)f->data;
RET CV(obj->shadowmapNear);
} EI(keyStr.equals("shadowMinBias", CPL_STR_HASH("shadowMinBias")))
{
Light*obj=(Light*)f->data;
RET CV(obj->shadowMinBias);
} EI(keyStr.equals("shadowBiasScale", CPL_STR_HASH("shadowBiasScale")))
{
Light*obj=(Light*)f->data;
RET CV(obj->shadowBiasScale);
} EI(keyStr.equals("shadowAutoBiasScale", CPL_STR_HASH("shadowAutoBiasScale")))
{
Light*obj=(Light*)f->data;
RET CV(obj->shadowAutoBiasScale);
} EI(keyStr.equals("shadowFixedBias", CPL_STR_HASH("shadowFixedBias")))
{
Light*obj=(Light*)f->data;
RET CV(obj->shadowFixedBias);
} EI(keyStr.equals("shadowRadius", CPL_STR_HASH("shadowRadius")))
{
Light*obj=(Light*)f->data;
RET CV(obj->shadowRadius);
} EI(keyStr.equals("shadowSplitDistances", CPL_STR_HASH("shadowSplitDistances")))
{
Light*obj=(Light*)f->data;
RET CV(obj->shadowSplitDistances);
} EI(keyStr.equals("direction", CPL_STR_HASH("direction")))
{
Light*obj=(Light*)f->data;
RET CV(obj->direction);
} EI(keyStr.equals("spot", CPL_STR_HASH("spot")))
{
Light*obj=(Light*)f->data;
RET CV(obj->spot);
} EI(keyStr.equals("point", CPL_STR_HASH("point")))
{
Light*obj=(Light*)f->data;
RET CV(obj->point);
} else
 CATE(KE,"Unknown member for Light."));
}
}
RET CN;
}

void Light_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("type", CPL_STR_HASH("type")))
{
Light*obj=(Light*)f->data;
obj->type=val_to_c<decltype(obj->type)>::f(ctx,value);
} EI(keyStr.equals("power", CPL_STR_HASH("power")))
{
Light*obj=(Light*)f->data;
obj->power=val_to_c<decltype(obj->power)>::f(ctx,value);
} EI(keyStr.equals("color", CPL_STR_HASH("color")))
{
Light*obj=(Light*)f->data;
obj->color=val_to_c<decltype(obj->color)>::f(ctx,value);
} EI(keyStr.equals("ambientStrength", CPL_STR_HASH("ambientStrength")))
{
Light*obj=(Light*)f->data;
obj->ambientStrength=val_to_c<decltype(obj->ambientStrength)>::f(ctx,value);
} EI(keyStr.equals("shadowmapNear", CPL_STR_HASH("shadowmapNear")))
{
Light*obj=(Light*)f->data;
obj->shadowmapNear=val_to_c<decltype(obj->shadowmapNear)>::f(ctx,value);
} EI(keyStr.equals("shadowMinBias", CPL_STR_HASH("shadowMinBias")))
{
Light*obj=(Light*)f->data;
obj->shadowMinBias=val_to_c<decltype(obj->shadowMinBias)>::f(ctx,value);
} EI(keyStr.equals("shadowBiasScale", CPL_STR_HASH("shadowBiasScale")))
{
Light*obj=(Light*)f->data;
obj->shadowBiasScale=val_to_c<decltype(obj->shadowBiasScale)>::f(ctx,value);
} EI(keyStr.equals("shadowAutoBiasScale", CPL_STR_HASH("shadowAutoBiasScale")))
{
Light*obj=(Light*)f->data;
obj->shadowAutoBiasScale=val_to_c<decltype(obj->shadowAutoBiasScale)>::f(ctx,value);
} EI(keyStr.equals("shadowFixedBias", CPL_STR_HASH("shadowFixedBias")))
{
Light*obj=(Light*)f->data;
obj->shadowFixedBias=val_to_c<decltype(obj->shadowFixedBias)>::f(ctx,value);
} EI(keyStr.equals("shadowRadius", CPL_STR_HASH("shadowRadius")))
{
Light*obj=(Light*)f->data;
obj->shadowRadius=val_to_c<decltype(obj->shadowRadius)>::f(ctx,value);
} EI(keyStr.equals("shadowSplitDistances", CPL_STR_HASH("shadowSplitDistances")))
{
Light*obj=(Light*)f->data;
obj->shadowSplitDistances=val_to_c<decltype(obj->shadowSplitDistances)>::f(ctx,value);
} EI(keyStr.equals("direction", CPL_STR_HASH("direction")))
{
Light*obj=(Light*)f->data;
obj->direction=val_to_c<decltype(obj->direction)>::f(ctx,value);
} EI(keyStr.equals("spot", CPL_STR_HASH("spot")))
{
Light*obj=(Light*)f->data;
obj->spot=val_to_c<decltype(obj->spot)>::f(ctx,value);
} EI(keyStr.equals("point", CPL_STR_HASH("point")))
{
Light*obj=(Light*)f->data;
obj->point=val_to_c<decltype(obj->point)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for Light."));
}
}
}

SV Light_getShadowmapResolution(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getShadowmapResolution" EAOE));
Light*f;
f=(Light*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShadowmapResolution());
;
}
CATE(TE,UFOF("Light::getShadowmapResolution.")));
RET CN;
}

SV Light_getPointLightInfluence(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getPointLightInfluence" EAOE));
Light*f;
f=(Light*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->getPointLightInfluence(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Light::getPointLightInfluence.")));
RET CN;
}

SV Light_getShadowmap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getShadowmap" EAOE));
Light*f;
f=(Light*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShadowmap());
;
}
CATE(TE,UFOF("Light::getShadowmap.")));
RET CN;
}

SV Light_getSpotLightInfluence(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getSpotLightInfluence" EAOE));
Light*f;
f=(Light*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->getSpotLightInfluence(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Light::getSpotLightInfluence.")));
RET CN;
}

SV Light_getShadowmapPrecision(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getShadowmapPrecision" EAOE));
Light*f;
f=(Light*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShadowmapPrecision());
;
}
CATE(TE,UFOF("Light::getShadowmapPrecision.")));
RET CN;
}

SV Light_getProjectionMatrix(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getProjectionMatrix" EAOE));
Light*f;
f=(Light*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getProjectionMatrix());
;
}
CATE(TE,UFOF("Light::getProjectionMatrix.")));
RET CN;
}

SV Light_addShadowmap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::addShadowmap" EAOE));
Light*f;
f=(Light*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],GfxShadowmapPrecision))
{
( f->addShadowmap(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxShadowmapPrecision>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("Light::addShadowmap.")));
RET CN;
}

SV Light_getCascadeProjectionMatrix(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getCascadeProjectionMatrix" EAOE));
Light*f;
f=(Light*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getCascadeProjectionMatrix(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Light::getCascadeProjectionMatrix.")));
RET CN;
}

SV Light_getFramebuffers(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getFramebuffers" EAOE));
Light*f;
f=(Light*)((NO)a[0].p)->data;

CATE(TE,UFOF("Light::getFramebuffers.")));
RET CN;
}

SV Light_updateMatrices(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::updateMatrices" EAOE));
Light*f;
f=(Light*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxRenderer *))
{
( f->updateMatrices(val_to_c<std::remove_reference<GfxRenderer *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Light::updateMatrices.")));
RET CN;
}

SV Light_removeShadowmap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::removeShadowmap" EAOE));
Light*f;
f=(Light*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeShadowmap());
RET CN;
}
CATE(TE,UFOF("Light::removeShadowmap.")));
RET CN;
}

SV Light_getCascadeViewMatrix(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getCascadeViewMatrix" EAOE));
Light*f;
f=(Light*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getCascadeViewMatrix(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Light::getCascadeViewMatrix.")));
RET CN;
}

SV Light_getViewMatrix(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getViewMatrix" EAOE));
Light*f;
f=(Light*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getViewMatrix());
;
}
CATE(TE,UFOF("Light::getViewMatrix.")));
RET CN;
}

void TextureSampler_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,TextureSampler))
CATE(TE,"TextureSampler::__del__ expects TextureSampler as first argument."));

SCRIPT_DELETE((TextureSampler*)f->data);
}SV TextureSampler_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"TextureSampler's constructor" EAOE));
if(!TS(a[0],TextureSampler))
CATE(TE,"TextureSampler's constructor expects TextureSampler as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(TextureSampler));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(TextureSampler_funcs,p,EXT->TextureSampler_typeID);
}if(a.getCount()==7)
if(true&&TS(a[1],float)&&TS(a[2],GfxFilter)&&TS(a[3],GfxFilter)&&TS(a[4],GfxMipmapMode)&&TS(a[5],GfxWrapMode)&&TS(a[6],bool)){
void *p = (void *)NEW(TYPE(TextureSampler),val_to_c<float>::f(ctx,a[1]),val_to_c<GfxFilter>::f(ctx,a[2]),val_to_c<GfxFilter>::f(ctx,a[3]),val_to_c<GfxMipmapMode>::f(ctx,a[4]),val_to_c<GfxWrapMode>::f(ctx,a[5]),val_to_c<bool>::f(ctx,a[6]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(TextureSampler_funcs,p,EXT->TextureSampler_typeID);
}CATE(TE,UFOF("TextureSampler's constructor.")));
RET CN;
}

SV TextureSampler_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("TextureSampler");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(TextureSampler_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(TextureSampler_new);
else
 CATE(KE,"Unknown member for TextureSampler."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(TextureSampler_new);
 EI(keyStr.equals("createShadowmap", CPL_STR_HASH("createShadowmap")))
RET CNF(TextureSampler_createShadowmap);
 EI(keyStr.equals("maxAnisotropy", CPL_STR_HASH("maxAnisotropy")))
{
TextureSampler*obj=(TextureSampler*)f->data;
RET CV(obj->maxAnisotropy);
} EI(keyStr.equals("minFilter", CPL_STR_HASH("minFilter")))
{
TextureSampler*obj=(TextureSampler*)f->data;
RET CV(obj->minFilter);
} EI(keyStr.equals("magFilter", CPL_STR_HASH("magFilter")))
{
TextureSampler*obj=(TextureSampler*)f->data;
RET CV(obj->magFilter);
} EI(keyStr.equals("mipmapMode", CPL_STR_HASH("mipmapMode")))
{
TextureSampler*obj=(TextureSampler*)f->data;
RET CV(obj->mipmapMode);
} EI(keyStr.equals("wrapMode", CPL_STR_HASH("wrapMode")))
{
TextureSampler*obj=(TextureSampler*)f->data;
RET CV(obj->wrapMode);
} EI(keyStr.equals("shadowmap", CPL_STR_HASH("shadowmap")))
{
TextureSampler*obj=(TextureSampler*)f->data;
RET CV(obj->shadowmap);
} else
 CATE(KE,"Unknown member for TextureSampler."));
}
}
RET CN;
}

void TextureSampler_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("maxAnisotropy", CPL_STR_HASH("maxAnisotropy")))
{
TextureSampler*obj=(TextureSampler*)f->data;
obj->maxAnisotropy=val_to_c<decltype(obj->maxAnisotropy)>::f(ctx,value);
} EI(keyStr.equals("minFilter", CPL_STR_HASH("minFilter")))
{
TextureSampler*obj=(TextureSampler*)f->data;
obj->minFilter=val_to_c<decltype(obj->minFilter)>::f(ctx,value);
} EI(keyStr.equals("magFilter", CPL_STR_HASH("magFilter")))
{
TextureSampler*obj=(TextureSampler*)f->data;
obj->magFilter=val_to_c<decltype(obj->magFilter)>::f(ctx,value);
} EI(keyStr.equals("mipmapMode", CPL_STR_HASH("mipmapMode")))
{
TextureSampler*obj=(TextureSampler*)f->data;
obj->mipmapMode=val_to_c<decltype(obj->mipmapMode)>::f(ctx,value);
} EI(keyStr.equals("wrapMode", CPL_STR_HASH("wrapMode")))
{
TextureSampler*obj=(TextureSampler*)f->data;
obj->wrapMode=val_to_c<decltype(obj->wrapMode)>::f(ctx,value);
} EI(keyStr.equals("shadowmap", CPL_STR_HASH("shadowmap")))
{
TextureSampler*obj=(TextureSampler*)f->data;
obj->shadowmap=val_to_c<decltype(obj->shadowmap)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for TextureSampler."));
}
}
}

SV TextureSampler_createShadowmap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"TextureSampler::createShadowmap" EAOE));
TextureSampler*f;
f=(TextureSampler*)((NO)a[0].p)->data;

CATE(TE,UFOF("TextureSampler::createShadowmap.")));
RET CN;
}

void GhostObject_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GhostObject))
CATE(TE,"GhostObject::__del__ expects GhostObject as first argument."));

}SV GhostObject_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GhostObject's constructor" EAOE));
if(!TS(a[0],GhostObject))
CATE(TE,"GhostObject's constructor expects GhostObject as first argument."));
CATE(TE,UFOF("GhostObject's constructor.")));
}

SV GhostObject_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GhostObject");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GhostObject_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GhostObject_new);
else
 CATE(KE,"Unknown member for GhostObject."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GhostObject_new);
 EI(keyStr.equals("getBulletGhostObject", CPL_STR_HASH("getBulletGhostObject")))
RET CNF(GhostObject_getBulletGhostObject);
 EI(keyStr.equals("getTransform", CPL_STR_HASH("getTransform")))
RET CNF(GhostObject_getTransform);
 EI(keyStr.equals("setTransform", CPL_STR_HASH("setTransform")))
RET CNF(GhostObject_setTransform);
 EI(keyStr.equals("getWorld", CPL_STR_HASH("getWorld")))
RET CNF(GhostObject_getWorld);
 EI(keyStr.equals("getCollisionMask", CPL_STR_HASH("getCollisionMask")))
RET CNF(GhostObject_getCollisionMask);
 EI(keyStr.equals("setShape", CPL_STR_HASH("setShape")))
RET CNF(GhostObject_setShape);
 EI(keyStr.equals("getCollisions", CPL_STR_HASH("getCollisions")))
RET CNF(GhostObject_getCollisions);
 EI(keyStr.equals("getRigidBodyCollisions", CPL_STR_HASH("getRigidBodyCollisions")))
RET CNF(GhostObject_getRigidBodyCollisions);
 EI(keyStr.equals("getGhostCollisions", CPL_STR_HASH("getGhostCollisions")))
RET CNF(GhostObject_getGhostCollisions);
 EI(keyStr.equals("getShape", CPL_STR_HASH("getShape")))
RET CNF(GhostObject_getShape);
 else
 CATE(KE,"Unknown member for GhostObject."));
}
}
RET CN;
}

void GhostObject_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for GhostObject."));
}
}
}

SV GhostObject_getTransform(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::getTransform" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getTransform());
;
}
CATE(TE,UFOF("GhostObject::getTransform.")));
RET CN;
}

SV GhostObject_setTransform(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::setTransform" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Transform &))
{
( f->setTransform(val_to_c<std::remove_reference<const Transform &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GhostObject::setTransform.")));
RET CN;
}

SV GhostObject_getGhostCollisions(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::getGhostCollisions" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGhostCollisions());
;
}
CATE(TE,UFOF("GhostObject::getGhostCollisions.")));
RET CN;
}

SV GhostObject_getCollisions(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::getCollisions" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0].p)->data;

CATE(TE,UFOF("GhostObject::getCollisions.")));
RET CN;
}

SV GhostObject_getBulletGhostObject(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::getBulletGhostObject" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0].p)->data;

CATE(TE,UFOF("GhostObject::getBulletGhostObject.")));
RET CN;
}

SV GhostObject_getWorld(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::getWorld" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWorld());
;
}
CATE(TE,UFOF("GhostObject::getWorld.")));
RET CN;
}

SV GhostObject_getShape(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::getShape" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShape());
;
}
CATE(TE,UFOF("GhostObject::getShape.")));
RET CN;
}

SV GhostObject_getRigidBodyCollisions(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::getRigidBodyCollisions" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRigidBodyCollisions());
;
}
CATE(TE,UFOF("GhostObject::getRigidBodyCollisions.")));
RET CN;
}

SV GhostObject_getCollisionMask(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::getCollisionMask" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCollisionMask());
;
}
CATE(TE,UFOF("GhostObject::getCollisionMask.")));
RET CN;
}

SV GhostObject_setShape(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::setShape" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],PhysicsShape *))
{
( f->setShape(val_to_c<std::remove_reference<PhysicsShape *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GhostObject::setShape.")));
RET CN;
}

void RayCastResultList_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,List<RayCastResult>))
CATE(TE,"RayCastResultList::__del__ expects RayCastResultList as first argument."));

SCRIPT_DELETE((List<RayCastResult>*)f->data);
}SV RayCastResultList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList's constructor" EAOE));
if(!TS(a[0],List<RayCastResult>))
CATE(TE,"RayCastResultList's constructor expects RayCastResultList as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(List<RayCastResult>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(RayCastResultList_funcs,p,EXT->RayCastResultList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],std::size_t)){
void *p = (void *)NEW(TYPE(List<RayCastResult>),val_to_c<std::size_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(RayCastResultList_funcs,p,EXT->RayCastResultList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const List<RayCastResult> &)){
void *p = (void *)NEW(TYPE(List<RayCastResult>),val_to_c<const List<RayCastResult> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(RayCastResultList_funcs,p,EXT->RayCastResultList_typeID);
}CATE(TE,UFOF("RayCastResultList's constructor.")));
RET CN;
}

SV RayCastResultList_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("RayCastResultList");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(RayCastResultList_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(RayCastResultList_new);
else
 CATE(KE,"Unknown member for RayCastResultList."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(RayCastResultList_new);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(RayCastResultList___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(RayCastResultList___neq__);
 EI(keyStr.equals("get", CPL_STR_HASH("get")))
RET CNF(RayCastResultList_get);
 EI(keyStr.equals("set", CPL_STR_HASH("set")))
RET CNF(RayCastResultList_set);
 EI(keyStr.equals("getCount", CPL_STR_HASH("getCount")))
RET CNF(RayCastResultList_getCount);
 EI(keyStr.equals("getData", CPL_STR_HASH("getData")))
RET CNF(RayCastResultList_getData);
 EI(keyStr.equals("append", CPL_STR_HASH("append")))
RET CNF(RayCastResultList_append);
 EI(keyStr.equals("insert", CPL_STR_HASH("insert")))
RET CNF(RayCastResultList_insert);
 EI(keyStr.equals("remove", CPL_STR_HASH("remove")))
RET CNF(RayCastResultList_remove);
 EI(keyStr.equals("clear", CPL_STR_HASH("clear")))
RET CNF(RayCastResultList_clear);
 EI(keyStr.equals("find", CPL_STR_HASH("find")))
RET CNF(RayCastResultList_find);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(RayCastResultList_copy);
 EI(keyStr.equals("in", CPL_STR_HASH("in")))
RET CNF(RayCastResultList_in);
 EI(keyStr.equals("reserve", CPL_STR_HASH("reserve")))
RET CNF(RayCastResultList_reserve);
 EI(keyStr.equals("begin", CPL_STR_HASH("begin")))
RET CNF(RayCastResultList_begin);
 EI(keyStr.equals("end", CPL_STR_HASH("end")))
RET CNF(RayCastResultList_end);
 else
 CATE(KE,"Unknown member for RayCastResultList."));
}
}
RET CN;
}

void RayCastResultList_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for RayCastResultList."));
}
}
}

SV RayCastResultList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::insert" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],RayCastResult))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<RayCastResult>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<RayCastResult> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<RayCastResult> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("RayCastResultList::insert.")));
RET CN;
}

SV RayCastResultList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::begin" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0].p)->data;

CATE(TE,UFOF("RayCastResultList::begin.")));
RET CN;
}

SV RayCastResultList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::set" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],RayCastResult))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<RayCastResult>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("RayCastResultList::set.")));
RET CN;
}

SV RayCastResultList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::end" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0].p)->data;

CATE(TE,UFOF("RayCastResultList::end.")));
RET CN;
}

SV RayCastResultList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::get" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("RayCastResultList::get.")));
RET CN;
}

SV RayCastResultList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::clear" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("RayCastResultList::clear.")));
RET CN;
}

SV RayCastResultList_reserve(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::reserve" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->reserve(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RayCastResultList::reserve.")));
RET CN;
}

SV RayCastResultList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::copy" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("RayCastResultList::copy.")));
RET CN;
}

SV RayCastResultList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::remove" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("RayCastResultList::remove.")));
RET CN;
}

SV RayCastResultList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::in" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],RayCastResult))
{
RET CV( f->in(val_to_c<std::remove_reference<RayCastResult>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("RayCastResultList::in.")));
RET CN;
}

SV RayCastResultList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::getCount" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("RayCastResultList::getCount.")));
RET CN;
}

SV RayCastResultList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::getData" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0].p)->data;

CATE(TE,UFOF("RayCastResultList::getData.")));
RET CN;
}

SV RayCastResultList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::__eq__" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<RayCastResult> &))
{
auto v=val_to_c<std::remove_reference<const List<RayCastResult> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("RayCastResultList::__eq__.")));
RET CN;
}

SV RayCastResultList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::find" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],RayCastResult))
{
RET CV( f->find(val_to_c<std::remove_reference<RayCastResult>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("RayCastResultList::find.")));
RET CN;
}

SV RayCastResultList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::append" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],RayCastResult))
{
( f->append(val_to_c<std::remove_reference<RayCastResult>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<RayCastResult> &))
{
( f->append(val_to_c<std::remove_reference<const List<RayCastResult> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RayCastResultList::append.")));
RET CN;
}

SV RayCastResultList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::__neq__" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<RayCastResult> &))
{
auto v=val_to_c<std::remove_reference<const List<RayCastResult> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("RayCastResultList::__neq__.")));
RET CN;
}

void RenderStats_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,RenderStats))
CATE(TE,"RenderStats::__del__ expects RenderStats as first argument."));

SCRIPT_DELETE((RenderStats*)f->data);
}SV RenderStats_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"RenderStats's constructor" EAOE));
if(!TS(a[0],RenderStats))
CATE(TE,"RenderStats's constructor expects RenderStats as first argument."));
RET STG::createNativeObject(RenderStats_funcs,NEW(TYPE(RenderStats)),EXT->RenderStats_typeID);
}

SV RenderStats_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("RenderStats");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(RenderStats_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(RenderStats_new);
else
 CATE(KE,"Unknown member for RenderStats."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(RenderStats_new);
 EI(keyStr.equals("gBufferTiming", CPL_STR_HASH("gBufferTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->gBufferTiming);
} EI(keyStr.equals("ssaoTiming", CPL_STR_HASH("ssaoTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->ssaoTiming);
} EI(keyStr.equals("ssaoBlurXTiming", CPL_STR_HASH("ssaoBlurXTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->ssaoBlurXTiming);
} EI(keyStr.equals("ssaoBlurYTiming", CPL_STR_HASH("ssaoBlurYTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->ssaoBlurYTiming);
} EI(keyStr.equals("deferredShadingTiming", CPL_STR_HASH("deferredShadingTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->deferredShadingTiming);
} EI(keyStr.equals("forwardTiming", CPL_STR_HASH("forwardTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->forwardTiming);
} EI(keyStr.equals("gammaCorrectionTiming", CPL_STR_HASH("gammaCorrectionTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->gammaCorrectionTiming);
} EI(keyStr.equals("fxaaTiming", CPL_STR_HASH("fxaaTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->fxaaTiming);
} EI(keyStr.equals("colorModifierTiming", CPL_STR_HASH("colorModifierTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->colorModifierTiming);
} EI(keyStr.equals("bloomTiming", CPL_STR_HASH("bloomTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->bloomTiming);
} EI(keyStr.equals("shadowmapTiming", CPL_STR_HASH("shadowmapTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->shadowmapTiming);
} EI(keyStr.equals("overlayTiming", CPL_STR_HASH("overlayTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->overlayTiming);
} EI(keyStr.equals("debugDrawTiming", CPL_STR_HASH("debugDrawTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->debugDrawTiming);
} EI(keyStr.equals("shadowmapCPUTiming", CPL_STR_HASH("shadowmapCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->shadowmapCPUTiming);
} EI(keyStr.equals("gbufferCPUTiming", CPL_STR_HASH("gbufferCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->gbufferCPUTiming);
} EI(keyStr.equals("forwardCPUTiming", CPL_STR_HASH("forwardCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->forwardCPUTiming);
} EI(keyStr.equals("overlayCPUTiming", CPL_STR_HASH("overlayCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->overlayCPUTiming);
} EI(keyStr.equals("batchingCPUTiming", CPL_STR_HASH("batchingCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->batchingCPUTiming);
} EI(keyStr.equals("animationCPUTiming", CPL_STR_HASH("animationCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->animationCPUTiming);
} EI(keyStr.equals("deferredShadingCPUTiming", CPL_STR_HASH("deferredShadingCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->deferredShadingCPUTiming);
} EI(keyStr.equals("updateStatsCPUTiming", CPL_STR_HASH("updateStatsCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->updateStatsCPUTiming);
} EI(keyStr.equals("miscPostEffectsCPUTiming", CPL_STR_HASH("miscPostEffectsCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->miscPostEffectsCPUTiming);
} EI(keyStr.equals("numDrawCalls", CPL_STR_HASH("numDrawCalls")))
{
RenderStats*obj=(RenderStats*)f->data;
RET CV(obj->numDrawCalls);
} else
 CATE(KE,"Unknown member for RenderStats."));
}
}
RET CN;
}

void RenderStats_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("gBufferTiming", CPL_STR_HASH("gBufferTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->gBufferTiming=val_to_c<decltype(obj->gBufferTiming)>::f(ctx,value);
} EI(keyStr.equals("ssaoTiming", CPL_STR_HASH("ssaoTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->ssaoTiming=val_to_c<decltype(obj->ssaoTiming)>::f(ctx,value);
} EI(keyStr.equals("ssaoBlurXTiming", CPL_STR_HASH("ssaoBlurXTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->ssaoBlurXTiming=val_to_c<decltype(obj->ssaoBlurXTiming)>::f(ctx,value);
} EI(keyStr.equals("ssaoBlurYTiming", CPL_STR_HASH("ssaoBlurYTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->ssaoBlurYTiming=val_to_c<decltype(obj->ssaoBlurYTiming)>::f(ctx,value);
} EI(keyStr.equals("deferredShadingTiming", CPL_STR_HASH("deferredShadingTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->deferredShadingTiming=val_to_c<decltype(obj->deferredShadingTiming)>::f(ctx,value);
} EI(keyStr.equals("forwardTiming", CPL_STR_HASH("forwardTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->forwardTiming=val_to_c<decltype(obj->forwardTiming)>::f(ctx,value);
} EI(keyStr.equals("gammaCorrectionTiming", CPL_STR_HASH("gammaCorrectionTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->gammaCorrectionTiming=val_to_c<decltype(obj->gammaCorrectionTiming)>::f(ctx,value);
} EI(keyStr.equals("fxaaTiming", CPL_STR_HASH("fxaaTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->fxaaTiming=val_to_c<decltype(obj->fxaaTiming)>::f(ctx,value);
} EI(keyStr.equals("colorModifierTiming", CPL_STR_HASH("colorModifierTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->colorModifierTiming=val_to_c<decltype(obj->colorModifierTiming)>::f(ctx,value);
} EI(keyStr.equals("bloomTiming", CPL_STR_HASH("bloomTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->bloomTiming=val_to_c<decltype(obj->bloomTiming)>::f(ctx,value);
} EI(keyStr.equals("shadowmapTiming", CPL_STR_HASH("shadowmapTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->shadowmapTiming=val_to_c<decltype(obj->shadowmapTiming)>::f(ctx,value);
} EI(keyStr.equals("overlayTiming", CPL_STR_HASH("overlayTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->overlayTiming=val_to_c<decltype(obj->overlayTiming)>::f(ctx,value);
} EI(keyStr.equals("debugDrawTiming", CPL_STR_HASH("debugDrawTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->debugDrawTiming=val_to_c<decltype(obj->debugDrawTiming)>::f(ctx,value);
} EI(keyStr.equals("shadowmapCPUTiming", CPL_STR_HASH("shadowmapCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->shadowmapCPUTiming=val_to_c<decltype(obj->shadowmapCPUTiming)>::f(ctx,value);
} EI(keyStr.equals("gbufferCPUTiming", CPL_STR_HASH("gbufferCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->gbufferCPUTiming=val_to_c<decltype(obj->gbufferCPUTiming)>::f(ctx,value);
} EI(keyStr.equals("forwardCPUTiming", CPL_STR_HASH("forwardCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->forwardCPUTiming=val_to_c<decltype(obj->forwardCPUTiming)>::f(ctx,value);
} EI(keyStr.equals("overlayCPUTiming", CPL_STR_HASH("overlayCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->overlayCPUTiming=val_to_c<decltype(obj->overlayCPUTiming)>::f(ctx,value);
} EI(keyStr.equals("batchingCPUTiming", CPL_STR_HASH("batchingCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->batchingCPUTiming=val_to_c<decltype(obj->batchingCPUTiming)>::f(ctx,value);
} EI(keyStr.equals("animationCPUTiming", CPL_STR_HASH("animationCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->animationCPUTiming=val_to_c<decltype(obj->animationCPUTiming)>::f(ctx,value);
} EI(keyStr.equals("deferredShadingCPUTiming", CPL_STR_HASH("deferredShadingCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->deferredShadingCPUTiming=val_to_c<decltype(obj->deferredShadingCPUTiming)>::f(ctx,value);
} EI(keyStr.equals("updateStatsCPUTiming", CPL_STR_HASH("updateStatsCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->updateStatsCPUTiming=val_to_c<decltype(obj->updateStatsCPUTiming)>::f(ctx,value);
} EI(keyStr.equals("miscPostEffectsCPUTiming", CPL_STR_HASH("miscPostEffectsCPUTiming")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->miscPostEffectsCPUTiming=val_to_c<decltype(obj->miscPostEffectsCPUTiming)>::f(ctx,value);
} EI(keyStr.equals("numDrawCalls", CPL_STR_HASH("numDrawCalls")))
{
RenderStats*obj=(RenderStats*)f->data;
obj->numDrawCalls=val_to_c<decltype(obj->numDrawCalls)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for RenderStats."));
}
}
}

void Quaternion_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Quaternion))
CATE(TE,"Quaternion::__del__ expects Quaternion as first argument."));

SCRIPT_DELETE((Quaternion*)f->data);
}SV Quaternion_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion's constructor" EAOE));
if(!TS(a[0],Quaternion))
CATE(TE,"Quaternion's constructor expects Quaternion as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(Quaternion));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Quaternion_funcs,p,EXT->Quaternion_typeID);
}if(a.getCount()==3)
if(true&&TS(a[1],const Direction3D &)&&TS(a[2],float)){
void *p = (void *)NEW(TYPE(Quaternion),val_to_c<const Direction3D &>::f(ctx,a[1]),val_to_c<float>::f(ctx,a[2]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Quaternion_funcs,p,EXT->Quaternion_typeID);
}if(a.getCount()==5)
if(true&&TS(a[1],float)&&TS(a[2],float)&&TS(a[3],float)&&TS(a[4],float)){
void *p = (void *)NEW(TYPE(Quaternion),val_to_c<float>::f(ctx,a[1]),val_to_c<float>::f(ctx,a[2]),val_to_c<float>::f(ctx,a[3]),val_to_c<float>::f(ctx,a[4]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Quaternion_funcs,p,EXT->Quaternion_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const Float3 &)){
void *p = (void *)NEW(TYPE(Quaternion),val_to_c<const Float3 &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Quaternion_funcs,p,EXT->Quaternion_typeID);
}CATE(TE,UFOF("Quaternion's constructor.")));
RET CN;
}

SV Quaternion_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Quaternion");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Quaternion_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Quaternion_new);
else
 CATE(KE,"Unknown member for Quaternion."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Quaternion_new);
 EI(keyStr.equals("__mul__", CPL_STR_HASH("__mul__")))
RET CNF(Quaternion___mul__);
 EI(keyStr.equals("toMatrix", CPL_STR_HASH("toMatrix")))
RET CNF(Quaternion_toMatrix);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(Quaternion___eq__);
 EI(keyStr.equals("normalize", CPL_STR_HASH("normalize")))
RET CNF(Quaternion_normalize);
 EI(keyStr.equals("getAngle", CPL_STR_HASH("getAngle")))
RET CNF(Quaternion_getAngle);
 EI(keyStr.equals("getXAxis", CPL_STR_HASH("getXAxis")))
RET CNF(Quaternion_getXAxis);
 EI(keyStr.equals("getYAxis", CPL_STR_HASH("getYAxis")))
RET CNF(Quaternion_getYAxis);
 EI(keyStr.equals("getZAxis", CPL_STR_HASH("getZAxis")))
RET CNF(Quaternion_getZAxis);
 EI(keyStr.equals("getAxis", CPL_STR_HASH("getAxis")))
RET CNF(Quaternion_getAxis);
 EI(keyStr.equals("getAxisAndAngle", CPL_STR_HASH("getAxisAndAngle")))
RET CNF(Quaternion_getAxisAndAngle);
 EI(keyStr.equals("setAngle", CPL_STR_HASH("setAngle")))
RET CNF(Quaternion_setAngle);
 EI(keyStr.equals("setXAxis", CPL_STR_HASH("setXAxis")))
RET CNF(Quaternion_setXAxis);
 EI(keyStr.equals("setYAxis", CPL_STR_HASH("setYAxis")))
RET CNF(Quaternion_setYAxis);
 EI(keyStr.equals("setZAxis", CPL_STR_HASH("setZAxis")))
RET CNF(Quaternion_setZAxis);
 EI(keyStr.equals("setAxis", CPL_STR_HASH("setAxis")))
RET CNF(Quaternion_setAxis);
 EI(keyStr.equals("setAxisAndAngle", CPL_STR_HASH("setAxisAndAngle")))
RET CNF(Quaternion_setAxisAndAngle);
 EI(keyStr.equals("setEulerAngles", CPL_STR_HASH("setEulerAngles")))
RET CNF(Quaternion_setEulerAngles);
 EI(keyStr.equals("getEulerAngles", CPL_STR_HASH("getEulerAngles")))
RET CNF(Quaternion_getEulerAngles);
 EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
Quaternion*obj=(Quaternion*)f->data;
RET CV(obj->x);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
Quaternion*obj=(Quaternion*)f->data;
RET CV(obj->y);
} EI(keyStr.equals("z", CPL_STR_HASH("z")))
{
Quaternion*obj=(Quaternion*)f->data;
RET CV(obj->z);
} EI(keyStr.equals("w", CPL_STR_HASH("w")))
{
Quaternion*obj=(Quaternion*)f->data;
RET CV(obj->w);
} else
 CATE(KE,"Unknown member for Quaternion."));
}
}
RET CN;
}

void Quaternion_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
Quaternion*obj=(Quaternion*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
Quaternion*obj=(Quaternion*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} EI(keyStr.equals("z", CPL_STR_HASH("z")))
{
Quaternion*obj=(Quaternion*)f->data;
obj->z=val_to_c<decltype(obj->z)>::f(ctx,value);
} EI(keyStr.equals("w", CPL_STR_HASH("w")))
{
Quaternion*obj=(Quaternion*)f->data;
obj->w=val_to_c<decltype(obj->w)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for Quaternion."));
}
}
}

SV Quaternion_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::normalize" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("Quaternion::normalize.")));
RET CN;
}

SV Quaternion_setEulerAngles(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::setEulerAngles" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
( f->setEulerAngles(val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Quaternion::setEulerAngles.")));
RET CN;
}

SV Quaternion_getAngle(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::getAngle" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAngle());
;
}
CATE(TE,UFOF("Quaternion::getAngle.")));
RET CN;
}

SV Quaternion_getAxis(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::getAxis" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAxis());
;
}
CATE(TE,UFOF("Quaternion::getAxis.")));
RET CN;
}

SV Quaternion_setAngle(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::setAngle" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setAngle(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Quaternion::setAngle.")));
RET CN;
}

SV Quaternion_setYAxis(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::setYAxis" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setYAxis(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Quaternion::setYAxis.")));
RET CN;
}

SV Quaternion_getEulerAngles(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::getEulerAngles" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getEulerAngles());
;
}
CATE(TE,UFOF("Quaternion::getEulerAngles.")));
RET CN;
}

SV Quaternion_setAxisAndAngle(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::setAxisAndAngle" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],const Direction3D &)&&TS(a[2],float))
{
( f->setAxisAndAngle(val_to_c<std::remove_reference<const Direction3D &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("Quaternion::setAxisAndAngle.")));
RET CN;
}

SV Quaternion_getAxisAndAngle(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::getAxisAndAngle" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAxisAndAngle());
;
}
CATE(TE,UFOF("Quaternion::getAxisAndAngle.")));
RET CN;
}

SV Quaternion_setAxis(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::setAxis" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Direction3D &))
{
( f->setAxis(val_to_c<std::remove_reference<const Direction3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Quaternion::setAxis.")));
RET CN;
}

SV Quaternion___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::__mul__" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Quaternion &))
{
auto v=val_to_c<std::remove_reference<const Quaternion &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Quaternion::__mul__.")));
RET CN;
}

SV Quaternion_getYAxis(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::getYAxis" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYAxis());
;
}
CATE(TE,UFOF("Quaternion::getYAxis.")));
RET CN;
}

SV Quaternion_getXAxis(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::getXAxis" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXAxis());
;
}
CATE(TE,UFOF("Quaternion::getXAxis.")));
RET CN;
}

SV Quaternion_toMatrix(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::toMatrix" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->toMatrix());
;
}
CATE(TE,UFOF("Quaternion::toMatrix.")));
RET CN;
}

SV Quaternion_setZAxis(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::setZAxis" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setZAxis(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Quaternion::setZAxis.")));
RET CN;
}

SV Quaternion_setXAxis(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::setXAxis" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setXAxis(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Quaternion::setXAxis.")));
RET CN;
}

SV Quaternion___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::__eq__" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Quaternion &))
{
auto v=val_to_c<std::remove_reference<const Quaternion &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Quaternion::__eq__.")));
RET CN;
}

SV Quaternion_getZAxis(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::getZAxis" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZAxis());
;
}
CATE(TE,UFOF("Quaternion::getZAxis.")));
RET CN;
}

void ImGui_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,ImGui))
CATE(TE,"ImGui::__del__ expects ImGui as first argument."));

SCRIPT_DELETE((ImGui*)f->data);
}SV ImGui_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui's constructor" EAOE));
if(!TS(a[0],ImGui))
CATE(TE,"ImGui's constructor expects ImGui as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(ImGui));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(ImGui_funcs,p,EXT->ImGui_typeID);
}CATE(TE,UFOF("ImGui's constructor.")));
RET CN;
}

SV ImGui_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("ImGui");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(ImGui_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(ImGui_new);
else
 CATE(KE,"Unknown member for ImGui."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(ImGui_new);
 EI(keyStr.equals("rectangle", CPL_STR_HASH("rectangle")))
RET CNF(ImGui_rectangle);
 EI(keyStr.equals("beginContainer", CPL_STR_HASH("beginContainer")))
RET CNF(ImGui_beginContainer);
 EI(keyStr.equals("endContainer", CPL_STR_HASH("endContainer")))
RET CNF(ImGui_endContainer);
 EI(keyStr.equals("verticalScrollBar", CPL_STR_HASH("verticalScrollBar")))
RET CNF(ImGui_verticalScrollBar);
 EI(keyStr.equals("horizontalScrollBar", CPL_STR_HASH("horizontalScrollBar")))
RET CNF(ImGui_horizontalScrollBar);
 EI(keyStr.equals("button", CPL_STR_HASH("button")))
RET CNF(ImGui_button);
 EI(keyStr.equals("label", CPL_STR_HASH("label")))
RET CNF(ImGui_label);
 EI(keyStr.equals("render", CPL_STR_HASH("render")))
RET CNF(ImGui_render);
 EI(keyStr.equals("buttonTextColor", CPL_STR_HASH("buttonTextColor")))
{
ImGui*obj=(ImGui*)f->data;
RET CV(obj->buttonTextColor);
} EI(keyStr.equals("labelColor", CPL_STR_HASH("labelColor")))
{
ImGui*obj=(ImGui*)f->data;
RET CV(obj->labelColor);
} EI(keyStr.equals("textSize", CPL_STR_HASH("textSize")))
{
ImGui*obj=(ImGui*)f->data;
RET CV(obj->textSize);
} EI(keyStr.equals("scrollSpeed", CPL_STR_HASH("scrollSpeed")))
{
ImGui*obj=(ImGui*)f->data;
RET CV(obj->scrollSpeed);
} else
 CATE(KE,"Unknown member for ImGui."));
}
}
RET CN;
}

void ImGui_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("buttonTextColor", CPL_STR_HASH("buttonTextColor")))
{
ImGui*obj=(ImGui*)f->data;
obj->buttonTextColor=val_to_c<decltype(obj->buttonTextColor)>::f(ctx,value);
} EI(keyStr.equals("labelColor", CPL_STR_HASH("labelColor")))
{
ImGui*obj=(ImGui*)f->data;
obj->labelColor=val_to_c<decltype(obj->labelColor)>::f(ctx,value);
} EI(keyStr.equals("textSize", CPL_STR_HASH("textSize")))
{
ImGui*obj=(ImGui*)f->data;
obj->textSize=val_to_c<decltype(obj->textSize)>::f(ctx,value);
} EI(keyStr.equals("scrollSpeed", CPL_STR_HASH("scrollSpeed")))
{
ImGui*obj=(ImGui*)f->data;
obj->scrollSpeed=val_to_c<decltype(obj->scrollSpeed)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for ImGui."));
}
}
}

SV ImGui_endContainer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui::endContainer" EAOE));
ImGui*f;
f=(ImGui*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Container *))
{
( f->endContainer(val_to_c<std::remove_reference<Container *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("ImGui::endContainer.")));
RET CN;
}

SV ImGui_render(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui::render" EAOE));
ImGui*f;
f=(ImGui*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->render());
RET CN;
}
CATE(TE,UFOF("ImGui::render.")));
RET CN;
}

SV ImGui_beginContainer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui::beginContainer" EAOE));
ImGui*f;
f=(ImGui*)((NO)a[0].p)->data;

CATE(TE,UFOF("ImGui::beginContainer.")));
RET CN;
}

SV ImGui_button(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui::button" EAOE));
ImGui*f;
f=(ImGui*)((NO)a[0].p)->data;

if(a.getCount()==6)
if(1&&TS(a[1],const char *)&&TS(a[2],int)&&TS(a[3],int)&&TS(a[4],int)&&TS(a[5],int))
{
RET CV( f->button(val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[5])));
;
}
CATE(TE,UFOF("ImGui::button.")));
RET CN;
}

SV ImGui_label(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui::label" EAOE));
ImGui*f;
f=(ImGui*)((NO)a[0].p)->data;

if(a.getCount()==6)
if(1&&TS(a[1],const char *)&&TS(a[2],int)&&TS(a[3],int)&&TS(a[4],bool)&&TS(a[5],bool))
{
RET CV( f->label(val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<bool>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<bool>::type>::f(ctx,a[5])));
;
}
CATE(TE,UFOF("ImGui::label.")));
RET CN;
}

SV ImGui_verticalScrollBar(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui::verticalScrollBar" EAOE));
ImGui*f;
f=(ImGui*)((NO)a[0].p)->data;

if(a.getCount()==8)
if(1&&TS(a[1],int)&&TS(a[2],int)&&TS(a[3],int)&&TS(a[4],int)&&TS(a[5],bool)&&TS(a[6],bool)&&TS(a[7],ScrollBar *))
{
( f->verticalScrollBar(val_to_c<std::remove_reference<int>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<bool>::type>::f(ctx,a[5]), val_to_c<std::remove_reference<bool>::type>::f(ctx,a[6]), val_to_c<std::remove_reference<ScrollBar *>::type>::f(ctx,a[7])));
RET CN;
}
CATE(TE,UFOF("ImGui::verticalScrollBar.")));
RET CN;
}

SV ImGui_horizontalScrollBar(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui::horizontalScrollBar" EAOE));
ImGui*f;
f=(ImGui*)((NO)a[0].p)->data;

if(a.getCount()==8)
if(1&&TS(a[1],int)&&TS(a[2],int)&&TS(a[3],int)&&TS(a[4],int)&&TS(a[5],bool)&&TS(a[6],bool)&&TS(a[7],ScrollBar *))
{
( f->horizontalScrollBar(val_to_c<std::remove_reference<int>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<bool>::type>::f(ctx,a[5]), val_to_c<std::remove_reference<bool>::type>::f(ctx,a[6]), val_to_c<std::remove_reference<ScrollBar *>::type>::f(ctx,a[7])));
RET CN;
}
CATE(TE,UFOF("ImGui::horizontalScrollBar.")));
RET CN;
}

SV ImGui_rectangle(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui::rectangle" EAOE));
ImGui*f;
f=(ImGui*)((NO)a[0].p)->data;

if(a.getCount()==11)
if(1&&TS(a[1],int)&&TS(a[2],int)&&TS(a[3],int)&&TS(a[4],int)&&TS(a[5],float)&&TS(a[6],float)&&TS(a[7],float)&&TS(a[8],float)&&TS(a[9],Float3)&&TS(a[10],Float4))
{
( f->rectangle(val_to_c<std::remove_reference<int>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[5]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[6]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[7]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[8]), val_to_c<std::remove_reference<Float3>::type>::f(ctx,a[9]), val_to_c<std::remove_reference<Float4>::type>::f(ctx,a[10])));
RET CN;
}
CATE(TE,UFOF("ImGui::rectangle.")));
RET CN;
}

void LightDirectionalData_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,LightDirectionalData))
CATE(TE,"LightDirectionalData::__del__ expects LightDirectionalData as first argument."));

SCRIPT_DELETE((LightDirectionalData*)f->data);
}SV LightDirectionalData_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"LightDirectionalData's constructor" EAOE));
if(!TS(a[0],LightDirectionalData))
CATE(TE,"LightDirectionalData's constructor expects LightDirectionalData as first argument."));
RET STG::createNativeObject(LightDirectionalData_funcs,NEW(TYPE(LightDirectionalData)),EXT->LightDirectionalData_typeID);
}

SV LightDirectionalData_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("LightDirectionalData");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(LightDirectionalData_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(LightDirectionalData_new);
else
 CATE(KE,"Unknown member for LightDirectionalData."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(LightDirectionalData_new);
 EI(keyStr.equals("direction", CPL_STR_HASH("direction")))
{
LightDirectionalData*obj=(LightDirectionalData*)f->data;
RET CV(obj->direction);
} else
 CATE(KE,"Unknown member for LightDirectionalData."));
}
}
RET CN;
}

void LightDirectionalData_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("direction", CPL_STR_HASH("direction")))
{
LightDirectionalData*obj=(LightDirectionalData*)f->data;
obj->direction=val_to_c<decltype(obj->direction)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for LightDirectionalData."));
}
}
}

void LightSpotData_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,LightSpotData))
CATE(TE,"LightSpotData::__del__ expects LightSpotData as first argument."));

SCRIPT_DELETE((LightSpotData*)f->data);
}SV LightSpotData_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"LightSpotData's constructor" EAOE));
if(!TS(a[0],LightSpotData))
CATE(TE,"LightSpotData's constructor expects LightSpotData as first argument."));
RET STG::createNativeObject(LightSpotData_funcs,NEW(TYPE(LightSpotData)),EXT->LightSpotData_typeID);
}

SV LightSpotData_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("LightSpotData");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(LightSpotData_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(LightSpotData_new);
else
 CATE(KE,"Unknown member for LightSpotData."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(LightSpotData_new);
 EI(keyStr.equals("position", CPL_STR_HASH("position")))
{
LightSpotData*obj=(LightSpotData*)f->data;
RET CV(obj->position);
} EI(keyStr.equals("direction", CPL_STR_HASH("direction")))
{
LightSpotData*obj=(LightSpotData*)f->data;
RET CV(obj->direction);
} EI(keyStr.equals("innerCutoff", CPL_STR_HASH("innerCutoff")))
{
LightSpotData*obj=(LightSpotData*)f->data;
RET CV(obj->innerCutoff);
} EI(keyStr.equals("outerCutoff", CPL_STR_HASH("outerCutoff")))
{
LightSpotData*obj=(LightSpotData*)f->data;
RET CV(obj->outerCutoff);
} EI(keyStr.equals("radius", CPL_STR_HASH("radius")))
{
LightSpotData*obj=(LightSpotData*)f->data;
RET CV(obj->radius);
} else
 CATE(KE,"Unknown member for LightSpotData."));
}
}
RET CN;
}

void LightSpotData_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("position", CPL_STR_HASH("position")))
{
LightSpotData*obj=(LightSpotData*)f->data;
obj->position=val_to_c<decltype(obj->position)>::f(ctx,value);
} EI(keyStr.equals("direction", CPL_STR_HASH("direction")))
{
LightSpotData*obj=(LightSpotData*)f->data;
obj->direction=val_to_c<decltype(obj->direction)>::f(ctx,value);
} EI(keyStr.equals("innerCutoff", CPL_STR_HASH("innerCutoff")))
{
LightSpotData*obj=(LightSpotData*)f->data;
obj->innerCutoff=val_to_c<decltype(obj->innerCutoff)>::f(ctx,value);
} EI(keyStr.equals("outerCutoff", CPL_STR_HASH("outerCutoff")))
{
LightSpotData*obj=(LightSpotData*)f->data;
obj->outerCutoff=val_to_c<decltype(obj->outerCutoff)>::f(ctx,value);
} EI(keyStr.equals("radius", CPL_STR_HASH("radius")))
{
LightSpotData*obj=(LightSpotData*)f->data;
obj->radius=val_to_c<decltype(obj->radius)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for LightSpotData."));
}
}
}

void FloatList_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,List<float>))
CATE(TE,"FloatList::__del__ expects FloatList as first argument."));

SCRIPT_DELETE((List<float>*)f->data);
}SV FloatList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList's constructor" EAOE));
if(!TS(a[0],List<float>))
CATE(TE,"FloatList's constructor expects FloatList as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(List<float>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(FloatList_funcs,p,EXT->FloatList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],std::size_t)){
void *p = (void *)NEW(TYPE(List<float>),val_to_c<std::size_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(FloatList_funcs,p,EXT->FloatList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const List<float> &)){
void *p = (void *)NEW(TYPE(List<float>),val_to_c<const List<float> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(FloatList_funcs,p,EXT->FloatList_typeID);
}CATE(TE,UFOF("FloatList's constructor.")));
RET CN;
}

SV FloatList_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("FloatList");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(FloatList_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(FloatList_new);
else
 CATE(KE,"Unknown member for FloatList."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(FloatList_new);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(FloatList___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(FloatList___neq__);
 EI(keyStr.equals("get", CPL_STR_HASH("get")))
RET CNF(FloatList_get);
 EI(keyStr.equals("set", CPL_STR_HASH("set")))
RET CNF(FloatList_set);
 EI(keyStr.equals("getCount", CPL_STR_HASH("getCount")))
RET CNF(FloatList_getCount);
 EI(keyStr.equals("getData", CPL_STR_HASH("getData")))
RET CNF(FloatList_getData);
 EI(keyStr.equals("append", CPL_STR_HASH("append")))
RET CNF(FloatList_append);
 EI(keyStr.equals("insert", CPL_STR_HASH("insert")))
RET CNF(FloatList_insert);
 EI(keyStr.equals("remove", CPL_STR_HASH("remove")))
RET CNF(FloatList_remove);
 EI(keyStr.equals("clear", CPL_STR_HASH("clear")))
RET CNF(FloatList_clear);
 EI(keyStr.equals("find", CPL_STR_HASH("find")))
RET CNF(FloatList_find);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(FloatList_copy);
 EI(keyStr.equals("in", CPL_STR_HASH("in")))
RET CNF(FloatList_in);
 EI(keyStr.equals("reserve", CPL_STR_HASH("reserve")))
RET CNF(FloatList_reserve);
 EI(keyStr.equals("begin", CPL_STR_HASH("begin")))
RET CNF(FloatList_begin);
 EI(keyStr.equals("end", CPL_STR_HASH("end")))
RET CNF(FloatList_end);
 else
 CATE(KE,"Unknown member for FloatList."));
}
}
RET CN;
}

void FloatList_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for FloatList."));
}
}
}

SV FloatList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::insert" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],float))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<float> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<float> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("FloatList::insert.")));
RET CN;
}

SV FloatList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::begin" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0].p)->data;

CATE(TE,UFOF("FloatList::begin.")));
RET CN;
}

SV FloatList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::set" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],float))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("FloatList::set.")));
RET CN;
}

SV FloatList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::end" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0].p)->data;

CATE(TE,UFOF("FloatList::end.")));
RET CN;
}

SV FloatList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::get" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("FloatList::get.")));
RET CN;
}

SV FloatList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::clear" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("FloatList::clear.")));
RET CN;
}

SV FloatList_reserve(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::reserve" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->reserve(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("FloatList::reserve.")));
RET CN;
}

SV FloatList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::copy" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("FloatList::copy.")));
RET CN;
}

SV FloatList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::remove" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("FloatList::remove.")));
RET CN;
}

SV FloatList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::in" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->in(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("FloatList::in.")));
RET CN;
}

SV FloatList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::getCount" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("FloatList::getCount.")));
RET CN;
}

SV FloatList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::getData" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0].p)->data;

CATE(TE,UFOF("FloatList::getData.")));
RET CN;
}

SV FloatList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::__eq__" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<float> &))
{
auto v=val_to_c<std::remove_reference<const List<float> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("FloatList::__eq__.")));
RET CN;
}

SV FloatList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::find" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->find(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("FloatList::find.")));
RET CN;
}

SV FloatList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::append" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->append(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<float> &))
{
( f->append(val_to_c<std::remove_reference<const List<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("FloatList::append.")));
RET CN;
}

SV FloatList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::__neq__" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<float> &))
{
auto v=val_to_c<std::remove_reference<const List<float> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("FloatList::__neq__.")));
RET CN;
}

void GfxLOD_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GfxLOD))
CATE(TE,"GfxLOD::__del__ expects GfxLOD as first argument."));

SCRIPT_DELETE((GfxLOD*)f->data);
}SV GfxLOD_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLOD's constructor" EAOE));
if(!TS(a[0],GfxLOD))
CATE(TE,"GfxLOD's constructor expects GfxLOD as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(GfxLOD));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxLOD_funcs,p,EXT->GfxLOD_typeID);
}if(a.getCount()==6)
if(true&&TS(a[1],float)&&TS(a[2],float)&&TS(a[3],GfxMesh *)&&TS(a[4],GfxMaterial *)&&TS(a[5],const Matrix4x4 &)){
void *p = (void *)NEW(TYPE(GfxLOD),val_to_c<float>::f(ctx,a[1]),val_to_c<float>::f(ctx,a[2]),val_to_c<GfxMesh *>::f(ctx,a[3]),val_to_c<GfxMaterial *>::f(ctx,a[4]),val_to_c<const Matrix4x4 &>::f(ctx,a[5]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxLOD_funcs,p,EXT->GfxLOD_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const GfxLOD &)){
void *p = (void *)NEW(TYPE(GfxLOD),val_to_c<const GfxLOD &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxLOD_funcs,p,EXT->GfxLOD_typeID);
}CATE(TE,UFOF("GfxLOD's constructor.")));
RET CN;
}

SV GfxLOD_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxLOD");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxLOD_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxLOD_new);
else
 CATE(KE,"Unknown member for GfxLOD."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxLOD_new);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxLOD___eq__);
 EI(keyStr.equals("minDistance", CPL_STR_HASH("minDistance")))
{
GfxLOD*obj=(GfxLOD*)f->data;
RET CV(obj->minDistance);
} EI(keyStr.equals("maxDistance", CPL_STR_HASH("maxDistance")))
{
GfxLOD*obj=(GfxLOD*)f->data;
RET CV(obj->maxDistance);
} EI(keyStr.equals("worldMatrix", CPL_STR_HASH("worldMatrix")))
{
GfxLOD*obj=(GfxLOD*)f->data;
RET CV(obj->worldMatrix);
} else
 CATE(KE,"Unknown member for GfxLOD."));
}
}
RET CN;
}

void GfxLOD_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("minDistance", CPL_STR_HASH("minDistance")))
{
GfxLOD*obj=(GfxLOD*)f->data;
obj->minDistance=val_to_c<decltype(obj->minDistance)>::f(ctx,value);
} EI(keyStr.equals("maxDistance", CPL_STR_HASH("maxDistance")))
{
GfxLOD*obj=(GfxLOD*)f->data;
obj->maxDistance=val_to_c<decltype(obj->maxDistance)>::f(ctx,value);
} EI(keyStr.equals("worldMatrix", CPL_STR_HASH("worldMatrix")))
{
GfxLOD*obj=(GfxLOD*)f->data;
obj->worldMatrix=val_to_c<decltype(obj->worldMatrix)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for GfxLOD."));
}
}
}

SV GfxLOD___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLOD::__eq__" EAOE));
GfxLOD*f;
f=(GfxLOD*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const GfxLOD &))
{
auto v=val_to_c<std::remove_reference<const GfxLOD &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("GfxLOD::__eq__.")));
RET CN;
}

void List_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,List<AutoVal>))
CATE(TE,"List::__del__ expects List as first argument."));

SCRIPT_DELETE((List<AutoVal>*)f->data);
}SV List_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List's constructor" EAOE));
if(!TS(a[0],List<AutoVal>))
CATE(TE,"List's constructor expects List as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(List<AutoVal>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(List_funcs,p,EXT->List_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],std::size_t)){
void *p = (void *)NEW(TYPE(List<AutoVal>),val_to_c<std::size_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(List_funcs,p,EXT->List_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const List<AutoVal> &)){
void *p = (void *)NEW(TYPE(List<AutoVal>),val_to_c<const List<AutoVal> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(List_funcs,p,EXT->List_typeID);
}CATE(TE,UFOF("List's constructor.")));
RET CN;
}

SV List_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("List");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(List_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(List_new);
else
 CATE(KE,"Unknown member for List."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(List_new);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(List___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(List___neq__);
 EI(keyStr.equals("get", CPL_STR_HASH("get")))
RET CNF(List_get);
 EI(keyStr.equals("set", CPL_STR_HASH("set")))
RET CNF(List_set);
 EI(keyStr.equals("getCount", CPL_STR_HASH("getCount")))
RET CNF(List_getCount);
 EI(keyStr.equals("getData", CPL_STR_HASH("getData")))
RET CNF(List_getData);
 EI(keyStr.equals("append", CPL_STR_HASH("append")))
RET CNF(List_append);
 EI(keyStr.equals("insert", CPL_STR_HASH("insert")))
RET CNF(List_insert);
 EI(keyStr.equals("remove", CPL_STR_HASH("remove")))
RET CNF(List_remove);
 EI(keyStr.equals("clear", CPL_STR_HASH("clear")))
RET CNF(List_clear);
 EI(keyStr.equals("find", CPL_STR_HASH("find")))
RET CNF(List_find);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(List_copy);
 EI(keyStr.equals("in", CPL_STR_HASH("in")))
RET CNF(List_in);
 EI(keyStr.equals("reserve", CPL_STR_HASH("reserve")))
RET CNF(List_reserve);
 EI(keyStr.equals("begin", CPL_STR_HASH("begin")))
RET CNF(List_begin);
 EI(keyStr.equals("end", CPL_STR_HASH("end")))
RET CNF(List_end);
 else
 CATE(KE,"Unknown member for List."));
}
}
RET CN;
}

void List_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for List."));
}
}
}

SV List_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::insert" EAOE));
List<AutoVal>*f;
f=(List<AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],AutoVal))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<AutoVal>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<AutoVal> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<AutoVal> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("List::insert.")));
RET CN;
}

SV List_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::begin" EAOE));
List<AutoVal>*f;
f=(List<AutoVal>*)((NO)a[0].p)->data;

CATE(TE,UFOF("List::begin.")));
RET CN;
}

SV List_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::set" EAOE));
List<AutoVal>*f;
f=(List<AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],AutoVal))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<AutoVal>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("List::set.")));
RET CN;
}

SV List_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::end" EAOE));
List<AutoVal>*f;
f=(List<AutoVal>*)((NO)a[0].p)->data;

CATE(TE,UFOF("List::end.")));
RET CN;
}

SV List_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::get" EAOE));
List<AutoVal>*f;
f=(List<AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("List::get.")));
RET CN;
}

SV List_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::clear" EAOE));
List<AutoVal>*f;
f=(List<AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("List::clear.")));
RET CN;
}

SV List_reserve(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::reserve" EAOE));
List<AutoVal>*f;
f=(List<AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->reserve(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("List::reserve.")));
RET CN;
}

SV List_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::copy" EAOE));
List<AutoVal>*f;
f=(List<AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("List::copy.")));
RET CN;
}

SV List_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::remove" EAOE));
List<AutoVal>*f;
f=(List<AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("List::remove.")));
RET CN;
}

SV List_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::in" EAOE));
List<AutoVal>*f;
f=(List<AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],AutoVal))
{
RET CV( f->in(val_to_c<std::remove_reference<AutoVal>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("List::in.")));
RET CN;
}

SV List_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::getCount" EAOE));
List<AutoVal>*f;
f=(List<AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("List::getCount.")));
RET CN;
}

SV List_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::getData" EAOE));
List<AutoVal>*f;
f=(List<AutoVal>*)((NO)a[0].p)->data;

CATE(TE,UFOF("List::getData.")));
RET CN;
}

SV List___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::__eq__" EAOE));
List<AutoVal>*f;
f=(List<AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<AutoVal> &))
{
auto v=val_to_c<std::remove_reference<const List<AutoVal> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("List::__eq__.")));
RET CN;
}

SV List_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::find" EAOE));
List<AutoVal>*f;
f=(List<AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],AutoVal))
{
RET CV( f->find(val_to_c<std::remove_reference<AutoVal>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("List::find.")));
RET CN;
}

SV List_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::append" EAOE));
List<AutoVal>*f;
f=(List<AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],AutoVal))
{
( f->append(val_to_c<std::remove_reference<AutoVal>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<AutoVal> &))
{
( f->append(val_to_c<std::remove_reference<const List<AutoVal> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("List::append.")));
RET CN;
}

SV List___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::__neq__" EAOE));
List<AutoVal>*f;
f=(List<AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<AutoVal> &))
{
auto v=val_to_c<std::remove_reference<const List<AutoVal> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("List::__neq__.")));
RET CN;
}

void File_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,File))
CATE(TE,"File::__del__ expects File as first argument."));

SCRIPT_DELETE((File*)f->data);
}SV File_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File's constructor" EAOE));
if(!TS(a[0],File))
CATE(TE,"File's constructor expects File as first argument."));
if(a.getCount()==3)
if(true&&TS(a[1],const char *)&&TS(a[2],const char *)){
void *p = (void *)NEW(TYPE(File),val_to_c<const char *>::f(ctx,a[1]),val_to_c<const char *>::f(ctx,a[2]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(File_funcs,p,EXT->File_typeID);
}CATE(TE,UFOF("File's constructor.")));
RET CN;
}

SV File_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("File");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(File_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(File_new);
else
 CATE(KE,"Unknown member for File."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(File_new);
 EI(keyStr.equals("read", CPL_STR_HASH("read")))
RET CNF(File_read);
 EI(keyStr.equals("write", CPL_STR_HASH("write")))
RET CNF(File_write);
 EI(keyStr.equals("seek", CPL_STR_HASH("seek")))
RET CNF(File_seek);
 EI(keyStr.equals("tell", CPL_STR_HASH("tell")))
RET CNF(File_tell);
 EI(keyStr.equals("flush", CPL_STR_HASH("flush")))
RET CNF(File_flush);
 EI(keyStr.equals("isAtEndOfFile", CPL_STR_HASH("isAtEndOfFile")))
RET CNF(File_isAtEndOfFile);
 EI(keyStr.equals("getSize", CPL_STR_HASH("getSize")))
RET CNF(File_getSize);
 EI(keyStr.equals("readUInt8", CPL_STR_HASH("readUInt8")))
RET CNF(File_readUInt8);
 EI(keyStr.equals("readInt8", CPL_STR_HASH("readInt8")))
RET CNF(File_readInt8);
 EI(keyStr.equals("readUInt16LE", CPL_STR_HASH("readUInt16LE")))
RET CNF(File_readUInt16LE);
 EI(keyStr.equals("readInt16LE", CPL_STR_HASH("readInt16LE")))
RET CNF(File_readInt16LE);
 EI(keyStr.equals("readUInt32LE", CPL_STR_HASH("readUInt32LE")))
RET CNF(File_readUInt32LE);
 EI(keyStr.equals("readInt32LE", CPL_STR_HASH("readInt32LE")))
RET CNF(File_readInt32LE);
 EI(keyStr.equals("readUInt64LE", CPL_STR_HASH("readUInt64LE")))
RET CNF(File_readUInt64LE);
 EI(keyStr.equals("readInt64LE", CPL_STR_HASH("readInt64LE")))
RET CNF(File_readInt64LE);
 EI(keyStr.equals("readUInt16BE", CPL_STR_HASH("readUInt16BE")))
RET CNF(File_readUInt16BE);
 EI(keyStr.equals("readInt16BE", CPL_STR_HASH("readInt16BE")))
RET CNF(File_readInt16BE);
 EI(keyStr.equals("readUInt32BE", CPL_STR_HASH("readUInt32BE")))
RET CNF(File_readUInt32BE);
 EI(keyStr.equals("readInt32BE", CPL_STR_HASH("readInt32BE")))
RET CNF(File_readInt32BE);
 EI(keyStr.equals("readUInt64BE", CPL_STR_HASH("readUInt64BE")))
RET CNF(File_readUInt64BE);
 EI(keyStr.equals("readInt64BE", CPL_STR_HASH("readInt64BE")))
RET CNF(File_readInt64BE);
 EI(keyStr.equals("readFloat32", CPL_STR_HASH("readFloat32")))
RET CNF(File_readFloat32);
 EI(keyStr.equals("readChar", CPL_STR_HASH("readChar")))
RET CNF(File_readChar);
 EI(keyStr.equals("readStr", CPL_STR_HASH("readStr")))
RET CNF(File_readStr);
 EI(keyStr.equals("writeUInt8", CPL_STR_HASH("writeUInt8")))
RET CNF(File_writeUInt8);
 EI(keyStr.equals("writeInt8", CPL_STR_HASH("writeInt8")))
RET CNF(File_writeInt8);
 EI(keyStr.equals("writeUInt16LE", CPL_STR_HASH("writeUInt16LE")))
RET CNF(File_writeUInt16LE);
 EI(keyStr.equals("writeInt16LE", CPL_STR_HASH("writeInt16LE")))
RET CNF(File_writeInt16LE);
 EI(keyStr.equals("writeUInt32LE", CPL_STR_HASH("writeUInt32LE")))
RET CNF(File_writeUInt32LE);
 EI(keyStr.equals("writeInt32LE", CPL_STR_HASH("writeInt32LE")))
RET CNF(File_writeInt32LE);
 EI(keyStr.equals("writeUInt64LE", CPL_STR_HASH("writeUInt64LE")))
RET CNF(File_writeUInt64LE);
 EI(keyStr.equals("writeInt64LE", CPL_STR_HASH("writeInt64LE")))
RET CNF(File_writeInt64LE);
 EI(keyStr.equals("writeUInt16BE", CPL_STR_HASH("writeUInt16BE")))
RET CNF(File_writeUInt16BE);
 EI(keyStr.equals("writeInt16BE", CPL_STR_HASH("writeInt16BE")))
RET CNF(File_writeInt16BE);
 EI(keyStr.equals("writeUInt32BE", CPL_STR_HASH("writeUInt32BE")))
RET CNF(File_writeUInt32BE);
 EI(keyStr.equals("writeInt32BE", CPL_STR_HASH("writeInt32BE")))
RET CNF(File_writeInt32BE);
 EI(keyStr.equals("writeUInt64BE", CPL_STR_HASH("writeUInt64BE")))
RET CNF(File_writeUInt64BE);
 EI(keyStr.equals("writeInt64BE", CPL_STR_HASH("writeInt64BE")))
RET CNF(File_writeInt64BE);
 EI(keyStr.equals("writeFloat32", CPL_STR_HASH("writeFloat32")))
RET CNF(File_writeFloat32);
 EI(keyStr.equals("writeStr", CPL_STR_HASH("writeStr")))
RET CNF(File_writeStr);
 EI(keyStr.equals("printf", CPL_STR_HASH("printf")))
RET CNF(File_printf);
 EI(keyStr.equals("vprintf", CPL_STR_HASH("vprintf")))
RET CNF(File_vprintf);
 EI(keyStr.equals("writeChar", CPL_STR_HASH("writeChar")))
RET CNF(File_writeChar);
 else
 CATE(KE,"Unknown member for File."));
}
}
RET CN;
}

void File_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for File."));
}
}
}

SV File_readFloat32(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readFloat32" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readFloat32());
;
}
CATE(TE,UFOF("File::readFloat32.")));
RET CN;
}

SV File_writeStr(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeStr" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Str))
{
( f->writeStr(val_to_c<std::remove_reference<Str>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeStr.")));
RET CN;
}

SV File_printf(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::printf" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

CATE(TE,UFOF("File::printf.")));
RET CN;
}

SV File_readUInt8(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readUInt8" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readUInt8());
;
}
CATE(TE,UFOF("File::readUInt8.")));
RET CN;
}

SV File_getSize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::getSize" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getSize());
;
}
CATE(TE,UFOF("File::getSize.")));
RET CN;
}

SV File_readInt32LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readInt32LE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readInt32LE());
;
}
CATE(TE,UFOF("File::readInt32LE.")));
RET CN;
}

SV File_flush(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::flush" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->flush());
RET CN;
}
CATE(TE,UFOF("File::flush.")));
RET CN;
}

SV File_writeChar(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeChar" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],char))
{
( f->writeChar(val_to_c<std::remove_reference<char>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeChar.")));
RET CN;
}

SV File_seek(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::seek" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],long)&&TS(a[2],FileOrigin))
{
( f->seek(val_to_c<std::remove_reference<long>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<FileOrigin>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("File::seek.")));
RET CN;
}

SV File_readInt8(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readInt8" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readInt8());
;
}
CATE(TE,UFOF("File::readInt8.")));
RET CN;
}

SV File_readInt32BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readInt32BE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readInt32BE());
;
}
CATE(TE,UFOF("File::readInt32BE.")));
RET CN;
}

SV File_writeInt32BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeInt32BE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
( f->writeInt32BE(val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeInt32BE.")));
RET CN;
}

SV File_readStr(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readStr" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->readStr(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("File::readStr.")));
RET CN;
}

SV File_readInt64LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readInt64LE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readInt64LE());
;
}
CATE(TE,UFOF("File::readInt64LE.")));
RET CN;
}

SV File_writeUInt32BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeUInt32BE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
( f->writeUInt32BE(val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeUInt32BE.")));
RET CN;
}

SV File_writeUInt64LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeUInt64LE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],uint64_t))
{
( f->writeUInt64LE(val_to_c<std::remove_reference<uint64_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeUInt64LE.")));
RET CN;
}

SV File_write(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::write" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const ResizableData &))
{
( f->write(val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::write.")));
RET CN;
}

SV File_writeFloat32(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeFloat32" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->writeFloat32(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeFloat32.")));
RET CN;
}

SV File_writeInt64BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeInt64BE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],int64_t))
{
( f->writeInt64BE(val_to_c<std::remove_reference<int64_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeInt64BE.")));
RET CN;
}

SV File_readUInt32LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readUInt32LE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readUInt32LE());
;
}
CATE(TE,UFOF("File::readUInt32LE.")));
RET CN;
}

SV File_tell(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::tell" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->tell());
;
}
CATE(TE,UFOF("File::tell.")));
RET CN;
}

SV File_writeUInt32LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeUInt32LE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
( f->writeUInt32LE(val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeUInt32LE.")));
RET CN;
}

SV File_vprintf(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::vprintf" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

CATE(TE,UFOF("File::vprintf.")));
RET CN;
}

SV File_writeUInt64BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeUInt64BE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],uint64_t))
{
( f->writeUInt64BE(val_to_c<std::remove_reference<uint64_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeUInt64BE.")));
RET CN;
}

SV File_read(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::read" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->read(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("File::read.")));
RET CN;
}

SV File_readInt64BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readInt64BE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readInt64BE());
;
}
CATE(TE,UFOF("File::readInt64BE.")));
RET CN;
}

SV File_writeInt16LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeInt16LE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],int16_t))
{
( f->writeInt16LE(val_to_c<std::remove_reference<int16_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeInt16LE.")));
RET CN;
}

SV File_isAtEndOfFile(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::isAtEndOfFile" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->isAtEndOfFile());
;
}
CATE(TE,UFOF("File::isAtEndOfFile.")));
RET CN;
}

SV File_writeInt64LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeInt64LE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],int64_t))
{
( f->writeInt64LE(val_to_c<std::remove_reference<int64_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeInt64LE.")));
RET CN;
}

SV File_readUInt32BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readUInt32BE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readUInt32BE());
;
}
CATE(TE,UFOF("File::readUInt32BE.")));
RET CN;
}

SV File_readChar(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readChar" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readChar());
;
}
CATE(TE,UFOF("File::readChar.")));
RET CN;
}

SV File_readUInt16BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readUInt16BE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readUInt16BE());
;
}
CATE(TE,UFOF("File::readUInt16BE.")));
RET CN;
}

SV File_writeInt32LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeInt32LE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
( f->writeInt32LE(val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeInt32LE.")));
RET CN;
}

SV File_readUInt64LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readUInt64LE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readUInt64LE());
;
}
CATE(TE,UFOF("File::readUInt64LE.")));
RET CN;
}

SV File_writeUInt16LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeUInt16LE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],uint16_t))
{
( f->writeUInt16LE(val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeUInt16LE.")));
RET CN;
}

SV File_writeInt8(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeInt8" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],int8_t))
{
( f->writeInt8(val_to_c<std::remove_reference<int8_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeInt8.")));
RET CN;
}

SV File_readInt16BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readInt16BE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readInt16BE());
;
}
CATE(TE,UFOF("File::readInt16BE.")));
RET CN;
}

SV File_writeUInt16BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeUInt16BE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],uint16_t))
{
( f->writeUInt16BE(val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeUInt16BE.")));
RET CN;
}

SV File_writeUInt8(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeUInt8" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],uint8_t))
{
( f->writeUInt8(val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeUInt8.")));
RET CN;
}

SV File_readInt16LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readInt16LE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readInt16LE());
;
}
CATE(TE,UFOF("File::readInt16LE.")));
RET CN;
}

SV File_readUInt16LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readUInt16LE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readUInt16LE());
;
}
CATE(TE,UFOF("File::readUInt16LE.")));
RET CN;
}

SV File_readUInt64BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readUInt64BE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readUInt64BE());
;
}
CATE(TE,UFOF("File::readUInt64BE.")));
RET CN;
}

SV File_writeInt16BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeInt16BE" EAOE));
File*f;
f=(File*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],int16_t))
{
( f->writeInt16BE(val_to_c<std::remove_reference<int16_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeInt16BE.")));
RET CN;
}

void Matrix3x3_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Matrix3x3))
CATE(TE,"Matrix3x3::__del__ expects Matrix3x3 as first argument."));

SCRIPT_DELETE((Matrix3x3*)f->data);
}SV Matrix3x3_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3's constructor" EAOE));
if(!TS(a[0],Matrix3x3))
CATE(TE,"Matrix3x3's constructor expects Matrix3x3 as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(Matrix3x3));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Matrix3x3_funcs,p,EXT->Matrix3x3_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const Matrix4x4 &)){
void *p = (void *)NEW(TYPE(Matrix3x3),val_to_c<const Matrix4x4 &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Matrix3x3_funcs,p,EXT->Matrix3x3_typeID);
}if(a.getCount()==4)
if(true&&TS(a[1],const Float3 &)&&TS(a[2],const Float3 &)&&TS(a[3],const Float3 &)){
void *p = (void *)NEW(TYPE(Matrix3x3),val_to_c<const Float3 &>::f(ctx,a[1]),val_to_c<const Float3 &>::f(ctx,a[2]),val_to_c<const Float3 &>::f(ctx,a[3]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Matrix3x3_funcs,p,EXT->Matrix3x3_typeID);
}CATE(TE,UFOF("Matrix3x3's constructor.")));
RET CN;
}

SV Matrix3x3_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Matrix3x3");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Matrix3x3_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Matrix3x3_new);
else
 CATE(KE,"Unknown member for Matrix3x3."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Matrix3x3_new);
 EI(keyStr.equals("__mul__", CPL_STR_HASH("__mul__")))
RET CNF(Matrix3x3___mul__);
 EI(keyStr.equals("__div__", CPL_STR_HASH("__div__")))
RET CNF(Matrix3x3___div__);
 EI(keyStr.equals("get", CPL_STR_HASH("get")))
RET CNF(Matrix3x3_get);
 EI(keyStr.equals("set", CPL_STR_HASH("set")))
RET CNF(Matrix3x3_set);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(Matrix3x3___eq__);
 EI(keyStr.equals("transpose", CPL_STR_HASH("transpose")))
RET CNF(Matrix3x3_transpose);
 EI(keyStr.equals("inverse", CPL_STR_HASH("inverse")))
RET CNF(Matrix3x3_inverse);
 EI(keyStr.equals("translate", CPL_STR_HASH("translate")))
RET CNF(Matrix3x3_translate);
 EI(keyStr.equals("scale", CPL_STR_HASH("scale")))
RET CNF(Matrix3x3_scale);
 EI(keyStr.equals("rotate", CPL_STR_HASH("rotate")))
RET CNF(Matrix3x3_rotate);
 EI(keyStr.equals("rotatex", CPL_STR_HASH("rotatex")))
RET CNF(Matrix3x3_rotatex);
 EI(keyStr.equals("rotatey", CPL_STR_HASH("rotatey")))
RET CNF(Matrix3x3_rotatey);
 EI(keyStr.equals("rotatez", CPL_STR_HASH("rotatez")))
RET CNF(Matrix3x3_rotatez);
 else
 CATE(KE,"Unknown member for Matrix3x3."));
}
}
RET CN;
}

void Matrix3x3_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for Matrix3x3."));
}
}
}

SV Matrix3x3_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::set" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t)&&TS(a[3],float))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("Matrix3x3::set.")));
RET CN;
}

SV Matrix3x3_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::get" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("Matrix3x3::get.")));
RET CN;
}

SV Matrix3x3_transpose(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::transpose" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->transpose());
;
}
CATE(TE,UFOF("Matrix3x3::transpose.")));
RET CN;
}

SV Matrix3x3_rotatez(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::rotatez" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->rotatez(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix3x3::rotatez.")));
RET CN;
}

SV Matrix3x3_rotatex(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::rotatex" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->rotatex(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix3x3::rotatex.")));
RET CN;
}

SV Matrix3x3_rotatey(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::rotatey" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->rotatey(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix3x3::rotatey.")));
RET CN;
}

SV Matrix3x3___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::__div__" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("Matrix3x3::__div__.")));
RET CN;
}

SV Matrix3x3_inverse(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::inverse" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->inverse());
;
}
CATE(TE,UFOF("Matrix3x3::inverse.")));
RET CN;
}

SV Matrix3x3___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::__mul__" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Matrix3x3 &))
{
auto v=val_to_c<std::remove_reference<const Matrix3x3 &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
auto v=val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Matrix3x3::__mul__.")));
RET CN;
}

SV Matrix3x3_translate(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::translate" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float2 &))
{
RET CV( f->translate(val_to_c<std::remove_reference<const Float2 &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix3x3::translate.")));
RET CN;
}

SV Matrix3x3___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::__eq__" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Matrix3x3 &))
{
auto v=val_to_c<std::remove_reference<const Matrix3x3 &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Matrix3x3::__eq__.")));
RET CN;
}

SV Matrix3x3_rotate(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::rotate" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->rotate(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix3x3::rotate.")));
RET CN;
}

SV Matrix3x3_scale(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::scale" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
RET CV( f->scale(val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix3x3::scale.")));
RET CN;
}

void GPUTimer_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GPUTimer))
CATE(TE,"GPUTimer::__del__ expects GPUTimer as first argument."));

SCRIPT_DELETE((GPUTimer*)f->data);
}SV GPUTimer_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GPUTimer's constructor" EAOE));
if(!TS(a[0],GPUTimer))
CATE(TE,"GPUTimer's constructor expects GPUTimer as first argument."));
CATE(TE,UFOF("GPUTimer's constructor.")));
}

SV GPUTimer_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GPUTimer");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GPUTimer_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GPUTimer_new);
else
 CATE(KE,"Unknown member for GPUTimer."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GPUTimer_new);
 EI(keyStr.equals("resultAvailable", CPL_STR_HASH("resultAvailable")))
RET CNF(GPUTimer_resultAvailable);
 EI(keyStr.equals("getResult", CPL_STR_HASH("getResult")))
RET CNF(GPUTimer_getResult);
 EI(keyStr.equals("getResultResolution", CPL_STR_HASH("getResultResolution")))
RET CNF(GPUTimer_getResultResolution);
 EI(keyStr.equals("begin", CPL_STR_HASH("begin")))
RET CNF(GPUTimer_begin);
 EI(keyStr.equals("end", CPL_STR_HASH("end")))
RET CNF(GPUTimer_end);
 EI(keyStr.equals("swap", CPL_STR_HASH("swap")))
RET CNF(GPUTimer_swap);
 else
 CATE(KE,"Unknown member for GPUTimer."));
}
}
RET CN;
}

void GPUTimer_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for GPUTimer."));
}
}
}

SV GPUTimer_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GPUTimer::begin" EAOE));
GPUTimer*f;
f=(GPUTimer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->begin());
RET CN;
}
CATE(TE,UFOF("GPUTimer::begin.")));
RET CN;
}

SV GPUTimer_resultAvailable(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GPUTimer::resultAvailable" EAOE));
GPUTimer*f;
f=(GPUTimer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->resultAvailable());
;
}
CATE(TE,UFOF("GPUTimer::resultAvailable.")));
RET CN;
}

SV GPUTimer_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GPUTimer::end" EAOE));
GPUTimer*f;
f=(GPUTimer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->end());
RET CN;
}
CATE(TE,UFOF("GPUTimer::end.")));
RET CN;
}

SV GPUTimer_getResultResolution(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GPUTimer::getResultResolution" EAOE));
GPUTimer*f;
f=(GPUTimer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getResultResolution());
;
}
CATE(TE,UFOF("GPUTimer::getResultResolution.")));
RET CN;
}

SV GPUTimer_getResult(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GPUTimer::getResult" EAOE));
GPUTimer*f;
f=(GPUTimer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getResult());
;
}
CATE(TE,UFOF("GPUTimer::getResult.")));
RET CN;
}

SV GPUTimer_swap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GPUTimer::swap" EAOE));
GPUTimer*f;
f=(GPUTimer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->swap());
RET CN;
}
CATE(TE,UFOF("GPUTimer::swap.")));
RET CN;
}

void Filesystem_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Filesystem))
CATE(TE,"Filesystem::__del__ expects Filesystem as first argument."));

SCRIPT_DELETE((Filesystem*)f->data);
}SV Filesystem_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Filesystem's constructor" EAOE));
if(!TS(a[0],Filesystem))
CATE(TE,"Filesystem's constructor expects Filesystem as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(Filesystem));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Filesystem_funcs,p,EXT->Filesystem_typeID);
}CATE(TE,UFOF("Filesystem's constructor.")));
RET CN;
}

SV Filesystem_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Filesystem");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Filesystem_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Filesystem_new);
else
 CATE(KE,"Unknown member for Filesystem."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Filesystem_new);
 EI(keyStr.equals("pushSearchPaths", CPL_STR_HASH("pushSearchPaths")))
RET CNF(Filesystem_pushSearchPaths);
 EI(keyStr.equals("popSearchPaths", CPL_STR_HASH("popSearchPaths")))
RET CNF(Filesystem_popSearchPaths);
 EI(keyStr.equals("addSearchPath", CPL_STR_HASH("addSearchPath")))
RET CNF(Filesystem_addSearchPath);
 EI(keyStr.equals("getAbsolutePath", CPL_STR_HASH("getAbsolutePath")))
RET CNF(Filesystem_getAbsolutePath);
 else
 CATE(KE,"Unknown member for Filesystem."));
}
}
RET CN;
}

void Filesystem_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for Filesystem."));
}
}
}

SV Filesystem_addSearchPath(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Filesystem::addSearchPath" EAOE));
Filesystem*f;
f=(Filesystem*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
( f->addSearchPath(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Filesystem::addSearchPath.")));
RET CN;
}

SV Filesystem_pushSearchPaths(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Filesystem::pushSearchPaths" EAOE));
Filesystem*f;
f=(Filesystem*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->pushSearchPaths());
RET CN;
}
CATE(TE,UFOF("Filesystem::pushSearchPaths.")));
RET CN;
}

SV Filesystem_popSearchPaths(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Filesystem::popSearchPaths" EAOE));
Filesystem*f;
f=(Filesystem*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->popSearchPaths());
RET CN;
}
CATE(TE,UFOF("Filesystem::popSearchPaths.")));
RET CN;
}

SV Filesystem_getAbsolutePath(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Filesystem::getAbsolutePath" EAOE));
Filesystem*f;
f=(Filesystem*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const char *))
{
RET CV( f->getAbsolutePath(val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Filesystem::getAbsolutePath.")));
RET CN;
}

void GfxFramebuffer_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GfxFramebuffer))
CATE(TE,"GfxFramebuffer::__del__ expects GfxFramebuffer as first argument."));

SCRIPT_DELETE((GfxFramebuffer*)f->data);
}SV GfxFramebuffer_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxFramebuffer's constructor" EAOE));
if(!TS(a[0],GfxFramebuffer))
CATE(TE,"GfxFramebuffer's constructor expects GfxFramebuffer as first argument."));
CATE(TE,UFOF("GfxFramebuffer's constructor.")));
}

SV GfxFramebuffer_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxFramebuffer");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxFramebuffer_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxFramebuffer_new);
else
 CATE(KE,"Unknown member for GfxFramebuffer."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxFramebuffer_new);
 EI(keyStr.equals("addColorAttachment", CPL_STR_HASH("addColorAttachment")))
RET CNF(GfxFramebuffer_addColorAttachment);
 EI(keyStr.equals("removeColorAttachment", CPL_STR_HASH("removeColorAttachment")))
RET CNF(GfxFramebuffer_removeColorAttachment);
 EI(keyStr.equals("getNumColorAttachments", CPL_STR_HASH("getNumColorAttachments")))
RET CNF(GfxFramebuffer_getNumColorAttachments);
 EI(keyStr.equals("getColorRT", CPL_STR_HASH("getColorRT")))
RET CNF(GfxFramebuffer_getColorRT);
 EI(keyStr.equals("getColorAttachment", CPL_STR_HASH("getColorAttachment")))
RET CNF(GfxFramebuffer_getColorAttachment);
 EI(keyStr.equals("getColorAttachmentMipmapLevel", CPL_STR_HASH("getColorAttachmentMipmapLevel")))
RET CNF(GfxFramebuffer_getColorAttachmentMipmapLevel);
 EI(keyStr.equals("getColorAttachmentLayer", CPL_STR_HASH("getColorAttachmentLayer")))
RET CNF(GfxFramebuffer_getColorAttachmentLayer);
 EI(keyStr.equals("setDepthAttachment", CPL_STR_HASH("setDepthAttachment")))
RET CNF(GfxFramebuffer_setDepthAttachment);
 EI(keyStr.equals("removeDepthAttachment", CPL_STR_HASH("removeDepthAttachment")))
RET CNF(GfxFramebuffer_removeDepthAttachment);
 EI(keyStr.equals("hasDepthAttachment", CPL_STR_HASH("hasDepthAttachment")))
RET CNF(GfxFramebuffer_hasDepthAttachment);
 EI(keyStr.equals("getDepthTexture", CPL_STR_HASH("getDepthTexture")))
RET CNF(GfxFramebuffer_getDepthTexture);
 EI(keyStr.equals("getDepthTextureMipmapLevel", CPL_STR_HASH("getDepthTextureMipmapLevel")))
RET CNF(GfxFramebuffer_getDepthTextureMipmapLevel);
 EI(keyStr.equals("getDepthAttachmentLayer", CPL_STR_HASH("getDepthAttachmentLayer")))
RET CNF(GfxFramebuffer_getDepthAttachmentLayer);
 else
 CATE(KE,"Unknown member for GfxFramebuffer."));
}
}
RET CN;
}

void GfxFramebuffer_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for GfxFramebuffer."));
}
}
}

SV GfxFramebuffer_getDepthTextureMipmapLevel(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::getDepthTextureMipmapLevel" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDepthTextureMipmapLevel());
;
}
CATE(TE,UFOF("GfxFramebuffer::getDepthTextureMipmapLevel.")));
RET CN;
}

SV GfxFramebuffer_removeDepthAttachment(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::removeDepthAttachment" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeDepthAttachment());
RET CN;
}
CATE(TE,UFOF("GfxFramebuffer::removeDepthAttachment.")));
RET CN;
}

SV GfxFramebuffer_getColorAttachmentLayer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::getColorAttachmentLayer" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getColorAttachmentLayer(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxFramebuffer::getColorAttachmentLayer.")));
RET CN;
}

SV GfxFramebuffer_getColorAttachment(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::getColorAttachment" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getColorAttachment(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxFramebuffer::getColorAttachment.")));
RET CN;
}

SV GfxFramebuffer_setDepthAttachment(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::setDepthAttachment" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],GfxTexture *)&&TS(a[2],size_t)&&TS(a[3],int))
{
( f->setDepthAttachment(val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("GfxFramebuffer::setDepthAttachment.")));
RET CN;
}

SV GfxFramebuffer_removeColorAttachment(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::removeColorAttachment" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->removeColorAttachment(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxFramebuffer::removeColorAttachment.")));
RET CN;
}

SV GfxFramebuffer_getDepthAttachmentLayer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::getDepthAttachmentLayer" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDepthAttachmentLayer());
;
}
CATE(TE,UFOF("GfxFramebuffer::getDepthAttachmentLayer.")));
RET CN;
}

SV GfxFramebuffer_getColorRT(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::getColorRT" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getColorRT(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxFramebuffer::getColorRT.")));
RET CN;
}

SV GfxFramebuffer_getDepthTexture(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::getDepthTexture" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDepthTexture());
;
}
CATE(TE,UFOF("GfxFramebuffer::getDepthTexture.")));
RET CN;
}

SV GfxFramebuffer_getColorAttachmentMipmapLevel(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::getColorAttachmentMipmapLevel" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getColorAttachmentMipmapLevel(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxFramebuffer::getColorAttachmentMipmapLevel.")));
RET CN;
}

SV GfxFramebuffer_hasDepthAttachment(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::hasDepthAttachment" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->hasDepthAttachment());
;
}
CATE(TE,UFOF("GfxFramebuffer::hasDepthAttachment.")));
RET CN;
}

SV GfxFramebuffer_addColorAttachment(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::addColorAttachment" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0].p)->data;

if(a.getCount()==5)
if(1&&TS(a[1],size_t)&&TS(a[2],GfxTexture *)&&TS(a[3],size_t)&&TS(a[4],int))
{
( f->addColorAttachment(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[4])));
RET CN;
}
CATE(TE,UFOF("GfxFramebuffer::addColorAttachment.")));
RET CN;
}

SV GfxFramebuffer_getNumColorAttachments(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::getNumColorAttachments" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getNumColorAttachments());
;
}
CATE(TE,UFOF("GfxFramebuffer::getNumColorAttachments.")));
RET CN;
}

void Event_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Event))
CATE(TE,"Event::__del__ expects Event as first argument."));

SCRIPT_DELETE((Event*)f->data);
}SV Event_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Event's constructor" EAOE));
if(!TS(a[0],Event))
CATE(TE,"Event's constructor expects Event as first argument."));
RET STG::createNativeObject(Event_funcs,NEW(TYPE(Event)),EXT->Event_typeID);
}

SV Event_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Event");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Event_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Event_new);
else
 CATE(KE,"Unknown member for Event."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Event_new);
 EI(keyStr.equals("getWidth", CPL_STR_HASH("getWidth")))
RET CNF(Event_getWidth);
 EI(keyStr.equals("getHeight", CPL_STR_HASH("getHeight")))
RET CNF(Event_getHeight);
 EI(keyStr.equals("getKey", CPL_STR_HASH("getKey")))
RET CNF(Event_getKey);
 EI(keyStr.equals("getX", CPL_STR_HASH("getX")))
RET CNF(Event_getX);
 EI(keyStr.equals("getY", CPL_STR_HASH("getY")))
RET CNF(Event_getY);
 EI(keyStr.equals("getRelX", CPL_STR_HASH("getRelX")))
RET CNF(Event_getRelX);
 EI(keyStr.equals("getRelY", CPL_STR_HASH("getRelY")))
RET CNF(Event_getRelY);
 EI(keyStr.equals("getButton", CPL_STR_HASH("getButton")))
RET CNF(Event_getButton);
 EI(keyStr.equals("getDoubleClicked", CPL_STR_HASH("getDoubleClicked")))
RET CNF(Event_getDoubleClicked);
 EI(keyStr.equals("type", CPL_STR_HASH("type")))
{
Event*obj=(Event*)f->data;
RET CV(obj->type);
} else
 CATE(KE,"Unknown member for Event."));
}
}
RET CN;
}

void Event_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("type", CPL_STR_HASH("type")))
{
Event*obj=(Event*)f->data;
obj->type=val_to_c<decltype(obj->type)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for Event."));
}
}
}

SV Event_getX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getX" EAOE));
Event*f;
f=(Event*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getX());
;
}
CATE(TE,UFOF("Event::getX.")));
RET CN;
}

SV Event_getButton(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getButton" EAOE));
Event*f;
f=(Event*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getButton());
;
}
CATE(TE,UFOF("Event::getButton.")));
RET CN;
}

SV Event_getRelX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getRelX" EAOE));
Event*f;
f=(Event*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRelX());
;
}
CATE(TE,UFOF("Event::getRelX.")));
RET CN;
}

SV Event_getHeight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getHeight" EAOE));
Event*f;
f=(Event*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getHeight());
;
}
CATE(TE,UFOF("Event::getHeight.")));
RET CN;
}

SV Event_getRelY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getRelY" EAOE));
Event*f;
f=(Event*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRelY());
;
}
CATE(TE,UFOF("Event::getRelY.")));
RET CN;
}

SV Event_getKey(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getKey" EAOE));
Event*f;
f=(Event*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getKey());
;
}
CATE(TE,UFOF("Event::getKey.")));
RET CN;
}

SV Event_getWidth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getWidth" EAOE));
Event*f;
f=(Event*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWidth());
;
}
CATE(TE,UFOF("Event::getWidth.")));
RET CN;
}

SV Event_getY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getY" EAOE));
Event*f;
f=(Event*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getY());
;
}
CATE(TE,UFOF("Event::getY.")));
RET CN;
}

SV Event_getDoubleClicked(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getDoubleClicked" EAOE));
Event*f;
f=(Event*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDoubleClicked());
;
}
CATE(TE,UFOF("Event::getDoubleClicked.")));
RET CN;
}

void Platform_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Platform))
CATE(TE,"Platform::__del__ expects Platform as first argument."));

SCRIPT_DELETE((Platform*)f->data);
}SV Platform_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform's constructor" EAOE));
if(!TS(a[0],Platform))
CATE(TE,"Platform's constructor expects Platform as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(Platform));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Platform_funcs,p,EXT->Platform_typeID);
}CATE(TE,UFOF("Platform's constructor.")));
RET CN;
}

SV Platform_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Platform");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Platform_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Platform_new);
else
 CATE(KE,"Unknown member for Platform."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Platform_new);
 EI(keyStr.equals("initWindow", CPL_STR_HASH("initWindow")))
RET CNF(Platform_initWindow);
 EI(keyStr.equals("destroyWindow", CPL_STR_HASH("destroyWindow")))
RET CNF(Platform_destroyWindow);
 EI(keyStr.equals("run", CPL_STR_HASH("run")))
RET CNF(Platform_run);
 EI(keyStr.equals("pollEvent", CPL_STR_HASH("pollEvent")))
RET CNF(Platform_pollEvent);
 EI(keyStr.equals("eventsLeft", CPL_STR_HASH("eventsLeft")))
RET CNF(Platform_eventsLeft);
 EI(keyStr.equals("popEvent", CPL_STR_HASH("popEvent")))
RET CNF(Platform_popEvent);
 EI(keyStr.equals("getTime", CPL_STR_HASH("getTime")))
RET CNF(Platform_getTime);
 EI(keyStr.equals("getTimerFrequency", CPL_STR_HASH("getTimerFrequency")))
RET CNF(Platform_getTimerFrequency);
 EI(keyStr.equals("getWindowWidth", CPL_STR_HASH("getWindowWidth")))
RET CNF(Platform_getWindowWidth);
 EI(keyStr.equals("getWindowHeight", CPL_STR_HASH("getWindowHeight")))
RET CNF(Platform_getWindowHeight);
 EI(keyStr.equals("getMousePosition", CPL_STR_HASH("getMousePosition")))
RET CNF(Platform_getMousePosition);
 EI(keyStr.equals("setMousePosition", CPL_STR_HASH("setMousePosition")))
RET CNF(Platform_setMousePosition);
 EI(keyStr.equals("isLeftMouseButtonPressed", CPL_STR_HASH("isLeftMouseButtonPressed")))
RET CNF(Platform_isLeftMouseButtonPressed);
 EI(keyStr.equals("isRightMouseButtonPressed", CPL_STR_HASH("isRightMouseButtonPressed")))
RET CNF(Platform_isRightMouseButtonPressed);
 EI(keyStr.equals("isMiddleMouseButtonPressed", CPL_STR_HASH("isMiddleMouseButtonPressed")))
RET CNF(Platform_isMiddleMouseButtonPressed);
 EI(keyStr.equals("getMouseWheel", CPL_STR_HASH("getMouseWheel")))
RET CNF(Platform_getMouseWheel);
 EI(keyStr.equals("isCursorVisible", CPL_STR_HASH("isCursorVisible")))
RET CNF(Platform_isCursorVisible);
 EI(keyStr.equals("setCursorVisible", CPL_STR_HASH("setCursorVisible")))
RET CNF(Platform_setCursorVisible);
 EI(keyStr.equals("isKeyPressed", CPL_STR_HASH("isKeyPressed")))
RET CNF(Platform_isKeyPressed);
 EI(keyStr.equals("getFullscreen", CPL_STR_HASH("getFullscreen")))
RET CNF(Platform_getFullscreen);
 EI(keyStr.equals("setFullscreen", CPL_STR_HASH("setFullscreen")))
RET CNF(Platform_setFullscreen);
 EI(keyStr.equals("getFrametime", CPL_STR_HASH("getFrametime")))
RET CNF(Platform_getFrametime);
 EI(keyStr.equals("getGPUFrametime", CPL_STR_HASH("getGPUFrametime")))
RET CNF(Platform_getGPUFrametime);
 EI(keyStr.equals("getCPUFrametime", CPL_STR_HASH("getCPUFrametime")))
RET CNF(Platform_getCPUFrametime);
 EI(keyStr.equals("running", CPL_STR_HASH("running")))
{
Platform*obj=(Platform*)f->data;
RET CV(obj->running);
} else
 CATE(KE,"Unknown member for Platform."));
}
}
RET CN;
}

void Platform_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("running", CPL_STR_HASH("running")))
{
Platform*obj=(Platform*)f->data;
obj->running=val_to_c<decltype(obj->running)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for Platform."));
}
}
}

SV Platform_setFullscreen(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::setFullscreen" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],bool))
{
( f->setFullscreen(val_to_c<std::remove_reference<bool>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Platform::setFullscreen.")));
RET CN;
}

SV Platform_getTime(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getTime" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getTime());
;
}
CATE(TE,UFOF("Platform::getTime.")));
RET CN;
}

SV Platform_eventsLeft(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::eventsLeft" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->eventsLeft());
;
}
CATE(TE,UFOF("Platform::eventsLeft.")));
RET CN;
}

SV Platform_setMousePosition(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::setMousePosition" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Int2))
{
( f->setMousePosition(val_to_c<std::remove_reference<Int2>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Platform::setMousePosition.")));
RET CN;
}

SV Platform_getMousePosition(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getMousePosition" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getMousePosition());
;
}
CATE(TE,UFOF("Platform::getMousePosition.")));
RET CN;
}

SV Platform_setCursorVisible(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::setCursorVisible" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],bool))
{
( f->setCursorVisible(val_to_c<std::remove_reference<bool>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Platform::setCursorVisible.")));
RET CN;
}

SV Platform_isRightMouseButtonPressed(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::isRightMouseButtonPressed" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->isRightMouseButtonPressed());
;
}
CATE(TE,UFOF("Platform::isRightMouseButtonPressed.")));
RET CN;
}

SV Platform_getFullscreen(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getFullscreen" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFullscreen());
;
}
CATE(TE,UFOF("Platform::getFullscreen.")));
RET CN;
}

SV Platform_getFrametime(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getFrametime" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFrametime());
;
}
CATE(TE,UFOF("Platform::getFrametime.")));
RET CN;
}

SV Platform_initWindow(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::initWindow" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],uint32_t)&&TS(a[2],uint32_t))
{
( f->initWindow(val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("Platform::initWindow.")));
RET CN;
}

SV Platform_isKeyPressed(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::isKeyPressed" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Key))
{
RET CV( f->isKeyPressed(val_to_c<std::remove_reference<Key>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Platform::isKeyPressed.")));
RET CN;
}

SV Platform_destroyWindow(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::destroyWindow" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->destroyWindow());
RET CN;
}
CATE(TE,UFOF("Platform::destroyWindow.")));
RET CN;
}

SV Platform_run(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::run" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

CATE(TE,UFOF("Platform::run.")));
RET CN;
}

SV Platform_getWindowWidth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getWindowWidth" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWindowWidth());
;
}
CATE(TE,UFOF("Platform::getWindowWidth.")));
RET CN;
}

SV Platform_popEvent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::popEvent" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->popEvent());
;
}
CATE(TE,UFOF("Platform::popEvent.")));
RET CN;
}

SV Platform_getTimerFrequency(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getTimerFrequency" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getTimerFrequency());
;
}
CATE(TE,UFOF("Platform::getTimerFrequency.")));
RET CN;
}

SV Platform_getWindowHeight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getWindowHeight" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWindowHeight());
;
}
CATE(TE,UFOF("Platform::getWindowHeight.")));
RET CN;
}

SV Platform_getMouseWheel(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getMouseWheel" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getMouseWheel());
;
}
CATE(TE,UFOF("Platform::getMouseWheel.")));
RET CN;
}

SV Platform_isMiddleMouseButtonPressed(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::isMiddleMouseButtonPressed" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->isMiddleMouseButtonPressed());
;
}
CATE(TE,UFOF("Platform::isMiddleMouseButtonPressed.")));
RET CN;
}

SV Platform_pollEvent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::pollEvent" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

CATE(TE,UFOF("Platform::pollEvent.")));
RET CN;
}

SV Platform_isLeftMouseButtonPressed(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::isLeftMouseButtonPressed" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->isLeftMouseButtonPressed());
;
}
CATE(TE,UFOF("Platform::isLeftMouseButtonPressed.")));
RET CN;
}

SV Platform_isCursorVisible(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::isCursorVisible" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->isCursorVisible());
;
}
CATE(TE,UFOF("Platform::isCursorVisible.")));
RET CN;
}

SV Platform_getCPUFrametime(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getCPUFrametime" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCPUFrametime());
;
}
CATE(TE,UFOF("Platform::getCPUFrametime.")));
RET CN;
}

SV Platform_getGPUFrametime(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getGPUFrametime" EAOE));
Platform*f;
f=(Platform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGPUFrametime());
;
}
CATE(TE,UFOF("Platform::getGPUFrametime.")));
RET CN;
}

void GfxMesh_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GfxMesh))
CATE(TE,"GfxMesh::__del__ expects GfxMesh as first argument."));

GfxMesh*obj=(GfxMesh*)f->data;
if(_scriptDeletePart(obj)){obj->release();}
}SV GfxMesh_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh's constructor" EAOE));
if(!TS(a[0],GfxMesh))
CATE(TE,"GfxMesh's constructor expects GfxMesh as first argument."));
if(a.getCount()==2)
if(true&&TS(a[1],const Str &)){
void *p = (void *)NEW(TYPE(GfxMesh),val_to_c<const Str &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxMesh_funcs,p,EXT->GfxMesh_typeID);
}if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(GfxMesh));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxMesh_funcs,p,EXT->GfxMesh_typeID);
}CATE(TE,UFOF("GfxMesh's constructor.")));
RET CN;
}

SV GfxMesh_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxMesh");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxMesh_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxMesh_new);
else
 CATE(KE,"Unknown member for GfxMesh."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxMesh_new);
 EI(keyStr.equals("addIndices", CPL_STR_HASH("addIndices")))
RET CNF(GfxMesh_addIndices);
 EI(keyStr.equals("removeIndices", CPL_STR_HASH("removeIndices")))
RET CNF(GfxMesh_removeIndices);
 EI(keyStr.equals("setAttribute", CPL_STR_HASH("setAttribute")))
RET CNF(GfxMesh_setAttribute);
 EI(keyStr.equals("removeAttribute", CPL_STR_HASH("removeAttribute")))
RET CNF(GfxMesh_removeAttribute);
 EI(keyStr.equals("getIndexed", CPL_STR_HASH("getIndexed")))
RET CNF(GfxMesh_getIndexed);
 EI(keyStr.equals("getIndexType", CPL_STR_HASH("getIndexType")))
RET CNF(GfxMesh_getIndexType);
 EI(keyStr.equals("getIndices", CPL_STR_HASH("getIndices")))
RET CNF(GfxMesh_getIndices);
 EI(keyStr.equals("getAttribs", CPL_STR_HASH("getAttribs")))
RET CNF(GfxMesh_getAttribs);
 EI(keyStr.equals("getAttribCount", CPL_STR_HASH("getAttribCount")))
RET CNF(GfxMesh_getAttribCount);
 EI(keyStr.equals("getAttrib", CPL_STR_HASH("getAttrib")))
RET CNF(GfxMesh_getAttrib);
 EI(keyStr.equals("getGLVAO", CPL_STR_HASH("getGLVAO")))
RET CNF(GfxMesh_getGLVAO);
 EI(keyStr.equals("getGLIndexBuffer", CPL_STR_HASH("getGLIndexBuffer")))
RET CNF(GfxMesh_getGLIndexBuffer);
 EI(keyStr.equals("removeContent", CPL_STR_HASH("removeContent")))
RET CNF(GfxMesh_removeContent);
 EI(keyStr.equals("save", CPL_STR_HASH("save")))
RET CNF(GfxMesh_save);
 EI(keyStr.equals("load", CPL_STR_HASH("load")))
RET CNF(GfxMesh_load);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(GfxMesh_copy);
 EI(keyStr.equals("getType", CPL_STR_HASH("getType")))
RET CNF(GfxMesh_getType);
 EI(keyStr.equals("release", CPL_STR_HASH("release")))
RET CNF(GfxMesh_release);
 EI(keyStr.equals("getRefCount", CPL_STR_HASH("getRefCount")))
RET CNF(GfxMesh_getRefCount);
 EI(keyStr.equals("getFilename", CPL_STR_HASH("getFilename")))
RET CNF(GfxMesh_getFilename);
 EI(keyStr.equals("setFilename", CPL_STR_HASH("setFilename")))
RET CNF(GfxMesh_setFilename);
 EI(keyStr.equals("aabb", CPL_STR_HASH("aabb")))
{
GfxMesh*obj=(GfxMesh*)f->data;
RET CV(obj->aabb);
} EI(keyStr.equals("numVertices", CPL_STR_HASH("numVertices")))
{
GfxMesh*obj=(GfxMesh*)f->data;
RET CV(obj->numVertices);
} EI(keyStr.equals("numIndices", CPL_STR_HASH("numIndices")))
{
GfxMesh*obj=(GfxMesh*)f->data;
RET CV(obj->numIndices);
} EI(keyStr.equals("primitive", CPL_STR_HASH("primitive")))
{
GfxMesh*obj=(GfxMesh*)f->data;
RET CV(obj->primitive);
} EI(keyStr.equals("cullMode", CPL_STR_HASH("cullMode")))
{
GfxMesh*obj=(GfxMesh*)f->data;
RET CV(obj->cullMode);
} EI(keyStr.equals("winding", CPL_STR_HASH("winding")))
{
GfxMesh*obj=(GfxMesh*)f->data;
RET CV(obj->winding);
} else
 CATE(KE,"Unknown member for GfxMesh."));
}
}
RET CN;
}

void GfxMesh_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("aabb", CPL_STR_HASH("aabb")))
{
GfxMesh*obj=(GfxMesh*)f->data;
obj->aabb=val_to_c<decltype(obj->aabb)>::f(ctx,value);
} EI(keyStr.equals("numVertices", CPL_STR_HASH("numVertices")))
{
GfxMesh*obj=(GfxMesh*)f->data;
obj->numVertices=val_to_c<decltype(obj->numVertices)>::f(ctx,value);
} EI(keyStr.equals("numIndices", CPL_STR_HASH("numIndices")))
{
GfxMesh*obj=(GfxMesh*)f->data;
obj->numIndices=val_to_c<decltype(obj->numIndices)>::f(ctx,value);
} EI(keyStr.equals("primitive", CPL_STR_HASH("primitive")))
{
GfxMesh*obj=(GfxMesh*)f->data;
obj->primitive=val_to_c<decltype(obj->primitive)>::f(ctx,value);
} EI(keyStr.equals("cullMode", CPL_STR_HASH("cullMode")))
{
GfxMesh*obj=(GfxMesh*)f->data;
obj->cullMode=val_to_c<decltype(obj->cullMode)>::f(ctx,value);
} EI(keyStr.equals("winding", CPL_STR_HASH("winding")))
{
GfxMesh*obj=(GfxMesh*)f->data;
obj->winding=val_to_c<decltype(obj->winding)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for GfxMesh."));
}
}
}

SV GfxMesh_getAttribs(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getAttribs" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

CATE(TE,UFOF("GfxMesh::getAttribs.")));
RET CN;
}

SV GfxMesh_getGLIndexBuffer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getGLIndexBuffer" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGLIndexBuffer());
;
}
CATE(TE,UFOF("GfxMesh::getGLIndexBuffer.")));
RET CN;
}

SV GfxMesh_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getType" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("GfxMesh::getType.")));
RET CN;
}

SV GfxMesh_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::copy" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("GfxMesh::copy.")));
RET CN;
}

SV GfxMesh_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::setFilename" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
( f->setFilename(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxMesh::setFilename.")));
RET CN;
}

SV GfxMesh_removeAttribute(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::removeAttribute" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxMeshAttribType))
{
( f->removeAttribute(val_to_c<std::remove_reference<GfxMeshAttribType>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxMesh::removeAttribute.")));
RET CN;
}

SV GfxMesh_getAttrib(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getAttrib" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getAttrib(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxMesh::getAttrib.")));
RET CN;
}

SV GfxMesh_removeIndices(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::removeIndices" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeIndices());
RET CN;
}
CATE(TE,UFOF("GfxMesh::removeIndices.")));
RET CN;
}

SV GfxMesh_getAttribCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getAttribCount" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAttribCount());
;
}
CATE(TE,UFOF("GfxMesh::getAttribCount.")));
RET CN;
}

SV GfxMesh_setAttribute(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::setAttribute" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const GfxMeshAttrib &))
{
( f->setAttribute(val_to_c<std::remove_reference<const GfxMeshAttrib &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxMesh::setAttribute.")));
RET CN;
}

SV GfxMesh_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::load" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("GfxMesh::load.")));
RET CN;
}

SV GfxMesh_getGLVAO(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getGLVAO" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGLVAO());
;
}
CATE(TE,UFOF("GfxMesh::getGLVAO.")));
RET CN;
}

SV GfxMesh_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::removeContent" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("GfxMesh::removeContent.")));
RET CN;
}

SV GfxMesh_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getRefCount" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("GfxMesh::getRefCount.")));
RET CN;
}

SV GfxMesh_getIndices(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getIndices" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

CATE(TE,UFOF("GfxMesh::getIndices.")));
RET CN;
}

SV GfxMesh_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::release" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("GfxMesh::release.")));
RET CN;
}

SV GfxMesh_getIndexed(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getIndexed" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getIndexed());
;
}
CATE(TE,UFOF("GfxMesh::getIndexed.")));
RET CN;
}

SV GfxMesh_addIndices(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::addIndices" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],size_t)&&TS(a[2],GfxMeshIndexDataType)&&TS(a[3],const ResizableData &))
{
( f->addIndices(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxMeshIndexDataType>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("GfxMesh::addIndices.")));
RET CN;
}

SV GfxMesh_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::save" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("GfxMesh::save.")));
RET CN;
}

SV GfxMesh_getIndexType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getIndexType" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getIndexType());
;
}
CATE(TE,UFOF("GfxMesh::getIndexType.")));
RET CN;
}

SV GfxMesh_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getFilename" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("GfxMesh::getFilename.")));
RET CN;
}

void GfxShader_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GfxShader))
CATE(TE,"GfxShader::__del__ expects GfxShader as first argument."));

GfxShader*obj=(GfxShader*)f->data;
if(_scriptDeletePart(obj)){obj->release();}
}SV GfxShader_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader's constructor" EAOE));
if(!TS(a[0],GfxShader))
CATE(TE,"GfxShader's constructor expects GfxShader as first argument."));
if(a.getCount()==2)
if(true&&TS(a[1],const Str &)){
void *p = (void *)NEW(TYPE(GfxShader),val_to_c<const Str &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxShader_funcs,p,EXT->GfxShader_typeID);
}if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(GfxShader));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxShader_funcs,p,EXT->GfxShader_typeID);
}CATE(TE,UFOF("GfxShader's constructor.")));
RET CN;
}

SV GfxShader_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxShader");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxShader_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxShader_new);
else
 CATE(KE,"Unknown member for GfxShader."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxShader_new);
 EI(keyStr.equals("removeContent", CPL_STR_HASH("removeContent")))
RET CNF(GfxShader_removeContent);
 EI(keyStr.equals("save", CPL_STR_HASH("save")))
RET CNF(GfxShader_save);
 EI(keyStr.equals("compile", CPL_STR_HASH("compile")))
RET CNF(GfxShader_compile);
 EI(keyStr.equals("getSource", CPL_STR_HASH("getSource")))
RET CNF(GfxShader_getSource);
 EI(keyStr.equals("getShaderType", CPL_STR_HASH("getShaderType")))
RET CNF(GfxShader_getShaderType);
 EI(keyStr.equals("getCompiled", CPL_STR_HASH("getCompiled")))
RET CNF(GfxShader_getCompiled);
 EI(keyStr.equals("load", CPL_STR_HASH("load")))
RET CNF(GfxShader_load);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(GfxShader_copy);
 EI(keyStr.equals("getType", CPL_STR_HASH("getType")))
RET CNF(GfxShader_getType);
 EI(keyStr.equals("release", CPL_STR_HASH("release")))
RET CNF(GfxShader_release);
 EI(keyStr.equals("getRefCount", CPL_STR_HASH("getRefCount")))
RET CNF(GfxShader_getRefCount);
 EI(keyStr.equals("getFilename", CPL_STR_HASH("getFilename")))
RET CNF(GfxShader_getFilename);
 EI(keyStr.equals("setFilename", CPL_STR_HASH("setFilename")))
RET CNF(GfxShader_setFilename);
 else
 CATE(KE,"Unknown member for GfxShader."));
}
}
RET CN;
}

void GfxShader_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for GfxShader."));
}
}
}

SV GfxShader_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::load" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("GfxShader::load.")));
RET CN;
}

SV GfxShader_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::getFilename" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("GfxShader::getFilename.")));
RET CN;
}

SV GfxShader_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::copy" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("GfxShader::copy.")));
RET CN;
}

SV GfxShader_getCompiled(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::getCompiled" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const HashMap<Str, Str> &))
{
RET CV( f->getCompiled(val_to_c<std::remove_reference<const HashMap<Str, Str> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxShader::getCompiled.")));
RET CN;
}

SV GfxShader_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::getType" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("GfxShader::getType.")));
RET CN;
}

SV GfxShader_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::setFilename" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
( f->setFilename(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxShader::setFilename.")));
RET CN;
}

SV GfxShader_compile(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::compile" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],GfxShaderType)&&TS(a[2],const Str &))
{
( f->compile(val_to_c<std::remove_reference<GfxShaderType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxShader::compile.")));
RET CN;
}

SV GfxShader_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::removeContent" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("GfxShader::removeContent.")));
RET CN;
}

SV GfxShader_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::getRefCount" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("GfxShader::getRefCount.")));
RET CN;
}

SV GfxShader_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::release" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("GfxShader::release.")));
RET CN;
}

SV GfxShader_getSource(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::getSource" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getSource());
;
}
CATE(TE,UFOF("GfxShader::getSource.")));
RET CN;
}

SV GfxShader_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::save" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("GfxShader::save.")));
RET CN;
}

SV GfxShader_getShaderType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::getShaderType" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShaderType());
;
}
CATE(TE,UFOF("GfxShader::getShaderType.")));
RET CN;
}

void GfxAnimationState_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GfxAnimationState))
CATE(TE,"GfxAnimationState::__del__ expects GfxAnimationState as first argument."));

SCRIPT_DELETE((GfxAnimationState*)f->data);
}SV GfxAnimationState_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxAnimationState's constructor" EAOE));
if(!TS(a[0],GfxAnimationState))
CATE(TE,"GfxAnimationState's constructor expects GfxAnimationState as first argument."));
if(a.getCount()==3)
if(true&&TS(a[1],GfxMesh *)&&TS(a[2],const Str &)){
void *p = (void *)NEW(TYPE(GfxAnimationState),val_to_c<GfxMesh *>::f(ctx,a[1]),val_to_c<const Str &>::f(ctx,a[2]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxAnimationState_funcs,p,EXT->GfxAnimationState_typeID);
}CATE(TE,UFOF("GfxAnimationState's constructor.")));
RET CN;
}

SV GfxAnimationState_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxAnimationState");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxAnimationState_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxAnimationState_new);
else
 CATE(KE,"Unknown member for GfxAnimationState."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxAnimationState_new);
 EI(keyStr.equals("updateMatrices", CPL_STR_HASH("updateMatrices")))
RET CNF(GfxAnimationState_updateMatrices);
 EI(keyStr.equals("getAnimName", CPL_STR_HASH("getAnimName")))
RET CNF(GfxAnimationState_getAnimName);
 EI(keyStr.equals("getMesh", CPL_STR_HASH("getMesh")))
RET CNF(GfxAnimationState_getMesh);
 EI(keyStr.equals("getMatrixBuffer", CPL_STR_HASH("getMatrixBuffer")))
RET CNF(GfxAnimationState_getMatrixBuffer);
 EI(keyStr.equals("getNormalMatrixBuffer", CPL_STR_HASH("getNormalMatrixBuffer")))
RET CNF(GfxAnimationState_getNormalMatrixBuffer);
 EI(keyStr.equals("timeOffset", CPL_STR_HASH("timeOffset")))
{
GfxAnimationState*obj=(GfxAnimationState*)f->data;
RET CV(obj->timeOffset);
} else
 CATE(KE,"Unknown member for GfxAnimationState."));
}
}
RET CN;
}

void GfxAnimationState_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("timeOffset", CPL_STR_HASH("timeOffset")))
{
GfxAnimationState*obj=(GfxAnimationState*)f->data;
obj->timeOffset=val_to_c<decltype(obj->timeOffset)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for GfxAnimationState."));
}
}
}

SV GfxAnimationState_updateMatrices(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxAnimationState::updateMatrices" EAOE));
GfxAnimationState*f;
f=(GfxAnimationState*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->updateMatrices());
RET CN;
}
CATE(TE,UFOF("GfxAnimationState::updateMatrices.")));
RET CN;
}

SV GfxAnimationState_getMesh(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxAnimationState::getMesh" EAOE));
GfxAnimationState*f;
f=(GfxAnimationState*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getMesh());
;
}
CATE(TE,UFOF("GfxAnimationState::getMesh.")));
RET CN;
}

SV GfxAnimationState_getAnimName(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxAnimationState::getAnimName" EAOE));
GfxAnimationState*f;
f=(GfxAnimationState*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAnimName());
;
}
CATE(TE,UFOF("GfxAnimationState::getAnimName.")));
RET CN;
}

SV GfxAnimationState_getMatrixBuffer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxAnimationState::getMatrixBuffer" EAOE));
GfxAnimationState*f;
f=(GfxAnimationState*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getMatrixBuffer());
;
}
CATE(TE,UFOF("GfxAnimationState::getMatrixBuffer.")));
RET CN;
}

SV GfxAnimationState_getNormalMatrixBuffer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxAnimationState::getNormalMatrixBuffer" EAOE));
GfxAnimationState*f;
f=(GfxAnimationState*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getNormalMatrixBuffer());
;
}
CATE(TE,UFOF("GfxAnimationState::getNormalMatrixBuffer.")));
RET CN;
}

void StringList_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,List<Str>))
CATE(TE,"StringList::__del__ expects StringList as first argument."));

SCRIPT_DELETE((List<Str>*)f->data);
}SV StringList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList's constructor" EAOE));
if(!TS(a[0],List<Str>))
CATE(TE,"StringList's constructor expects StringList as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(List<Str>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(StringList_funcs,p,EXT->StringList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],std::size_t)){
void *p = (void *)NEW(TYPE(List<Str>),val_to_c<std::size_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(StringList_funcs,p,EXT->StringList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const List<Str> &)){
void *p = (void *)NEW(TYPE(List<Str>),val_to_c<const List<Str> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(StringList_funcs,p,EXT->StringList_typeID);
}CATE(TE,UFOF("StringList's constructor.")));
RET CN;
}

SV StringList_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("StringList");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(StringList_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(StringList_new);
else
 CATE(KE,"Unknown member for StringList."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(StringList_new);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(StringList___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(StringList___neq__);
 EI(keyStr.equals("get", CPL_STR_HASH("get")))
RET CNF(StringList_get);
 EI(keyStr.equals("set", CPL_STR_HASH("set")))
RET CNF(StringList_set);
 EI(keyStr.equals("getCount", CPL_STR_HASH("getCount")))
RET CNF(StringList_getCount);
 EI(keyStr.equals("getData", CPL_STR_HASH("getData")))
RET CNF(StringList_getData);
 EI(keyStr.equals("append", CPL_STR_HASH("append")))
RET CNF(StringList_append);
 EI(keyStr.equals("insert", CPL_STR_HASH("insert")))
RET CNF(StringList_insert);
 EI(keyStr.equals("remove", CPL_STR_HASH("remove")))
RET CNF(StringList_remove);
 EI(keyStr.equals("clear", CPL_STR_HASH("clear")))
RET CNF(StringList_clear);
 EI(keyStr.equals("find", CPL_STR_HASH("find")))
RET CNF(StringList_find);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(StringList_copy);
 EI(keyStr.equals("in", CPL_STR_HASH("in")))
RET CNF(StringList_in);
 EI(keyStr.equals("reserve", CPL_STR_HASH("reserve")))
RET CNF(StringList_reserve);
 EI(keyStr.equals("begin", CPL_STR_HASH("begin")))
RET CNF(StringList_begin);
 EI(keyStr.equals("end", CPL_STR_HASH("end")))
RET CNF(StringList_end);
 else
 CATE(KE,"Unknown member for StringList."));
}
}
RET CN;
}

void StringList_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for StringList."));
}
}
}

SV StringList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::insert" EAOE));
List<Str>*f;
f=(List<Str>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],Str))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<Str>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<Str> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<Str> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("StringList::insert.")));
RET CN;
}

SV StringList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::begin" EAOE));
List<Str>*f;
f=(List<Str>*)((NO)a[0].p)->data;

CATE(TE,UFOF("StringList::begin.")));
RET CN;
}

SV StringList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::set" EAOE));
List<Str>*f;
f=(List<Str>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],Str))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<Str>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("StringList::set.")));
RET CN;
}

SV StringList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::end" EAOE));
List<Str>*f;
f=(List<Str>*)((NO)a[0].p)->data;

CATE(TE,UFOF("StringList::end.")));
RET CN;
}

SV StringList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::get" EAOE));
List<Str>*f;
f=(List<Str>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("StringList::get.")));
RET CN;
}

SV StringList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::clear" EAOE));
List<Str>*f;
f=(List<Str>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("StringList::clear.")));
RET CN;
}

SV StringList_reserve(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::reserve" EAOE));
List<Str>*f;
f=(List<Str>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->reserve(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("StringList::reserve.")));
RET CN;
}

SV StringList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::copy" EAOE));
List<Str>*f;
f=(List<Str>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("StringList::copy.")));
RET CN;
}

SV StringList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::remove" EAOE));
List<Str>*f;
f=(List<Str>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("StringList::remove.")));
RET CN;
}

SV StringList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::in" EAOE));
List<Str>*f;
f=(List<Str>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Str))
{
RET CV( f->in(val_to_c<std::remove_reference<Str>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("StringList::in.")));
RET CN;
}

SV StringList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::getCount" EAOE));
List<Str>*f;
f=(List<Str>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("StringList::getCount.")));
RET CN;
}

SV StringList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::getData" EAOE));
List<Str>*f;
f=(List<Str>*)((NO)a[0].p)->data;

CATE(TE,UFOF("StringList::getData.")));
RET CN;
}

SV StringList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::__eq__" EAOE));
List<Str>*f;
f=(List<Str>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<Str> &))
{
auto v=val_to_c<std::remove_reference<const List<Str> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("StringList::__eq__.")));
RET CN;
}

SV StringList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::find" EAOE));
List<Str>*f;
f=(List<Str>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Str))
{
RET CV( f->find(val_to_c<std::remove_reference<Str>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("StringList::find.")));
RET CN;
}

SV StringList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::append" EAOE));
List<Str>*f;
f=(List<Str>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Str))
{
( f->append(val_to_c<std::remove_reference<Str>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<Str> &))
{
( f->append(val_to_c<std::remove_reference<const List<Str> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("StringList::append.")));
RET CN;
}

SV StringList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::__neq__" EAOE));
List<Str>*f;
f=(List<Str>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<Str> &))
{
auto v=val_to_c<std::remove_reference<const List<Str> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("StringList::__neq__.")));
RET CN;
}

void GfxRenderer_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GfxRenderer))
CATE(TE,"GfxRenderer::__del__ expects GfxRenderer as first argument."));

SCRIPT_DELETE((GfxRenderer*)f->data);
}SV GfxRenderer_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxRenderer's constructor" EAOE));
if(!TS(a[0],GfxRenderer))
CATE(TE,"GfxRenderer's constructor expects GfxRenderer as first argument."));
CATE(TE,UFOF("GfxRenderer's constructor.")));
}

SV GfxRenderer_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxRenderer");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxRenderer_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxRenderer_new);
else
 CATE(KE,"Unknown member for GfxRenderer."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxRenderer_new);
 EI(keyStr.equals("resize", CPL_STR_HASH("resize")))
RET CNF(GfxRenderer_resize);
 EI(keyStr.equals("render", CPL_STR_HASH("render")))
RET CNF(GfxRenderer_render);
 EI(keyStr.equals("addObject", CPL_STR_HASH("addObject")))
RET CNF(GfxRenderer_addObject);
 EI(keyStr.equals("getNumLights", CPL_STR_HASH("getNumLights")))
RET CNF(GfxRenderer_getNumLights);
 EI(keyStr.equals("getLightBuffer", CPL_STR_HASH("getLightBuffer")))
RET CNF(GfxRenderer_getLightBuffer);
 EI(keyStr.equals("getStats", CPL_STR_HASH("getStats")))
RET CNF(GfxRenderer_getStats);
 EI(keyStr.equals("addLight", CPL_STR_HASH("addLight")))
RET CNF(GfxRenderer_addLight);
 EI(keyStr.equals("removeLight", CPL_STR_HASH("removeLight")))
RET CNF(GfxRenderer_removeLight);
 EI(keyStr.equals("getLights", CPL_STR_HASH("getLights")))
RET CNF(GfxRenderer_getLights);
 EI(keyStr.equals("updateStats", CPL_STR_HASH("updateStats")))
RET CNF(GfxRenderer_updateStats);
 EI(keyStr.equals("updateColorModifierShader", CPL_STR_HASH("updateColorModifierShader")))
RET CNF(GfxRenderer_updateColorModifierShader);
 EI(keyStr.equals("setSkybox", CPL_STR_HASH("setSkybox")))
RET CNF(GfxRenderer_setSkybox);
 EI(keyStr.equals("getSkybox", CPL_STR_HASH("getSkybox")))
RET CNF(GfxRenderer_getSkybox);
 EI(keyStr.equals("addTerrain", CPL_STR_HASH("addTerrain")))
RET CNF(GfxRenderer_addTerrain);
 EI(keyStr.equals("removeTerrain", CPL_STR_HASH("removeTerrain")))
RET CNF(GfxRenderer_removeTerrain);
 EI(keyStr.equals("getTerrain", CPL_STR_HASH("getTerrain")))
RET CNF(GfxRenderer_getTerrain);
 EI(keyStr.equals("getForwardList", CPL_STR_HASH("getForwardList")))
RET CNF(GfxRenderer_getForwardList);
 EI(keyStr.equals("getDeferredList", CPL_STR_HASH("getDeferredList")))
RET CNF(GfxRenderer_getDeferredList);
 EI(keyStr.equals("getShadowmapList", CPL_STR_HASH("getShadowmapList")))
RET CNF(GfxRenderer_getShadowmapList);
 EI(keyStr.equals("getSceneAABB", CPL_STR_HASH("getSceneAABB")))
RET CNF(GfxRenderer_getSceneAABB);
 EI(keyStr.equals("getShadowCasterAABB", CPL_STR_HASH("getShadowCasterAABB")))
RET CNF(GfxRenderer_getShadowCasterAABB);
 EI(keyStr.equals("computeSceneAABB", CPL_STR_HASH("computeSceneAABB")))
RET CNF(GfxRenderer_computeSceneAABB);
 EI(keyStr.equals("computeShadowCasterAABB", CPL_STR_HASH("computeShadowCasterAABB")))
RET CNF(GfxRenderer_computeShadowCasterAABB);
 EI(keyStr.equals("camera", CPL_STR_HASH("camera")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->camera);
} EI(keyStr.equals("debugDraw", CPL_STR_HASH("debugDraw")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->debugDraw);
} EI(keyStr.equals("bloomThreshold", CPL_STR_HASH("bloomThreshold")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloomThreshold);
} EI(keyStr.equals("bloom1Radius", CPL_STR_HASH("bloom1Radius")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloom1Radius);
} EI(keyStr.equals("bloom2Radius", CPL_STR_HASH("bloom2Radius")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloom2Radius);
} EI(keyStr.equals("bloom3Radius", CPL_STR_HASH("bloom3Radius")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloom3Radius);
} EI(keyStr.equals("bloom4Radius", CPL_STR_HASH("bloom4Radius")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloom4Radius);
} EI(keyStr.equals("bloom1Strength", CPL_STR_HASH("bloom1Strength")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloom1Strength);
} EI(keyStr.equals("bloom2Strength", CPL_STR_HASH("bloom2Strength")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloom2Strength);
} EI(keyStr.equals("bloom3Strength", CPL_STR_HASH("bloom3Strength")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloom3Strength);
} EI(keyStr.equals("bloom4Strength", CPL_STR_HASH("bloom4Strength")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloom4Strength);
} EI(keyStr.equals("bloomEnabled", CPL_STR_HASH("bloomEnabled")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloomEnabled);
} EI(keyStr.equals("ssaoRadius", CPL_STR_HASH("ssaoRadius")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->ssaoRadius);
} else
 CATE(KE,"Unknown member for GfxRenderer."));
}
}
RET CN;
}

void GfxRenderer_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("camera", CPL_STR_HASH("camera")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->camera=val_to_c<decltype(obj->camera)>::f(ctx,value);
} EI(keyStr.equals("debugDraw", CPL_STR_HASH("debugDraw")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->debugDraw=val_to_c<decltype(obj->debugDraw)>::f(ctx,value);
} EI(keyStr.equals("bloomThreshold", CPL_STR_HASH("bloomThreshold")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloomThreshold=val_to_c<decltype(obj->bloomThreshold)>::f(ctx,value);
} EI(keyStr.equals("bloom1Radius", CPL_STR_HASH("bloom1Radius")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloom1Radius=val_to_c<decltype(obj->bloom1Radius)>::f(ctx,value);
} EI(keyStr.equals("bloom2Radius", CPL_STR_HASH("bloom2Radius")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloom2Radius=val_to_c<decltype(obj->bloom2Radius)>::f(ctx,value);
} EI(keyStr.equals("bloom3Radius", CPL_STR_HASH("bloom3Radius")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloom3Radius=val_to_c<decltype(obj->bloom3Radius)>::f(ctx,value);
} EI(keyStr.equals("bloom4Radius", CPL_STR_HASH("bloom4Radius")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloom4Radius=val_to_c<decltype(obj->bloom4Radius)>::f(ctx,value);
} EI(keyStr.equals("bloom1Strength", CPL_STR_HASH("bloom1Strength")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloom1Strength=val_to_c<decltype(obj->bloom1Strength)>::f(ctx,value);
} EI(keyStr.equals("bloom2Strength", CPL_STR_HASH("bloom2Strength")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloom2Strength=val_to_c<decltype(obj->bloom2Strength)>::f(ctx,value);
} EI(keyStr.equals("bloom3Strength", CPL_STR_HASH("bloom3Strength")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloom3Strength=val_to_c<decltype(obj->bloom3Strength)>::f(ctx,value);
} EI(keyStr.equals("bloom4Strength", CPL_STR_HASH("bloom4Strength")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloom4Strength=val_to_c<decltype(obj->bloom4Strength)>::f(ctx,value);
} EI(keyStr.equals("bloomEnabled", CPL_STR_HASH("bloomEnabled")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloomEnabled=val_to_c<decltype(obj->bloomEnabled)>::f(ctx,value);
} EI(keyStr.equals("ssaoRadius", CPL_STR_HASH("ssaoRadius")))
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->ssaoRadius=val_to_c<decltype(obj->ssaoRadius)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for GfxRenderer."));
}
}
}

SV GfxRenderer_updateColorModifierShader(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::updateColorModifierShader" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->updateColorModifierShader());
RET CN;
}
CATE(TE,UFOF("GfxRenderer::updateColorModifierShader.")));
RET CN;
}

SV GfxRenderer_getSceneAABB(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::getSceneAABB" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getSceneAABB());
;
}
CATE(TE,UFOF("GfxRenderer::getSceneAABB.")));
RET CN;
}

SV GfxRenderer_getShadowCasterAABB(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::getShadowCasterAABB" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShadowCasterAABB());
;
}
CATE(TE,UFOF("GfxRenderer::getShadowCasterAABB.")));
RET CN;
}

SV GfxRenderer_getShadowmapList(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::getShadowmapList" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShadowmapList());
;
}
CATE(TE,UFOF("GfxRenderer::getShadowmapList.")));
RET CN;
}

SV GfxRenderer_getForwardList(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::getForwardList" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getForwardList());
;
}
CATE(TE,UFOF("GfxRenderer::getForwardList.")));
RET CN;
}

SV GfxRenderer_getSkybox(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::getSkybox" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getSkybox());
;
}
CATE(TE,UFOF("GfxRenderer::getSkybox.")));
RET CN;
}

SV GfxRenderer_addTerrain(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::addTerrain" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

CATE(TE,UFOF("GfxRenderer::addTerrain.")));
RET CN;
}

SV GfxRenderer_render(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::render" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->render());
RET CN;
}
CATE(TE,UFOF("GfxRenderer::render.")));
RET CN;
}

SV GfxRenderer_getLights(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::getLights" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getLights());
;
}
CATE(TE,UFOF("GfxRenderer::getLights.")));
RET CN;
}

SV GfxRenderer_removeLight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::removeLight" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->removeLight(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxRenderer::removeLight.")));
RET CN;
}

SV GfxRenderer_addObject(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::addObject" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const GfxObject &))
{
( f->addObject(val_to_c<std::remove_reference<const GfxObject &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxRenderer::addObject.")));
RET CN;
}

SV GfxRenderer_addLight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::addLight" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->addLight());
;
}
CATE(TE,UFOF("GfxRenderer::addLight.")));
RET CN;
}

SV GfxRenderer_removeTerrain(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::removeTerrain" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeTerrain());
RET CN;
}
CATE(TE,UFOF("GfxRenderer::removeTerrain.")));
RET CN;
}

SV GfxRenderer_getStats(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::getStats" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getStats());
;
}
CATE(TE,UFOF("GfxRenderer::getStats.")));
RET CN;
}

SV GfxRenderer_updateStats(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::updateStats" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->updateStats());
RET CN;
}
CATE(TE,UFOF("GfxRenderer::updateStats.")));
RET CN;
}

SV GfxRenderer_resize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::resize" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const UInt2 &))
{
( f->resize(val_to_c<std::remove_reference<const UInt2 &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxRenderer::resize.")));
RET CN;
}

SV GfxRenderer_getLightBuffer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::getLightBuffer" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getLightBuffer());
;
}
CATE(TE,UFOF("GfxRenderer::getLightBuffer.")));
RET CN;
}

SV GfxRenderer_getNumLights(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::getNumLights" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getNumLights());
;
}
CATE(TE,UFOF("GfxRenderer::getNumLights.")));
RET CN;
}

SV GfxRenderer_computeSceneAABB(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::computeSceneAABB" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->computeSceneAABB());
RET CN;
}
CATE(TE,UFOF("GfxRenderer::computeSceneAABB.")));
RET CN;
}

SV GfxRenderer_getTerrain(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::getTerrain" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

CATE(TE,UFOF("GfxRenderer::getTerrain.")));
RET CN;
}

SV GfxRenderer_computeShadowCasterAABB(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::computeShadowCasterAABB" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->computeShadowCasterAABB());
RET CN;
}
CATE(TE,UFOF("GfxRenderer::computeShadowCasterAABB.")));
RET CN;
}

SV GfxRenderer_setSkybox(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::setSkybox" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxTexture *))
{
( f->setSkybox(val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxRenderer::setSkybox.")));
RET CN;
}

SV GfxRenderer_getDeferredList(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::getDeferredList" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDeferredList());
;
}
CATE(TE,UFOF("GfxRenderer::getDeferredList.")));
RET CN;
}

void Float4_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,T4<float>))
CATE(TE,"Float4::__del__ expects Float4 as first argument."));

SCRIPT_DELETE((T4<float>*)f->data);
}SV Float4_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4's constructor" EAOE));
if(!TS(a[0],T4<float>))
CATE(TE,"Float4's constructor expects Float4 as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(T4<float>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float4_funcs,p,EXT->Float4_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],float)){
void *p = (void *)NEW(TYPE(T4<float>),val_to_c<float>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float4_funcs,p,EXT->Float4_typeID);
}if(a.getCount()==5)
if(true&&TS(a[1],float)&&TS(a[2],float)&&TS(a[3],float)&&TS(a[4],float)){
void *p = (void *)NEW(TYPE(T4<float>),val_to_c<float>::f(ctx,a[1]),val_to_c<float>::f(ctx,a[2]),val_to_c<float>::f(ctx,a[3]),val_to_c<float>::f(ctx,a[4]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float4_funcs,p,EXT->Float4_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T4<float> &)){
void *p = (void *)NEW(TYPE(T4<float>),val_to_c<const T4<float> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float4_funcs,p,EXT->Float4_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T4<int32_t> &)){
void *p = (void *)NEW(TYPE(T4<float>),val_to_c<const T4<int32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float4_funcs,p,EXT->Float4_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T4<uint32_t> &)){
void *p = (void *)NEW(TYPE(T4<float>),val_to_c<const T4<uint32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float4_funcs,p,EXT->Float4_typeID);
}CATE(TE,UFOF("Float4's constructor.")));
RET CN;
}

SV Float4_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Float4");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Float4_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Float4_new);
else
 CATE(KE,"Unknown member for Float4."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Float4_new);
 EI(keyStr.equals("__add__", CPL_STR_HASH("__add__")))
RET CNF(Float4___add__);
 EI(keyStr.equals("__sub__", CPL_STR_HASH("__sub__")))
RET CNF(Float4___sub__);
 EI(keyStr.equals("__mul__", CPL_STR_HASH("__mul__")))
RET CNF(Float4___mul__);
 EI(keyStr.equals("__div__", CPL_STR_HASH("__div__")))
RET CNF(Float4___div__);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(Float4___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(Float4___neq__);
 EI(keyStr.equals("__less__", CPL_STR_HASH("__less__")))
RET CNF(Float4___less__);
 EI(keyStr.equals("__grtr__", CPL_STR_HASH("__grtr__")))
RET CNF(Float4___grtr__);
 EI(keyStr.equals("__leq__", CPL_STR_HASH("__leq__")))
RET CNF(Float4___leq__);
 EI(keyStr.equals("__geq__", CPL_STR_HASH("__geq__")))
RET CNF(Float4___geq__);
 EI(keyStr.equals("sum", CPL_STR_HASH("sum")))
RET CNF(Float4_sum);
 EI(keyStr.equals("length", CPL_STR_HASH("length")))
RET CNF(Float4_length);
 EI(keyStr.equals("lengthSquared", CPL_STR_HASH("lengthSquared")))
RET CNF(Float4_lengthSquared);
 EI(keyStr.equals("dot", CPL_STR_HASH("dot")))
RET CNF(Float4_dot);
 EI(keyStr.equals("distance", CPL_STR_HASH("distance")))
RET CNF(Float4_distance);
 EI(keyStr.equals("distanceSquared", CPL_STR_HASH("distanceSquared")))
RET CNF(Float4_distanceSquared);
 EI(keyStr.equals("normalize", CPL_STR_HASH("normalize")))
RET CNF(Float4_normalize);
 EI(keyStr.equals("getXY", CPL_STR_HASH("getXY")))
RET CNF(Float4_getXY);
 EI(keyStr.equals("setXY", CPL_STR_HASH("setXY")))
RET CNF(Float4_setXY);
 EI(keyStr.equals("getXZ", CPL_STR_HASH("getXZ")))
RET CNF(Float4_getXZ);
 EI(keyStr.equals("setXZ", CPL_STR_HASH("setXZ")))
RET CNF(Float4_setXZ);
 EI(keyStr.equals("getXW", CPL_STR_HASH("getXW")))
RET CNF(Float4_getXW);
 EI(keyStr.equals("setXW", CPL_STR_HASH("setXW")))
RET CNF(Float4_setXW);
 EI(keyStr.equals("getYX", CPL_STR_HASH("getYX")))
RET CNF(Float4_getYX);
 EI(keyStr.equals("setYX", CPL_STR_HASH("setYX")))
RET CNF(Float4_setYX);
 EI(keyStr.equals("getYZ", CPL_STR_HASH("getYZ")))
RET CNF(Float4_getYZ);
 EI(keyStr.equals("setYZ", CPL_STR_HASH("setYZ")))
RET CNF(Float4_setYZ);
 EI(keyStr.equals("getYW", CPL_STR_HASH("getYW")))
RET CNF(Float4_getYW);
 EI(keyStr.equals("setYW", CPL_STR_HASH("setYW")))
RET CNF(Float4_setYW);
 EI(keyStr.equals("getZX", CPL_STR_HASH("getZX")))
RET CNF(Float4_getZX);
 EI(keyStr.equals("setZX", CPL_STR_HASH("setZX")))
RET CNF(Float4_setZX);
 EI(keyStr.equals("getZY", CPL_STR_HASH("getZY")))
RET CNF(Float4_getZY);
 EI(keyStr.equals("setZY", CPL_STR_HASH("setZY")))
RET CNF(Float4_setZY);
 EI(keyStr.equals("getZW", CPL_STR_HASH("getZW")))
RET CNF(Float4_getZW);
 EI(keyStr.equals("setZW", CPL_STR_HASH("setZW")))
RET CNF(Float4_setZW);
 EI(keyStr.equals("getWX", CPL_STR_HASH("getWX")))
RET CNF(Float4_getWX);
 EI(keyStr.equals("setWX", CPL_STR_HASH("setWX")))
RET CNF(Float4_setWX);
 EI(keyStr.equals("getWY", CPL_STR_HASH("getWY")))
RET CNF(Float4_getWY);
 EI(keyStr.equals("setWY", CPL_STR_HASH("setWY")))
RET CNF(Float4_setWY);
 EI(keyStr.equals("getWZ", CPL_STR_HASH("getWZ")))
RET CNF(Float4_getWZ);
 EI(keyStr.equals("setWZ", CPL_STR_HASH("setWZ")))
RET CNF(Float4_setWZ);
 EI(keyStr.equals("getXYZ", CPL_STR_HASH("getXYZ")))
RET CNF(Float4_getXYZ);
 EI(keyStr.equals("setXYZ", CPL_STR_HASH("setXYZ")))
RET CNF(Float4_setXYZ);
 EI(keyStr.equals("getXYW", CPL_STR_HASH("getXYW")))
RET CNF(Float4_getXYW);
 EI(keyStr.equals("setXYW", CPL_STR_HASH("setXYW")))
RET CNF(Float4_setXYW);
 EI(keyStr.equals("getXZY", CPL_STR_HASH("getXZY")))
RET CNF(Float4_getXZY);
 EI(keyStr.equals("setXZY", CPL_STR_HASH("setXZY")))
RET CNF(Float4_setXZY);
 EI(keyStr.equals("getXZW", CPL_STR_HASH("getXZW")))
RET CNF(Float4_getXZW);
 EI(keyStr.equals("setXZW", CPL_STR_HASH("setXZW")))
RET CNF(Float4_setXZW);
 EI(keyStr.equals("getXWZ", CPL_STR_HASH("getXWZ")))
RET CNF(Float4_getXWZ);
 EI(keyStr.equals("setXWZ", CPL_STR_HASH("setXWZ")))
RET CNF(Float4_setXWZ);
 EI(keyStr.equals("getXWY", CPL_STR_HASH("getXWY")))
RET CNF(Float4_getXWY);
 EI(keyStr.equals("setXWY", CPL_STR_HASH("setXWY")))
RET CNF(Float4_setXWY);
 EI(keyStr.equals("getYXZ", CPL_STR_HASH("getYXZ")))
RET CNF(Float4_getYXZ);
 EI(keyStr.equals("setYXZ", CPL_STR_HASH("setYXZ")))
RET CNF(Float4_setYXZ);
 EI(keyStr.equals("getYXW", CPL_STR_HASH("getYXW")))
RET CNF(Float4_getYXW);
 EI(keyStr.equals("setYXW", CPL_STR_HASH("setYXW")))
RET CNF(Float4_setYXW);
 EI(keyStr.equals("getYZX", CPL_STR_HASH("getYZX")))
RET CNF(Float4_getYZX);
 EI(keyStr.equals("setYZX", CPL_STR_HASH("setYZX")))
RET CNF(Float4_setYZX);
 EI(keyStr.equals("getYZW", CPL_STR_HASH("getYZW")))
RET CNF(Float4_getYZW);
 EI(keyStr.equals("setYZW", CPL_STR_HASH("setYZW")))
RET CNF(Float4_setYZW);
 EI(keyStr.equals("getYWZ", CPL_STR_HASH("getYWZ")))
RET CNF(Float4_getYWZ);
 EI(keyStr.equals("setYWZ", CPL_STR_HASH("setYWZ")))
RET CNF(Float4_setYWZ);
 EI(keyStr.equals("getYWX", CPL_STR_HASH("getYWX")))
RET CNF(Float4_getYWX);
 EI(keyStr.equals("setYWX", CPL_STR_HASH("setYWX")))
RET CNF(Float4_setYWX);
 EI(keyStr.equals("getZXY", CPL_STR_HASH("getZXY")))
RET CNF(Float4_getZXY);
 EI(keyStr.equals("setZXY", CPL_STR_HASH("setZXY")))
RET CNF(Float4_setZXY);
 EI(keyStr.equals("getZXW", CPL_STR_HASH("getZXW")))
RET CNF(Float4_getZXW);
 EI(keyStr.equals("setZXW", CPL_STR_HASH("setZXW")))
RET CNF(Float4_setZXW);
 EI(keyStr.equals("getZYX", CPL_STR_HASH("getZYX")))
RET CNF(Float4_getZYX);
 EI(keyStr.equals("setZYX", CPL_STR_HASH("setZYX")))
RET CNF(Float4_setZYX);
 EI(keyStr.equals("getZYW", CPL_STR_HASH("getZYW")))
RET CNF(Float4_getZYW);
 EI(keyStr.equals("setZYW", CPL_STR_HASH("setZYW")))
RET CNF(Float4_setZYW);
 EI(keyStr.equals("getZWY", CPL_STR_HASH("getZWY")))
RET CNF(Float4_getZWY);
 EI(keyStr.equals("setZWY", CPL_STR_HASH("setZWY")))
RET CNF(Float4_setZWY);
 EI(keyStr.equals("getZWX", CPL_STR_HASH("getZWX")))
RET CNF(Float4_getZWX);
 EI(keyStr.equals("setZWX", CPL_STR_HASH("setZWX")))
RET CNF(Float4_setZWX);
 EI(keyStr.equals("getWXY", CPL_STR_HASH("getWXY")))
RET CNF(Float4_getWXY);
 EI(keyStr.equals("setWXY", CPL_STR_HASH("setWXY")))
RET CNF(Float4_setWXY);
 EI(keyStr.equals("getWXZ", CPL_STR_HASH("getWXZ")))
RET CNF(Float4_getWXZ);
 EI(keyStr.equals("setWXZ", CPL_STR_HASH("setWXZ")))
RET CNF(Float4_setWXZ);
 EI(keyStr.equals("getWYX", CPL_STR_HASH("getWYX")))
RET CNF(Float4_getWYX);
 EI(keyStr.equals("setWYX", CPL_STR_HASH("setWYX")))
RET CNF(Float4_setWYX);
 EI(keyStr.equals("getWYZ", CPL_STR_HASH("getWYZ")))
RET CNF(Float4_getWYZ);
 EI(keyStr.equals("setWYZ", CPL_STR_HASH("setWYZ")))
RET CNF(Float4_setWYZ);
 EI(keyStr.equals("getWZY", CPL_STR_HASH("getWZY")))
RET CNF(Float4_getWZY);
 EI(keyStr.equals("setWZY", CPL_STR_HASH("setWZY")))
RET CNF(Float4_setWZY);
 EI(keyStr.equals("getWZX", CPL_STR_HASH("getWZX")))
RET CNF(Float4_getWZX);
 EI(keyStr.equals("setWZX", CPL_STR_HASH("setWZX")))
RET CNF(Float4_setWZX);
 EI(keyStr.equals("getXYZW", CPL_STR_HASH("getXYZW")))
RET CNF(Float4_getXYZW);
 EI(keyStr.equals("setXYZW", CPL_STR_HASH("setXYZW")))
RET CNF(Float4_setXYZW);
 EI(keyStr.equals("getXYWZ", CPL_STR_HASH("getXYWZ")))
RET CNF(Float4_getXYWZ);
 EI(keyStr.equals("setXYWZ", CPL_STR_HASH("setXYWZ")))
RET CNF(Float4_setXYWZ);
 EI(keyStr.equals("getXZYW", CPL_STR_HASH("getXZYW")))
RET CNF(Float4_getXZYW);
 EI(keyStr.equals("setXZYW", CPL_STR_HASH("setXZYW")))
RET CNF(Float4_setXZYW);
 EI(keyStr.equals("getXZWY", CPL_STR_HASH("getXZWY")))
RET CNF(Float4_getXZWY);
 EI(keyStr.equals("setXZWY", CPL_STR_HASH("setXZWY")))
RET CNF(Float4_setXZWY);
 EI(keyStr.equals("getXWZY", CPL_STR_HASH("getXWZY")))
RET CNF(Float4_getXWZY);
 EI(keyStr.equals("setXWZY", CPL_STR_HASH("setXWZY")))
RET CNF(Float4_setXWZY);
 EI(keyStr.equals("getXWYZ", CPL_STR_HASH("getXWYZ")))
RET CNF(Float4_getXWYZ);
 EI(keyStr.equals("setXWYZ", CPL_STR_HASH("setXWYZ")))
RET CNF(Float4_setXWYZ);
 EI(keyStr.equals("getYXZW", CPL_STR_HASH("getYXZW")))
RET CNF(Float4_getYXZW);
 EI(keyStr.equals("setYXZW", CPL_STR_HASH("setYXZW")))
RET CNF(Float4_setYXZW);
 EI(keyStr.equals("getYXWZ", CPL_STR_HASH("getYXWZ")))
RET CNF(Float4_getYXWZ);
 EI(keyStr.equals("setYXWZ", CPL_STR_HASH("setYXWZ")))
RET CNF(Float4_setYXWZ);
 EI(keyStr.equals("getYZXW", CPL_STR_HASH("getYZXW")))
RET CNF(Float4_getYZXW);
 EI(keyStr.equals("setYZXW", CPL_STR_HASH("setYZXW")))
RET CNF(Float4_setYZXW);
 EI(keyStr.equals("getYZWX", CPL_STR_HASH("getYZWX")))
RET CNF(Float4_getYZWX);
 EI(keyStr.equals("setYZWX", CPL_STR_HASH("setYZWX")))
RET CNF(Float4_setYZWX);
 EI(keyStr.equals("getYWZX", CPL_STR_HASH("getYWZX")))
RET CNF(Float4_getYWZX);
 EI(keyStr.equals("setYWZX", CPL_STR_HASH("setYWZX")))
RET CNF(Float4_setYWZX);
 EI(keyStr.equals("getYWXZ", CPL_STR_HASH("getYWXZ")))
RET CNF(Float4_getYWXZ);
 EI(keyStr.equals("setYWXZ", CPL_STR_HASH("setYWXZ")))
RET CNF(Float4_setYWXZ);
 EI(keyStr.equals("getZYXW", CPL_STR_HASH("getZYXW")))
RET CNF(Float4_getZYXW);
 EI(keyStr.equals("setZYXW", CPL_STR_HASH("setZYXW")))
RET CNF(Float4_setZYXW);
 EI(keyStr.equals("getZYWX", CPL_STR_HASH("getZYWX")))
RET CNF(Float4_getZYWX);
 EI(keyStr.equals("setZYWX", CPL_STR_HASH("setZYWX")))
RET CNF(Float4_setZYWX);
 EI(keyStr.equals("getZXYW", CPL_STR_HASH("getZXYW")))
RET CNF(Float4_getZXYW);
 EI(keyStr.equals("setZXYW", CPL_STR_HASH("setZXYW")))
RET CNF(Float4_setZXYW);
 EI(keyStr.equals("getZXWY", CPL_STR_HASH("getZXWY")))
RET CNF(Float4_getZXWY);
 EI(keyStr.equals("setZXWY", CPL_STR_HASH("setZXWY")))
RET CNF(Float4_setZXWY);
 EI(keyStr.equals("getZWXY", CPL_STR_HASH("getZWXY")))
RET CNF(Float4_getZWXY);
 EI(keyStr.equals("setZWXY", CPL_STR_HASH("setZWXY")))
RET CNF(Float4_setZWXY);
 EI(keyStr.equals("getZWYX", CPL_STR_HASH("getZWYX")))
RET CNF(Float4_getZWYX);
 EI(keyStr.equals("setZWYX", CPL_STR_HASH("setZWYX")))
RET CNF(Float4_setZWYX);
 EI(keyStr.equals("getWYZX", CPL_STR_HASH("getWYZX")))
RET CNF(Float4_getWYZX);
 EI(keyStr.equals("setWYZX", CPL_STR_HASH("setWYZX")))
RET CNF(Float4_setWYZX);
 EI(keyStr.equals("getWYXZ", CPL_STR_HASH("getWYXZ")))
RET CNF(Float4_getWYXZ);
 EI(keyStr.equals("setWYXZ", CPL_STR_HASH("setWYXZ")))
RET CNF(Float4_setWYXZ);
 EI(keyStr.equals("getWZYX", CPL_STR_HASH("getWZYX")))
RET CNF(Float4_getWZYX);
 EI(keyStr.equals("setWZYX", CPL_STR_HASH("setWZYX")))
RET CNF(Float4_setWZYX);
 EI(keyStr.equals("getWZXY", CPL_STR_HASH("getWZXY")))
RET CNF(Float4_getWZXY);
 EI(keyStr.equals("setWZXY", CPL_STR_HASH("setWZXY")))
RET CNF(Float4_setWZXY);
 EI(keyStr.equals("getWXZY", CPL_STR_HASH("getWXZY")))
RET CNF(Float4_getWXZY);
 EI(keyStr.equals("setWXZY", CPL_STR_HASH("setWXZY")))
RET CNF(Float4_setWXZY);
 EI(keyStr.equals("getWXYZ", CPL_STR_HASH("getWXYZ")))
RET CNF(Float4_getWXYZ);
 EI(keyStr.equals("setWXYZ", CPL_STR_HASH("setWXYZ")))
RET CNF(Float4_setWXYZ);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(Float4_copy);
 EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T4<float>*obj=(T4<float>*)f->data;
RET CV(obj->x);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T4<float>*obj=(T4<float>*)f->data;
RET CV(obj->y);
} EI(keyStr.equals("z", CPL_STR_HASH("z")))
{
T4<float>*obj=(T4<float>*)f->data;
RET CV(obj->z);
} EI(keyStr.equals("w", CPL_STR_HASH("w")))
{
T4<float>*obj=(T4<float>*)f->data;
RET CV(obj->w);
} else
 CATE(KE,"Unknown member for Float4."));
}
}
RET CN;
}

void Float4_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T4<float>*obj=(T4<float>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T4<float>*obj=(T4<float>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} EI(keyStr.equals("z", CPL_STR_HASH("z")))
{
T4<float>*obj=(T4<float>*)f->data;
obj->z=val_to_c<decltype(obj->z)>::f(ctx,value);
} EI(keyStr.equals("w", CPL_STR_HASH("w")))
{
T4<float>*obj=(T4<float>*)f->data;
obj->w=val_to_c<decltype(obj->w)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for Float4."));
}
}
}

SV Float4_setZXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZXYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setZXYW(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZXYW.")));
RET CN;
}

SV Float4_setWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setWYZ(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWYZ.")));
RET CN;
}

SV Float4_setWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setWYX(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWYX.")));
RET CN;
}

SV Float4_getZWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZWYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWYX());
;
}
CATE(TE,UFOF("Float4::getZWYX.")));
RET CN;
}

SV Float4_getZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZW());
;
}
CATE(TE,UFOF("Float4::getZW.")));
RET CN;
}

SV Float4_getZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZY());
;
}
CATE(TE,UFOF("Float4::getZY.")));
RET CN;
}

SV Float4_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::distanceSquared" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Float4::distanceSquared.")));
RET CN;
}

SV Float4_getYXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYXZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZW());
;
}
CATE(TE,UFOF("Float4::getYXZW.")));
RET CN;
}

SV Float4_setYZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYZWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setYZWX(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYZWX.")));
RET CN;
}

SV Float4_getYWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYWZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWZX());
;
}
CATE(TE,UFOF("Float4::getYWZX.")));
RET CN;
}

SV Float4_getWZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWZXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZXY());
;
}
CATE(TE,UFOF("Float4::getWZXY.")));
RET CN;
}

SV Float4_getZYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZYXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYXW());
;
}
CATE(TE,UFOF("Float4::getZYXW.")));
RET CN;
}

SV Float4_setXWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXWYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setXWYZ(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXWYZ.")));
RET CN;
}

SV Float4_setZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setZY(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZY.")));
RET CN;
}

SV Float4_setZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setZX(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZX.")));
RET CN;
}

SV Float4_getZXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZXWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXWY());
;
}
CATE(TE,UFOF("Float4::getZXWY.")));
RET CN;
}

SV Float4_getXWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXWZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWZY());
;
}
CATE(TE,UFOF("Float4::getXWZY.")));
RET CN;
}

SV Float4_setZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setZW(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZW.")));
RET CN;
}

SV Float4_setZYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZYWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setZYWX(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZYWX.")));
RET CN;
}

SV Float4_getYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZX());
;
}
CATE(TE,UFOF("Float4::getYZX.")));
RET CN;
}

SV Float4_getXYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXYWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYWZ());
;
}
CATE(TE,UFOF("Float4::getXYWZ.")));
RET CN;
}

SV Float4_setYXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYXZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setYXZW(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYXZW.")));
RET CN;
}

SV Float4_getWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZY());
;
}
CATE(TE,UFOF("Float4::getWZY.")));
RET CN;
}

SV Float4_getWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZX());
;
}
CATE(TE,UFOF("Float4::getWZX.")));
RET CN;
}

SV Float4_getWZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWZYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZYX());
;
}
CATE(TE,UFOF("Float4::getWZYX.")));
RET CN;
}

SV Float4_setXWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXWZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setXWZY(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXWZY.")));
RET CN;
}

SV Float4_getZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXY());
;
}
CATE(TE,UFOF("Float4::getZXY.")));
RET CN;
}

SV Float4_setWZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWZYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setWZYX(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWZYX.")));
RET CN;
}

SV Float4_setZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setZYW(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZYW.")));
RET CN;
}

SV Float4_setZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setZYX(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZYX.")));
RET CN;
}

SV Float4_setXZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXZYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setXZYW(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXZYW.")));
RET CN;
}

SV Float4_getZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXW());
;
}
CATE(TE,UFOF("Float4::getZXW.")));
RET CN;
}

SV Float4_setYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setYZW(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYZW.")));
RET CN;
}

SV Float4_getYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWZ());
;
}
CATE(TE,UFOF("Float4::getYWZ.")));
RET CN;
}

SV Float4___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__leq__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("Float4::__leq__.")));
RET CN;
}

SV Float4_getYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWX());
;
}
CATE(TE,UFOF("Float4::getYWX.")));
RET CN;
}

SV Float4_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::sum" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("Float4::sum.")));
RET CN;
}

SV Float4_setYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setYZX(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYZX.")));
RET CN;
}

SV Float4_getXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZ());
;
}
CATE(TE,UFOF("Float4::getXYZ.")));
RET CN;
}

SV Float4_getZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZX());
;
}
CATE(TE,UFOF("Float4::getZX.")));
RET CN;
}

SV Float4_getXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYW());
;
}
CATE(TE,UFOF("Float4::getXYW.")));
RET CN;
}

SV Float4_setYWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYWZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setYWZX(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYWZX.")));
RET CN;
}

SV Float4_setWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setWXY(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWXY.")));
RET CN;
}

SV Float4_setWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setWXZ(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWXZ.")));
RET CN;
}

SV Float4_setZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setZXW(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZXW.")));
RET CN;
}

SV Float4_getXWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXWYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWYZ());
;
}
CATE(TE,UFOF("Float4::getXWYZ.")));
RET CN;
}

SV Float4_setWYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWYXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setWYXZ(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWYXZ.")));
RET CN;
}

SV Float4_setZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setZXY(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZXY.")));
RET CN;
}

SV Float4_getXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWY());
;
}
CATE(TE,UFOF("Float4::getXWY.")));
RET CN;
}

SV Float4_getYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXW());
;
}
CATE(TE,UFOF("Float4::getYXW.")));
RET CN;
}

SV Float4_getYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZ());
;
}
CATE(TE,UFOF("Float4::getYXZ.")));
RET CN;
}

SV Float4_setXYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXYWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setXYWZ(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXYWZ.")));
RET CN;
}

SV Float4_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::length" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("Float4::length.")));
RET CN;
}

SV Float4_setWXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWXZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setWXZY(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWXZY.")));
RET CN;
}

SV Float4_getYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZW());
;
}
CATE(TE,UFOF("Float4::getYZW.")));
RET CN;
}

SV Float4_setXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setXWZ(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXWZ.")));
RET CN;
}

SV Float4_setXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setXWY(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXWY.")));
RET CN;
}

SV Float4_getWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYZ());
;
}
CATE(TE,UFOF("Float4::getWYZ.")));
RET CN;
}

SV Float4_getWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYX());
;
}
CATE(TE,UFOF("Float4::getWYX.")));
RET CN;
}

SV Float4_getZYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZYWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYWX());
;
}
CATE(TE,UFOF("Float4::getZYWX.")));
RET CN;
}

SV Float4_getXYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXYZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZW());
;
}
CATE(TE,UFOF("Float4::getXYZW.")));
RET CN;
}

SV Float4_setZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setZWY(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZWY.")));
RET CN;
}

SV Float4_setZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setZWX(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZWX.")));
RET CN;
}

SV Float4_setWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setWX(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWX.")));
RET CN;
}

SV Float4_setWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setWY(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWY.")));
RET CN;
}

SV Float4_setWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setWZ(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWZ.")));
RET CN;
}

SV Float4_getZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWY());
;
}
CATE(TE,UFOF("Float4::getZWY.")));
RET CN;
}

SV Float4_getZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWX());
;
}
CATE(TE,UFOF("Float4::getZWX.")));
RET CN;
}

SV Float4_setYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setYXZ(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYXZ.")));
RET CN;
}

SV Float4_setYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setYXW(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYXW.")));
RET CN;
}

SV Float4_getXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWZ());
;
}
CATE(TE,UFOF("Float4::getXWZ.")));
RET CN;
}

SV Float4_getXZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXZWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZWY());
;
}
CATE(TE,UFOF("Float4::getXZWY.")));
RET CN;
}

SV Float4___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__less__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("Float4::__less__.")));
RET CN;
}

SV Float4_getZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYW());
;
}
CATE(TE,UFOF("Float4::getZYW.")));
RET CN;
}

SV Float4_setWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setWZY(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWZY.")));
RET CN;
}

SV Float4_setWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setWZX(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWZX.")));
RET CN;
}

SV Float4_setZYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZYXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setZYXW(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZYXW.")));
RET CN;
}

SV Float4_getYZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYZWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZWX());
;
}
CATE(TE,UFOF("Float4::getYZWX.")));
RET CN;
}

SV Float4_getZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYX());
;
}
CATE(TE,UFOF("Float4::getZYX.")));
RET CN;
}

SV Float4_getXZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXZYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZYW());
;
}
CATE(TE,UFOF("Float4::getXZYW.")));
RET CN;
}

SV Float4_setYXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYXWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setYXWZ(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYXWZ.")));
RET CN;
}

SV Float4_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::copy" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("Float4::copy.")));
RET CN;
}

SV Float4___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__eq__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Float4::__eq__.")));
RET CN;
}

SV Float4_getWYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWYXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYXZ());
;
}
CATE(TE,UFOF("Float4::getWYXZ.")));
RET CN;
}

SV Float4_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::distance" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Float4::distance.")));
RET CN;
}

SV Float4_getXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZW());
;
}
CATE(TE,UFOF("Float4::getXZW.")));
RET CN;
}

SV Float4_setYZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYZXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setYZXW(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYZXW.")));
RET CN;
}

SV Float4_getZWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZWXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWXY());
;
}
CATE(TE,UFOF("Float4::getZWXY.")));
RET CN;
}

SV Float4_getXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZY());
;
}
CATE(TE,UFOF("Float4::getXZY.")));
RET CN;
}

SV Float4_getYZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYZXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZXW());
;
}
CATE(TE,UFOF("Float4::getYZXW.")));
RET CN;
}

SV Float4_setZWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZWYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setZWYX(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZWYX.")));
RET CN;
}

SV Float4___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__sub__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("Float4::__sub__.")));
RET CN;
}

SV Float4_getYXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYXWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXWZ());
;
}
CATE(TE,UFOF("Float4::getYXWZ.")));
RET CN;
}

SV Float4_setXZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXZWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setXZWY(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXZWY.")));
RET CN;
}

SV Float4_setYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setYWZ(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYWZ.")));
RET CN;
}

SV Float4_setYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setYWX(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYWX.")));
RET CN;
}

SV Float4_setYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setYZ(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYZ.")));
RET CN;
}

SV Float4_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYX.")));
RET CN;
}

SV Float4_setYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setYW(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYW.")));
RET CN;
}

SV Float4_getWXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWXYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXYZ());
;
}
CATE(TE,UFOF("Float4::getWXYZ.")));
RET CN;
}

SV Float4___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__neq__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("Float4::__neq__.")));
RET CN;
}

SV Float4_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::normalize" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("Float4::normalize.")));
RET CN;
}

SV Float4_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("Float4::getYX.")));
RET CN;
}

SV Float4_setXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setXZW(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXZW.")));
RET CN;
}

SV Float4_setXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setXZY(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXZY.")));
RET CN;
}

SV Float4_setXYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXYZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setXYZW(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXYZW.")));
RET CN;
}

SV Float4_getYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYW());
;
}
CATE(TE,UFOF("Float4::getYW.")));
RET CN;
}

SV Float4_setWXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWXYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setWXYZ(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWXYZ.")));
RET CN;
}

SV Float4_getYWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYWXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWXZ());
;
}
CATE(TE,UFOF("Float4::getYWXZ.")));
RET CN;
}

SV Float4___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__mul__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Float4::__mul__.")));
RET CN;
}

SV Float4_getYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZ());
;
}
CATE(TE,UFOF("Float4::getYZ.")));
RET CN;
}

SV Float4_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::lengthSquared" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("Float4::lengthSquared.")));
RET CN;
}

SV Float4_getWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXY());
;
}
CATE(TE,UFOF("Float4::getWXY.")));
RET CN;
}

SV Float4_getWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXZ());
;
}
CATE(TE,UFOF("Float4::getWXZ.")));
RET CN;
}

SV Float4_getWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWX());
;
}
CATE(TE,UFOF("Float4::getWX.")));
RET CN;
}

SV Float4_getWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWY());
;
}
CATE(TE,UFOF("Float4::getWY.")));
RET CN;
}

SV Float4_getWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZ());
;
}
CATE(TE,UFOF("Float4::getWZ.")));
RET CN;
}

SV Float4_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXY.")));
RET CN;
}

SV Float4_getZXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZXYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXYW());
;
}
CATE(TE,UFOF("Float4::getZXYW.")));
RET CN;
}

SV Float4___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__add__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("Float4::__add__.")));
RET CN;
}

SV Float4_setXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setXZ(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXZ.")));
RET CN;
}

SV Float4_getWYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWYZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYZX());
;
}
CATE(TE,UFOF("Float4::getWYZX.")));
RET CN;
}

SV Float4_setXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setXW(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXW.")));
RET CN;
}

SV Float4_getWXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWXZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXZY());
;
}
CATE(TE,UFOF("Float4::getWXZY.")));
RET CN;
}

SV Float4_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("Float4::getXY.")));
RET CN;
}

SV Float4_setZXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZXWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setZXWY(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZXWY.")));
RET CN;
}

SV Float4_setXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setXYW(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXYW.")));
RET CN;
}

SV Float4_getXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZ());
;
}
CATE(TE,UFOF("Float4::getXZ.")));
RET CN;
}

SV Float4_setWZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWZXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setWZXY(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWZXY.")));
RET CN;
}

SV Float4___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__grtr__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("Float4::__grtr__.")));
RET CN;
}

SV Float4_setZWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZWXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setZWXY(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZWXY.")));
RET CN;
}

SV Float4_getXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXW());
;
}
CATE(TE,UFOF("Float4::getXW.")));
RET CN;
}

SV Float4_setXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setXYZ(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXYZ.")));
RET CN;
}

SV Float4___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__div__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("Float4::__div__.")));
RET CN;
}

SV Float4_setWYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWYZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setWYZX(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWYZX.")));
RET CN;
}

SV Float4_setYWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYWXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setYWXZ(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYWXZ.")));
RET CN;
}

SV Float4___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__geq__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("Float4::__geq__.")));
RET CN;
}

SV Float4_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::dot" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("Float4::dot.")));
RET CN;
}

void LightList_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,List<Light*>))
CATE(TE,"LightList::__del__ expects LightList as first argument."));

SCRIPT_DELETE((List<Light*>*)f->data);
}SV LightList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList's constructor" EAOE));
if(!TS(a[0],List<Light*>))
CATE(TE,"LightList's constructor expects LightList as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(List<Light*>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(LightList_funcs,p,EXT->LightList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],std::size_t)){
void *p = (void *)NEW(TYPE(List<Light*>),val_to_c<std::size_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(LightList_funcs,p,EXT->LightList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const List<Light*> &)){
void *p = (void *)NEW(TYPE(List<Light*>),val_to_c<const List<Light*> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(LightList_funcs,p,EXT->LightList_typeID);
}CATE(TE,UFOF("LightList's constructor.")));
RET CN;
}

SV LightList_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("LightList");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(LightList_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(LightList_new);
else
 CATE(KE,"Unknown member for LightList."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(LightList_new);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(LightList___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(LightList___neq__);
 EI(keyStr.equals("get", CPL_STR_HASH("get")))
RET CNF(LightList_get);
 EI(keyStr.equals("set", CPL_STR_HASH("set")))
RET CNF(LightList_set);
 EI(keyStr.equals("getCount", CPL_STR_HASH("getCount")))
RET CNF(LightList_getCount);
 EI(keyStr.equals("getData", CPL_STR_HASH("getData")))
RET CNF(LightList_getData);
 EI(keyStr.equals("append", CPL_STR_HASH("append")))
RET CNF(LightList_append);
 EI(keyStr.equals("insert", CPL_STR_HASH("insert")))
RET CNF(LightList_insert);
 EI(keyStr.equals("remove", CPL_STR_HASH("remove")))
RET CNF(LightList_remove);
 EI(keyStr.equals("clear", CPL_STR_HASH("clear")))
RET CNF(LightList_clear);
 EI(keyStr.equals("find", CPL_STR_HASH("find")))
RET CNF(LightList_find);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(LightList_copy);
 EI(keyStr.equals("in", CPL_STR_HASH("in")))
RET CNF(LightList_in);
 EI(keyStr.equals("reserve", CPL_STR_HASH("reserve")))
RET CNF(LightList_reserve);
 EI(keyStr.equals("begin", CPL_STR_HASH("begin")))
RET CNF(LightList_begin);
 EI(keyStr.equals("end", CPL_STR_HASH("end")))
RET CNF(LightList_end);
 else
 CATE(KE,"Unknown member for LightList."));
}
}
RET CN;
}

void LightList_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for LightList."));
}
}
}

SV LightList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::insert" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],Light*))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<Light*>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<Light*> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<Light*> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("LightList::insert.")));
RET CN;
}

SV LightList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::begin" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("LightList::begin.")));
RET CN;
}

SV LightList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::set" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],Light*))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<Light*>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("LightList::set.")));
RET CN;
}

SV LightList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::end" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("LightList::end.")));
RET CN;
}

SV LightList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::get" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("LightList::get.")));
RET CN;
}

SV LightList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::clear" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("LightList::clear.")));
RET CN;
}

SV LightList_reserve(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::reserve" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->reserve(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("LightList::reserve.")));
RET CN;
}

SV LightList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::copy" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("LightList::copy.")));
RET CN;
}

SV LightList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::remove" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("LightList::remove.")));
RET CN;
}

SV LightList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::in" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Light*))
{
RET CV( f->in(val_to_c<std::remove_reference<Light*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("LightList::in.")));
RET CN;
}

SV LightList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::getCount" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("LightList::getCount.")));
RET CN;
}

SV LightList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::getData" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("LightList::getData.")));
RET CN;
}

SV LightList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::__eq__" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<Light*> &))
{
auto v=val_to_c<std::remove_reference<const List<Light*> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("LightList::__eq__.")));
RET CN;
}

SV LightList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::find" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Light*))
{
RET CV( f->find(val_to_c<std::remove_reference<Light*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("LightList::find.")));
RET CN;
}

SV LightList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::append" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Light*))
{
( f->append(val_to_c<std::remove_reference<Light*>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<Light*> &))
{
( f->append(val_to_c<std::remove_reference<const List<Light*> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("LightList::append.")));
RET CN;
}

SV LightList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::__neq__" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<Light*> &))
{
auto v=val_to_c<std::remove_reference<const List<Light*> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("LightList::__neq__.")));
RET CN;
}

void Float2_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,T2<float>))
CATE(TE,"Float2::__del__ expects Float2 as first argument."));

SCRIPT_DELETE((T2<float>*)f->data);
}SV Float2_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2's constructor" EAOE));
if(!TS(a[0],T2<float>))
CATE(TE,"Float2's constructor expects Float2 as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(T2<float>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float2_funcs,p,EXT->Float2_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],float)){
void *p = (void *)NEW(TYPE(T2<float>),val_to_c<float>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float2_funcs,p,EXT->Float2_typeID);
}if(a.getCount()==3)
if(true&&TS(a[1],float)&&TS(a[2],float)){
void *p = (void *)NEW(TYPE(T2<float>),val_to_c<float>::f(ctx,a[1]),val_to_c<float>::f(ctx,a[2]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float2_funcs,p,EXT->Float2_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T2<float> &)){
void *p = (void *)NEW(TYPE(T2<float>),val_to_c<const T2<float> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float2_funcs,p,EXT->Float2_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T2<int32_t> &)){
void *p = (void *)NEW(TYPE(T2<float>),val_to_c<const T2<int32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float2_funcs,p,EXT->Float2_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T2<uint32_t> &)){
void *p = (void *)NEW(TYPE(T2<float>),val_to_c<const T2<uint32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float2_funcs,p,EXT->Float2_typeID);
}CATE(TE,UFOF("Float2's constructor.")));
RET CN;
}

SV Float2_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Float2");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Float2_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Float2_new);
else
 CATE(KE,"Unknown member for Float2."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Float2_new);
 EI(keyStr.equals("__add__", CPL_STR_HASH("__add__")))
RET CNF(Float2___add__);
 EI(keyStr.equals("__sub__", CPL_STR_HASH("__sub__")))
RET CNF(Float2___sub__);
 EI(keyStr.equals("__mul__", CPL_STR_HASH("__mul__")))
RET CNF(Float2___mul__);
 EI(keyStr.equals("__div__", CPL_STR_HASH("__div__")))
RET CNF(Float2___div__);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(Float2___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(Float2___neq__);
 EI(keyStr.equals("__less__", CPL_STR_HASH("__less__")))
RET CNF(Float2___less__);
 EI(keyStr.equals("__grtr__", CPL_STR_HASH("__grtr__")))
RET CNF(Float2___grtr__);
 EI(keyStr.equals("__leq__", CPL_STR_HASH("__leq__")))
RET CNF(Float2___leq__);
 EI(keyStr.equals("__geq__", CPL_STR_HASH("__geq__")))
RET CNF(Float2___geq__);
 EI(keyStr.equals("sum", CPL_STR_HASH("sum")))
RET CNF(Float2_sum);
 EI(keyStr.equals("length", CPL_STR_HASH("length")))
RET CNF(Float2_length);
 EI(keyStr.equals("lengthSquared", CPL_STR_HASH("lengthSquared")))
RET CNF(Float2_lengthSquared);
 EI(keyStr.equals("dot", CPL_STR_HASH("dot")))
RET CNF(Float2_dot);
 EI(keyStr.equals("distance", CPL_STR_HASH("distance")))
RET CNF(Float2_distance);
 EI(keyStr.equals("distanceSquared", CPL_STR_HASH("distanceSquared")))
RET CNF(Float2_distanceSquared);
 EI(keyStr.equals("normalize", CPL_STR_HASH("normalize")))
RET CNF(Float2_normalize);
 EI(keyStr.equals("getXY", CPL_STR_HASH("getXY")))
RET CNF(Float2_getXY);
 EI(keyStr.equals("setXY", CPL_STR_HASH("setXY")))
RET CNF(Float2_setXY);
 EI(keyStr.equals("getYX", CPL_STR_HASH("getYX")))
RET CNF(Float2_getYX);
 EI(keyStr.equals("setYX", CPL_STR_HASH("setYX")))
RET CNF(Float2_setYX);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(Float2_copy);
 EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T2<float>*obj=(T2<float>*)f->data;
RET CV(obj->x);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T2<float>*obj=(T2<float>*)f->data;
RET CV(obj->y);
} else
 CATE(KE,"Unknown member for Float2."));
}
}
RET CN;
}

void Float2_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T2<float>*obj=(T2<float>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T2<float>*obj=(T2<float>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for Float2."));
}
}
}

SV Float2_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::setYX" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float2::setYX.")));
RET CN;
}

SV Float2_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::distanceSquared" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Float2::distanceSquared.")));
RET CN;
}

SV Float2_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::normalize" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("Float2::normalize.")));
RET CN;
}

SV Float2_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::getYX" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("Float2::getYX.")));
RET CN;
}

SV Float2___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__leq__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("Float2::__leq__.")));
RET CN;
}

SV Float2_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::sum" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("Float2::sum.")));
RET CN;
}

SV Float2___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__div__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("Float2::__div__.")));
RET CN;
}

SV Float2___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__less__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("Float2::__less__.")));
RET CN;
}

SV Float2___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__neq__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("Float2::__neq__.")));
RET CN;
}

SV Float2_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::lengthSquared" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("Float2::lengthSquared.")));
RET CN;
}

SV Float2_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::setXY" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float2::setXY.")));
RET CN;
}

SV Float2___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__add__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("Float2::__add__.")));
RET CN;
}

SV Float2_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::copy" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("Float2::copy.")));
RET CN;
}

SV Float2___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__eq__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Float2::__eq__.")));
RET CN;
}

SV Float2_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::getXY" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("Float2::getXY.")));
RET CN;
}

SV Float2_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::distance" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Float2::distance.")));
RET CN;
}

SV Float2___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__grtr__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("Float2::__grtr__.")));
RET CN;
}

SV Float2_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::length" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("Float2::length.")));
RET CN;
}

SV Float2___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__mul__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Float2::__mul__.")));
RET CN;
}

SV Float2___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__sub__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("Float2::__sub__.")));
RET CN;
}

SV Float2___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__geq__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("Float2::__geq__.")));
RET CN;
}

SV Float2_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::dot" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("Float2::dot.")));
RET CN;
}

void Float3_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,T3<float>))
CATE(TE,"Float3::__del__ expects Float3 as first argument."));

SCRIPT_DELETE((T3<float>*)f->data);
}SV Float3_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3's constructor" EAOE));
if(!TS(a[0],T3<float>))
CATE(TE,"Float3's constructor expects Float3 as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(T3<float>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float3_funcs,p,EXT->Float3_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],float)){
void *p = (void *)NEW(TYPE(T3<float>),val_to_c<float>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float3_funcs,p,EXT->Float3_typeID);
}if(a.getCount()==4)
if(true&&TS(a[1],float)&&TS(a[2],float)&&TS(a[3],float)){
void *p = (void *)NEW(TYPE(T3<float>),val_to_c<float>::f(ctx,a[1]),val_to_c<float>::f(ctx,a[2]),val_to_c<float>::f(ctx,a[3]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float3_funcs,p,EXT->Float3_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T3<float> &)){
void *p = (void *)NEW(TYPE(T3<float>),val_to_c<const T3<float> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float3_funcs,p,EXT->Float3_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T3<int32_t> &)){
void *p = (void *)NEW(TYPE(T3<float>),val_to_c<const T3<int32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float3_funcs,p,EXT->Float3_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T3<uint32_t> &)){
void *p = (void *)NEW(TYPE(T3<float>),val_to_c<const T3<uint32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Float3_funcs,p,EXT->Float3_typeID);
}CATE(TE,UFOF("Float3's constructor.")));
RET CN;
}

SV Float3_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Float3");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Float3_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Float3_new);
else
 CATE(KE,"Unknown member for Float3."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Float3_new);
 EI(keyStr.equals("__add__", CPL_STR_HASH("__add__")))
RET CNF(Float3___add__);
 EI(keyStr.equals("__sub__", CPL_STR_HASH("__sub__")))
RET CNF(Float3___sub__);
 EI(keyStr.equals("__mul__", CPL_STR_HASH("__mul__")))
RET CNF(Float3___mul__);
 EI(keyStr.equals("__div__", CPL_STR_HASH("__div__")))
RET CNF(Float3___div__);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(Float3___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(Float3___neq__);
 EI(keyStr.equals("__less__", CPL_STR_HASH("__less__")))
RET CNF(Float3___less__);
 EI(keyStr.equals("__grtr__", CPL_STR_HASH("__grtr__")))
RET CNF(Float3___grtr__);
 EI(keyStr.equals("__leq__", CPL_STR_HASH("__leq__")))
RET CNF(Float3___leq__);
 EI(keyStr.equals("__geq__", CPL_STR_HASH("__geq__")))
RET CNF(Float3___geq__);
 EI(keyStr.equals("sum", CPL_STR_HASH("sum")))
RET CNF(Float3_sum);
 EI(keyStr.equals("length", CPL_STR_HASH("length")))
RET CNF(Float3_length);
 EI(keyStr.equals("lengthSquared", CPL_STR_HASH("lengthSquared")))
RET CNF(Float3_lengthSquared);
 EI(keyStr.equals("dot", CPL_STR_HASH("dot")))
RET CNF(Float3_dot);
 EI(keyStr.equals("distance", CPL_STR_HASH("distance")))
RET CNF(Float3_distance);
 EI(keyStr.equals("distanceSquared", CPL_STR_HASH("distanceSquared")))
RET CNF(Float3_distanceSquared);
 EI(keyStr.equals("normalize", CPL_STR_HASH("normalize")))
RET CNF(Float3_normalize);
 EI(keyStr.equals("cross", CPL_STR_HASH("cross")))
RET CNF(Float3_cross);
 EI(keyStr.equals("getXY", CPL_STR_HASH("getXY")))
RET CNF(Float3_getXY);
 EI(keyStr.equals("setXY", CPL_STR_HASH("setXY")))
RET CNF(Float3_setXY);
 EI(keyStr.equals("getXZ", CPL_STR_HASH("getXZ")))
RET CNF(Float3_getXZ);
 EI(keyStr.equals("setXZ", CPL_STR_HASH("setXZ")))
RET CNF(Float3_setXZ);
 EI(keyStr.equals("getYX", CPL_STR_HASH("getYX")))
RET CNF(Float3_getYX);
 EI(keyStr.equals("setYX", CPL_STR_HASH("setYX")))
RET CNF(Float3_setYX);
 EI(keyStr.equals("getYZ", CPL_STR_HASH("getYZ")))
RET CNF(Float3_getYZ);
 EI(keyStr.equals("setYZ", CPL_STR_HASH("setYZ")))
RET CNF(Float3_setYZ);
 EI(keyStr.equals("getZX", CPL_STR_HASH("getZX")))
RET CNF(Float3_getZX);
 EI(keyStr.equals("setZX", CPL_STR_HASH("setZX")))
RET CNF(Float3_setZX);
 EI(keyStr.equals("getZY", CPL_STR_HASH("getZY")))
RET CNF(Float3_getZY);
 EI(keyStr.equals("setZY", CPL_STR_HASH("setZY")))
RET CNF(Float3_setZY);
 EI(keyStr.equals("getXYZ", CPL_STR_HASH("getXYZ")))
RET CNF(Float3_getXYZ);
 EI(keyStr.equals("setXYZ", CPL_STR_HASH("setXYZ")))
RET CNF(Float3_setXYZ);
 EI(keyStr.equals("getXZY", CPL_STR_HASH("getXZY")))
RET CNF(Float3_getXZY);
 EI(keyStr.equals("setXZY", CPL_STR_HASH("setXZY")))
RET CNF(Float3_setXZY);
 EI(keyStr.equals("getYXZ", CPL_STR_HASH("getYXZ")))
RET CNF(Float3_getYXZ);
 EI(keyStr.equals("setYXZ", CPL_STR_HASH("setYXZ")))
RET CNF(Float3_setYXZ);
 EI(keyStr.equals("getYZX", CPL_STR_HASH("getYZX")))
RET CNF(Float3_getYZX);
 EI(keyStr.equals("setYZX", CPL_STR_HASH("setYZX")))
RET CNF(Float3_setYZX);
 EI(keyStr.equals("getZXY", CPL_STR_HASH("getZXY")))
RET CNF(Float3_getZXY);
 EI(keyStr.equals("setZXY", CPL_STR_HASH("setZXY")))
RET CNF(Float3_setZXY);
 EI(keyStr.equals("getZYX", CPL_STR_HASH("getZYX")))
RET CNF(Float3_getZYX);
 EI(keyStr.equals("setZYX", CPL_STR_HASH("setZYX")))
RET CNF(Float3_setZYX);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(Float3_copy);
 EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T3<float>*obj=(T3<float>*)f->data;
RET CV(obj->x);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T3<float>*obj=(T3<float>*)f->data;
RET CV(obj->y);
} EI(keyStr.equals("z", CPL_STR_HASH("z")))
{
T3<float>*obj=(T3<float>*)f->data;
RET CV(obj->z);
} else
 CATE(KE,"Unknown member for Float3."));
}
}
RET CN;
}

void Float3_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T3<float>*obj=(T3<float>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T3<float>*obj=(T3<float>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} EI(keyStr.equals("z", CPL_STR_HASH("z")))
{
T3<float>*obj=(T3<float>*)f->data;
obj->z=val_to_c<decltype(obj->z)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for Float3."));
}
}
}

SV Float3_setYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setYZX" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setYZX(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setYZX.")));
RET CN;
}

SV Float3_getZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getZXY" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXY());
;
}
CATE(TE,UFOF("Float3::getZXY.")));
RET CN;
}

SV Float3_setYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setYZ" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setYZ(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setYZ.")));
RET CN;
}

SV Float3_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setYX" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setYX.")));
RET CN;
}

SV Float3_setZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setZYX" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setZYX(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setZYX.")));
RET CN;
}

SV Float3_getZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getZY" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZY());
;
}
CATE(TE,UFOF("Float3::getZY.")));
RET CN;
}

SV Float3_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::distanceSquared" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Float3::distanceSquared.")));
RET CN;
}

SV Float3_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::normalize" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("Float3::normalize.")));
RET CN;
}

SV Float3_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getYX" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("Float3::getYX.")));
RET CN;
}

SV Float3___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__leq__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("Float3::__leq__.")));
RET CN;
}

SV Float3_setXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setXZY" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setXZY(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setXZY.")));
RET CN;
}

SV Float3_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::sum" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("Float3::sum.")));
RET CN;
}

SV Float3_cross(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::cross" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
RET CV( f->cross(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Float3::cross.")));
RET CN;
}

SV Float3_getXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getXYZ" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZ());
;
}
CATE(TE,UFOF("Float3::getXYZ.")));
RET CN;
}

SV Float3___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__less__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("Float3::__less__.")));
RET CN;
}

SV Float3___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__neq__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("Float3::__neq__.")));
RET CN;
}

SV Float3_getYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getYZ" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZ());
;
}
CATE(TE,UFOF("Float3::getYZ.")));
RET CN;
}

SV Float3_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::lengthSquared" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("Float3::lengthSquared.")));
RET CN;
}

SV Float3_getZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getZYX" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYX());
;
}
CATE(TE,UFOF("Float3::getZYX.")));
RET CN;
}

SV Float3___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__div__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("Float3::__div__.")));
RET CN;
}

SV Float3_setZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setZY" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setZY(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setZY.")));
RET CN;
}

SV Float3_setZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setZX" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setZX(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setZX.")));
RET CN;
}

SV Float3_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setXY" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setXY.")));
RET CN;
}

SV Float3___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__add__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("Float3::__add__.")));
RET CN;
}

SV Float3_setXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setXZ" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setXZ(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setXZ.")));
RET CN;
}

SV Float3_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::copy" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("Float3::copy.")));
RET CN;
}

SV Float3___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__eq__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Float3::__eq__.")));
RET CN;
}

SV Float3_setZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setZXY" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setZXY(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setZXY.")));
RET CN;
}

SV Float3_setYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setYXZ" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setYXZ(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setYXZ.")));
RET CN;
}

SV Float3_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getXY" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("Float3::getXY.")));
RET CN;
}

SV Float3_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::distance" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Float3::distance.")));
RET CN;
}

SV Float3_getXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getXZ" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZ());
;
}
CATE(TE,UFOF("Float3::getXZ.")));
RET CN;
}

SV Float3___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__grtr__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("Float3::__grtr__.")));
RET CN;
}

SV Float3_getXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getXZY" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZY());
;
}
CATE(TE,UFOF("Float3::getXZY.")));
RET CN;
}

SV Float3_setXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setXYZ" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setXYZ(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setXYZ.")));
RET CN;
}

SV Float3_getYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getYZX" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZX());
;
}
CATE(TE,UFOF("Float3::getYZX.")));
RET CN;
}

SV Float3_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::length" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("Float3::length.")));
RET CN;
}

SV Float3___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__mul__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Float3::__mul__.")));
RET CN;
}

SV Float3_getYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getYXZ" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZ());
;
}
CATE(TE,UFOF("Float3::getYXZ.")));
RET CN;
}

SV Float3_getZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getZX" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZX());
;
}
CATE(TE,UFOF("Float3::getZX.")));
RET CN;
}

SV Float3___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__sub__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("Float3::__sub__.")));
RET CN;
}

SV Float3___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__geq__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("Float3::__geq__.")));
RET CN;
}

SV Float3_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::dot" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("Float3::dot.")));
RET CN;
}

void Container_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Container))
CATE(TE,"Container::__del__ expects Container as first argument."));

SCRIPT_DELETE((Container*)f->data);
}SV Container_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Container's constructor" EAOE));
if(!TS(a[0],Container))
CATE(TE,"Container's constructor expects Container as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(Container));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Container_funcs,p,EXT->Container_typeID);
}CATE(TE,UFOF("Container's constructor.")));
RET CN;
}

SV Container_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Container");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Container_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Container_new);
else
 CATE(KE,"Unknown member for Container."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Container_new);
 EI(keyStr.equals("vertical", CPL_STR_HASH("vertical")))
{
Container*obj=(Container*)f->data;
RET CV(obj->vertical);
} EI(keyStr.equals("horizonal", CPL_STR_HASH("horizonal")))
{
Container*obj=(Container*)f->data;
RET CV(obj->horizonal);
} else
 CATE(KE,"Unknown member for Container."));
}
}
RET CN;
}

void Container_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("vertical", CPL_STR_HASH("vertical")))
{
Container*obj=(Container*)f->data;
obj->vertical=val_to_c<decltype(obj->vertical)>::f(ctx,value);
} EI(keyStr.equals("horizonal", CPL_STR_HASH("horizonal")))
{
Container*obj=(Container*)f->data;
obj->horizonal=val_to_c<decltype(obj->horizonal)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for Container."));
}
}
}

void Frustum_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Frustum))
CATE(TE,"Frustum::__del__ expects Frustum as first argument."));

SCRIPT_DELETE((Frustum*)f->data);
}SV Frustum_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Frustum's constructor" EAOE));
if(!TS(a[0],Frustum))
CATE(TE,"Frustum's constructor expects Frustum as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(Frustum));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Frustum_funcs,p,EXT->Frustum_typeID);
}if(a.getCount()==10)
if(true&&TS(a[1],const Position3D &)&&TS(a[2],const Position3D)&&TS(a[3],const Position3D)&&TS(a[4],const Position3D)&&TS(a[5],const Position3D)&&TS(a[6],const Position3D)&&TS(a[7],const Position3D)&&TS(a[8],const Position3D)&&TS(a[9],const Position3D)){
void *p = (void *)NEW(TYPE(Frustum),val_to_c<const Position3D &>::f(ctx,a[1]),val_to_c<const Position3D>::f(ctx,a[2]),val_to_c<const Position3D>::f(ctx,a[3]),val_to_c<const Position3D>::f(ctx,a[4]),val_to_c<const Position3D>::f(ctx,a[5]),val_to_c<const Position3D>::f(ctx,a[6]),val_to_c<const Position3D>::f(ctx,a[7]),val_to_c<const Position3D>::f(ctx,a[8]),val_to_c<const Position3D>::f(ctx,a[9]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Frustum_funcs,p,EXT->Frustum_typeID);
}CATE(TE,UFOF("Frustum's constructor.")));
RET CN;
}

SV Frustum_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Frustum");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Frustum_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Frustum_new);
else
 CATE(KE,"Unknown member for Frustum."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Frustum_new);
 EI(keyStr.equals("getOrigin", CPL_STR_HASH("getOrigin")))
RET CNF(Frustum_getOrigin);
 EI(keyStr.equals("getCorner", CPL_STR_HASH("getCorner")))
RET CNF(Frustum_getCorner);
 EI(keyStr.equals("getPlane", CPL_STR_HASH("getPlane")))
RET CNF(Frustum_getPlane);
 EI(keyStr.equals("view", CPL_STR_HASH("view")))
RET CNF(Frustum_view);
 EI(keyStr.equals("box", CPL_STR_HASH("box")))
RET CNF(Frustum_box);
 EI(keyStr.equals("getAABB", CPL_STR_HASH("getAABB")))
RET CNF(Frustum_getAABB);
 EI(keyStr.equals("sphereIntersection", CPL_STR_HASH("sphereIntersection")))
RET CNF(Frustum_sphereIntersection);
 EI(keyStr.equals("aabbIntersection", CPL_STR_HASH("aabbIntersection")))
RET CNF(Frustum_aabbIntersection);
 else
 CATE(KE,"Unknown member for Frustum."));
}
}
RET CN;
}

void Frustum_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for Frustum."));
}
}
}

SV Frustum_box(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Frustum::box" EAOE));
Frustum*f;
f=(Frustum*)((NO)a[0].p)->data;

if(a.getCount()==8)
if(1&&TS(a[1],const Matrix4x4 &)&&TS(a[2],float)&&TS(a[3],float)&&TS(a[4],float)&&TS(a[5],float)&&TS(a[6],float)&&TS(a[7],float))
{
RET CV( f->box(val_to_c<std::remove_reference<const Matrix4x4 &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[5]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[6]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[7])));
;
}
CATE(TE,UFOF("Frustum::box.")));
RET CN;
}

SV Frustum_getCorner(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Frustum::getCorner" EAOE));
Frustum*f;
f=(Frustum*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getCorner(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Frustum::getCorner.")));
RET CN;
}

SV Frustum_sphereIntersection(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Frustum::sphereIntersection" EAOE));
Frustum*f;
f=(Frustum*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],const Position3D &)&&TS(a[2],float))
{
RET CV( f->sphereIntersection(val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("Frustum::sphereIntersection.")));
RET CN;
}

SV Frustum_getOrigin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Frustum::getOrigin" EAOE));
Frustum*f;
f=(Frustum*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getOrigin());
;
}
CATE(TE,UFOF("Frustum::getOrigin.")));
RET CN;
}

SV Frustum_getPlane(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Frustum::getPlane" EAOE));
Frustum*f;
f=(Frustum*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getPlane(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Frustum::getPlane.")));
RET CN;
}

SV Frustum_getAABB(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Frustum::getAABB" EAOE));
Frustum*f;
f=(Frustum*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAABB());
;
}
CATE(TE,UFOF("Frustum::getAABB.")));
RET CN;
}

SV Frustum_aabbIntersection(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Frustum::aabbIntersection" EAOE));
Frustum*f;
f=(Frustum*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const AABB &))
{
RET CV( f->aabbIntersection(val_to_c<std::remove_reference<const AABB &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Frustum::aabbIntersection.")));
RET CN;
}

SV Frustum_view(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Frustum::view" EAOE));
Frustum*f;
f=(Frustum*)((NO)a[0].p)->data;

if(a.getCount()==6)
if(1&&TS(a[1],const Matrix4x4 &)&&TS(a[2],float)&&TS(a[3],float)&&TS(a[4],float)&&TS(a[5],float))
{
RET CV( f->view(val_to_c<std::remove_reference<const Matrix4x4 &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[5])));
;
}
if(a.getCount()==8)
if(1&&TS(a[1],const Matrix4x4 &)&&TS(a[2],float)&&TS(a[3],float)&&TS(a[4],float)&&TS(a[5],float)&&TS(a[6],float)&&TS(a[7],float))
{
RET CV( f->view(val_to_c<std::remove_reference<const Matrix4x4 &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[5]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[6]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[7])));
;
}
CATE(TE,UFOF("Frustum::view.")));
RET CN;
}

void AudioDevice_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,AudioDevice))
CATE(TE,"AudioDevice::__del__ expects AudioDevice as first argument."));

SCRIPT_DELETE((AudioDevice*)f->data);
}SV AudioDevice_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice's constructor" EAOE));
if(!TS(a[0],AudioDevice))
CATE(TE,"AudioDevice's constructor expects AudioDevice as first argument."));
if(a.getCount()==4)
if(true&&TS(a[1],size_t)&&TS(a[2],size_t)&&TS(a[3],size_t)){
void *p = (void *)NEW(TYPE(AudioDevice),val_to_c<size_t>::f(ctx,a[1]),val_to_c<size_t>::f(ctx,a[2]),val_to_c<size_t>::f(ctx,a[3]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(AudioDevice_funcs,p,EXT->AudioDevice_typeID);
}CATE(TE,UFOF("AudioDevice's constructor.")));
RET CN;
}

SV AudioDevice_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("AudioDevice");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(AudioDevice_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(AudioDevice_new);
else
 CATE(KE,"Unknown member for AudioDevice."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(AudioDevice_new);
 EI(keyStr.equals("getName", CPL_STR_HASH("getName")))
RET CNF(AudioDevice_getName);
 EI(keyStr.equals("getDeviceCount", CPL_STR_HASH("getDeviceCount")))
RET CNF(AudioDevice_getDeviceCount);
 EI(keyStr.equals("setIndex", CPL_STR_HASH("setIndex")))
RET CNF(AudioDevice_setIndex);
 EI(keyStr.equals("setFrequency", CPL_STR_HASH("setFrequency")))
RET CNF(AudioDevice_setFrequency);
 EI(keyStr.equals("setSamples", CPL_STR_HASH("setSamples")))
RET CNF(AudioDevice_setSamples);
 EI(keyStr.equals("getIndex", CPL_STR_HASH("getIndex")))
RET CNF(AudioDevice_getIndex);
 EI(keyStr.equals("getFrequency", CPL_STR_HASH("getFrequency")))
RET CNF(AudioDevice_getFrequency);
 EI(keyStr.equals("getSamples", CPL_STR_HASH("getSamples")))
RET CNF(AudioDevice_getSamples);
 EI(keyStr.equals("getNumQueuedSamples", CPL_STR_HASH("getNumQueuedSamples")))
RET CNF(AudioDevice_getNumQueuedSamples);
 EI(keyStr.equals("pause", CPL_STR_HASH("pause")))
RET CNF(AudioDevice_pause);
 EI(keyStr.equals("play", CPL_STR_HASH("play")))
RET CNF(AudioDevice_play);
 EI(keyStr.equals("getPaused", CPL_STR_HASH("getPaused")))
RET CNF(AudioDevice_getPaused);
 EI(keyStr.equals("runCallbacks", CPL_STR_HASH("runCallbacks")))
RET CNF(AudioDevice_runCallbacks);
 EI(keyStr.equals("volume", CPL_STR_HASH("volume")))
{
AudioDevice*obj=(AudioDevice*)f->data;
RET CV(obj->volume);
} else
 CATE(KE,"Unknown member for AudioDevice."));
}
}
RET CN;
}

void AudioDevice_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("volume", CPL_STR_HASH("volume")))
{
AudioDevice*obj=(AudioDevice*)f->data;
obj->volume=val_to_c<decltype(obj->volume)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for AudioDevice."));
}
}
}

SV AudioDevice_getIndex(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::getIndex" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getIndex());
;
}
CATE(TE,UFOF("AudioDevice::getIndex.")));
RET CN;
}

SV AudioDevice_getFrequency(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::getFrequency" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFrequency());
;
}
CATE(TE,UFOF("AudioDevice::getFrequency.")));
RET CN;
}

SV AudioDevice_pause(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::pause" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->pause());
RET CN;
}
CATE(TE,UFOF("AudioDevice::pause.")));
RET CN;
}

SV AudioDevice_runCallbacks(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::runCallbacks" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->runCallbacks(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioDevice::runCallbacks.")));
RET CN;
}

SV AudioDevice_getName(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::getName" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getName());
;
}
if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getName(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("AudioDevice::getName.")));
RET CN;
}

SV AudioDevice_getPaused(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::getPaused" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getPaused());
;
}
CATE(TE,UFOF("AudioDevice::getPaused.")));
RET CN;
}

SV AudioDevice_setIndex(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::setIndex" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->setIndex(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioDevice::setIndex.")));
RET CN;
}

SV AudioDevice_play(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::play" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->play());
RET CN;
}
CATE(TE,UFOF("AudioDevice::play.")));
RET CN;
}

SV AudioDevice_getSamples(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::getSamples" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getSamples());
;
}
CATE(TE,UFOF("AudioDevice::getSamples.")));
RET CN;
}

SV AudioDevice_setFrequency(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::setFrequency" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->setFrequency(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioDevice::setFrequency.")));
RET CN;
}

SV AudioDevice_getNumQueuedSamples(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::getNumQueuedSamples" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getNumQueuedSamples());
;
}
CATE(TE,UFOF("AudioDevice::getNumQueuedSamples.")));
RET CN;
}

SV AudioDevice_getDeviceCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::getDeviceCount" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDeviceCount());
;
}
CATE(TE,UFOF("AudioDevice::getDeviceCount.")));
RET CN;
}

SV AudioDevice_setSamples(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::setSamples" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->setSamples(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioDevice::setSamples.")));
RET CN;
}

void UInt4_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,T4<uint32_t>))
CATE(TE,"UInt4::__del__ expects UInt4 as first argument."));

SCRIPT_DELETE((T4<uint32_t>*)f->data);
}SV UInt4_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4's constructor" EAOE));
if(!TS(a[0],T4<uint32_t>))
CATE(TE,"UInt4's constructor expects UInt4 as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(T4<uint32_t>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt4_funcs,p,EXT->UInt4_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],uint32_t)){
void *p = (void *)NEW(TYPE(T4<uint32_t>),val_to_c<uint32_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt4_funcs,p,EXT->UInt4_typeID);
}if(a.getCount()==5)
if(true&&TS(a[1],uint32_t)&&TS(a[2],uint32_t)&&TS(a[3],uint32_t)&&TS(a[4],uint32_t)){
void *p = (void *)NEW(TYPE(T4<uint32_t>),val_to_c<uint32_t>::f(ctx,a[1]),val_to_c<uint32_t>::f(ctx,a[2]),val_to_c<uint32_t>::f(ctx,a[3]),val_to_c<uint32_t>::f(ctx,a[4]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt4_funcs,p,EXT->UInt4_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T4<float> &)){
void *p = (void *)NEW(TYPE(T4<uint32_t>),val_to_c<const T4<float> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt4_funcs,p,EXT->UInt4_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T4<int32_t> &)){
void *p = (void *)NEW(TYPE(T4<uint32_t>),val_to_c<const T4<int32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt4_funcs,p,EXT->UInt4_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T4<uint32_t> &)){
void *p = (void *)NEW(TYPE(T4<uint32_t>),val_to_c<const T4<uint32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt4_funcs,p,EXT->UInt4_typeID);
}CATE(TE,UFOF("UInt4's constructor.")));
RET CN;
}

SV UInt4_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("UInt4");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(UInt4_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(UInt4_new);
else
 CATE(KE,"Unknown member for UInt4."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(UInt4_new);
 EI(keyStr.equals("__add__", CPL_STR_HASH("__add__")))
RET CNF(UInt4___add__);
 EI(keyStr.equals("__sub__", CPL_STR_HASH("__sub__")))
RET CNF(UInt4___sub__);
 EI(keyStr.equals("__mul__", CPL_STR_HASH("__mul__")))
RET CNF(UInt4___mul__);
 EI(keyStr.equals("__div__", CPL_STR_HASH("__div__")))
RET CNF(UInt4___div__);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(UInt4___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(UInt4___neq__);
 EI(keyStr.equals("__less__", CPL_STR_HASH("__less__")))
RET CNF(UInt4___less__);
 EI(keyStr.equals("__grtr__", CPL_STR_HASH("__grtr__")))
RET CNF(UInt4___grtr__);
 EI(keyStr.equals("__leq__", CPL_STR_HASH("__leq__")))
RET CNF(UInt4___leq__);
 EI(keyStr.equals("__geq__", CPL_STR_HASH("__geq__")))
RET CNF(UInt4___geq__);
 EI(keyStr.equals("sum", CPL_STR_HASH("sum")))
RET CNF(UInt4_sum);
 EI(keyStr.equals("length", CPL_STR_HASH("length")))
RET CNF(UInt4_length);
 EI(keyStr.equals("lengthSquared", CPL_STR_HASH("lengthSquared")))
RET CNF(UInt4_lengthSquared);
 EI(keyStr.equals("dot", CPL_STR_HASH("dot")))
RET CNF(UInt4_dot);
 EI(keyStr.equals("distance", CPL_STR_HASH("distance")))
RET CNF(UInt4_distance);
 EI(keyStr.equals("distanceSquared", CPL_STR_HASH("distanceSquared")))
RET CNF(UInt4_distanceSquared);
 EI(keyStr.equals("normalize", CPL_STR_HASH("normalize")))
RET CNF(UInt4_normalize);
 EI(keyStr.equals("getXY", CPL_STR_HASH("getXY")))
RET CNF(UInt4_getXY);
 EI(keyStr.equals("setXY", CPL_STR_HASH("setXY")))
RET CNF(UInt4_setXY);
 EI(keyStr.equals("getXZ", CPL_STR_HASH("getXZ")))
RET CNF(UInt4_getXZ);
 EI(keyStr.equals("setXZ", CPL_STR_HASH("setXZ")))
RET CNF(UInt4_setXZ);
 EI(keyStr.equals("getXW", CPL_STR_HASH("getXW")))
RET CNF(UInt4_getXW);
 EI(keyStr.equals("setXW", CPL_STR_HASH("setXW")))
RET CNF(UInt4_setXW);
 EI(keyStr.equals("getYX", CPL_STR_HASH("getYX")))
RET CNF(UInt4_getYX);
 EI(keyStr.equals("setYX", CPL_STR_HASH("setYX")))
RET CNF(UInt4_setYX);
 EI(keyStr.equals("getYZ", CPL_STR_HASH("getYZ")))
RET CNF(UInt4_getYZ);
 EI(keyStr.equals("setYZ", CPL_STR_HASH("setYZ")))
RET CNF(UInt4_setYZ);
 EI(keyStr.equals("getYW", CPL_STR_HASH("getYW")))
RET CNF(UInt4_getYW);
 EI(keyStr.equals("setYW", CPL_STR_HASH("setYW")))
RET CNF(UInt4_setYW);
 EI(keyStr.equals("getZX", CPL_STR_HASH("getZX")))
RET CNF(UInt4_getZX);
 EI(keyStr.equals("setZX", CPL_STR_HASH("setZX")))
RET CNF(UInt4_setZX);
 EI(keyStr.equals("getZY", CPL_STR_HASH("getZY")))
RET CNF(UInt4_getZY);
 EI(keyStr.equals("setZY", CPL_STR_HASH("setZY")))
RET CNF(UInt4_setZY);
 EI(keyStr.equals("getZW", CPL_STR_HASH("getZW")))
RET CNF(UInt4_getZW);
 EI(keyStr.equals("setZW", CPL_STR_HASH("setZW")))
RET CNF(UInt4_setZW);
 EI(keyStr.equals("getWX", CPL_STR_HASH("getWX")))
RET CNF(UInt4_getWX);
 EI(keyStr.equals("setWX", CPL_STR_HASH("setWX")))
RET CNF(UInt4_setWX);
 EI(keyStr.equals("getWY", CPL_STR_HASH("getWY")))
RET CNF(UInt4_getWY);
 EI(keyStr.equals("setWY", CPL_STR_HASH("setWY")))
RET CNF(UInt4_setWY);
 EI(keyStr.equals("getWZ", CPL_STR_HASH("getWZ")))
RET CNF(UInt4_getWZ);
 EI(keyStr.equals("setWZ", CPL_STR_HASH("setWZ")))
RET CNF(UInt4_setWZ);
 EI(keyStr.equals("getXYZ", CPL_STR_HASH("getXYZ")))
RET CNF(UInt4_getXYZ);
 EI(keyStr.equals("setXYZ", CPL_STR_HASH("setXYZ")))
RET CNF(UInt4_setXYZ);
 EI(keyStr.equals("getXYW", CPL_STR_HASH("getXYW")))
RET CNF(UInt4_getXYW);
 EI(keyStr.equals("setXYW", CPL_STR_HASH("setXYW")))
RET CNF(UInt4_setXYW);
 EI(keyStr.equals("getXZY", CPL_STR_HASH("getXZY")))
RET CNF(UInt4_getXZY);
 EI(keyStr.equals("setXZY", CPL_STR_HASH("setXZY")))
RET CNF(UInt4_setXZY);
 EI(keyStr.equals("getXZW", CPL_STR_HASH("getXZW")))
RET CNF(UInt4_getXZW);
 EI(keyStr.equals("setXZW", CPL_STR_HASH("setXZW")))
RET CNF(UInt4_setXZW);
 EI(keyStr.equals("getXWZ", CPL_STR_HASH("getXWZ")))
RET CNF(UInt4_getXWZ);
 EI(keyStr.equals("setXWZ", CPL_STR_HASH("setXWZ")))
RET CNF(UInt4_setXWZ);
 EI(keyStr.equals("getXWY", CPL_STR_HASH("getXWY")))
RET CNF(UInt4_getXWY);
 EI(keyStr.equals("setXWY", CPL_STR_HASH("setXWY")))
RET CNF(UInt4_setXWY);
 EI(keyStr.equals("getYXZ", CPL_STR_HASH("getYXZ")))
RET CNF(UInt4_getYXZ);
 EI(keyStr.equals("setYXZ", CPL_STR_HASH("setYXZ")))
RET CNF(UInt4_setYXZ);
 EI(keyStr.equals("getYXW", CPL_STR_HASH("getYXW")))
RET CNF(UInt4_getYXW);
 EI(keyStr.equals("setYXW", CPL_STR_HASH("setYXW")))
RET CNF(UInt4_setYXW);
 EI(keyStr.equals("getYZX", CPL_STR_HASH("getYZX")))
RET CNF(UInt4_getYZX);
 EI(keyStr.equals("setYZX", CPL_STR_HASH("setYZX")))
RET CNF(UInt4_setYZX);
 EI(keyStr.equals("getYZW", CPL_STR_HASH("getYZW")))
RET CNF(UInt4_getYZW);
 EI(keyStr.equals("setYZW", CPL_STR_HASH("setYZW")))
RET CNF(UInt4_setYZW);
 EI(keyStr.equals("getYWZ", CPL_STR_HASH("getYWZ")))
RET CNF(UInt4_getYWZ);
 EI(keyStr.equals("setYWZ", CPL_STR_HASH("setYWZ")))
RET CNF(UInt4_setYWZ);
 EI(keyStr.equals("getYWX", CPL_STR_HASH("getYWX")))
RET CNF(UInt4_getYWX);
 EI(keyStr.equals("setYWX", CPL_STR_HASH("setYWX")))
RET CNF(UInt4_setYWX);
 EI(keyStr.equals("getZXY", CPL_STR_HASH("getZXY")))
RET CNF(UInt4_getZXY);
 EI(keyStr.equals("setZXY", CPL_STR_HASH("setZXY")))
RET CNF(UInt4_setZXY);
 EI(keyStr.equals("getZXW", CPL_STR_HASH("getZXW")))
RET CNF(UInt4_getZXW);
 EI(keyStr.equals("setZXW", CPL_STR_HASH("setZXW")))
RET CNF(UInt4_setZXW);
 EI(keyStr.equals("getZYX", CPL_STR_HASH("getZYX")))
RET CNF(UInt4_getZYX);
 EI(keyStr.equals("setZYX", CPL_STR_HASH("setZYX")))
RET CNF(UInt4_setZYX);
 EI(keyStr.equals("getZYW", CPL_STR_HASH("getZYW")))
RET CNF(UInt4_getZYW);
 EI(keyStr.equals("setZYW", CPL_STR_HASH("setZYW")))
RET CNF(UInt4_setZYW);
 EI(keyStr.equals("getZWY", CPL_STR_HASH("getZWY")))
RET CNF(UInt4_getZWY);
 EI(keyStr.equals("setZWY", CPL_STR_HASH("setZWY")))
RET CNF(UInt4_setZWY);
 EI(keyStr.equals("getZWX", CPL_STR_HASH("getZWX")))
RET CNF(UInt4_getZWX);
 EI(keyStr.equals("setZWX", CPL_STR_HASH("setZWX")))
RET CNF(UInt4_setZWX);
 EI(keyStr.equals("getWXY", CPL_STR_HASH("getWXY")))
RET CNF(UInt4_getWXY);
 EI(keyStr.equals("setWXY", CPL_STR_HASH("setWXY")))
RET CNF(UInt4_setWXY);
 EI(keyStr.equals("getWXZ", CPL_STR_HASH("getWXZ")))
RET CNF(UInt4_getWXZ);
 EI(keyStr.equals("setWXZ", CPL_STR_HASH("setWXZ")))
RET CNF(UInt4_setWXZ);
 EI(keyStr.equals("getWYX", CPL_STR_HASH("getWYX")))
RET CNF(UInt4_getWYX);
 EI(keyStr.equals("setWYX", CPL_STR_HASH("setWYX")))
RET CNF(UInt4_setWYX);
 EI(keyStr.equals("getWYZ", CPL_STR_HASH("getWYZ")))
RET CNF(UInt4_getWYZ);
 EI(keyStr.equals("setWYZ", CPL_STR_HASH("setWYZ")))
RET CNF(UInt4_setWYZ);
 EI(keyStr.equals("getWZY", CPL_STR_HASH("getWZY")))
RET CNF(UInt4_getWZY);
 EI(keyStr.equals("setWZY", CPL_STR_HASH("setWZY")))
RET CNF(UInt4_setWZY);
 EI(keyStr.equals("getWZX", CPL_STR_HASH("getWZX")))
RET CNF(UInt4_getWZX);
 EI(keyStr.equals("setWZX", CPL_STR_HASH("setWZX")))
RET CNF(UInt4_setWZX);
 EI(keyStr.equals("getXYZW", CPL_STR_HASH("getXYZW")))
RET CNF(UInt4_getXYZW);
 EI(keyStr.equals("setXYZW", CPL_STR_HASH("setXYZW")))
RET CNF(UInt4_setXYZW);
 EI(keyStr.equals("getXYWZ", CPL_STR_HASH("getXYWZ")))
RET CNF(UInt4_getXYWZ);
 EI(keyStr.equals("setXYWZ", CPL_STR_HASH("setXYWZ")))
RET CNF(UInt4_setXYWZ);
 EI(keyStr.equals("getXZYW", CPL_STR_HASH("getXZYW")))
RET CNF(UInt4_getXZYW);
 EI(keyStr.equals("setXZYW", CPL_STR_HASH("setXZYW")))
RET CNF(UInt4_setXZYW);
 EI(keyStr.equals("getXZWY", CPL_STR_HASH("getXZWY")))
RET CNF(UInt4_getXZWY);
 EI(keyStr.equals("setXZWY", CPL_STR_HASH("setXZWY")))
RET CNF(UInt4_setXZWY);
 EI(keyStr.equals("getXWZY", CPL_STR_HASH("getXWZY")))
RET CNF(UInt4_getXWZY);
 EI(keyStr.equals("setXWZY", CPL_STR_HASH("setXWZY")))
RET CNF(UInt4_setXWZY);
 EI(keyStr.equals("getXWYZ", CPL_STR_HASH("getXWYZ")))
RET CNF(UInt4_getXWYZ);
 EI(keyStr.equals("setXWYZ", CPL_STR_HASH("setXWYZ")))
RET CNF(UInt4_setXWYZ);
 EI(keyStr.equals("getYXZW", CPL_STR_HASH("getYXZW")))
RET CNF(UInt4_getYXZW);
 EI(keyStr.equals("setYXZW", CPL_STR_HASH("setYXZW")))
RET CNF(UInt4_setYXZW);
 EI(keyStr.equals("getYXWZ", CPL_STR_HASH("getYXWZ")))
RET CNF(UInt4_getYXWZ);
 EI(keyStr.equals("setYXWZ", CPL_STR_HASH("setYXWZ")))
RET CNF(UInt4_setYXWZ);
 EI(keyStr.equals("getYZXW", CPL_STR_HASH("getYZXW")))
RET CNF(UInt4_getYZXW);
 EI(keyStr.equals("setYZXW", CPL_STR_HASH("setYZXW")))
RET CNF(UInt4_setYZXW);
 EI(keyStr.equals("getYZWX", CPL_STR_HASH("getYZWX")))
RET CNF(UInt4_getYZWX);
 EI(keyStr.equals("setYZWX", CPL_STR_HASH("setYZWX")))
RET CNF(UInt4_setYZWX);
 EI(keyStr.equals("getYWZX", CPL_STR_HASH("getYWZX")))
RET CNF(UInt4_getYWZX);
 EI(keyStr.equals("setYWZX", CPL_STR_HASH("setYWZX")))
RET CNF(UInt4_setYWZX);
 EI(keyStr.equals("getYWXZ", CPL_STR_HASH("getYWXZ")))
RET CNF(UInt4_getYWXZ);
 EI(keyStr.equals("setYWXZ", CPL_STR_HASH("setYWXZ")))
RET CNF(UInt4_setYWXZ);
 EI(keyStr.equals("getZYXW", CPL_STR_HASH("getZYXW")))
RET CNF(UInt4_getZYXW);
 EI(keyStr.equals("setZYXW", CPL_STR_HASH("setZYXW")))
RET CNF(UInt4_setZYXW);
 EI(keyStr.equals("getZYWX", CPL_STR_HASH("getZYWX")))
RET CNF(UInt4_getZYWX);
 EI(keyStr.equals("setZYWX", CPL_STR_HASH("setZYWX")))
RET CNF(UInt4_setZYWX);
 EI(keyStr.equals("getZXYW", CPL_STR_HASH("getZXYW")))
RET CNF(UInt4_getZXYW);
 EI(keyStr.equals("setZXYW", CPL_STR_HASH("setZXYW")))
RET CNF(UInt4_setZXYW);
 EI(keyStr.equals("getZXWY", CPL_STR_HASH("getZXWY")))
RET CNF(UInt4_getZXWY);
 EI(keyStr.equals("setZXWY", CPL_STR_HASH("setZXWY")))
RET CNF(UInt4_setZXWY);
 EI(keyStr.equals("getZWXY", CPL_STR_HASH("getZWXY")))
RET CNF(UInt4_getZWXY);
 EI(keyStr.equals("setZWXY", CPL_STR_HASH("setZWXY")))
RET CNF(UInt4_setZWXY);
 EI(keyStr.equals("getZWYX", CPL_STR_HASH("getZWYX")))
RET CNF(UInt4_getZWYX);
 EI(keyStr.equals("setZWYX", CPL_STR_HASH("setZWYX")))
RET CNF(UInt4_setZWYX);
 EI(keyStr.equals("getWYZX", CPL_STR_HASH("getWYZX")))
RET CNF(UInt4_getWYZX);
 EI(keyStr.equals("setWYZX", CPL_STR_HASH("setWYZX")))
RET CNF(UInt4_setWYZX);
 EI(keyStr.equals("getWYXZ", CPL_STR_HASH("getWYXZ")))
RET CNF(UInt4_getWYXZ);
 EI(keyStr.equals("setWYXZ", CPL_STR_HASH("setWYXZ")))
RET CNF(UInt4_setWYXZ);
 EI(keyStr.equals("getWZYX", CPL_STR_HASH("getWZYX")))
RET CNF(UInt4_getWZYX);
 EI(keyStr.equals("setWZYX", CPL_STR_HASH("setWZYX")))
RET CNF(UInt4_setWZYX);
 EI(keyStr.equals("getWZXY", CPL_STR_HASH("getWZXY")))
RET CNF(UInt4_getWZXY);
 EI(keyStr.equals("setWZXY", CPL_STR_HASH("setWZXY")))
RET CNF(UInt4_setWZXY);
 EI(keyStr.equals("getWXZY", CPL_STR_HASH("getWXZY")))
RET CNF(UInt4_getWXZY);
 EI(keyStr.equals("setWXZY", CPL_STR_HASH("setWXZY")))
RET CNF(UInt4_setWXZY);
 EI(keyStr.equals("getWXYZ", CPL_STR_HASH("getWXYZ")))
RET CNF(UInt4_getWXYZ);
 EI(keyStr.equals("setWXYZ", CPL_STR_HASH("setWXYZ")))
RET CNF(UInt4_setWXYZ);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(UInt4_copy);
 EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T4<uint32_t>*obj=(T4<uint32_t>*)f->data;
RET CV(obj->x);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T4<uint32_t>*obj=(T4<uint32_t>*)f->data;
RET CV(obj->y);
} EI(keyStr.equals("z", CPL_STR_HASH("z")))
{
T4<uint32_t>*obj=(T4<uint32_t>*)f->data;
RET CV(obj->z);
} EI(keyStr.equals("w", CPL_STR_HASH("w")))
{
T4<uint32_t>*obj=(T4<uint32_t>*)f->data;
RET CV(obj->w);
} else
 CATE(KE,"Unknown member for UInt4."));
}
}
RET CN;
}

void UInt4_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T4<uint32_t>*obj=(T4<uint32_t>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T4<uint32_t>*obj=(T4<uint32_t>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} EI(keyStr.equals("z", CPL_STR_HASH("z")))
{
T4<uint32_t>*obj=(T4<uint32_t>*)f->data;
obj->z=val_to_c<decltype(obj->z)>::f(ctx,value);
} EI(keyStr.equals("w", CPL_STR_HASH("w")))
{
T4<uint32_t>*obj=(T4<uint32_t>*)f->data;
obj->w=val_to_c<decltype(obj->w)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for UInt4."));
}
}
}

SV UInt4_setZXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZXYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setZXYW(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZXYW.")));
RET CN;
}

SV UInt4_setWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setWYZ(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWYZ.")));
RET CN;
}

SV UInt4_setWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setWYX(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWYX.")));
RET CN;
}

SV UInt4_getZWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZWYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWYX());
;
}
CATE(TE,UFOF("UInt4::getZWYX.")));
RET CN;
}

SV UInt4_getZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZW());
;
}
CATE(TE,UFOF("UInt4::getZW.")));
RET CN;
}

SV UInt4_getZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZY());
;
}
CATE(TE,UFOF("UInt4::getZY.")));
RET CN;
}

SV UInt4_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::distanceSquared" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("UInt4::distanceSquared.")));
RET CN;
}

SV UInt4_getYXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYXZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZW());
;
}
CATE(TE,UFOF("UInt4::getYXZW.")));
RET CN;
}

SV UInt4_setYZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYZWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setYZWX(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYZWX.")));
RET CN;
}

SV UInt4_getYWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYWZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWZX());
;
}
CATE(TE,UFOF("UInt4::getYWZX.")));
RET CN;
}

SV UInt4_getWZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWZXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZXY());
;
}
CATE(TE,UFOF("UInt4::getWZXY.")));
RET CN;
}

SV UInt4_getZYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZYXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYXW());
;
}
CATE(TE,UFOF("UInt4::getZYXW.")));
RET CN;
}

SV UInt4_setXWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXWYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setXWYZ(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXWYZ.")));
RET CN;
}

SV UInt4_setZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setZY(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZY.")));
RET CN;
}

SV UInt4_setZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setZX(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZX.")));
RET CN;
}

SV UInt4_getZXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZXWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXWY());
;
}
CATE(TE,UFOF("UInt4::getZXWY.")));
RET CN;
}

SV UInt4_getXWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXWZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWZY());
;
}
CATE(TE,UFOF("UInt4::getXWZY.")));
RET CN;
}

SV UInt4_setZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setZW(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZW.")));
RET CN;
}

SV UInt4_setZYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZYWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setZYWX(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZYWX.")));
RET CN;
}

SV UInt4_getYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZX());
;
}
CATE(TE,UFOF("UInt4::getYZX.")));
RET CN;
}

SV UInt4_getXYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXYWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYWZ());
;
}
CATE(TE,UFOF("UInt4::getXYWZ.")));
RET CN;
}

SV UInt4_setYXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYXZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setYXZW(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYXZW.")));
RET CN;
}

SV UInt4_getWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZY());
;
}
CATE(TE,UFOF("UInt4::getWZY.")));
RET CN;
}

SV UInt4_getWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZX());
;
}
CATE(TE,UFOF("UInt4::getWZX.")));
RET CN;
}

SV UInt4_getWZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWZYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZYX());
;
}
CATE(TE,UFOF("UInt4::getWZYX.")));
RET CN;
}

SV UInt4_setXWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXWZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setXWZY(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXWZY.")));
RET CN;
}

SV UInt4_getZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXY());
;
}
CATE(TE,UFOF("UInt4::getZXY.")));
RET CN;
}

SV UInt4_setWZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWZYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setWZYX(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWZYX.")));
RET CN;
}

SV UInt4_setZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setZYW(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZYW.")));
RET CN;
}

SV UInt4_setZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setZYX(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZYX.")));
RET CN;
}

SV UInt4_setXZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXZYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setXZYW(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXZYW.")));
RET CN;
}

SV UInt4_getZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXW());
;
}
CATE(TE,UFOF("UInt4::getZXW.")));
RET CN;
}

SV UInt4_setYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setYZW(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYZW.")));
RET CN;
}

SV UInt4_getYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWZ());
;
}
CATE(TE,UFOF("UInt4::getYWZ.")));
RET CN;
}

SV UInt4___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__leq__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("UInt4::__leq__.")));
RET CN;
}

SV UInt4_getYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWX());
;
}
CATE(TE,UFOF("UInt4::getYWX.")));
RET CN;
}

SV UInt4_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::sum" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("UInt4::sum.")));
RET CN;
}

SV UInt4_setYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setYZX(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYZX.")));
RET CN;
}

SV UInt4_getXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZ());
;
}
CATE(TE,UFOF("UInt4::getXYZ.")));
RET CN;
}

SV UInt4_getZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZX());
;
}
CATE(TE,UFOF("UInt4::getZX.")));
RET CN;
}

SV UInt4_getXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYW());
;
}
CATE(TE,UFOF("UInt4::getXYW.")));
RET CN;
}

SV UInt4_setYWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYWZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setYWZX(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYWZX.")));
RET CN;
}

SV UInt4_setWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setWXY(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWXY.")));
RET CN;
}

SV UInt4_setWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setWXZ(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWXZ.")));
RET CN;
}

SV UInt4_setZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setZXW(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZXW.")));
RET CN;
}

SV UInt4_getXWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXWYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWYZ());
;
}
CATE(TE,UFOF("UInt4::getXWYZ.")));
RET CN;
}

SV UInt4_setWYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWYXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setWYXZ(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWYXZ.")));
RET CN;
}

SV UInt4_setZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setZXY(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZXY.")));
RET CN;
}

SV UInt4_getXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWY());
;
}
CATE(TE,UFOF("UInt4::getXWY.")));
RET CN;
}

SV UInt4_getYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXW());
;
}
CATE(TE,UFOF("UInt4::getYXW.")));
RET CN;
}

SV UInt4_getYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZ());
;
}
CATE(TE,UFOF("UInt4::getYXZ.")));
RET CN;
}

SV UInt4_setXYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXYWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setXYWZ(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXYWZ.")));
RET CN;
}

SV UInt4_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::length" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("UInt4::length.")));
RET CN;
}

SV UInt4_setWXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWXZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setWXZY(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWXZY.")));
RET CN;
}

SV UInt4_getYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZW());
;
}
CATE(TE,UFOF("UInt4::getYZW.")));
RET CN;
}

SV UInt4_setXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setXWZ(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXWZ.")));
RET CN;
}

SV UInt4_setXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setXWY(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXWY.")));
RET CN;
}

SV UInt4_getWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYZ());
;
}
CATE(TE,UFOF("UInt4::getWYZ.")));
RET CN;
}

SV UInt4_getWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYX());
;
}
CATE(TE,UFOF("UInt4::getWYX.")));
RET CN;
}

SV UInt4_getZYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZYWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYWX());
;
}
CATE(TE,UFOF("UInt4::getZYWX.")));
RET CN;
}

SV UInt4_getXYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXYZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZW());
;
}
CATE(TE,UFOF("UInt4::getXYZW.")));
RET CN;
}

SV UInt4_setZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setZWY(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZWY.")));
RET CN;
}

SV UInt4_setZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setZWX(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZWX.")));
RET CN;
}

SV UInt4_setWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setWX(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWX.")));
RET CN;
}

SV UInt4_setWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setWY(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWY.")));
RET CN;
}

SV UInt4_setWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setWZ(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWZ.")));
RET CN;
}

SV UInt4_getZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWY());
;
}
CATE(TE,UFOF("UInt4::getZWY.")));
RET CN;
}

SV UInt4_getZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWX());
;
}
CATE(TE,UFOF("UInt4::getZWX.")));
RET CN;
}

SV UInt4_setYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setYXZ(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYXZ.")));
RET CN;
}

SV UInt4_setYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setYXW(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYXW.")));
RET CN;
}

SV UInt4_getXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWZ());
;
}
CATE(TE,UFOF("UInt4::getXWZ.")));
RET CN;
}

SV UInt4_getXZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXZWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZWY());
;
}
CATE(TE,UFOF("UInt4::getXZWY.")));
RET CN;
}

SV UInt4___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__less__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("UInt4::__less__.")));
RET CN;
}

SV UInt4_getZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYW());
;
}
CATE(TE,UFOF("UInt4::getZYW.")));
RET CN;
}

SV UInt4_setWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setWZY(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWZY.")));
RET CN;
}

SV UInt4_setWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setWZX(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWZX.")));
RET CN;
}

SV UInt4_setZYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZYXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setZYXW(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZYXW.")));
RET CN;
}

SV UInt4_getYZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYZWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZWX());
;
}
CATE(TE,UFOF("UInt4::getYZWX.")));
RET CN;
}

SV UInt4_getZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYX());
;
}
CATE(TE,UFOF("UInt4::getZYX.")));
RET CN;
}

SV UInt4_getXZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXZYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZYW());
;
}
CATE(TE,UFOF("UInt4::getXZYW.")));
RET CN;
}

SV UInt4_setYXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYXWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setYXWZ(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYXWZ.")));
RET CN;
}

SV UInt4_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::copy" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("UInt4::copy.")));
RET CN;
}

SV UInt4___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__eq__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("UInt4::__eq__.")));
RET CN;
}

SV UInt4_getWYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWYXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYXZ());
;
}
CATE(TE,UFOF("UInt4::getWYXZ.")));
RET CN;
}

SV UInt4_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::distance" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("UInt4::distance.")));
RET CN;
}

SV UInt4_getXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZW());
;
}
CATE(TE,UFOF("UInt4::getXZW.")));
RET CN;
}

SV UInt4_setYZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYZXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setYZXW(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYZXW.")));
RET CN;
}

SV UInt4_getZWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZWXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWXY());
;
}
CATE(TE,UFOF("UInt4::getZWXY.")));
RET CN;
}

SV UInt4_getXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZY());
;
}
CATE(TE,UFOF("UInt4::getXZY.")));
RET CN;
}

SV UInt4_getYZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYZXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZXW());
;
}
CATE(TE,UFOF("UInt4::getYZXW.")));
RET CN;
}

SV UInt4_setZWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZWYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setZWYX(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZWYX.")));
RET CN;
}

SV UInt4___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__sub__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("UInt4::__sub__.")));
RET CN;
}

SV UInt4_getYXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYXWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXWZ());
;
}
CATE(TE,UFOF("UInt4::getYXWZ.")));
RET CN;
}

SV UInt4_setXZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXZWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setXZWY(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXZWY.")));
RET CN;
}

SV UInt4_setYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setYWZ(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYWZ.")));
RET CN;
}

SV UInt4_setYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setYWX(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYWX.")));
RET CN;
}

SV UInt4_setYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setYZ(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYZ.")));
RET CN;
}

SV UInt4_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYX.")));
RET CN;
}

SV UInt4_setYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setYW(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYW.")));
RET CN;
}

SV UInt4_getWXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWXYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXYZ());
;
}
CATE(TE,UFOF("UInt4::getWXYZ.")));
RET CN;
}

SV UInt4___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__neq__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("UInt4::__neq__.")));
RET CN;
}

SV UInt4_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::normalize" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("UInt4::normalize.")));
RET CN;
}

SV UInt4_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("UInt4::getYX.")));
RET CN;
}

SV UInt4_setXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setXZW(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXZW.")));
RET CN;
}

SV UInt4_setXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setXZY(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXZY.")));
RET CN;
}

SV UInt4_setXYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXYZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setXYZW(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXYZW.")));
RET CN;
}

SV UInt4_getYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYW());
;
}
CATE(TE,UFOF("UInt4::getYW.")));
RET CN;
}

SV UInt4_setWXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWXYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setWXYZ(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWXYZ.")));
RET CN;
}

SV UInt4_getYWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYWXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWXZ());
;
}
CATE(TE,UFOF("UInt4::getYWXZ.")));
RET CN;
}

SV UInt4___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__mul__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("UInt4::__mul__.")));
RET CN;
}

SV UInt4_getYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZ());
;
}
CATE(TE,UFOF("UInt4::getYZ.")));
RET CN;
}

SV UInt4_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::lengthSquared" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("UInt4::lengthSquared.")));
RET CN;
}

SV UInt4_getWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXY());
;
}
CATE(TE,UFOF("UInt4::getWXY.")));
RET CN;
}

SV UInt4_getWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXZ());
;
}
CATE(TE,UFOF("UInt4::getWXZ.")));
RET CN;
}

SV UInt4_getWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWX());
;
}
CATE(TE,UFOF("UInt4::getWX.")));
RET CN;
}

SV UInt4_getWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWY());
;
}
CATE(TE,UFOF("UInt4::getWY.")));
RET CN;
}

SV UInt4_getWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZ());
;
}
CATE(TE,UFOF("UInt4::getWZ.")));
RET CN;
}

SV UInt4_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXY.")));
RET CN;
}

SV UInt4_getZXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZXYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXYW());
;
}
CATE(TE,UFOF("UInt4::getZXYW.")));
RET CN;
}

SV UInt4___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__add__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("UInt4::__add__.")));
RET CN;
}

SV UInt4_setXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setXZ(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXZ.")));
RET CN;
}

SV UInt4_getWYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWYZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYZX());
;
}
CATE(TE,UFOF("UInt4::getWYZX.")));
RET CN;
}

SV UInt4_setXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setXW(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXW.")));
RET CN;
}

SV UInt4_getWXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWXZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXZY());
;
}
CATE(TE,UFOF("UInt4::getWXZY.")));
RET CN;
}

SV UInt4_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("UInt4::getXY.")));
RET CN;
}

SV UInt4_setZXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZXWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setZXWY(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZXWY.")));
RET CN;
}

SV UInt4_setXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setXYW(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXYW.")));
RET CN;
}

SV UInt4_getXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZ());
;
}
CATE(TE,UFOF("UInt4::getXZ.")));
RET CN;
}

SV UInt4_setWZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWZXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setWZXY(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWZXY.")));
RET CN;
}

SV UInt4___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__grtr__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("UInt4::__grtr__.")));
RET CN;
}

SV UInt4_setZWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZWXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setZWXY(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZWXY.")));
RET CN;
}

SV UInt4_getXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXW());
;
}
CATE(TE,UFOF("UInt4::getXW.")));
RET CN;
}

SV UInt4_setXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setXYZ(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXYZ.")));
RET CN;
}

SV UInt4___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__div__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("UInt4::__div__.")));
RET CN;
}

SV UInt4_setWYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWYZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setWYZX(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWYZX.")));
RET CN;
}

SV UInt4_setYWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYWXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setYWXZ(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYWXZ.")));
RET CN;
}

SV UInt4___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__geq__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("UInt4::__geq__.")));
RET CN;
}

SV UInt4_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::dot" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("UInt4::dot.")));
RET CN;
}

void UInt3_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,T3<uint32_t>))
CATE(TE,"UInt3::__del__ expects UInt3 as first argument."));

SCRIPT_DELETE((T3<uint32_t>*)f->data);
}SV UInt3_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3's constructor" EAOE));
if(!TS(a[0],T3<uint32_t>))
CATE(TE,"UInt3's constructor expects UInt3 as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(T3<uint32_t>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt3_funcs,p,EXT->UInt3_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],uint32_t)){
void *p = (void *)NEW(TYPE(T3<uint32_t>),val_to_c<uint32_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt3_funcs,p,EXT->UInt3_typeID);
}if(a.getCount()==4)
if(true&&TS(a[1],uint32_t)&&TS(a[2],uint32_t)&&TS(a[3],uint32_t)){
void *p = (void *)NEW(TYPE(T3<uint32_t>),val_to_c<uint32_t>::f(ctx,a[1]),val_to_c<uint32_t>::f(ctx,a[2]),val_to_c<uint32_t>::f(ctx,a[3]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt3_funcs,p,EXT->UInt3_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T3<float> &)){
void *p = (void *)NEW(TYPE(T3<uint32_t>),val_to_c<const T3<float> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt3_funcs,p,EXT->UInt3_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T3<int32_t> &)){
void *p = (void *)NEW(TYPE(T3<uint32_t>),val_to_c<const T3<int32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt3_funcs,p,EXT->UInt3_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T3<uint32_t> &)){
void *p = (void *)NEW(TYPE(T3<uint32_t>),val_to_c<const T3<uint32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt3_funcs,p,EXT->UInt3_typeID);
}CATE(TE,UFOF("UInt3's constructor.")));
RET CN;
}

SV UInt3_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("UInt3");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(UInt3_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(UInt3_new);
else
 CATE(KE,"Unknown member for UInt3."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(UInt3_new);
 EI(keyStr.equals("__add__", CPL_STR_HASH("__add__")))
RET CNF(UInt3___add__);
 EI(keyStr.equals("__sub__", CPL_STR_HASH("__sub__")))
RET CNF(UInt3___sub__);
 EI(keyStr.equals("__mul__", CPL_STR_HASH("__mul__")))
RET CNF(UInt3___mul__);
 EI(keyStr.equals("__div__", CPL_STR_HASH("__div__")))
RET CNF(UInt3___div__);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(UInt3___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(UInt3___neq__);
 EI(keyStr.equals("__less__", CPL_STR_HASH("__less__")))
RET CNF(UInt3___less__);
 EI(keyStr.equals("__grtr__", CPL_STR_HASH("__grtr__")))
RET CNF(UInt3___grtr__);
 EI(keyStr.equals("__leq__", CPL_STR_HASH("__leq__")))
RET CNF(UInt3___leq__);
 EI(keyStr.equals("__geq__", CPL_STR_HASH("__geq__")))
RET CNF(UInt3___geq__);
 EI(keyStr.equals("sum", CPL_STR_HASH("sum")))
RET CNF(UInt3_sum);
 EI(keyStr.equals("length", CPL_STR_HASH("length")))
RET CNF(UInt3_length);
 EI(keyStr.equals("lengthSquared", CPL_STR_HASH("lengthSquared")))
RET CNF(UInt3_lengthSquared);
 EI(keyStr.equals("dot", CPL_STR_HASH("dot")))
RET CNF(UInt3_dot);
 EI(keyStr.equals("distance", CPL_STR_HASH("distance")))
RET CNF(UInt3_distance);
 EI(keyStr.equals("distanceSquared", CPL_STR_HASH("distanceSquared")))
RET CNF(UInt3_distanceSquared);
 EI(keyStr.equals("normalize", CPL_STR_HASH("normalize")))
RET CNF(UInt3_normalize);
 EI(keyStr.equals("cross", CPL_STR_HASH("cross")))
RET CNF(UInt3_cross);
 EI(keyStr.equals("getXY", CPL_STR_HASH("getXY")))
RET CNF(UInt3_getXY);
 EI(keyStr.equals("setXY", CPL_STR_HASH("setXY")))
RET CNF(UInt3_setXY);
 EI(keyStr.equals("getXZ", CPL_STR_HASH("getXZ")))
RET CNF(UInt3_getXZ);
 EI(keyStr.equals("setXZ", CPL_STR_HASH("setXZ")))
RET CNF(UInt3_setXZ);
 EI(keyStr.equals("getYX", CPL_STR_HASH("getYX")))
RET CNF(UInt3_getYX);
 EI(keyStr.equals("setYX", CPL_STR_HASH("setYX")))
RET CNF(UInt3_setYX);
 EI(keyStr.equals("getYZ", CPL_STR_HASH("getYZ")))
RET CNF(UInt3_getYZ);
 EI(keyStr.equals("setYZ", CPL_STR_HASH("setYZ")))
RET CNF(UInt3_setYZ);
 EI(keyStr.equals("getZX", CPL_STR_HASH("getZX")))
RET CNF(UInt3_getZX);
 EI(keyStr.equals("setZX", CPL_STR_HASH("setZX")))
RET CNF(UInt3_setZX);
 EI(keyStr.equals("getZY", CPL_STR_HASH("getZY")))
RET CNF(UInt3_getZY);
 EI(keyStr.equals("setZY", CPL_STR_HASH("setZY")))
RET CNF(UInt3_setZY);
 EI(keyStr.equals("getXYZ", CPL_STR_HASH("getXYZ")))
RET CNF(UInt3_getXYZ);
 EI(keyStr.equals("setXYZ", CPL_STR_HASH("setXYZ")))
RET CNF(UInt3_setXYZ);
 EI(keyStr.equals("getXZY", CPL_STR_HASH("getXZY")))
RET CNF(UInt3_getXZY);
 EI(keyStr.equals("setXZY", CPL_STR_HASH("setXZY")))
RET CNF(UInt3_setXZY);
 EI(keyStr.equals("getYXZ", CPL_STR_HASH("getYXZ")))
RET CNF(UInt3_getYXZ);
 EI(keyStr.equals("setYXZ", CPL_STR_HASH("setYXZ")))
RET CNF(UInt3_setYXZ);
 EI(keyStr.equals("getYZX", CPL_STR_HASH("getYZX")))
RET CNF(UInt3_getYZX);
 EI(keyStr.equals("setYZX", CPL_STR_HASH("setYZX")))
RET CNF(UInt3_setYZX);
 EI(keyStr.equals("getZXY", CPL_STR_HASH("getZXY")))
RET CNF(UInt3_getZXY);
 EI(keyStr.equals("setZXY", CPL_STR_HASH("setZXY")))
RET CNF(UInt3_setZXY);
 EI(keyStr.equals("getZYX", CPL_STR_HASH("getZYX")))
RET CNF(UInt3_getZYX);
 EI(keyStr.equals("setZYX", CPL_STR_HASH("setZYX")))
RET CNF(UInt3_setZYX);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(UInt3_copy);
 EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T3<uint32_t>*obj=(T3<uint32_t>*)f->data;
RET CV(obj->x);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T3<uint32_t>*obj=(T3<uint32_t>*)f->data;
RET CV(obj->y);
} EI(keyStr.equals("z", CPL_STR_HASH("z")))
{
T3<uint32_t>*obj=(T3<uint32_t>*)f->data;
RET CV(obj->z);
} else
 CATE(KE,"Unknown member for UInt3."));
}
}
RET CN;
}

void UInt3_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T3<uint32_t>*obj=(T3<uint32_t>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T3<uint32_t>*obj=(T3<uint32_t>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} EI(keyStr.equals("z", CPL_STR_HASH("z")))
{
T3<uint32_t>*obj=(T3<uint32_t>*)f->data;
obj->z=val_to_c<decltype(obj->z)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for UInt3."));
}
}
}

SV UInt3_setYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setYZX" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setYZX(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setYZX.")));
RET CN;
}

SV UInt3_getZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getZXY" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXY());
;
}
CATE(TE,UFOF("UInt3::getZXY.")));
RET CN;
}

SV UInt3_setYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setYZ" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setYZ(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setYZ.")));
RET CN;
}

SV UInt3_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setYX" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setYX.")));
RET CN;
}

SV UInt3_setZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setZYX" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setZYX(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setZYX.")));
RET CN;
}

SV UInt3_getZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getZY" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZY());
;
}
CATE(TE,UFOF("UInt3::getZY.")));
RET CN;
}

SV UInt3_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::distanceSquared" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("UInt3::distanceSquared.")));
RET CN;
}

SV UInt3_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::normalize" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("UInt3::normalize.")));
RET CN;
}

SV UInt3_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getYX" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("UInt3::getYX.")));
RET CN;
}

SV UInt3___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__leq__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("UInt3::__leq__.")));
RET CN;
}

SV UInt3_setXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setXZY" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setXZY(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setXZY.")));
RET CN;
}

SV UInt3_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::sum" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("UInt3::sum.")));
RET CN;
}

SV UInt3_cross(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::cross" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
RET CV( f->cross(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("UInt3::cross.")));
RET CN;
}

SV UInt3_getXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getXYZ" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZ());
;
}
CATE(TE,UFOF("UInt3::getXYZ.")));
RET CN;
}

SV UInt3___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__less__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("UInt3::__less__.")));
RET CN;
}

SV UInt3___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__neq__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("UInt3::__neq__.")));
RET CN;
}

SV UInt3_getYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getYZ" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZ());
;
}
CATE(TE,UFOF("UInt3::getYZ.")));
RET CN;
}

SV UInt3_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::lengthSquared" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("UInt3::lengthSquared.")));
RET CN;
}

SV UInt3_getZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getZYX" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYX());
;
}
CATE(TE,UFOF("UInt3::getZYX.")));
RET CN;
}

SV UInt3___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__div__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("UInt3::__div__.")));
RET CN;
}

SV UInt3_setZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setZY" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setZY(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setZY.")));
RET CN;
}

SV UInt3_setZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setZX" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setZX(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setZX.")));
RET CN;
}

SV UInt3_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setXY" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setXY.")));
RET CN;
}

SV UInt3___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__add__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("UInt3::__add__.")));
RET CN;
}

SV UInt3_setXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setXZ" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setXZ(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setXZ.")));
RET CN;
}

SV UInt3_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::copy" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("UInt3::copy.")));
RET CN;
}

SV UInt3___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__eq__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("UInt3::__eq__.")));
RET CN;
}

SV UInt3_setZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setZXY" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setZXY(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setZXY.")));
RET CN;
}

SV UInt3_setYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setYXZ" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setYXZ(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setYXZ.")));
RET CN;
}

SV UInt3_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getXY" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("UInt3::getXY.")));
RET CN;
}

SV UInt3_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::distance" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("UInt3::distance.")));
RET CN;
}

SV UInt3_getXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getXZ" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZ());
;
}
CATE(TE,UFOF("UInt3::getXZ.")));
RET CN;
}

SV UInt3___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__grtr__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("UInt3::__grtr__.")));
RET CN;
}

SV UInt3_getXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getXZY" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZY());
;
}
CATE(TE,UFOF("UInt3::getXZY.")));
RET CN;
}

SV UInt3_setXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setXYZ" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setXYZ(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setXYZ.")));
RET CN;
}

SV UInt3_getYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getYZX" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZX());
;
}
CATE(TE,UFOF("UInt3::getYZX.")));
RET CN;
}

SV UInt3_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::length" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("UInt3::length.")));
RET CN;
}

SV UInt3___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__mul__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("UInt3::__mul__.")));
RET CN;
}

SV UInt3_getYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getYXZ" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZ());
;
}
CATE(TE,UFOF("UInt3::getYXZ.")));
RET CN;
}

SV UInt3_getZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getZX" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZX());
;
}
CATE(TE,UFOF("UInt3::getZX.")));
RET CN;
}

SV UInt3___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__sub__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("UInt3::__sub__.")));
RET CN;
}

SV UInt3___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__geq__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("UInt3::__geq__.")));
RET CN;
}

SV UInt3_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::dot" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("UInt3::dot.")));
RET CN;
}

void UInt2_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,T2<uint32_t>))
CATE(TE,"UInt2::__del__ expects UInt2 as first argument."));

SCRIPT_DELETE((T2<uint32_t>*)f->data);
}SV UInt2_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2's constructor" EAOE));
if(!TS(a[0],T2<uint32_t>))
CATE(TE,"UInt2's constructor expects UInt2 as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(T2<uint32_t>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt2_funcs,p,EXT->UInt2_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],uint32_t)){
void *p = (void *)NEW(TYPE(T2<uint32_t>),val_to_c<uint32_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt2_funcs,p,EXT->UInt2_typeID);
}if(a.getCount()==3)
if(true&&TS(a[1],uint32_t)&&TS(a[2],uint32_t)){
void *p = (void *)NEW(TYPE(T2<uint32_t>),val_to_c<uint32_t>::f(ctx,a[1]),val_to_c<uint32_t>::f(ctx,a[2]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt2_funcs,p,EXT->UInt2_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T2<float> &)){
void *p = (void *)NEW(TYPE(T2<uint32_t>),val_to_c<const T2<float> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt2_funcs,p,EXT->UInt2_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T2<int32_t> &)){
void *p = (void *)NEW(TYPE(T2<uint32_t>),val_to_c<const T2<int32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt2_funcs,p,EXT->UInt2_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T2<uint32_t> &)){
void *p = (void *)NEW(TYPE(T2<uint32_t>),val_to_c<const T2<uint32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(UInt2_funcs,p,EXT->UInt2_typeID);
}CATE(TE,UFOF("UInt2's constructor.")));
RET CN;
}

SV UInt2_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("UInt2");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(UInt2_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(UInt2_new);
else
 CATE(KE,"Unknown member for UInt2."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(UInt2_new);
 EI(keyStr.equals("__add__", CPL_STR_HASH("__add__")))
RET CNF(UInt2___add__);
 EI(keyStr.equals("__sub__", CPL_STR_HASH("__sub__")))
RET CNF(UInt2___sub__);
 EI(keyStr.equals("__mul__", CPL_STR_HASH("__mul__")))
RET CNF(UInt2___mul__);
 EI(keyStr.equals("__div__", CPL_STR_HASH("__div__")))
RET CNF(UInt2___div__);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(UInt2___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(UInt2___neq__);
 EI(keyStr.equals("__less__", CPL_STR_HASH("__less__")))
RET CNF(UInt2___less__);
 EI(keyStr.equals("__grtr__", CPL_STR_HASH("__grtr__")))
RET CNF(UInt2___grtr__);
 EI(keyStr.equals("__leq__", CPL_STR_HASH("__leq__")))
RET CNF(UInt2___leq__);
 EI(keyStr.equals("__geq__", CPL_STR_HASH("__geq__")))
RET CNF(UInt2___geq__);
 EI(keyStr.equals("sum", CPL_STR_HASH("sum")))
RET CNF(UInt2_sum);
 EI(keyStr.equals("length", CPL_STR_HASH("length")))
RET CNF(UInt2_length);
 EI(keyStr.equals("lengthSquared", CPL_STR_HASH("lengthSquared")))
RET CNF(UInt2_lengthSquared);
 EI(keyStr.equals("dot", CPL_STR_HASH("dot")))
RET CNF(UInt2_dot);
 EI(keyStr.equals("distance", CPL_STR_HASH("distance")))
RET CNF(UInt2_distance);
 EI(keyStr.equals("distanceSquared", CPL_STR_HASH("distanceSquared")))
RET CNF(UInt2_distanceSquared);
 EI(keyStr.equals("normalize", CPL_STR_HASH("normalize")))
RET CNF(UInt2_normalize);
 EI(keyStr.equals("getXY", CPL_STR_HASH("getXY")))
RET CNF(UInt2_getXY);
 EI(keyStr.equals("setXY", CPL_STR_HASH("setXY")))
RET CNF(UInt2_setXY);
 EI(keyStr.equals("getYX", CPL_STR_HASH("getYX")))
RET CNF(UInt2_getYX);
 EI(keyStr.equals("setYX", CPL_STR_HASH("setYX")))
RET CNF(UInt2_setYX);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(UInt2_copy);
 EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T2<uint32_t>*obj=(T2<uint32_t>*)f->data;
RET CV(obj->x);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T2<uint32_t>*obj=(T2<uint32_t>*)f->data;
RET CV(obj->y);
} else
 CATE(KE,"Unknown member for UInt2."));
}
}
RET CN;
}

void UInt2_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T2<uint32_t>*obj=(T2<uint32_t>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T2<uint32_t>*obj=(T2<uint32_t>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for UInt2."));
}
}
}

SV UInt2_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::setYX" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt2::setYX.")));
RET CN;
}

SV UInt2_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::distanceSquared" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("UInt2::distanceSquared.")));
RET CN;
}

SV UInt2_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::normalize" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("UInt2::normalize.")));
RET CN;
}

SV UInt2_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::getYX" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("UInt2::getYX.")));
RET CN;
}

SV UInt2___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__leq__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("UInt2::__leq__.")));
RET CN;
}

SV UInt2_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::sum" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("UInt2::sum.")));
RET CN;
}

SV UInt2___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__div__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("UInt2::__div__.")));
RET CN;
}

SV UInt2___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__less__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("UInt2::__less__.")));
RET CN;
}

SV UInt2___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__neq__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("UInt2::__neq__.")));
RET CN;
}

SV UInt2_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::lengthSquared" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("UInt2::lengthSquared.")));
RET CN;
}

SV UInt2_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::setXY" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt2::setXY.")));
RET CN;
}

SV UInt2___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__add__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("UInt2::__add__.")));
RET CN;
}

SV UInt2_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::copy" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("UInt2::copy.")));
RET CN;
}

SV UInt2___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__eq__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("UInt2::__eq__.")));
RET CN;
}

SV UInt2_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::getXY" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("UInt2::getXY.")));
RET CN;
}

SV UInt2_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::distance" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("UInt2::distance.")));
RET CN;
}

SV UInt2___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__grtr__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("UInt2::__grtr__.")));
RET CN;
}

SV UInt2_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::length" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("UInt2::length.")));
RET CN;
}

SV UInt2___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__mul__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("UInt2::__mul__.")));
RET CN;
}

SV UInt2___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__sub__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("UInt2::__sub__.")));
RET CN;
}

SV UInt2___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__geq__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("UInt2::__geq__.")));
RET CN;
}

SV UInt2_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::dot" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("UInt2::dot.")));
RET CN;
}

void AABB_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,AABB))
CATE(TE,"AABB::__del__ expects AABB as first argument."));

SCRIPT_DELETE((AABB*)f->data);
}SV AABB_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AABB's constructor" EAOE));
if(!TS(a[0],AABB))
CATE(TE,"AABB's constructor expects AABB as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(AABB));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(AABB_funcs,p,EXT->AABB_typeID);
}if(a.getCount()==3)
if(true&&TS(a[1],const Position3D &)&&TS(a[2],const Position3D &)){
void *p = (void *)NEW(TYPE(AABB),val_to_c<const Position3D &>::f(ctx,a[1]),val_to_c<const Position3D &>::f(ctx,a[2]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(AABB_funcs,p,EXT->AABB_typeID);
}CATE(TE,UFOF("AABB's constructor.")));
RET CN;
}

SV AABB_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("AABB");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(AABB_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(AABB_new);
else
 CATE(KE,"Unknown member for AABB."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(AABB_new);
 EI(keyStr.equals("transform", CPL_STR_HASH("transform")))
RET CNF(AABB_transform);
 EI(keyStr.equals("extend", CPL_STR_HASH("extend")))
RET CNF(AABB_extend);
 EI(keyStr.equals("grow", CPL_STR_HASH("grow")))
RET CNF(AABB_grow);
 EI(keyStr.equals("getCorner", CPL_STR_HASH("getCorner")))
RET CNF(AABB_getCorner);
 EI(keyStr.equals("intersection", CPL_STR_HASH("intersection")))
RET CNF(AABB_intersection);
 EI(keyStr.equals("min", CPL_STR_HASH("min")))
{
AABB*obj=(AABB*)f->data;
RET CV(obj->min);
} EI(keyStr.equals("max", CPL_STR_HASH("max")))
{
AABB*obj=(AABB*)f->data;
RET CV(obj->max);
} else
 CATE(KE,"Unknown member for AABB."));
}
}
RET CN;
}

void AABB_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("min", CPL_STR_HASH("min")))
{
AABB*obj=(AABB*)f->data;
obj->min=val_to_c<decltype(obj->min)>::f(ctx,value);
} EI(keyStr.equals("max", CPL_STR_HASH("max")))
{
AABB*obj=(AABB*)f->data;
obj->max=val_to_c<decltype(obj->max)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for AABB."));
}
}
}

SV AABB_getCorner(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AABB::getCorner" EAOE));
AABB*f;
f=(AABB*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getCorner(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("AABB::getCorner.")));
RET CN;
}

SV AABB_intersection(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AABB::intersection" EAOE));
AABB*f;
f=(AABB*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const AABB &))
{
RET CV( f->intersection(val_to_c<std::remove_reference<const AABB &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("AABB::intersection.")));
RET CN;
}

SV AABB_transform(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AABB::transform" EAOE));
AABB*f;
f=(AABB*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Matrix4x4 &))
{
RET CV( f->transform(val_to_c<std::remove_reference<const Matrix4x4 &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("AABB::transform.")));
RET CN;
}

SV AABB_extend(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AABB::extend" EAOE));
AABB*f;
f=(AABB*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Position3D &))
{
( f->extend(val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const AABB &))
{
( f->extend(val_to_c<std::remove_reference<const AABB &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AABB::extend.")));
RET CN;
}

SV AABB_grow(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AABB::grow" EAOE));
AABB*f;
f=(AABB*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->grow(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AABB::grow.")));
RET CN;
}

void Scene_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Scene))
CATE(TE,"Scene::__del__ expects Scene as first argument."));

Scene*obj=(Scene*)f->data;
if(_scriptDeletePart(obj)){obj->release();}
}SV Scene_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene's constructor" EAOE));
if(!TS(a[0],Scene))
CATE(TE,"Scene's constructor expects Scene as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(Scene));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Scene_funcs,p,EXT->Scene_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const Str &)){
void *p = (void *)NEW(TYPE(Scene),val_to_c<const Str &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Scene_funcs,p,EXT->Scene_typeID);
}CATE(TE,UFOF("Scene's constructor.")));
RET CN;
}

SV Scene_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Scene");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Scene_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Scene_new);
else
 CATE(KE,"Unknown member for Scene."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Scene_new);
 EI(keyStr.equals("removeContent", CPL_STR_HASH("removeContent")))
RET CNF(Scene_removeContent);
 EI(keyStr.equals("handleInput", CPL_STR_HASH("handleInput")))
RET CNF(Scene_handleInput);
 EI(keyStr.equals("update", CPL_STR_HASH("update")))
RET CNF(Scene_update);
 EI(keyStr.equals("fixedUpdate", CPL_STR_HASH("fixedUpdate")))
RET CNF(Scene_fixedUpdate);
 EI(keyStr.equals("render", CPL_STR_HASH("render")))
RET CNF(Scene_render);
 EI(keyStr.equals("getPhysicsWorld", CPL_STR_HASH("getPhysicsWorld")))
RET CNF(Scene_getPhysicsWorld);
 EI(keyStr.equals("getRenderer", CPL_STR_HASH("getRenderer")))
RET CNF(Scene_getRenderer);
 EI(keyStr.equals("getAudioWorld", CPL_STR_HASH("getAudioWorld")))
RET CNF(Scene_getAudioWorld);
 EI(keyStr.equals("save", CPL_STR_HASH("save")))
RET CNF(Scene_save);
 EI(keyStr.equals("createEntity", CPL_STR_HASH("createEntity")))
RET CNF(Scene_createEntity);
 EI(keyStr.equals("removeEntity", CPL_STR_HASH("removeEntity")))
RET CNF(Scene_removeEntity);
 EI(keyStr.equals("findEntity", CPL_STR_HASH("findEntity")))
RET CNF(Scene_findEntity);
 EI(keyStr.equals("getEntities", CPL_STR_HASH("getEntities")))
RET CNF(Scene_getEntities);
 EI(keyStr.equals("addScript", CPL_STR_HASH("addScript")))
RET CNF(Scene_addScript);
 EI(keyStr.equals("removeScript", CPL_STR_HASH("removeScript")))
RET CNF(Scene_removeScript);
 EI(keyStr.equals("getScripts", CPL_STR_HASH("getScripts")))
RET CNF(Scene_getScripts);
 EI(keyStr.equals("findScriptInstance", CPL_STR_HASH("findScriptInstance")))
RET CNF(Scene_findScriptInstance);
 EI(keyStr.equals("load", CPL_STR_HASH("load")))
RET CNF(Scene_load);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(Scene_copy);
 EI(keyStr.equals("getType", CPL_STR_HASH("getType")))
RET CNF(Scene_getType);
 EI(keyStr.equals("release", CPL_STR_HASH("release")))
RET CNF(Scene_release);
 EI(keyStr.equals("getRefCount", CPL_STR_HASH("getRefCount")))
RET CNF(Scene_getRefCount);
 EI(keyStr.equals("getFilename", CPL_STR_HASH("getFilename")))
RET CNF(Scene_getFilename);
 EI(keyStr.equals("setFilename", CPL_STR_HASH("setFilename")))
RET CNF(Scene_setFilename);
 else
 CATE(KE,"Unknown member for Scene."));
}
}
RET CN;
}

void Scene_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for Scene."));
}
}
}

SV Scene_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::load" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("Scene::load.")));
RET CN;
}

SV Scene_render(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::render" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->render());
RET CN;
}
CATE(TE,UFOF("Scene::render.")));
RET CN;
}

SV Scene_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::setFilename" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
( f->setFilename(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Scene::setFilename.")));
RET CN;
}

SV Scene_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::getRefCount" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("Scene::getRefCount.")));
RET CN;
}

SV Scene_getScripts(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::getScripts" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScripts());
;
}
CATE(TE,UFOF("Scene::getScripts.")));
RET CN;
}

SV Scene_findEntity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::findEntity" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
RET CV( f->findEntity(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Scene::findEntity.")));
RET CN;
}

SV Scene_createEntity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::createEntity" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
RET CV( f->createEntity(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Scene::createEntity.")));
RET CN;
}

SV Scene_getRenderer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::getRenderer" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRenderer());
;
}
CATE(TE,UFOF("Scene::getRenderer.")));
RET CN;
}

SV Scene_handleInput(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::handleInput" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->handleInput());
RET CN;
}
CATE(TE,UFOF("Scene::handleInput.")));
RET CN;
}

SV Scene_removeEntity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::removeEntity" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->removeEntity(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Scene::removeEntity.")));
RET CN;
}

SV Scene_findScriptInstance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::findScriptInstance" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
RET CV( f->findScriptInstance(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Scene::findScriptInstance.")));
RET CN;
}

SV Scene_addScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::addScript" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Script *))
{
RET CV( f->addScript(val_to_c<std::remove_reference<Script *>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Scene::addScript.")));
RET CN;
}

SV Scene_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::save" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("Scene::save.")));
RET CN;
}

SV Scene_getEntities(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::getEntities" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getEntities());
;
}
CATE(TE,UFOF("Scene::getEntities.")));
RET CN;
}

SV Scene_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::getFilename" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("Scene::getFilename.")));
RET CN;
}

SV Scene_getAudioWorld(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::getAudioWorld" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAudioWorld());
;
}
CATE(TE,UFOF("Scene::getAudioWorld.")));
RET CN;
}

SV Scene_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::getType" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("Scene::getType.")));
RET CN;
}

SV Scene_update(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::update" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->update());
RET CN;
}
CATE(TE,UFOF("Scene::update.")));
RET CN;
}

SV Scene_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::removeContent" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("Scene::removeContent.")));
RET CN;
}

SV Scene_fixedUpdate(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::fixedUpdate" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->fixedUpdate(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Scene::fixedUpdate.")));
RET CN;
}

SV Scene_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::copy" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("Scene::copy.")));
RET CN;
}

SV Scene_getPhysicsWorld(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::getPhysicsWorld" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getPhysicsWorld());
;
}
CATE(TE,UFOF("Scene::getPhysicsWorld.")));
RET CN;
}

SV Scene_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::release" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("Scene::release.")));
RET CN;
}

SV Scene_removeScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::removeScript" EAOE));
Scene*f;
f=(Scene*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],ScriptInstance *))
{
( f->removeScript(val_to_c<std::remove_reference<ScriptInstance *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Scene::removeScript.")));
RET CN;
}

void GfxSubModelList_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,List<GfxModel::SubModel>))
CATE(TE,"GfxSubModelList::__del__ expects GfxSubModelList as first argument."));

SCRIPT_DELETE((List<GfxModel::SubModel>*)f->data);
}SV GfxSubModelList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList's constructor" EAOE));
if(!TS(a[0],List<GfxModel::SubModel>))
CATE(TE,"GfxSubModelList's constructor expects GfxSubModelList as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(List<GfxModel::SubModel>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxSubModelList_funcs,p,EXT->GfxSubModelList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],std::size_t)){
void *p = (void *)NEW(TYPE(List<GfxModel::SubModel>),val_to_c<std::size_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxSubModelList_funcs,p,EXT->GfxSubModelList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const List<GfxModel::SubModel> &)){
void *p = (void *)NEW(TYPE(List<GfxModel::SubModel>),val_to_c<const List<GfxModel::SubModel> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxSubModelList_funcs,p,EXT->GfxSubModelList_typeID);
}CATE(TE,UFOF("GfxSubModelList's constructor.")));
RET CN;
}

SV GfxSubModelList_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxSubModelList");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxSubModelList_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxSubModelList_new);
else
 CATE(KE,"Unknown member for GfxSubModelList."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxSubModelList_new);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxSubModelList___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(GfxSubModelList___neq__);
 EI(keyStr.equals("get", CPL_STR_HASH("get")))
RET CNF(GfxSubModelList_get);
 EI(keyStr.equals("set", CPL_STR_HASH("set")))
RET CNF(GfxSubModelList_set);
 EI(keyStr.equals("getCount", CPL_STR_HASH("getCount")))
RET CNF(GfxSubModelList_getCount);
 EI(keyStr.equals("getData", CPL_STR_HASH("getData")))
RET CNF(GfxSubModelList_getData);
 EI(keyStr.equals("append", CPL_STR_HASH("append")))
RET CNF(GfxSubModelList_append);
 EI(keyStr.equals("insert", CPL_STR_HASH("insert")))
RET CNF(GfxSubModelList_insert);
 EI(keyStr.equals("remove", CPL_STR_HASH("remove")))
RET CNF(GfxSubModelList_remove);
 EI(keyStr.equals("clear", CPL_STR_HASH("clear")))
RET CNF(GfxSubModelList_clear);
 EI(keyStr.equals("find", CPL_STR_HASH("find")))
RET CNF(GfxSubModelList_find);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(GfxSubModelList_copy);
 EI(keyStr.equals("in", CPL_STR_HASH("in")))
RET CNF(GfxSubModelList_in);
 EI(keyStr.equals("reserve", CPL_STR_HASH("reserve")))
RET CNF(GfxSubModelList_reserve);
 EI(keyStr.equals("begin", CPL_STR_HASH("begin")))
RET CNF(GfxSubModelList_begin);
 EI(keyStr.equals("end", CPL_STR_HASH("end")))
RET CNF(GfxSubModelList_end);
 else
 CATE(KE,"Unknown member for GfxSubModelList."));
}
}
RET CN;
}

void GfxSubModelList_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for GfxSubModelList."));
}
}
}

SV GfxSubModelList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::insert" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],GfxModel::SubModel))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxModel::SubModel>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<GfxModel::SubModel> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<GfxModel::SubModel> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxSubModelList::insert.")));
RET CN;
}

SV GfxSubModelList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::begin" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0].p)->data;

CATE(TE,UFOF("GfxSubModelList::begin.")));
RET CN;
}

SV GfxSubModelList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::set" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],GfxModel::SubModel))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxModel::SubModel>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxSubModelList::set.")));
RET CN;
}

SV GfxSubModelList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::end" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0].p)->data;

CATE(TE,UFOF("GfxSubModelList::end.")));
RET CN;
}

SV GfxSubModelList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::get" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxSubModelList::get.")));
RET CN;
}

SV GfxSubModelList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::clear" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("GfxSubModelList::clear.")));
RET CN;
}

SV GfxSubModelList_reserve(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::reserve" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->reserve(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxSubModelList::reserve.")));
RET CN;
}

SV GfxSubModelList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::copy" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("GfxSubModelList::copy.")));
RET CN;
}

SV GfxSubModelList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::remove" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxSubModelList::remove.")));
RET CN;
}

SV GfxSubModelList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::in" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxModel::SubModel))
{
RET CV( f->in(val_to_c<std::remove_reference<GfxModel::SubModel>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxSubModelList::in.")));
RET CN;
}

SV GfxSubModelList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::getCount" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("GfxSubModelList::getCount.")));
RET CN;
}

SV GfxSubModelList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::getData" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0].p)->data;

CATE(TE,UFOF("GfxSubModelList::getData.")));
RET CN;
}

SV GfxSubModelList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::__eq__" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<GfxModel::SubModel> &))
{
auto v=val_to_c<std::remove_reference<const List<GfxModel::SubModel> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("GfxSubModelList::__eq__.")));
RET CN;
}

SV GfxSubModelList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::find" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxModel::SubModel))
{
RET CV( f->find(val_to_c<std::remove_reference<GfxModel::SubModel>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxSubModelList::find.")));
RET CN;
}

SV GfxSubModelList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::append" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxModel::SubModel))
{
( f->append(val_to_c<std::remove_reference<GfxModel::SubModel>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<GfxModel::SubModel> &))
{
( f->append(val_to_c<std::remove_reference<const List<GfxModel::SubModel> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxSubModelList::append.")));
RET CN;
}

SV GfxSubModelList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::__neq__" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<GfxModel::SubModel> &))
{
auto v=val_to_c<std::remove_reference<const List<GfxModel::SubModel> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("GfxSubModelList::__neq__.")));
RET CN;
}

void GfxDebugDrawer_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GfxDebugDrawer))
CATE(TE,"GfxDebugDrawer::__del__ expects GfxDebugDrawer as first argument."));

SCRIPT_DELETE((GfxDebugDrawer*)f->data);
}SV GfxDebugDrawer_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxDebugDrawer's constructor" EAOE));
if(!TS(a[0],GfxDebugDrawer))
CATE(TE,"GfxDebugDrawer's constructor expects GfxDebugDrawer as first argument."));
CATE(TE,UFOF("GfxDebugDrawer's constructor.")));
RET CN;
}

SV GfxDebugDrawer_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxDebugDrawer");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxDebugDrawer_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxDebugDrawer_new);
else
 CATE(KE,"Unknown member for GfxDebugDrawer."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxDebugDrawer_new);
 EI(keyStr.equals("addLine", CPL_STR_HASH("addLine")))
RET CNF(GfxDebugDrawer_addLine);
 EI(keyStr.equals("addBox", CPL_STR_HASH("addBox")))
RET CNF(GfxDebugDrawer_addBox);
 EI(keyStr.equals("render", CPL_STR_HASH("render")))
RET CNF(GfxDebugDrawer_render);
 else
 CATE(KE,"Unknown member for GfxDebugDrawer."));
}
}
RET CN;
}

void GfxDebugDrawer_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for GfxDebugDrawer."));
}
}
}

SV GfxDebugDrawer_addBox(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxDebugDrawer::addBox" EAOE));
GfxDebugDrawer*f;
f=(GfxDebugDrawer*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],const AABB &)&&TS(a[2],const Float4 &))
{
( f->addBox(val_to_c<std::remove_reference<const AABB &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Float4 &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxDebugDrawer::addBox.")));
RET CN;
}

SV GfxDebugDrawer_addLine(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxDebugDrawer::addLine" EAOE));
GfxDebugDrawer*f;
f=(GfxDebugDrawer*)((NO)a[0].p)->data;

if(a.getCount()==5)
if(1&&TS(a[1],const Position3D &)&&TS(a[2],const Position3D &)&&TS(a[3],const Float4 &)&&TS(a[4],const Float4 &))
{
( f->addLine(val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Float4 &>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<const Float4 &>::type>::f(ctx,a[4])));
RET CN;
}
CATE(TE,UFOF("GfxDebugDrawer::addLine.")));
RET CN;
}

SV GfxDebugDrawer_render(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxDebugDrawer::render" EAOE));
GfxDebugDrawer*f;
f=(GfxDebugDrawer*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Camera &))
{
( f->render(val_to_c<std::remove_reference<const Camera &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxDebugDrawer::render.")));
RET CN;
}

void GuiPlacer_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GuiPlacer))
CATE(TE,"GuiPlacer::__del__ expects GuiPlacer as first argument."));

SCRIPT_DELETE((GuiPlacer*)f->data);
}SV GuiPlacer_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer's constructor" EAOE));
if(!TS(a[0],GuiPlacer))
CATE(TE,"GuiPlacer's constructor expects GuiPlacer as first argument."));
if(a.getCount()==5)
if(true&&TS(a[1],ImGui *)&&TS(a[2],int)&&TS(a[3],int)&&TS(a[4],size_t)){
void *p = (void *)NEW(TYPE(GuiPlacer),val_to_c<ImGui *>::f(ctx,a[1]),val_to_c<int>::f(ctx,a[2]),val_to_c<int>::f(ctx,a[3]),val_to_c<size_t>::f(ctx,a[4]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GuiPlacer_funcs,p,EXT->GuiPlacer_typeID);
}CATE(TE,UFOF("GuiPlacer's constructor.")));
RET CN;
}

SV GuiPlacer_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GuiPlacer");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GuiPlacer_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GuiPlacer_new);
else
 CATE(KE,"Unknown member for GuiPlacer."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GuiPlacer_new);
 EI(keyStr.equals("button", CPL_STR_HASH("button")))
RET CNF(GuiPlacer_button);
 EI(keyStr.equals("label", CPL_STR_HASH("label")))
RET CNF(GuiPlacer_label);
 EI(keyStr.equals("placer", CPL_STR_HASH("placer")))
RET CNF(GuiPlacer_placer);
 EI(keyStr.equals("advanceY", CPL_STR_HASH("advanceY")))
RET CNF(GuiPlacer_advanceY);
 EI(keyStr.equals("resetY", CPL_STR_HASH("resetY")))
RET CNF(GuiPlacer_resetY);
 EI(keyStr.equals("setXOrigin", CPL_STR_HASH("setXOrigin")))
RET CNF(GuiPlacer_setXOrigin);
 EI(keyStr.equals("getXOriginMode", CPL_STR_HASH("getXOriginMode")))
RET CNF(GuiPlacer_getXOriginMode);
 EI(keyStr.equals("getXOrigin", CPL_STR_HASH("getXOrigin")))
RET CNF(GuiPlacer_getXOrigin);
 EI(keyStr.equals("getPadding", CPL_STR_HASH("getPadding")))
RET CNF(GuiPlacer_getPadding);
 else
 CATE(KE,"Unknown member for GuiPlacer."));
}
}
RET CN;
}

void GuiPlacer_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for GuiPlacer."));
}
}
}

SV GuiPlacer_advanceY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::advanceY" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->advanceY());
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const GuiPlacer &))
{
( f->advanceY(val_to_c<std::remove_reference<const GuiPlacer &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GuiPlacer::advanceY.")));
RET CN;
}

SV GuiPlacer_placer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::placer" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t))
{
RET CV( f->placer(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("GuiPlacer::placer.")));
RET CN;
}

SV GuiPlacer_getPadding(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::getPadding" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getPadding());
;
}
CATE(TE,UFOF("GuiPlacer::getPadding.")));
RET CN;
}

SV GuiPlacer_button(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::button" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],const char *)&&TS(a[2],size_t)&&TS(a[3],size_t))
{
RET CV( f->button(val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[3])));
;
}
CATE(TE,UFOF("GuiPlacer::button.")));
RET CN;
}

SV GuiPlacer_label(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::label" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const char *))
{
( f->label(val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GuiPlacer::label.")));
RET CN;
}

SV GuiPlacer_resetY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::resetY" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->resetY());
RET CN;
}
CATE(TE,UFOF("GuiPlacer::resetY.")));
RET CN;
}

SV GuiPlacer_getXOriginMode(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::getXOriginMode" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXOriginMode());
;
}
CATE(TE,UFOF("GuiPlacer::getXOriginMode.")));
RET CN;
}

SV GuiPlacer_setXOrigin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::setXOrigin" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],XOrigin)&&TS(a[2],int))
{
( f->setXOrigin(val_to_c<std::remove_reference<XOrigin>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GuiPlacer::setXOrigin.")));
RET CN;
}

SV GuiPlacer_getXOrigin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::getXOrigin" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXOrigin());
;
}
CATE(TE,UFOF("GuiPlacer::getXOrigin.")));
RET CN;
}

void GhostObjList_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,List<GhostObject*>))
CATE(TE,"GhostObjList::__del__ expects GhostObjList as first argument."));

SCRIPT_DELETE((List<GhostObject*>*)f->data);
}SV GhostObjList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList's constructor" EAOE));
if(!TS(a[0],List<GhostObject*>))
CATE(TE,"GhostObjList's constructor expects GhostObjList as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(List<GhostObject*>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GhostObjList_funcs,p,EXT->GhostObjList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],std::size_t)){
void *p = (void *)NEW(TYPE(List<GhostObject*>),val_to_c<std::size_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GhostObjList_funcs,p,EXT->GhostObjList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const List<GhostObject*> &)){
void *p = (void *)NEW(TYPE(List<GhostObject*>),val_to_c<const List<GhostObject*> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GhostObjList_funcs,p,EXT->GhostObjList_typeID);
}CATE(TE,UFOF("GhostObjList's constructor.")));
RET CN;
}

SV GhostObjList_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GhostObjList");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GhostObjList_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GhostObjList_new);
else
 CATE(KE,"Unknown member for GhostObjList."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GhostObjList_new);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GhostObjList___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(GhostObjList___neq__);
 EI(keyStr.equals("get", CPL_STR_HASH("get")))
RET CNF(GhostObjList_get);
 EI(keyStr.equals("set", CPL_STR_HASH("set")))
RET CNF(GhostObjList_set);
 EI(keyStr.equals("getCount", CPL_STR_HASH("getCount")))
RET CNF(GhostObjList_getCount);
 EI(keyStr.equals("getData", CPL_STR_HASH("getData")))
RET CNF(GhostObjList_getData);
 EI(keyStr.equals("append", CPL_STR_HASH("append")))
RET CNF(GhostObjList_append);
 EI(keyStr.equals("insert", CPL_STR_HASH("insert")))
RET CNF(GhostObjList_insert);
 EI(keyStr.equals("remove", CPL_STR_HASH("remove")))
RET CNF(GhostObjList_remove);
 EI(keyStr.equals("clear", CPL_STR_HASH("clear")))
RET CNF(GhostObjList_clear);
 EI(keyStr.equals("find", CPL_STR_HASH("find")))
RET CNF(GhostObjList_find);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(GhostObjList_copy);
 EI(keyStr.equals("in", CPL_STR_HASH("in")))
RET CNF(GhostObjList_in);
 EI(keyStr.equals("reserve", CPL_STR_HASH("reserve")))
RET CNF(GhostObjList_reserve);
 EI(keyStr.equals("begin", CPL_STR_HASH("begin")))
RET CNF(GhostObjList_begin);
 EI(keyStr.equals("end", CPL_STR_HASH("end")))
RET CNF(GhostObjList_end);
 else
 CATE(KE,"Unknown member for GhostObjList."));
}
}
RET CN;
}

void GhostObjList_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for GhostObjList."));
}
}
}

SV GhostObjList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::insert" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],GhostObject*))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GhostObject*>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<GhostObject*> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<GhostObject*> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GhostObjList::insert.")));
RET CN;
}

SV GhostObjList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::begin" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("GhostObjList::begin.")));
RET CN;
}

SV GhostObjList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::set" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],GhostObject*))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GhostObject*>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GhostObjList::set.")));
RET CN;
}

SV GhostObjList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::end" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("GhostObjList::end.")));
RET CN;
}

SV GhostObjList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::get" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GhostObjList::get.")));
RET CN;
}

SV GhostObjList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::clear" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("GhostObjList::clear.")));
RET CN;
}

SV GhostObjList_reserve(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::reserve" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->reserve(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GhostObjList::reserve.")));
RET CN;
}

SV GhostObjList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::copy" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("GhostObjList::copy.")));
RET CN;
}

SV GhostObjList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::remove" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GhostObjList::remove.")));
RET CN;
}

SV GhostObjList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::in" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GhostObject*))
{
RET CV( f->in(val_to_c<std::remove_reference<GhostObject*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GhostObjList::in.")));
RET CN;
}

SV GhostObjList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::getCount" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("GhostObjList::getCount.")));
RET CN;
}

SV GhostObjList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::getData" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("GhostObjList::getData.")));
RET CN;
}

SV GhostObjList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::__eq__" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<GhostObject*> &))
{
auto v=val_to_c<std::remove_reference<const List<GhostObject*> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("GhostObjList::__eq__.")));
RET CN;
}

SV GhostObjList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::find" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GhostObject*))
{
RET CV( f->find(val_to_c<std::remove_reference<GhostObject*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GhostObjList::find.")));
RET CN;
}

SV GhostObjList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::append" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GhostObject*))
{
( f->append(val_to_c<std::remove_reference<GhostObject*>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<GhostObject*> &))
{
( f->append(val_to_c<std::remove_reference<const List<GhostObject*> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GhostObjList::append.")));
RET CN;
}

SV GhostObjList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::__neq__" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<GhostObject*> &))
{
auto v=val_to_c<std::remove_reference<const List<GhostObject*> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("GhostObjList::__neq__.")));
RET CN;
}

void PhysicsWorld_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,PhysicsWorld))
CATE(TE,"PhysicsWorld::__del__ expects PhysicsWorld as first argument."));

SCRIPT_DELETE((PhysicsWorld*)f->data);
}SV PhysicsWorld_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld's constructor" EAOE));
if(!TS(a[0],PhysicsWorld))
CATE(TE,"PhysicsWorld's constructor expects PhysicsWorld as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(PhysicsWorld));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(PhysicsWorld_funcs,p,EXT->PhysicsWorld_typeID);
}CATE(TE,UFOF("PhysicsWorld's constructor.")));
RET CN;
}

SV PhysicsWorld_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("PhysicsWorld");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(PhysicsWorld_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(PhysicsWorld_new);
else
 CATE(KE,"Unknown member for PhysicsWorld."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(PhysicsWorld_new);
 EI(keyStr.equals("addDebugDrawer", CPL_STR_HASH("addDebugDrawer")))
RET CNF(PhysicsWorld_addDebugDrawer);
 EI(keyStr.equals("setGravity", CPL_STR_HASH("setGravity")))
RET CNF(PhysicsWorld_setGravity);
 EI(keyStr.equals("getGravity", CPL_STR_HASH("getGravity")))
RET CNF(PhysicsWorld_getGravity);
 EI(keyStr.equals("getRigidBodies", CPL_STR_HASH("getRigidBodies")))
RET CNF(PhysicsWorld_getRigidBodies);
 EI(keyStr.equals("getGhostObjects", CPL_STR_HASH("getGhostObjects")))
RET CNF(PhysicsWorld_getGhostObjects);
 EI(keyStr.equals("createRigidBody", CPL_STR_HASH("createRigidBody")))
RET CNF(PhysicsWorld_createRigidBody);
 EI(keyStr.equals("destroyRigidBody", CPL_STR_HASH("destroyRigidBody")))
RET CNF(PhysicsWorld_destroyRigidBody);
 EI(keyStr.equals("createGhostObject", CPL_STR_HASH("createGhostObject")))
RET CNF(PhysicsWorld_createGhostObject);
 EI(keyStr.equals("destroyGhostObject", CPL_STR_HASH("destroyGhostObject")))
RET CNF(PhysicsWorld_destroyGhostObject);
 EI(keyStr.equals("stepSimulation", CPL_STR_HASH("stepSimulation")))
RET CNF(PhysicsWorld_stepSimulation);
 EI(keyStr.equals("debugDraw", CPL_STR_HASH("debugDraw")))
RET CNF(PhysicsWorld_debugDraw);
 EI(keyStr.equals("castRay", CPL_STR_HASH("castRay")))
RET CNF(PhysicsWorld_castRay);
 EI(keyStr.equals("getBulletWorld", CPL_STR_HASH("getBulletWorld")))
RET CNF(PhysicsWorld_getBulletWorld);
 else
 CATE(KE,"Unknown member for PhysicsWorld."));
}
}
RET CN;
}

void PhysicsWorld_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for PhysicsWorld."));
}
}
}

SV PhysicsWorld_setGravity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::setGravity" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->setGravity(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("PhysicsWorld::setGravity.")));
RET CN;
}

SV PhysicsWorld_stepSimulation(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::stepSimulation" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],float)&&TS(a[2],size_t)&&TS(a[3],float))
{
( f->stepSimulation(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("PhysicsWorld::stepSimulation.")));
RET CN;
}

SV PhysicsWorld_castRay(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::castRay" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],const Position3D &)&&TS(a[2],const Direction3D &)&&TS(a[3],float))
{
RET CV( f->castRay(val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Direction3D &>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
;
}
CATE(TE,UFOF("PhysicsWorld::castRay.")));
RET CN;
}

SV PhysicsWorld_getGhostObjects(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::getGhostObjects" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGhostObjects());
;
}
CATE(TE,UFOF("PhysicsWorld::getGhostObjects.")));
RET CN;
}

SV PhysicsWorld_getBulletWorld(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::getBulletWorld" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0].p)->data;

CATE(TE,UFOF("PhysicsWorld::getBulletWorld.")));
RET CN;
}

SV PhysicsWorld_addDebugDrawer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::addDebugDrawer" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->addDebugDrawer());
RET CN;
}
CATE(TE,UFOF("PhysicsWorld::addDebugDrawer.")));
RET CN;
}

SV PhysicsWorld_createRigidBody(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::createRigidBody" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],const RigidBodyConstructionInfo &)&&TS(a[2],PhysicsShape *))
{
RET CV( f->createRigidBody(val_to_c<std::remove_reference<const RigidBodyConstructionInfo &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<PhysicsShape *>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("PhysicsWorld::createRigidBody.")));
RET CN;
}

SV PhysicsWorld_getRigidBodies(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::getRigidBodies" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRigidBodies());
;
}
CATE(TE,UFOF("PhysicsWorld::getRigidBodies.")));
RET CN;
}

SV PhysicsWorld_getGravity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::getGravity" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGravity());
;
}
CATE(TE,UFOF("PhysicsWorld::getGravity.")));
RET CN;
}

SV PhysicsWorld_destroyGhostObject(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::destroyGhostObject" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GhostObject *))
{
( f->destroyGhostObject(val_to_c<std::remove_reference<GhostObject *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("PhysicsWorld::destroyGhostObject.")));
RET CN;
}

SV PhysicsWorld_createGhostObject(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::createGhostObject" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],PhysicsShape *)&&TS(a[2],unsigned short))
{
RET CV( f->createGhostObject(val_to_c<std::remove_reference<PhysicsShape *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<unsigned short>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("PhysicsWorld::createGhostObject.")));
RET CN;
}

SV PhysicsWorld_destroyRigidBody(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::destroyRigidBody" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],RigidBody *))
{
( f->destroyRigidBody(val_to_c<std::remove_reference<RigidBody *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("PhysicsWorld::destroyRigidBody.")));
RET CN;
}

SV PhysicsWorld_debugDraw(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::debugDraw" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->debugDraw());
RET CN;
}
CATE(TE,UFOF("PhysicsWorld::debugDraw.")));
RET CN;
}

void Script_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Script))
CATE(TE,"Script::__del__ expects Script as first argument."));

Script*obj=(Script*)f->data;
if(_scriptDeletePart(obj)){obj->release();}
}SV Script_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Script's constructor" EAOE));
if(!TS(a[0],Script))
CATE(TE,"Script's constructor expects Script as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(Script));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Script_funcs,p,EXT->Script_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const Str &)){
void *p = (void *)NEW(TYPE(Script),val_to_c<const Str &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Script_funcs,p,EXT->Script_typeID);
}CATE(TE,UFOF("Script's constructor.")));
RET CN;
}

SV Script_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Script");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Script_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Script_new);
else
 CATE(KE,"Unknown member for Script."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Script_new);
 EI(keyStr.equals("removeContent", CPL_STR_HASH("removeContent")))
RET CNF(Script_removeContent);
 EI(keyStr.equals("createInstance", CPL_STR_HASH("createInstance")))
RET CNF(Script_createInstance);
 EI(keyStr.equals("getContext", CPL_STR_HASH("getContext")))
RET CNF(Script_getContext);
 EI(keyStr.equals("load", CPL_STR_HASH("load")))
RET CNF(Script_load);
 EI(keyStr.equals("save", CPL_STR_HASH("save")))
RET CNF(Script_save);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(Script_copy);
 EI(keyStr.equals("getType", CPL_STR_HASH("getType")))
RET CNF(Script_getType);
 EI(keyStr.equals("release", CPL_STR_HASH("release")))
RET CNF(Script_release);
 EI(keyStr.equals("getRefCount", CPL_STR_HASH("getRefCount")))
RET CNF(Script_getRefCount);
 EI(keyStr.equals("getFilename", CPL_STR_HASH("getFilename")))
RET CNF(Script_getFilename);
 EI(keyStr.equals("setFilename", CPL_STR_HASH("setFilename")))
RET CNF(Script_setFilename);
 else
 CATE(KE,"Unknown member for Script."));
}
}
RET CN;
}

void Script_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for Script."));
}
}
}

SV Script_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Script::load" EAOE));
Script*f;
f=(Script*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("Script::load.")));
RET CN;
}

SV Script_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Script::getFilename" EAOE));
Script*f;
f=(Script*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("Script::getFilename.")));
RET CN;
}

SV Script_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Script::copy" EAOE));
Script*f;
f=(Script*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("Script::copy.")));
RET CN;
}

SV Script_createInstance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Script::createInstance" EAOE));
Script*f;
f=(Script*)((NO)a[0].p)->data;

CATE(TE,UFOF("Script::createInstance.")));
RET CN;
}

SV Script_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Script::setFilename" EAOE));
Script*f;
f=(Script*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
( f->setFilename(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Script::setFilename.")));
RET CN;
}

SV Script_getContext(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Script::getContext" EAOE));
Script*f;
f=(Script*)((NO)a[0].p)->data;

CATE(TE,UFOF("Script::getContext.")));
RET CN;
}

SV Script_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Script::removeContent" EAOE));
Script*f;
f=(Script*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("Script::removeContent.")));
RET CN;
}

SV Script_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Script::getRefCount" EAOE));
Script*f;
f=(Script*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("Script::getRefCount.")));
RET CN;
}

SV Script_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Script::release" EAOE));
Script*f;
f=(Script*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("Script::release.")));
RET CN;
}

SV Script_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Script::getType" EAOE));
Script*f;
f=(Script*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("Script::getType.")));
RET CN;
}

SV Script_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Script::save" EAOE));
Script*f;
f=(Script*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("Script::save.")));
RET CN;
}

void MCWorld_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,MCWorld))
CATE(TE,"MCWorld::__del__ expects MCWorld as first argument."));

SCRIPT_DELETE((MCWorld*)f->data);
}SV MCWorld_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCWorld's constructor" EAOE));
if(!TS(a[0],MCWorld))
CATE(TE,"MCWorld's constructor expects MCWorld as first argument."));
if(a.getCount()==5)
if(true&&TS(a[1],const UInt3 &)&&TS(a[2],uint8_t)&&TS(a[3],float)&&TS(a[4],PhysicsWorld *)){
void *p = (void *)NEW(TYPE(MCWorld),val_to_c<const UInt3 &>::f(ctx,a[1]),val_to_c<uint8_t>::f(ctx,a[2]),val_to_c<float>::f(ctx,a[3]),val_to_c<PhysicsWorld *>::f(ctx,a[4]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(MCWorld_funcs,p,EXT->MCWorld_typeID);
}CATE(TE,UFOF("MCWorld's constructor.")));
RET CN;
}

SV MCWorld_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("MCWorld");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(MCWorld_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(MCWorld_new);
else
 CATE(KE,"Unknown member for MCWorld."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(MCWorld_new);
 EI(keyStr.equals("setMaterial", CPL_STR_HASH("setMaterial")))
RET CNF(MCWorld_setMaterial);
 EI(keyStr.equals("render", CPL_STR_HASH("render")))
RET CNF(MCWorld_render);
 EI(keyStr.equals("update", CPL_STR_HASH("update")))
RET CNF(MCWorld_update);
 EI(keyStr.equals("setCube", CPL_STR_HASH("setCube")))
RET CNF(MCWorld_setCube);
 EI(keyStr.equals("getCube", CPL_STR_HASH("getCube")))
RET CNF(MCWorld_getCube);
 EI(keyStr.equals("getChunkSize", CPL_STR_HASH("getChunkSize")))
RET CNF(MCWorld_getChunkSize);
 EI(keyStr.equals("getNumTypes", CPL_STR_HASH("getNumTypes")))
RET CNF(MCWorld_getNumTypes);
 EI(keyStr.equals("getBlockSize", CPL_STR_HASH("getBlockSize")))
RET CNF(MCWorld_getBlockSize);
 EI(keyStr.equals("getPhysicsWorld", CPL_STR_HASH("getPhysicsWorld")))
RET CNF(MCWorld_getPhysicsWorld);
 EI(keyStr.equals("getCubeShape", CPL_STR_HASH("getCubeShape")))
RET CNF(MCWorld_getCubeShape);
 EI(keyStr.equals("getMaterial", CPL_STR_HASH("getMaterial")))
RET CNF(MCWorld_getMaterial);
 EI(keyStr.equals("save", CPL_STR_HASH("save")))
RET CNF(MCWorld_save);
 EI(keyStr.equals("load", CPL_STR_HASH("load")))
RET CNF(MCWorld_load);
 EI(keyStr.equals("clear", CPL_STR_HASH("clear")))
RET CNF(MCWorld_clear);
 else
 CATE(KE,"Unknown member for MCWorld."));
}
}
RET CN;
}

void MCWorld_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for MCWorld."));
}
}
}

SV MCWorld_setCube(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCWorld::setCube" EAOE));
MCWorld*f;
f=(MCWorld*)((NO)a[0].p)->data;

if(a.getCount()==5)
if(1&&TS(a[1],int)&&TS(a[2],int)&&TS(a[3],int)&&TS(a[4],uint8_t))
{
( f->setCube(val_to_c<std::remove_reference<int>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[4])));
RET CN;
}
if(a.getCount()==5)
if(1&&TS(a[1],float)&&TS(a[2],float)&&TS(a[3],float)&&TS(a[4],uint8_t))
{
( f->setCube(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[4])));
RET CN;
}
CATE(TE,UFOF("MCWorld::setCube.")));
RET CN;
}

SV MCWorld_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCWorld::load" EAOE));
MCWorld*f;
f=(MCWorld*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Str))
{
( f->load(val_to_c<std::remove_reference<Str>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("MCWorld::load.")));
RET CN;
}

SV MCWorld_render(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCWorld::render" EAOE));
MCWorld*f;
f=(MCWorld*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxRenderer *))
{
( f->render(val_to_c<std::remove_reference<GfxRenderer *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("MCWorld::render.")));
RET CN;
}

SV MCWorld_setMaterial(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCWorld::setMaterial" EAOE));
MCWorld*f;
f=(MCWorld*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],uint8_t)&&TS(a[2],GfxMaterial *))
{
( f->setMaterial(val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxMaterial *>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("MCWorld::setMaterial.")));
RET CN;
}

SV MCWorld_getChunkSize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCWorld::getChunkSize" EAOE));
MCWorld*f;
f=(MCWorld*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getChunkSize());
;
}
CATE(TE,UFOF("MCWorld::getChunkSize.")));
RET CN;
}

SV MCWorld_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCWorld::clear" EAOE));
MCWorld*f;
f=(MCWorld*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("MCWorld::clear.")));
RET CN;
}

SV MCWorld_getNumTypes(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCWorld::getNumTypes" EAOE));
MCWorld*f;
f=(MCWorld*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getNumTypes());
;
}
CATE(TE,UFOF("MCWorld::getNumTypes.")));
RET CN;
}

SV MCWorld_update(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCWorld::update" EAOE));
MCWorld*f;
f=(MCWorld*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->update());
RET CN;
}
CATE(TE,UFOF("MCWorld::update.")));
RET CN;
}

SV MCWorld_getPhysicsWorld(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCWorld::getPhysicsWorld" EAOE));
MCWorld*f;
f=(MCWorld*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getPhysicsWorld());
;
}
CATE(TE,UFOF("MCWorld::getPhysicsWorld.")));
RET CN;
}

SV MCWorld_getMaterial(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCWorld::getMaterial" EAOE));
MCWorld*f;
f=(MCWorld*)((NO)a[0].p)->data;

CATE(TE,UFOF("MCWorld::getMaterial.")));
RET CN;
}

SV MCWorld_getBlockSize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCWorld::getBlockSize" EAOE));
MCWorld*f;
f=(MCWorld*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlockSize());
;
}
CATE(TE,UFOF("MCWorld::getBlockSize.")));
RET CN;
}

SV MCWorld_getCubeShape(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCWorld::getCubeShape" EAOE));
MCWorld*f;
f=(MCWorld*)((NO)a[0].p)->data;

CATE(TE,UFOF("MCWorld::getCubeShape.")));
RET CN;
}

SV MCWorld_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCWorld::save" EAOE));
MCWorld*f;
f=(MCWorld*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Str))
{
( f->save(val_to_c<std::remove_reference<Str>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("MCWorld::save.")));
RET CN;
}

SV MCWorld_getCube(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"MCWorld::getCube" EAOE));
MCWorld*f;
f=(MCWorld*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],int)&&TS(a[2],int)&&TS(a[3],int))
{
RET CV( f->getCube(val_to_c<std::remove_reference<int>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[3])));
;
}
if(a.getCount()==4)
if(1&&TS(a[1],float)&&TS(a[2],float)&&TS(a[3],float))
{
RET CV( f->getCube(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
;
}
CATE(TE,UFOF("MCWorld::getCube.")));
RET CN;
}

void GfxObject_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GfxObject))
CATE(TE,"GfxObject::__del__ expects GfxObject as first argument."));

SCRIPT_DELETE((GfxObject*)f->data);
}SV GfxObject_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxObject's constructor" EAOE));
if(!TS(a[0],GfxObject))
CATE(TE,"GfxObject's constructor expects GfxObject as first argument."));
if(a.getCount()==3)
if(true&&TS(a[1],GfxMaterial *)&&TS(a[2],GfxMesh *)){
void *p = (void *)NEW(TYPE(GfxObject),val_to_c<GfxMaterial *>::f(ctx,a[1]),val_to_c<GfxMesh *>::f(ctx,a[2]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxObject_funcs,p,EXT->GfxObject_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const GfxObject &)){
void *p = (void *)NEW(TYPE(GfxObject),val_to_c<const GfxObject &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxObject_funcs,p,EXT->GfxObject_typeID);
}CATE(TE,UFOF("GfxObject's constructor.")));
RET CN;
}

SV GfxObject_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxObject");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxObject_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxObject_new);
else
 CATE(KE,"Unknown member for GfxObject."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxObject_new);
 EI(keyStr.equals("shadowCaster", CPL_STR_HASH("shadowCaster")))
{
GfxObject*obj=(GfxObject*)f->data;
RET CV(obj->shadowCaster);
} EI(keyStr.equals("material", CPL_STR_HASH("material")))
{
GfxObject*obj=(GfxObject*)f->data;
RET CV(obj->material);
} EI(keyStr.equals("mesh", CPL_STR_HASH("mesh")))
{
GfxObject*obj=(GfxObject*)f->data;
RET CV(obj->mesh);
} EI(keyStr.equals("animState", CPL_STR_HASH("animState")))
{
GfxObject*obj=(GfxObject*)f->data;
RET CV(obj->animState);
} EI(keyStr.equals("worldMatrix", CPL_STR_HASH("worldMatrix")))
{
GfxObject*obj=(GfxObject*)f->data;
RET CV(obj->worldMatrix);
} EI(keyStr.equals("normalMatrix", CPL_STR_HASH("normalMatrix")))
{
GfxObject*obj=(GfxObject*)f->data;
RET CV(obj->normalMatrix);
} else
 CATE(KE,"Unknown member for GfxObject."));
}
}
RET CN;
}

void GfxObject_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("shadowCaster", CPL_STR_HASH("shadowCaster")))
{
GfxObject*obj=(GfxObject*)f->data;
obj->shadowCaster=val_to_c<decltype(obj->shadowCaster)>::f(ctx,value);
} EI(keyStr.equals("material", CPL_STR_HASH("material")))
{
GfxObject*obj=(GfxObject*)f->data;
obj->material=val_to_c<decltype(obj->material)>::f(ctx,value);
} EI(keyStr.equals("mesh", CPL_STR_HASH("mesh")))
{
GfxObject*obj=(GfxObject*)f->data;
obj->mesh=val_to_c<decltype(obj->mesh)>::f(ctx,value);
} EI(keyStr.equals("animState", CPL_STR_HASH("animState")))
{
GfxObject*obj=(GfxObject*)f->data;
obj->animState=val_to_c<decltype(obj->animState)>::f(ctx,value);
} EI(keyStr.equals("worldMatrix", CPL_STR_HASH("worldMatrix")))
{
GfxObject*obj=(GfxObject*)f->data;
obj->worldMatrix=val_to_c<decltype(obj->worldMatrix)>::f(ctx,value);
} EI(keyStr.equals("normalMatrix", CPL_STR_HASH("normalMatrix")))
{
GfxObject*obj=(GfxObject*)f->data;
obj->normalMatrix=val_to_c<decltype(obj->normalMatrix)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for GfxObject."));
}
}
}

void Transform_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Transform))
CATE(TE,"Transform::__del__ expects Transform as first argument."));

SCRIPT_DELETE((Transform*)f->data);
}SV Transform_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Transform's constructor" EAOE));
if(!TS(a[0],Transform))
CATE(TE,"Transform's constructor expects Transform as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(Transform));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Transform_funcs,p,EXT->Transform_typeID);
}CATE(TE,UFOF("Transform's constructor.")));
RET CN;
}

SV Transform_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Transform");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Transform_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Transform_new);
else
 CATE(KE,"Unknown member for Transform."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Transform_new);
 EI(keyStr.equals("createMatrix", CPL_STR_HASH("createMatrix")))
RET CNF(Transform_createMatrix);
 EI(keyStr.equals("orientation", CPL_STR_HASH("orientation")))
{
Transform*obj=(Transform*)f->data;
RET CV(obj->orientation);
} EI(keyStr.equals("scale", CPL_STR_HASH("scale")))
{
Transform*obj=(Transform*)f->data;
RET CV(obj->scale);
} EI(keyStr.equals("position", CPL_STR_HASH("position")))
{
Transform*obj=(Transform*)f->data;
RET CV(obj->position);
} else
 CATE(KE,"Unknown member for Transform."));
}
}
RET CN;
}

void Transform_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("orientation", CPL_STR_HASH("orientation")))
{
Transform*obj=(Transform*)f->data;
obj->orientation=val_to_c<decltype(obj->orientation)>::f(ctx,value);
} EI(keyStr.equals("scale", CPL_STR_HASH("scale")))
{
Transform*obj=(Transform*)f->data;
obj->scale=val_to_c<decltype(obj->scale)>::f(ctx,value);
} EI(keyStr.equals("position", CPL_STR_HASH("position")))
{
Transform*obj=(Transform*)f->data;
obj->position=val_to_c<decltype(obj->position)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for Transform."));
}
}
}

SV Transform_createMatrix(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Transform::createMatrix" EAOE));
Transform*f;
f=(Transform*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->createMatrix());
;
}
CATE(TE,UFOF("Transform::createMatrix.")));
RET CN;
}

void AudioSourceList_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,List<AudioSource*>))
CATE(TE,"AudioSourceList::__del__ expects AudioSourceList as first argument."));

SCRIPT_DELETE((List<AudioSource*>*)f->data);
}SV AudioSourceList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList's constructor" EAOE));
if(!TS(a[0],List<AudioSource*>))
CATE(TE,"AudioSourceList's constructor expects AudioSourceList as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(List<AudioSource*>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(AudioSourceList_funcs,p,EXT->AudioSourceList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],std::size_t)){
void *p = (void *)NEW(TYPE(List<AudioSource*>),val_to_c<std::size_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(AudioSourceList_funcs,p,EXT->AudioSourceList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const List<AudioSource*> &)){
void *p = (void *)NEW(TYPE(List<AudioSource*>),val_to_c<const List<AudioSource*> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(AudioSourceList_funcs,p,EXT->AudioSourceList_typeID);
}CATE(TE,UFOF("AudioSourceList's constructor.")));
RET CN;
}

SV AudioSourceList_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("AudioSourceList");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(AudioSourceList_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(AudioSourceList_new);
else
 CATE(KE,"Unknown member for AudioSourceList."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(AudioSourceList_new);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(AudioSourceList___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(AudioSourceList___neq__);
 EI(keyStr.equals("get", CPL_STR_HASH("get")))
RET CNF(AudioSourceList_get);
 EI(keyStr.equals("set", CPL_STR_HASH("set")))
RET CNF(AudioSourceList_set);
 EI(keyStr.equals("getCount", CPL_STR_HASH("getCount")))
RET CNF(AudioSourceList_getCount);
 EI(keyStr.equals("getData", CPL_STR_HASH("getData")))
RET CNF(AudioSourceList_getData);
 EI(keyStr.equals("append", CPL_STR_HASH("append")))
RET CNF(AudioSourceList_append);
 EI(keyStr.equals("insert", CPL_STR_HASH("insert")))
RET CNF(AudioSourceList_insert);
 EI(keyStr.equals("remove", CPL_STR_HASH("remove")))
RET CNF(AudioSourceList_remove);
 EI(keyStr.equals("clear", CPL_STR_HASH("clear")))
RET CNF(AudioSourceList_clear);
 EI(keyStr.equals("find", CPL_STR_HASH("find")))
RET CNF(AudioSourceList_find);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(AudioSourceList_copy);
 EI(keyStr.equals("in", CPL_STR_HASH("in")))
RET CNF(AudioSourceList_in);
 EI(keyStr.equals("reserve", CPL_STR_HASH("reserve")))
RET CNF(AudioSourceList_reserve);
 EI(keyStr.equals("begin", CPL_STR_HASH("begin")))
RET CNF(AudioSourceList_begin);
 EI(keyStr.equals("end", CPL_STR_HASH("end")))
RET CNF(AudioSourceList_end);
 else
 CATE(KE,"Unknown member for AudioSourceList."));
}
}
RET CN;
}

void AudioSourceList_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for AudioSourceList."));
}
}
}

SV AudioSourceList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::insert" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],AudioSource*))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<AudioSource*>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<AudioSource*> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<AudioSource*> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("AudioSourceList::insert.")));
RET CN;
}

SV AudioSourceList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::begin" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("AudioSourceList::begin.")));
RET CN;
}

SV AudioSourceList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::set" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],AudioSource*))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<AudioSource*>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("AudioSourceList::set.")));
RET CN;
}

SV AudioSourceList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::end" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("AudioSourceList::end.")));
RET CN;
}

SV AudioSourceList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::get" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("AudioSourceList::get.")));
RET CN;
}

SV AudioSourceList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::clear" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("AudioSourceList::clear.")));
RET CN;
}

SV AudioSourceList_reserve(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::reserve" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->reserve(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioSourceList::reserve.")));
RET CN;
}

SV AudioSourceList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::copy" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("AudioSourceList::copy.")));
RET CN;
}

SV AudioSourceList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::remove" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("AudioSourceList::remove.")));
RET CN;
}

SV AudioSourceList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::in" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],AudioSource*))
{
RET CV( f->in(val_to_c<std::remove_reference<AudioSource*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("AudioSourceList::in.")));
RET CN;
}

SV AudioSourceList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::getCount" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("AudioSourceList::getCount.")));
RET CN;
}

SV AudioSourceList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::getData" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("AudioSourceList::getData.")));
RET CN;
}

SV AudioSourceList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::__eq__" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<AudioSource*> &))
{
auto v=val_to_c<std::remove_reference<const List<AudioSource*> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("AudioSourceList::__eq__.")));
RET CN;
}

SV AudioSourceList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::find" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],AudioSource*))
{
RET CV( f->find(val_to_c<std::remove_reference<AudioSource*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("AudioSourceList::find.")));
RET CN;
}

SV AudioSourceList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::append" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],AudioSource*))
{
( f->append(val_to_c<std::remove_reference<AudioSource*>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<AudioSource*> &))
{
( f->append(val_to_c<std::remove_reference<const List<AudioSource*> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioSourceList::append.")));
RET CN;
}

SV AudioSourceList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::__neq__" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<AudioSource*> &))
{
auto v=val_to_c<std::remove_reference<const List<AudioSource*> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("AudioSourceList::__neq__.")));
RET CN;
}

void Int4_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,T4<int32_t>))
CATE(TE,"Int4::__del__ expects Int4 as first argument."));

SCRIPT_DELETE((T4<int32_t>*)f->data);
}SV Int4_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4's constructor" EAOE));
if(!TS(a[0],T4<int32_t>))
CATE(TE,"Int4's constructor expects Int4 as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(T4<int32_t>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int4_funcs,p,EXT->Int4_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],int32_t)){
void *p = (void *)NEW(TYPE(T4<int32_t>),val_to_c<int32_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int4_funcs,p,EXT->Int4_typeID);
}if(a.getCount()==5)
if(true&&TS(a[1],int32_t)&&TS(a[2],int32_t)&&TS(a[3],int32_t)&&TS(a[4],int32_t)){
void *p = (void *)NEW(TYPE(T4<int32_t>),val_to_c<int32_t>::f(ctx,a[1]),val_to_c<int32_t>::f(ctx,a[2]),val_to_c<int32_t>::f(ctx,a[3]),val_to_c<int32_t>::f(ctx,a[4]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int4_funcs,p,EXT->Int4_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T4<float> &)){
void *p = (void *)NEW(TYPE(T4<int32_t>),val_to_c<const T4<float> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int4_funcs,p,EXT->Int4_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T4<int32_t> &)){
void *p = (void *)NEW(TYPE(T4<int32_t>),val_to_c<const T4<int32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int4_funcs,p,EXT->Int4_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T4<uint32_t> &)){
void *p = (void *)NEW(TYPE(T4<int32_t>),val_to_c<const T4<uint32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int4_funcs,p,EXT->Int4_typeID);
}CATE(TE,UFOF("Int4's constructor.")));
RET CN;
}

SV Int4_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Int4");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Int4_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Int4_new);
else
 CATE(KE,"Unknown member for Int4."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Int4_new);
 EI(keyStr.equals("__add__", CPL_STR_HASH("__add__")))
RET CNF(Int4___add__);
 EI(keyStr.equals("__sub__", CPL_STR_HASH("__sub__")))
RET CNF(Int4___sub__);
 EI(keyStr.equals("__mul__", CPL_STR_HASH("__mul__")))
RET CNF(Int4___mul__);
 EI(keyStr.equals("__div__", CPL_STR_HASH("__div__")))
RET CNF(Int4___div__);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(Int4___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(Int4___neq__);
 EI(keyStr.equals("__less__", CPL_STR_HASH("__less__")))
RET CNF(Int4___less__);
 EI(keyStr.equals("__grtr__", CPL_STR_HASH("__grtr__")))
RET CNF(Int4___grtr__);
 EI(keyStr.equals("__leq__", CPL_STR_HASH("__leq__")))
RET CNF(Int4___leq__);
 EI(keyStr.equals("__geq__", CPL_STR_HASH("__geq__")))
RET CNF(Int4___geq__);
 EI(keyStr.equals("sum", CPL_STR_HASH("sum")))
RET CNF(Int4_sum);
 EI(keyStr.equals("length", CPL_STR_HASH("length")))
RET CNF(Int4_length);
 EI(keyStr.equals("lengthSquared", CPL_STR_HASH("lengthSquared")))
RET CNF(Int4_lengthSquared);
 EI(keyStr.equals("dot", CPL_STR_HASH("dot")))
RET CNF(Int4_dot);
 EI(keyStr.equals("distance", CPL_STR_HASH("distance")))
RET CNF(Int4_distance);
 EI(keyStr.equals("distanceSquared", CPL_STR_HASH("distanceSquared")))
RET CNF(Int4_distanceSquared);
 EI(keyStr.equals("normalize", CPL_STR_HASH("normalize")))
RET CNF(Int4_normalize);
 EI(keyStr.equals("getXY", CPL_STR_HASH("getXY")))
RET CNF(Int4_getXY);
 EI(keyStr.equals("setXY", CPL_STR_HASH("setXY")))
RET CNF(Int4_setXY);
 EI(keyStr.equals("getXZ", CPL_STR_HASH("getXZ")))
RET CNF(Int4_getXZ);
 EI(keyStr.equals("setXZ", CPL_STR_HASH("setXZ")))
RET CNF(Int4_setXZ);
 EI(keyStr.equals("getXW", CPL_STR_HASH("getXW")))
RET CNF(Int4_getXW);
 EI(keyStr.equals("setXW", CPL_STR_HASH("setXW")))
RET CNF(Int4_setXW);
 EI(keyStr.equals("getYX", CPL_STR_HASH("getYX")))
RET CNF(Int4_getYX);
 EI(keyStr.equals("setYX", CPL_STR_HASH("setYX")))
RET CNF(Int4_setYX);
 EI(keyStr.equals("getYZ", CPL_STR_HASH("getYZ")))
RET CNF(Int4_getYZ);
 EI(keyStr.equals("setYZ", CPL_STR_HASH("setYZ")))
RET CNF(Int4_setYZ);
 EI(keyStr.equals("getYW", CPL_STR_HASH("getYW")))
RET CNF(Int4_getYW);
 EI(keyStr.equals("setYW", CPL_STR_HASH("setYW")))
RET CNF(Int4_setYW);
 EI(keyStr.equals("getZX", CPL_STR_HASH("getZX")))
RET CNF(Int4_getZX);
 EI(keyStr.equals("setZX", CPL_STR_HASH("setZX")))
RET CNF(Int4_setZX);
 EI(keyStr.equals("getZY", CPL_STR_HASH("getZY")))
RET CNF(Int4_getZY);
 EI(keyStr.equals("setZY", CPL_STR_HASH("setZY")))
RET CNF(Int4_setZY);
 EI(keyStr.equals("getZW", CPL_STR_HASH("getZW")))
RET CNF(Int4_getZW);
 EI(keyStr.equals("setZW", CPL_STR_HASH("setZW")))
RET CNF(Int4_setZW);
 EI(keyStr.equals("getWX", CPL_STR_HASH("getWX")))
RET CNF(Int4_getWX);
 EI(keyStr.equals("setWX", CPL_STR_HASH("setWX")))
RET CNF(Int4_setWX);
 EI(keyStr.equals("getWY", CPL_STR_HASH("getWY")))
RET CNF(Int4_getWY);
 EI(keyStr.equals("setWY", CPL_STR_HASH("setWY")))
RET CNF(Int4_setWY);
 EI(keyStr.equals("getWZ", CPL_STR_HASH("getWZ")))
RET CNF(Int4_getWZ);
 EI(keyStr.equals("setWZ", CPL_STR_HASH("setWZ")))
RET CNF(Int4_setWZ);
 EI(keyStr.equals("getXYZ", CPL_STR_HASH("getXYZ")))
RET CNF(Int4_getXYZ);
 EI(keyStr.equals("setXYZ", CPL_STR_HASH("setXYZ")))
RET CNF(Int4_setXYZ);
 EI(keyStr.equals("getXYW", CPL_STR_HASH("getXYW")))
RET CNF(Int4_getXYW);
 EI(keyStr.equals("setXYW", CPL_STR_HASH("setXYW")))
RET CNF(Int4_setXYW);
 EI(keyStr.equals("getXZY", CPL_STR_HASH("getXZY")))
RET CNF(Int4_getXZY);
 EI(keyStr.equals("setXZY", CPL_STR_HASH("setXZY")))
RET CNF(Int4_setXZY);
 EI(keyStr.equals("getXZW", CPL_STR_HASH("getXZW")))
RET CNF(Int4_getXZW);
 EI(keyStr.equals("setXZW", CPL_STR_HASH("setXZW")))
RET CNF(Int4_setXZW);
 EI(keyStr.equals("getXWZ", CPL_STR_HASH("getXWZ")))
RET CNF(Int4_getXWZ);
 EI(keyStr.equals("setXWZ", CPL_STR_HASH("setXWZ")))
RET CNF(Int4_setXWZ);
 EI(keyStr.equals("getXWY", CPL_STR_HASH("getXWY")))
RET CNF(Int4_getXWY);
 EI(keyStr.equals("setXWY", CPL_STR_HASH("setXWY")))
RET CNF(Int4_setXWY);
 EI(keyStr.equals("getYXZ", CPL_STR_HASH("getYXZ")))
RET CNF(Int4_getYXZ);
 EI(keyStr.equals("setYXZ", CPL_STR_HASH("setYXZ")))
RET CNF(Int4_setYXZ);
 EI(keyStr.equals("getYXW", CPL_STR_HASH("getYXW")))
RET CNF(Int4_getYXW);
 EI(keyStr.equals("setYXW", CPL_STR_HASH("setYXW")))
RET CNF(Int4_setYXW);
 EI(keyStr.equals("getYZX", CPL_STR_HASH("getYZX")))
RET CNF(Int4_getYZX);
 EI(keyStr.equals("setYZX", CPL_STR_HASH("setYZX")))
RET CNF(Int4_setYZX);
 EI(keyStr.equals("getYZW", CPL_STR_HASH("getYZW")))
RET CNF(Int4_getYZW);
 EI(keyStr.equals("setYZW", CPL_STR_HASH("setYZW")))
RET CNF(Int4_setYZW);
 EI(keyStr.equals("getYWZ", CPL_STR_HASH("getYWZ")))
RET CNF(Int4_getYWZ);
 EI(keyStr.equals("setYWZ", CPL_STR_HASH("setYWZ")))
RET CNF(Int4_setYWZ);
 EI(keyStr.equals("getYWX", CPL_STR_HASH("getYWX")))
RET CNF(Int4_getYWX);
 EI(keyStr.equals("setYWX", CPL_STR_HASH("setYWX")))
RET CNF(Int4_setYWX);
 EI(keyStr.equals("getZXY", CPL_STR_HASH("getZXY")))
RET CNF(Int4_getZXY);
 EI(keyStr.equals("setZXY", CPL_STR_HASH("setZXY")))
RET CNF(Int4_setZXY);
 EI(keyStr.equals("getZXW", CPL_STR_HASH("getZXW")))
RET CNF(Int4_getZXW);
 EI(keyStr.equals("setZXW", CPL_STR_HASH("setZXW")))
RET CNF(Int4_setZXW);
 EI(keyStr.equals("getZYX", CPL_STR_HASH("getZYX")))
RET CNF(Int4_getZYX);
 EI(keyStr.equals("setZYX", CPL_STR_HASH("setZYX")))
RET CNF(Int4_setZYX);
 EI(keyStr.equals("getZYW", CPL_STR_HASH("getZYW")))
RET CNF(Int4_getZYW);
 EI(keyStr.equals("setZYW", CPL_STR_HASH("setZYW")))
RET CNF(Int4_setZYW);
 EI(keyStr.equals("getZWY", CPL_STR_HASH("getZWY")))
RET CNF(Int4_getZWY);
 EI(keyStr.equals("setZWY", CPL_STR_HASH("setZWY")))
RET CNF(Int4_setZWY);
 EI(keyStr.equals("getZWX", CPL_STR_HASH("getZWX")))
RET CNF(Int4_getZWX);
 EI(keyStr.equals("setZWX", CPL_STR_HASH("setZWX")))
RET CNF(Int4_setZWX);
 EI(keyStr.equals("getWXY", CPL_STR_HASH("getWXY")))
RET CNF(Int4_getWXY);
 EI(keyStr.equals("setWXY", CPL_STR_HASH("setWXY")))
RET CNF(Int4_setWXY);
 EI(keyStr.equals("getWXZ", CPL_STR_HASH("getWXZ")))
RET CNF(Int4_getWXZ);
 EI(keyStr.equals("setWXZ", CPL_STR_HASH("setWXZ")))
RET CNF(Int4_setWXZ);
 EI(keyStr.equals("getWYX", CPL_STR_HASH("getWYX")))
RET CNF(Int4_getWYX);
 EI(keyStr.equals("setWYX", CPL_STR_HASH("setWYX")))
RET CNF(Int4_setWYX);
 EI(keyStr.equals("getWYZ", CPL_STR_HASH("getWYZ")))
RET CNF(Int4_getWYZ);
 EI(keyStr.equals("setWYZ", CPL_STR_HASH("setWYZ")))
RET CNF(Int4_setWYZ);
 EI(keyStr.equals("getWZY", CPL_STR_HASH("getWZY")))
RET CNF(Int4_getWZY);
 EI(keyStr.equals("setWZY", CPL_STR_HASH("setWZY")))
RET CNF(Int4_setWZY);
 EI(keyStr.equals("getWZX", CPL_STR_HASH("getWZX")))
RET CNF(Int4_getWZX);
 EI(keyStr.equals("setWZX", CPL_STR_HASH("setWZX")))
RET CNF(Int4_setWZX);
 EI(keyStr.equals("getXYZW", CPL_STR_HASH("getXYZW")))
RET CNF(Int4_getXYZW);
 EI(keyStr.equals("setXYZW", CPL_STR_HASH("setXYZW")))
RET CNF(Int4_setXYZW);
 EI(keyStr.equals("getXYWZ", CPL_STR_HASH("getXYWZ")))
RET CNF(Int4_getXYWZ);
 EI(keyStr.equals("setXYWZ", CPL_STR_HASH("setXYWZ")))
RET CNF(Int4_setXYWZ);
 EI(keyStr.equals("getXZYW", CPL_STR_HASH("getXZYW")))
RET CNF(Int4_getXZYW);
 EI(keyStr.equals("setXZYW", CPL_STR_HASH("setXZYW")))
RET CNF(Int4_setXZYW);
 EI(keyStr.equals("getXZWY", CPL_STR_HASH("getXZWY")))
RET CNF(Int4_getXZWY);
 EI(keyStr.equals("setXZWY", CPL_STR_HASH("setXZWY")))
RET CNF(Int4_setXZWY);
 EI(keyStr.equals("getXWZY", CPL_STR_HASH("getXWZY")))
RET CNF(Int4_getXWZY);
 EI(keyStr.equals("setXWZY", CPL_STR_HASH("setXWZY")))
RET CNF(Int4_setXWZY);
 EI(keyStr.equals("getXWYZ", CPL_STR_HASH("getXWYZ")))
RET CNF(Int4_getXWYZ);
 EI(keyStr.equals("setXWYZ", CPL_STR_HASH("setXWYZ")))
RET CNF(Int4_setXWYZ);
 EI(keyStr.equals("getYXZW", CPL_STR_HASH("getYXZW")))
RET CNF(Int4_getYXZW);
 EI(keyStr.equals("setYXZW", CPL_STR_HASH("setYXZW")))
RET CNF(Int4_setYXZW);
 EI(keyStr.equals("getYXWZ", CPL_STR_HASH("getYXWZ")))
RET CNF(Int4_getYXWZ);
 EI(keyStr.equals("setYXWZ", CPL_STR_HASH("setYXWZ")))
RET CNF(Int4_setYXWZ);
 EI(keyStr.equals("getYZXW", CPL_STR_HASH("getYZXW")))
RET CNF(Int4_getYZXW);
 EI(keyStr.equals("setYZXW", CPL_STR_HASH("setYZXW")))
RET CNF(Int4_setYZXW);
 EI(keyStr.equals("getYZWX", CPL_STR_HASH("getYZWX")))
RET CNF(Int4_getYZWX);
 EI(keyStr.equals("setYZWX", CPL_STR_HASH("setYZWX")))
RET CNF(Int4_setYZWX);
 EI(keyStr.equals("getYWZX", CPL_STR_HASH("getYWZX")))
RET CNF(Int4_getYWZX);
 EI(keyStr.equals("setYWZX", CPL_STR_HASH("setYWZX")))
RET CNF(Int4_setYWZX);
 EI(keyStr.equals("getYWXZ", CPL_STR_HASH("getYWXZ")))
RET CNF(Int4_getYWXZ);
 EI(keyStr.equals("setYWXZ", CPL_STR_HASH("setYWXZ")))
RET CNF(Int4_setYWXZ);
 EI(keyStr.equals("getZYXW", CPL_STR_HASH("getZYXW")))
RET CNF(Int4_getZYXW);
 EI(keyStr.equals("setZYXW", CPL_STR_HASH("setZYXW")))
RET CNF(Int4_setZYXW);
 EI(keyStr.equals("getZYWX", CPL_STR_HASH("getZYWX")))
RET CNF(Int4_getZYWX);
 EI(keyStr.equals("setZYWX", CPL_STR_HASH("setZYWX")))
RET CNF(Int4_setZYWX);
 EI(keyStr.equals("getZXYW", CPL_STR_HASH("getZXYW")))
RET CNF(Int4_getZXYW);
 EI(keyStr.equals("setZXYW", CPL_STR_HASH("setZXYW")))
RET CNF(Int4_setZXYW);
 EI(keyStr.equals("getZXWY", CPL_STR_HASH("getZXWY")))
RET CNF(Int4_getZXWY);
 EI(keyStr.equals("setZXWY", CPL_STR_HASH("setZXWY")))
RET CNF(Int4_setZXWY);
 EI(keyStr.equals("getZWXY", CPL_STR_HASH("getZWXY")))
RET CNF(Int4_getZWXY);
 EI(keyStr.equals("setZWXY", CPL_STR_HASH("setZWXY")))
RET CNF(Int4_setZWXY);
 EI(keyStr.equals("getZWYX", CPL_STR_HASH("getZWYX")))
RET CNF(Int4_getZWYX);
 EI(keyStr.equals("setZWYX", CPL_STR_HASH("setZWYX")))
RET CNF(Int4_setZWYX);
 EI(keyStr.equals("getWYZX", CPL_STR_HASH("getWYZX")))
RET CNF(Int4_getWYZX);
 EI(keyStr.equals("setWYZX", CPL_STR_HASH("setWYZX")))
RET CNF(Int4_setWYZX);
 EI(keyStr.equals("getWYXZ", CPL_STR_HASH("getWYXZ")))
RET CNF(Int4_getWYXZ);
 EI(keyStr.equals("setWYXZ", CPL_STR_HASH("setWYXZ")))
RET CNF(Int4_setWYXZ);
 EI(keyStr.equals("getWZYX", CPL_STR_HASH("getWZYX")))
RET CNF(Int4_getWZYX);
 EI(keyStr.equals("setWZYX", CPL_STR_HASH("setWZYX")))
RET CNF(Int4_setWZYX);
 EI(keyStr.equals("getWZXY", CPL_STR_HASH("getWZXY")))
RET CNF(Int4_getWZXY);
 EI(keyStr.equals("setWZXY", CPL_STR_HASH("setWZXY")))
RET CNF(Int4_setWZXY);
 EI(keyStr.equals("getWXZY", CPL_STR_HASH("getWXZY")))
RET CNF(Int4_getWXZY);
 EI(keyStr.equals("setWXZY", CPL_STR_HASH("setWXZY")))
RET CNF(Int4_setWXZY);
 EI(keyStr.equals("getWXYZ", CPL_STR_HASH("getWXYZ")))
RET CNF(Int4_getWXYZ);
 EI(keyStr.equals("setWXYZ", CPL_STR_HASH("setWXYZ")))
RET CNF(Int4_setWXYZ);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(Int4_copy);
 EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T4<int32_t>*obj=(T4<int32_t>*)f->data;
RET CV(obj->x);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T4<int32_t>*obj=(T4<int32_t>*)f->data;
RET CV(obj->y);
} EI(keyStr.equals("z", CPL_STR_HASH("z")))
{
T4<int32_t>*obj=(T4<int32_t>*)f->data;
RET CV(obj->z);
} EI(keyStr.equals("w", CPL_STR_HASH("w")))
{
T4<int32_t>*obj=(T4<int32_t>*)f->data;
RET CV(obj->w);
} else
 CATE(KE,"Unknown member for Int4."));
}
}
RET CN;
}

void Int4_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T4<int32_t>*obj=(T4<int32_t>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T4<int32_t>*obj=(T4<int32_t>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} EI(keyStr.equals("z", CPL_STR_HASH("z")))
{
T4<int32_t>*obj=(T4<int32_t>*)f->data;
obj->z=val_to_c<decltype(obj->z)>::f(ctx,value);
} EI(keyStr.equals("w", CPL_STR_HASH("w")))
{
T4<int32_t>*obj=(T4<int32_t>*)f->data;
obj->w=val_to_c<decltype(obj->w)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for Int4."));
}
}
}

SV Int4_setZXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZXYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setZXYW(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZXYW.")));
RET CN;
}

SV Int4_setWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setWYZ(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWYZ.")));
RET CN;
}

SV Int4_setWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setWYX(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWYX.")));
RET CN;
}

SV Int4_getZWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZWYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWYX());
;
}
CATE(TE,UFOF("Int4::getZWYX.")));
RET CN;
}

SV Int4_getZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZW());
;
}
CATE(TE,UFOF("Int4::getZW.")));
RET CN;
}

SV Int4_getZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZY());
;
}
CATE(TE,UFOF("Int4::getZY.")));
RET CN;
}

SV Int4_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::distanceSquared" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Int4::distanceSquared.")));
RET CN;
}

SV Int4_getYXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYXZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZW());
;
}
CATE(TE,UFOF("Int4::getYXZW.")));
RET CN;
}

SV Int4_setYZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYZWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setYZWX(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYZWX.")));
RET CN;
}

SV Int4_getYWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYWZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWZX());
;
}
CATE(TE,UFOF("Int4::getYWZX.")));
RET CN;
}

SV Int4_getWZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWZXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZXY());
;
}
CATE(TE,UFOF("Int4::getWZXY.")));
RET CN;
}

SV Int4_getZYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZYXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYXW());
;
}
CATE(TE,UFOF("Int4::getZYXW.")));
RET CN;
}

SV Int4_setXWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXWYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setXWYZ(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXWYZ.")));
RET CN;
}

SV Int4_setZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setZY(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZY.")));
RET CN;
}

SV Int4_setZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setZX(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZX.")));
RET CN;
}

SV Int4_getZXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZXWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXWY());
;
}
CATE(TE,UFOF("Int4::getZXWY.")));
RET CN;
}

SV Int4_getXWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXWZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWZY());
;
}
CATE(TE,UFOF("Int4::getXWZY.")));
RET CN;
}

SV Int4_setZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setZW(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZW.")));
RET CN;
}

SV Int4_setZYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZYWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setZYWX(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZYWX.")));
RET CN;
}

SV Int4_getYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZX());
;
}
CATE(TE,UFOF("Int4::getYZX.")));
RET CN;
}

SV Int4_getXYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXYWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYWZ());
;
}
CATE(TE,UFOF("Int4::getXYWZ.")));
RET CN;
}

SV Int4_setYXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYXZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setYXZW(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYXZW.")));
RET CN;
}

SV Int4_getWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZY());
;
}
CATE(TE,UFOF("Int4::getWZY.")));
RET CN;
}

SV Int4_getWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZX());
;
}
CATE(TE,UFOF("Int4::getWZX.")));
RET CN;
}

SV Int4_getWZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWZYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZYX());
;
}
CATE(TE,UFOF("Int4::getWZYX.")));
RET CN;
}

SV Int4_setXWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXWZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setXWZY(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXWZY.")));
RET CN;
}

SV Int4_getZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXY());
;
}
CATE(TE,UFOF("Int4::getZXY.")));
RET CN;
}

SV Int4_setWZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWZYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setWZYX(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWZYX.")));
RET CN;
}

SV Int4_setZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setZYW(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZYW.")));
RET CN;
}

SV Int4_setZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setZYX(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZYX.")));
RET CN;
}

SV Int4_setXZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXZYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setXZYW(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXZYW.")));
RET CN;
}

SV Int4_getZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXW());
;
}
CATE(TE,UFOF("Int4::getZXW.")));
RET CN;
}

SV Int4_setYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setYZW(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYZW.")));
RET CN;
}

SV Int4_getYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWZ());
;
}
CATE(TE,UFOF("Int4::getYWZ.")));
RET CN;
}

SV Int4___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__leq__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("Int4::__leq__.")));
RET CN;
}

SV Int4_getYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWX());
;
}
CATE(TE,UFOF("Int4::getYWX.")));
RET CN;
}

SV Int4_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::sum" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("Int4::sum.")));
RET CN;
}

SV Int4_setYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setYZX(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYZX.")));
RET CN;
}

SV Int4_getXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZ());
;
}
CATE(TE,UFOF("Int4::getXYZ.")));
RET CN;
}

SV Int4_getZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZX());
;
}
CATE(TE,UFOF("Int4::getZX.")));
RET CN;
}

SV Int4_getXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYW());
;
}
CATE(TE,UFOF("Int4::getXYW.")));
RET CN;
}

SV Int4_setYWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYWZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setYWZX(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYWZX.")));
RET CN;
}

SV Int4_setWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setWXY(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWXY.")));
RET CN;
}

SV Int4_setWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setWXZ(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWXZ.")));
RET CN;
}

SV Int4_setZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setZXW(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZXW.")));
RET CN;
}

SV Int4_getXWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXWYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWYZ());
;
}
CATE(TE,UFOF("Int4::getXWYZ.")));
RET CN;
}

SV Int4_setWYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWYXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setWYXZ(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWYXZ.")));
RET CN;
}

SV Int4_setZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setZXY(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZXY.")));
RET CN;
}

SV Int4_getXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWY());
;
}
CATE(TE,UFOF("Int4::getXWY.")));
RET CN;
}

SV Int4_getYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXW());
;
}
CATE(TE,UFOF("Int4::getYXW.")));
RET CN;
}

SV Int4_getYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZ());
;
}
CATE(TE,UFOF("Int4::getYXZ.")));
RET CN;
}

SV Int4_setXYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXYWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setXYWZ(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXYWZ.")));
RET CN;
}

SV Int4_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::length" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("Int4::length.")));
RET CN;
}

SV Int4_setWXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWXZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setWXZY(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWXZY.")));
RET CN;
}

SV Int4_getYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZW());
;
}
CATE(TE,UFOF("Int4::getYZW.")));
RET CN;
}

SV Int4_setXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setXWZ(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXWZ.")));
RET CN;
}

SV Int4_setXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setXWY(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXWY.")));
RET CN;
}

SV Int4_getWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYZ());
;
}
CATE(TE,UFOF("Int4::getWYZ.")));
RET CN;
}

SV Int4_getWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYX());
;
}
CATE(TE,UFOF("Int4::getWYX.")));
RET CN;
}

SV Int4_getZYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZYWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYWX());
;
}
CATE(TE,UFOF("Int4::getZYWX.")));
RET CN;
}

SV Int4_getXYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXYZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZW());
;
}
CATE(TE,UFOF("Int4::getXYZW.")));
RET CN;
}

SV Int4_setZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setZWY(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZWY.")));
RET CN;
}

SV Int4_setZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setZWX(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZWX.")));
RET CN;
}

SV Int4_setWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setWX(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWX.")));
RET CN;
}

SV Int4_setWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setWY(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWY.")));
RET CN;
}

SV Int4_setWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setWZ(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWZ.")));
RET CN;
}

SV Int4_getZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWY());
;
}
CATE(TE,UFOF("Int4::getZWY.")));
RET CN;
}

SV Int4_getZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWX());
;
}
CATE(TE,UFOF("Int4::getZWX.")));
RET CN;
}

SV Int4_setYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setYXZ(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYXZ.")));
RET CN;
}

SV Int4_setYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setYXW(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYXW.")));
RET CN;
}

SV Int4_getXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWZ());
;
}
CATE(TE,UFOF("Int4::getXWZ.")));
RET CN;
}

SV Int4_getXZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXZWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZWY());
;
}
CATE(TE,UFOF("Int4::getXZWY.")));
RET CN;
}

SV Int4___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__less__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("Int4::__less__.")));
RET CN;
}

SV Int4_getZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYW());
;
}
CATE(TE,UFOF("Int4::getZYW.")));
RET CN;
}

SV Int4_setWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setWZY(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWZY.")));
RET CN;
}

SV Int4_setWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setWZX(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWZX.")));
RET CN;
}

SV Int4_setZYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZYXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setZYXW(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZYXW.")));
RET CN;
}

SV Int4_getYZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYZWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZWX());
;
}
CATE(TE,UFOF("Int4::getYZWX.")));
RET CN;
}

SV Int4_getZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYX());
;
}
CATE(TE,UFOF("Int4::getZYX.")));
RET CN;
}

SV Int4_getXZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXZYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZYW());
;
}
CATE(TE,UFOF("Int4::getXZYW.")));
RET CN;
}

SV Int4_setYXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYXWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setYXWZ(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYXWZ.")));
RET CN;
}

SV Int4_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::copy" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("Int4::copy.")));
RET CN;
}

SV Int4___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__eq__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Int4::__eq__.")));
RET CN;
}

SV Int4_getWYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWYXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYXZ());
;
}
CATE(TE,UFOF("Int4::getWYXZ.")));
RET CN;
}

SV Int4_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::distance" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Int4::distance.")));
RET CN;
}

SV Int4_getXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZW());
;
}
CATE(TE,UFOF("Int4::getXZW.")));
RET CN;
}

SV Int4_setYZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYZXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setYZXW(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYZXW.")));
RET CN;
}

SV Int4_getZWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZWXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWXY());
;
}
CATE(TE,UFOF("Int4::getZWXY.")));
RET CN;
}

SV Int4_getXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZY());
;
}
CATE(TE,UFOF("Int4::getXZY.")));
RET CN;
}

SV Int4_getYZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYZXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZXW());
;
}
CATE(TE,UFOF("Int4::getYZXW.")));
RET CN;
}

SV Int4_setZWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZWYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setZWYX(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZWYX.")));
RET CN;
}

SV Int4___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__sub__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("Int4::__sub__.")));
RET CN;
}

SV Int4_getYXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYXWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXWZ());
;
}
CATE(TE,UFOF("Int4::getYXWZ.")));
RET CN;
}

SV Int4_setXZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXZWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setXZWY(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXZWY.")));
RET CN;
}

SV Int4_setYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setYWZ(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYWZ.")));
RET CN;
}

SV Int4_setYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setYWX(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYWX.")));
RET CN;
}

SV Int4_setYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setYZ(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYZ.")));
RET CN;
}

SV Int4_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYX.")));
RET CN;
}

SV Int4_setYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setYW(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYW.")));
RET CN;
}

SV Int4_getWXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWXYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXYZ());
;
}
CATE(TE,UFOF("Int4::getWXYZ.")));
RET CN;
}

SV Int4___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__neq__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("Int4::__neq__.")));
RET CN;
}

SV Int4_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::normalize" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("Int4::normalize.")));
RET CN;
}

SV Int4_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("Int4::getYX.")));
RET CN;
}

SV Int4_setXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setXZW(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXZW.")));
RET CN;
}

SV Int4_setXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setXZY(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXZY.")));
RET CN;
}

SV Int4_setXYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXYZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setXYZW(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXYZW.")));
RET CN;
}

SV Int4_getYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYW());
;
}
CATE(TE,UFOF("Int4::getYW.")));
RET CN;
}

SV Int4_setWXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWXYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setWXYZ(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWXYZ.")));
RET CN;
}

SV Int4_getYWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYWXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWXZ());
;
}
CATE(TE,UFOF("Int4::getYWXZ.")));
RET CN;
}

SV Int4___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__mul__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Int4::__mul__.")));
RET CN;
}

SV Int4_getYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZ());
;
}
CATE(TE,UFOF("Int4::getYZ.")));
RET CN;
}

SV Int4_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::lengthSquared" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("Int4::lengthSquared.")));
RET CN;
}

SV Int4_getWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXY());
;
}
CATE(TE,UFOF("Int4::getWXY.")));
RET CN;
}

SV Int4_getWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXZ());
;
}
CATE(TE,UFOF("Int4::getWXZ.")));
RET CN;
}

SV Int4_getWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWX());
;
}
CATE(TE,UFOF("Int4::getWX.")));
RET CN;
}

SV Int4_getWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWY());
;
}
CATE(TE,UFOF("Int4::getWY.")));
RET CN;
}

SV Int4_getWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZ());
;
}
CATE(TE,UFOF("Int4::getWZ.")));
RET CN;
}

SV Int4_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXY.")));
RET CN;
}

SV Int4_getZXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZXYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXYW());
;
}
CATE(TE,UFOF("Int4::getZXYW.")));
RET CN;
}

SV Int4___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__add__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("Int4::__add__.")));
RET CN;
}

SV Int4_setXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setXZ(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXZ.")));
RET CN;
}

SV Int4_getWYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWYZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYZX());
;
}
CATE(TE,UFOF("Int4::getWYZX.")));
RET CN;
}

SV Int4_setXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setXW(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXW.")));
RET CN;
}

SV Int4_getWXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWXZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXZY());
;
}
CATE(TE,UFOF("Int4::getWXZY.")));
RET CN;
}

SV Int4_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("Int4::getXY.")));
RET CN;
}

SV Int4_setZXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZXWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setZXWY(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZXWY.")));
RET CN;
}

SV Int4_setXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setXYW(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXYW.")));
RET CN;
}

SV Int4_getXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZ());
;
}
CATE(TE,UFOF("Int4::getXZ.")));
RET CN;
}

SV Int4_setWZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWZXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setWZXY(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWZXY.")));
RET CN;
}

SV Int4___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__grtr__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("Int4::__grtr__.")));
RET CN;
}

SV Int4_setZWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZWXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setZWXY(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZWXY.")));
RET CN;
}

SV Int4_getXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXW());
;
}
CATE(TE,UFOF("Int4::getXW.")));
RET CN;
}

SV Int4_setXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setXYZ(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXYZ.")));
RET CN;
}

SV Int4___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__div__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("Int4::__div__.")));
RET CN;
}

SV Int4_setWYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWYZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setWYZX(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWYZX.")));
RET CN;
}

SV Int4_setYWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYWXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setYWXZ(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYWXZ.")));
RET CN;
}

SV Int4___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__geq__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("Int4::__geq__.")));
RET CN;
}

SV Int4_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::dot" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("Int4::dot.")));
RET CN;
}

void ScrollBar_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,ScrollBar))
CATE(TE,"ScrollBar::__del__ expects ScrollBar as first argument."));

SCRIPT_DELETE((ScrollBar*)f->data);
}SV ScrollBar_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScrollBar's constructor" EAOE));
if(!TS(a[0],ScrollBar))
CATE(TE,"ScrollBar's constructor expects ScrollBar as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(ScrollBar));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(ScrollBar_funcs,p,EXT->ScrollBar_typeID);
}CATE(TE,UFOF("ScrollBar's constructor.")));
RET CN;
}

SV ScrollBar_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("ScrollBar");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(ScrollBar_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(ScrollBar_new);
else
 CATE(KE,"Unknown member for ScrollBar."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(ScrollBar_new);
 EI(keyStr.equals("getValue", CPL_STR_HASH("getValue")))
RET CNF(ScrollBar_getValue);
 EI(keyStr.equals("setValue", CPL_STR_HASH("setValue")))
RET CNF(ScrollBar_setValue);
 EI(keyStr.equals("center", CPL_STR_HASH("center")))
{
ScrollBar*obj=(ScrollBar*)f->data;
RET CV(obj->center);
} EI(keyStr.equals("barSize", CPL_STR_HASH("barSize")))
{
ScrollBar*obj=(ScrollBar*)f->data;
RET CV(obj->barSize);
} else
 CATE(KE,"Unknown member for ScrollBar."));
}
}
RET CN;
}

void ScrollBar_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("center", CPL_STR_HASH("center")))
{
ScrollBar*obj=(ScrollBar*)f->data;
obj->center=val_to_c<decltype(obj->center)>::f(ctx,value);
} EI(keyStr.equals("barSize", CPL_STR_HASH("barSize")))
{
ScrollBar*obj=(ScrollBar*)f->data;
obj->barSize=val_to_c<decltype(obj->barSize)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for ScrollBar."));
}
}
}

SV ScrollBar_setValue(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScrollBar::setValue" EAOE));
ScrollBar*f;
f=(ScrollBar*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setValue(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("ScrollBar::setValue.")));
RET CN;
}

SV ScrollBar_getValue(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScrollBar::getValue" EAOE));
ScrollBar*f;
f=(ScrollBar*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getValue());
;
}
CATE(TE,UFOF("ScrollBar::getValue.")));
RET CN;
}

void Int3_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,T3<int32_t>))
CATE(TE,"Int3::__del__ expects Int3 as first argument."));

SCRIPT_DELETE((T3<int32_t>*)f->data);
}SV Int3_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3's constructor" EAOE));
if(!TS(a[0],T3<int32_t>))
CATE(TE,"Int3's constructor expects Int3 as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(T3<int32_t>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int3_funcs,p,EXT->Int3_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],int32_t)){
void *p = (void *)NEW(TYPE(T3<int32_t>),val_to_c<int32_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int3_funcs,p,EXT->Int3_typeID);
}if(a.getCount()==4)
if(true&&TS(a[1],int32_t)&&TS(a[2],int32_t)&&TS(a[3],int32_t)){
void *p = (void *)NEW(TYPE(T3<int32_t>),val_to_c<int32_t>::f(ctx,a[1]),val_to_c<int32_t>::f(ctx,a[2]),val_to_c<int32_t>::f(ctx,a[3]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int3_funcs,p,EXT->Int3_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T3<float> &)){
void *p = (void *)NEW(TYPE(T3<int32_t>),val_to_c<const T3<float> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int3_funcs,p,EXT->Int3_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T3<int32_t> &)){
void *p = (void *)NEW(TYPE(T3<int32_t>),val_to_c<const T3<int32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int3_funcs,p,EXT->Int3_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T3<uint32_t> &)){
void *p = (void *)NEW(TYPE(T3<int32_t>),val_to_c<const T3<uint32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int3_funcs,p,EXT->Int3_typeID);
}CATE(TE,UFOF("Int3's constructor.")));
RET CN;
}

SV Int3_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Int3");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Int3_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Int3_new);
else
 CATE(KE,"Unknown member for Int3."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Int3_new);
 EI(keyStr.equals("__add__", CPL_STR_HASH("__add__")))
RET CNF(Int3___add__);
 EI(keyStr.equals("__sub__", CPL_STR_HASH("__sub__")))
RET CNF(Int3___sub__);
 EI(keyStr.equals("__mul__", CPL_STR_HASH("__mul__")))
RET CNF(Int3___mul__);
 EI(keyStr.equals("__div__", CPL_STR_HASH("__div__")))
RET CNF(Int3___div__);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(Int3___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(Int3___neq__);
 EI(keyStr.equals("__less__", CPL_STR_HASH("__less__")))
RET CNF(Int3___less__);
 EI(keyStr.equals("__grtr__", CPL_STR_HASH("__grtr__")))
RET CNF(Int3___grtr__);
 EI(keyStr.equals("__leq__", CPL_STR_HASH("__leq__")))
RET CNF(Int3___leq__);
 EI(keyStr.equals("__geq__", CPL_STR_HASH("__geq__")))
RET CNF(Int3___geq__);
 EI(keyStr.equals("sum", CPL_STR_HASH("sum")))
RET CNF(Int3_sum);
 EI(keyStr.equals("length", CPL_STR_HASH("length")))
RET CNF(Int3_length);
 EI(keyStr.equals("lengthSquared", CPL_STR_HASH("lengthSquared")))
RET CNF(Int3_lengthSquared);
 EI(keyStr.equals("dot", CPL_STR_HASH("dot")))
RET CNF(Int3_dot);
 EI(keyStr.equals("distance", CPL_STR_HASH("distance")))
RET CNF(Int3_distance);
 EI(keyStr.equals("distanceSquared", CPL_STR_HASH("distanceSquared")))
RET CNF(Int3_distanceSquared);
 EI(keyStr.equals("normalize", CPL_STR_HASH("normalize")))
RET CNF(Int3_normalize);
 EI(keyStr.equals("cross", CPL_STR_HASH("cross")))
RET CNF(Int3_cross);
 EI(keyStr.equals("getXY", CPL_STR_HASH("getXY")))
RET CNF(Int3_getXY);
 EI(keyStr.equals("setXY", CPL_STR_HASH("setXY")))
RET CNF(Int3_setXY);
 EI(keyStr.equals("getXZ", CPL_STR_HASH("getXZ")))
RET CNF(Int3_getXZ);
 EI(keyStr.equals("setXZ", CPL_STR_HASH("setXZ")))
RET CNF(Int3_setXZ);
 EI(keyStr.equals("getYX", CPL_STR_HASH("getYX")))
RET CNF(Int3_getYX);
 EI(keyStr.equals("setYX", CPL_STR_HASH("setYX")))
RET CNF(Int3_setYX);
 EI(keyStr.equals("getYZ", CPL_STR_HASH("getYZ")))
RET CNF(Int3_getYZ);
 EI(keyStr.equals("setYZ", CPL_STR_HASH("setYZ")))
RET CNF(Int3_setYZ);
 EI(keyStr.equals("getZX", CPL_STR_HASH("getZX")))
RET CNF(Int3_getZX);
 EI(keyStr.equals("setZX", CPL_STR_HASH("setZX")))
RET CNF(Int3_setZX);
 EI(keyStr.equals("getZY", CPL_STR_HASH("getZY")))
RET CNF(Int3_getZY);
 EI(keyStr.equals("setZY", CPL_STR_HASH("setZY")))
RET CNF(Int3_setZY);
 EI(keyStr.equals("getXYZ", CPL_STR_HASH("getXYZ")))
RET CNF(Int3_getXYZ);
 EI(keyStr.equals("setXYZ", CPL_STR_HASH("setXYZ")))
RET CNF(Int3_setXYZ);
 EI(keyStr.equals("getXZY", CPL_STR_HASH("getXZY")))
RET CNF(Int3_getXZY);
 EI(keyStr.equals("setXZY", CPL_STR_HASH("setXZY")))
RET CNF(Int3_setXZY);
 EI(keyStr.equals("getYXZ", CPL_STR_HASH("getYXZ")))
RET CNF(Int3_getYXZ);
 EI(keyStr.equals("setYXZ", CPL_STR_HASH("setYXZ")))
RET CNF(Int3_setYXZ);
 EI(keyStr.equals("getYZX", CPL_STR_HASH("getYZX")))
RET CNF(Int3_getYZX);
 EI(keyStr.equals("setYZX", CPL_STR_HASH("setYZX")))
RET CNF(Int3_setYZX);
 EI(keyStr.equals("getZXY", CPL_STR_HASH("getZXY")))
RET CNF(Int3_getZXY);
 EI(keyStr.equals("setZXY", CPL_STR_HASH("setZXY")))
RET CNF(Int3_setZXY);
 EI(keyStr.equals("getZYX", CPL_STR_HASH("getZYX")))
RET CNF(Int3_getZYX);
 EI(keyStr.equals("setZYX", CPL_STR_HASH("setZYX")))
RET CNF(Int3_setZYX);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(Int3_copy);
 EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T3<int32_t>*obj=(T3<int32_t>*)f->data;
RET CV(obj->x);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T3<int32_t>*obj=(T3<int32_t>*)f->data;
RET CV(obj->y);
} EI(keyStr.equals("z", CPL_STR_HASH("z")))
{
T3<int32_t>*obj=(T3<int32_t>*)f->data;
RET CV(obj->z);
} else
 CATE(KE,"Unknown member for Int3."));
}
}
RET CN;
}

void Int3_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T3<int32_t>*obj=(T3<int32_t>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T3<int32_t>*obj=(T3<int32_t>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} EI(keyStr.equals("z", CPL_STR_HASH("z")))
{
T3<int32_t>*obj=(T3<int32_t>*)f->data;
obj->z=val_to_c<decltype(obj->z)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for Int3."));
}
}
}

SV Int3_setYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setYZX" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setYZX(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setYZX.")));
RET CN;
}

SV Int3_getZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getZXY" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXY());
;
}
CATE(TE,UFOF("Int3::getZXY.")));
RET CN;
}

SV Int3_setYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setYZ" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setYZ(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setYZ.")));
RET CN;
}

SV Int3_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setYX" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setYX.")));
RET CN;
}

SV Int3_setZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setZYX" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setZYX(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setZYX.")));
RET CN;
}

SV Int3_getZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getZY" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZY());
;
}
CATE(TE,UFOF("Int3::getZY.")));
RET CN;
}

SV Int3_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::distanceSquared" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Int3::distanceSquared.")));
RET CN;
}

SV Int3_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::normalize" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("Int3::normalize.")));
RET CN;
}

SV Int3_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getYX" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("Int3::getYX.")));
RET CN;
}

SV Int3___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__leq__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("Int3::__leq__.")));
RET CN;
}

SV Int3_setXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setXZY" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setXZY(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setXZY.")));
RET CN;
}

SV Int3_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::sum" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("Int3::sum.")));
RET CN;
}

SV Int3_cross(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::cross" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
RET CV( f->cross(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Int3::cross.")));
RET CN;
}

SV Int3_getXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getXYZ" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZ());
;
}
CATE(TE,UFOF("Int3::getXYZ.")));
RET CN;
}

SV Int3___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__less__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("Int3::__less__.")));
RET CN;
}

SV Int3___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__neq__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("Int3::__neq__.")));
RET CN;
}

SV Int3_getYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getYZ" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZ());
;
}
CATE(TE,UFOF("Int3::getYZ.")));
RET CN;
}

SV Int3_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::lengthSquared" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("Int3::lengthSquared.")));
RET CN;
}

SV Int3_getZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getZYX" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYX());
;
}
CATE(TE,UFOF("Int3::getZYX.")));
RET CN;
}

SV Int3___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__div__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("Int3::__div__.")));
RET CN;
}

SV Int3_setZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setZY" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setZY(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setZY.")));
RET CN;
}

SV Int3_setZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setZX" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setZX(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setZX.")));
RET CN;
}

SV Int3_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setXY" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setXY.")));
RET CN;
}

SV Int3___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__add__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("Int3::__add__.")));
RET CN;
}

SV Int3_setXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setXZ" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setXZ(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setXZ.")));
RET CN;
}

SV Int3_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::copy" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("Int3::copy.")));
RET CN;
}

SV Int3___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__eq__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Int3::__eq__.")));
RET CN;
}

SV Int3_setZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setZXY" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setZXY(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setZXY.")));
RET CN;
}

SV Int3_setYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setYXZ" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setYXZ(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setYXZ.")));
RET CN;
}

SV Int3_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getXY" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("Int3::getXY.")));
RET CN;
}

SV Int3_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::distance" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Int3::distance.")));
RET CN;
}

SV Int3_getXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getXZ" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZ());
;
}
CATE(TE,UFOF("Int3::getXZ.")));
RET CN;
}

SV Int3___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__grtr__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("Int3::__grtr__.")));
RET CN;
}

SV Int3_getXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getXZY" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZY());
;
}
CATE(TE,UFOF("Int3::getXZY.")));
RET CN;
}

SV Int3_setXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setXYZ" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setXYZ(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setXYZ.")));
RET CN;
}

SV Int3_getYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getYZX" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZX());
;
}
CATE(TE,UFOF("Int3::getYZX.")));
RET CN;
}

SV Int3_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::length" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("Int3::length.")));
RET CN;
}

SV Int3___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__mul__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Int3::__mul__.")));
RET CN;
}

SV Int3_getYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getYXZ" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZ());
;
}
CATE(TE,UFOF("Int3::getYXZ.")));
RET CN;
}

SV Int3_getZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getZX" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZX());
;
}
CATE(TE,UFOF("Int3::getZX.")));
RET CN;
}

SV Int3___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__sub__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("Int3::__sub__.")));
RET CN;
}

SV Int3___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__geq__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("Int3::__geq__.")));
RET CN;
}

SV Int3_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::dot" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("Int3::dot.")));
RET CN;
}

void ScriptInstance_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,ScriptInstance))
CATE(TE,"ScriptInstance::__del__ expects ScriptInstance as first argument."));

SCRIPT_DELETE((ScriptInstance*)f->data);
}SV ScriptInstance_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"ScriptInstance's constructor" EAOE));
if(!TS(a[0],ScriptInstance))
CATE(TE,"ScriptInstance's constructor expects ScriptInstance as first argument."));
CATE(TE,UFOF("ScriptInstance's constructor.")));
}

SV ScriptInstance_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("ScriptInstance");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(ScriptInstance_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(ScriptInstance_new);
else
 CATE(KE,"Unknown member for ScriptInstance."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(ScriptInstance_new);
 EI(keyStr.equals("method", CPL_STR_HASH("method")))
RET CNF(ScriptInstance_method);
 EI(keyStr.equals("getScript", CPL_STR_HASH("getScript")))
RET CNF(ScriptInstance_getScript);
 EI(keyStr.equals("getObj", CPL_STR_HASH("getObj")))
RET CNF(ScriptInstance_getObj);
 else
 CATE(KE,"Unknown member for ScriptInstance."));
}
}
RET CN;
}

void ScriptInstance_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for ScriptInstance."));
}
}
}

SV ScriptInstance_getScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstance::getScript" EAOE));
ScriptInstance*f;
f=(ScriptInstance*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScript());
;
}
CATE(TE,UFOF("ScriptInstance::getScript.")));
RET CN;
}

SV ScriptInstance_method(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstance::method" EAOE));
ScriptInstance*f;
f=(ScriptInstance*)((NO)a[0].p)->data;

CATE(TE,UFOF("ScriptInstance::method.")));
RET CN;
}

SV ScriptInstance_getObj(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstance::getObj" EAOE));
ScriptInstance*f;
f=(ScriptInstance*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getObj());
;
}
CATE(TE,UFOF("ScriptInstance::getObj.")));
RET CN;
}

void RenderComponent_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,RenderComponent))
CATE(TE,"RenderComponent::__del__ expects RenderComponent as first argument."));

}SV RenderComponent_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"RenderComponent's constructor" EAOE));
if(!TS(a[0],RenderComponent))
CATE(TE,"RenderComponent's constructor expects RenderComponent as first argument."));
CATE(TE,UFOF("RenderComponent's constructor.")));
}

SV RenderComponent_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("RenderComponent");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(RenderComponent_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(RenderComponent_new);
else
 CATE(KE,"Unknown member for RenderComponent."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(RenderComponent_new);
 EI(keyStr.equals("getShadowCaster", CPL_STR_HASH("getShadowCaster")))
RET CNF(RenderComponent_getShadowCaster);
 EI(keyStr.equals("setShadowCaster", CPL_STR_HASH("setShadowCaster")))
RET CNF(RenderComponent_setShadowCaster);
 EI(keyStr.equals("getOverlayColor", CPL_STR_HASH("getOverlayColor")))
RET CNF(RenderComponent_getOverlayColor);
 EI(keyStr.equals("setOverlayColor", CPL_STR_HASH("setOverlayColor")))
RET CNF(RenderComponent_setOverlayColor);
 EI(keyStr.equals("setAnimationState", CPL_STR_HASH("setAnimationState")))
RET CNF(RenderComponent_setAnimationState);
 EI(keyStr.equals("removeAnimationState", CPL_STR_HASH("removeAnimationState")))
RET CNF(RenderComponent_removeAnimationState);
 EI(keyStr.equals("getAnimationState", CPL_STR_HASH("getAnimationState")))
RET CNF(RenderComponent_getAnimationState);
 EI(keyStr.equals("mode", CPL_STR_HASH("mode")))
{
RenderComponent*obj=(RenderComponent*)f->data;
RET CV(obj->mode);
} EI(keyStr.equals("model", CPL_STR_HASH("model")))
{
RenderComponent*obj=(RenderComponent*)f->data;
RET CV(obj->model);
} EI(keyStr.equals("overlayTexture", CPL_STR_HASH("overlayTexture")))
{
RenderComponent*obj=(RenderComponent*)f->data;
RET CV(obj->overlayTexture);
} else
 CATE(KE,"Unknown member for RenderComponent."));
}
}
RET CN;
}

void RenderComponent_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("mode", CPL_STR_HASH("mode")))
{
RenderComponent*obj=(RenderComponent*)f->data;
obj->mode=val_to_c<decltype(obj->mode)>::f(ctx,value);
} EI(keyStr.equals("model", CPL_STR_HASH("model")))
{
RenderComponent*obj=(RenderComponent*)f->data;
obj->model=val_to_c<decltype(obj->model)>::f(ctx,value);
} EI(keyStr.equals("overlayTexture", CPL_STR_HASH("overlayTexture")))
{
RenderComponent*obj=(RenderComponent*)f->data;
obj->overlayTexture=val_to_c<decltype(obj->overlayTexture)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for RenderComponent."));
}
}
}

SV RenderComponent_setOverlayColor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderComponent::setOverlayColor" EAOE));
RenderComponent*f;
f=(RenderComponent*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
( f->setOverlayColor(val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RenderComponent::setOverlayColor.")));
RET CN;
}

SV RenderComponent_getOverlayColor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderComponent::getOverlayColor" EAOE));
RenderComponent*f;
f=(RenderComponent*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getOverlayColor());
;
}
CATE(TE,UFOF("RenderComponent::getOverlayColor.")));
RET CN;
}

SV RenderComponent_setShadowCaster(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderComponent::setShadowCaster" EAOE));
RenderComponent*f;
f=(RenderComponent*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],bool))
{
( f->setShadowCaster(val_to_c<std::remove_reference<bool>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RenderComponent::setShadowCaster.")));
RET CN;
}

SV RenderComponent_getShadowCaster(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderComponent::getShadowCaster" EAOE));
RenderComponent*f;
f=(RenderComponent*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShadowCaster());
;
}
CATE(TE,UFOF("RenderComponent::getShadowCaster.")));
RET CN;
}

SV RenderComponent_setAnimationState(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderComponent::setAnimationState" EAOE));
RenderComponent*f;
f=(RenderComponent*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],GfxMesh *)&&TS(a[2],const Str &))
{
( f->setAnimationState(val_to_c<std::remove_reference<GfxMesh *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("RenderComponent::setAnimationState.")));
RET CN;
}

SV RenderComponent_getAnimationState(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderComponent::getAnimationState" EAOE));
RenderComponent*f;
f=(RenderComponent*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAnimationState());
;
}
CATE(TE,UFOF("RenderComponent::getAnimationState.")));
RET CN;
}

SV RenderComponent_removeAnimationState(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderComponent::removeAnimationState" EAOE));
RenderComponent*f;
f=(RenderComponent*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeAnimationState());
RET CN;
}
CATE(TE,UFOF("RenderComponent::removeAnimationState.")));
RET CN;
}

void RigidBody_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,RigidBody))
CATE(TE,"RigidBody::__del__ expects RigidBody as first argument."));

}SV RigidBody_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"RigidBody's constructor" EAOE));
if(!TS(a[0],RigidBody))
CATE(TE,"RigidBody's constructor expects RigidBody as first argument."));
CATE(TE,UFOF("RigidBody's constructor.")));
}

SV RigidBody_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("RigidBody");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(RigidBody_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(RigidBody_new);
else
 CATE(KE,"Unknown member for RigidBody."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(RigidBody_new);
 EI(keyStr.equals("getBulletRigidBody", CPL_STR_HASH("getBulletRigidBody")))
RET CNF(RigidBody_getBulletRigidBody);
 EI(keyStr.equals("getType", CPL_STR_HASH("getType")))
RET CNF(RigidBody_getType);
 EI(keyStr.equals("getGravity", CPL_STR_HASH("getGravity")))
RET CNF(RigidBody_getGravity);
 EI(keyStr.equals("setGravity", CPL_STR_HASH("setGravity")))
RET CNF(RigidBody_setGravity);
 EI(keyStr.equals("setLinearDamping", CPL_STR_HASH("setLinearDamping")))
RET CNF(RigidBody_setLinearDamping);
 EI(keyStr.equals("getLinearDamping", CPL_STR_HASH("getLinearDamping")))
RET CNF(RigidBody_getLinearDamping);
 EI(keyStr.equals("setAngularDamping", CPL_STR_HASH("setAngularDamping")))
RET CNF(RigidBody_setAngularDamping);
 EI(keyStr.equals("getAngularDamping", CPL_STR_HASH("getAngularDamping")))
RET CNF(RigidBody_getAngularDamping);
 EI(keyStr.equals("setMass", CPL_STR_HASH("setMass")))
RET CNF(RigidBody_setMass);
 EI(keyStr.equals("getMass", CPL_STR_HASH("getMass")))
RET CNF(RigidBody_getMass);
 EI(keyStr.equals("getLinearSleepingThreshold", CPL_STR_HASH("getLinearSleepingThreshold")))
RET CNF(RigidBody_getLinearSleepingThreshold);
 EI(keyStr.equals("setLinearSleepingThreshold", CPL_STR_HASH("setLinearSleepingThreshold")))
RET CNF(RigidBody_setLinearSleepingThreshold);
 EI(keyStr.equals("getAngularSleepingThreshold", CPL_STR_HASH("getAngularSleepingThreshold")))
RET CNF(RigidBody_getAngularSleepingThreshold);
 EI(keyStr.equals("setAngularSleepingThreshold", CPL_STR_HASH("setAngularSleepingThreshold")))
RET CNF(RigidBody_setAngularSleepingThreshold);
 EI(keyStr.equals("applyTorque", CPL_STR_HASH("applyTorque")))
RET CNF(RigidBody_applyTorque);
 EI(keyStr.equals("applyForce", CPL_STR_HASH("applyForce")))
RET CNF(RigidBody_applyForce);
 EI(keyStr.equals("applyCentralImpulse", CPL_STR_HASH("applyCentralImpulse")))
RET CNF(RigidBody_applyCentralImpulse);
 EI(keyStr.equals("applyTorqueImpulse", CPL_STR_HASH("applyTorqueImpulse")))
RET CNF(RigidBody_applyTorqueImpulse);
 EI(keyStr.equals("applyImpulse", CPL_STR_HASH("applyImpulse")))
RET CNF(RigidBody_applyImpulse);
 EI(keyStr.equals("clearForces", CPL_STR_HASH("clearForces")))
RET CNF(RigidBody_clearForces);
 EI(keyStr.equals("getLinearVelocity", CPL_STR_HASH("getLinearVelocity")))
RET CNF(RigidBody_getLinearVelocity);
 EI(keyStr.equals("setLinearVelocity", CPL_STR_HASH("setLinearVelocity")))
RET CNF(RigidBody_setLinearVelocity);
 EI(keyStr.equals("getAngularVelocity", CPL_STR_HASH("getAngularVelocity")))
RET CNF(RigidBody_getAngularVelocity);
 EI(keyStr.equals("setAngularVelocity", CPL_STR_HASH("setAngularVelocity")))
RET CNF(RigidBody_setAngularVelocity);
 EI(keyStr.equals("getVelocityOfPoint", CPL_STR_HASH("getVelocityOfPoint")))
RET CNF(RigidBody_getVelocityOfPoint);
 EI(keyStr.equals("getRestitution", CPL_STR_HASH("getRestitution")))
RET CNF(RigidBody_getRestitution);
 EI(keyStr.equals("setRestitution", CPL_STR_HASH("setRestitution")))
RET CNF(RigidBody_setRestitution);
 EI(keyStr.equals("getFriction", CPL_STR_HASH("getFriction")))
RET CNF(RigidBody_getFriction);
 EI(keyStr.equals("setFriction", CPL_STR_HASH("setFriction")))
RET CNF(RigidBody_setFriction);
 EI(keyStr.equals("getRollingFriction", CPL_STR_HASH("getRollingFriction")))
RET CNF(RigidBody_getRollingFriction);
 EI(keyStr.equals("setRollingFriction", CPL_STR_HASH("setRollingFriction")))
RET CNF(RigidBody_setRollingFriction);
 EI(keyStr.equals("getLinearFactor", CPL_STR_HASH("getLinearFactor")))
RET CNF(RigidBody_getLinearFactor);
 EI(keyStr.equals("setLinearFactor", CPL_STR_HASH("setLinearFactor")))
RET CNF(RigidBody_setLinearFactor);
 EI(keyStr.equals("getAngularFactor", CPL_STR_HASH("getAngularFactor")))
RET CNF(RigidBody_getAngularFactor);
 EI(keyStr.equals("setAngularFactor", CPL_STR_HASH("setAngularFactor")))
RET CNF(RigidBody_setAngularFactor);
 EI(keyStr.equals("setTransform", CPL_STR_HASH("setTransform")))
RET CNF(RigidBody_setTransform);
 EI(keyStr.equals("getWorld", CPL_STR_HASH("getWorld")))
RET CNF(RigidBody_getWorld);
 EI(keyStr.equals("getCollisionMask", CPL_STR_HASH("getCollisionMask")))
RET CNF(RigidBody_getCollisionMask);
 EI(keyStr.equals("setShape", CPL_STR_HASH("setShape")))
RET CNF(RigidBody_setShape);
 EI(keyStr.equals("getShape", CPL_STR_HASH("getShape")))
RET CNF(RigidBody_getShape);
 EI(keyStr.equals("getEntity", CPL_STR_HASH("getEntity")))
RET CNF(RigidBody_getEntity);
 else
 CATE(KE,"Unknown member for RigidBody."));
}
}
RET CN;
}

void RigidBody_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for RigidBody."));
}
}
}

SV RigidBody_setGravity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setGravity" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->setGravity(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setGravity.")));
RET CN;
}

SV RigidBody_getFriction(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getFriction" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFriction());
;
}
CATE(TE,UFOF("RigidBody::getFriction.")));
RET CN;
}

SV RigidBody_getRollingFriction(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getRollingFriction" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRollingFriction());
;
}
CATE(TE,UFOF("RigidBody::getRollingFriction.")));
RET CN;
}

SV RigidBody_setAngularFactor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setAngularFactor" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
( f->setAngularFactor(val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setAngularFactor.")));
RET CN;
}

SV RigidBody_getVelocityOfPoint(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getVelocityOfPoint" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Position3D &))
{
RET CV( f->getVelocityOfPoint(val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("RigidBody::getVelocityOfPoint.")));
RET CN;
}

SV RigidBody_setTransform(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setTransform" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Matrix4x4 &))
{
( f->setTransform(val_to_c<std::remove_reference<const Matrix4x4 &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setTransform.")));
RET CN;
}

SV RigidBody_getMass(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getMass" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getMass());
;
}
CATE(TE,UFOF("RigidBody::getMass.")));
RET CN;
}

SV RigidBody_setFriction(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setFriction" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setFriction(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setFriction.")));
RET CN;
}

SV RigidBody_clearForces(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::clearForces" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clearForces());
RET CN;
}
CATE(TE,UFOF("RigidBody::clearForces.")));
RET CN;
}

SV RigidBody_applyImpulse(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::applyImpulse" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],const Vector3D &)&&TS(a[2],const Position3D &))
{
( f->applyImpulse(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("RigidBody::applyImpulse.")));
RET CN;
}

SV RigidBody_applyTorque(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::applyTorque" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->applyTorque(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::applyTorque.")));
RET CN;
}

SV RigidBody_setLinearFactor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setLinearFactor" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
( f->setLinearFactor(val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setLinearFactor.")));
RET CN;
}

SV RigidBody_setLinearDamping(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setLinearDamping" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setLinearDamping(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setLinearDamping.")));
RET CN;
}

SV RigidBody_getLinearFactor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getLinearFactor" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getLinearFactor());
;
}
CATE(TE,UFOF("RigidBody::getLinearFactor.")));
RET CN;
}

SV RigidBody_setAngularDamping(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setAngularDamping" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setAngularDamping(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setAngularDamping.")));
RET CN;
}

SV RigidBody_getWorld(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getWorld" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWorld());
;
}
CATE(TE,UFOF("RigidBody::getWorld.")));
RET CN;
}

SV RigidBody_getAngularVelocity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getAngularVelocity" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAngularVelocity());
;
}
CATE(TE,UFOF("RigidBody::getAngularVelocity.")));
RET CN;
}

SV RigidBody_getShape(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getShape" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShape());
;
}
CATE(TE,UFOF("RigidBody::getShape.")));
RET CN;
}

SV RigidBody_setAngularSleepingThreshold(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setAngularSleepingThreshold" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setAngularSleepingThreshold(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setAngularSleepingThreshold.")));
RET CN;
}

SV RigidBody_applyTorqueImpulse(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::applyTorqueImpulse" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->applyTorqueImpulse(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::applyTorqueImpulse.")));
RET CN;
}

SV RigidBody_setLinearVelocity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setLinearVelocity" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->setLinearVelocity(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setLinearVelocity.")));
RET CN;
}

SV RigidBody_getCollisionMask(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getCollisionMask" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCollisionMask());
;
}
CATE(TE,UFOF("RigidBody::getCollisionMask.")));
RET CN;
}

SV RigidBody_getLinearVelocity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getLinearVelocity" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getLinearVelocity());
;
}
CATE(TE,UFOF("RigidBody::getLinearVelocity.")));
RET CN;
}

SV RigidBody_setAngularVelocity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setAngularVelocity" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->setAngularVelocity(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setAngularVelocity.")));
RET CN;
}

SV RigidBody_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getType" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("RigidBody::getType.")));
RET CN;
}

SV RigidBody_getAngularSleepingThreshold(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getAngularSleepingThreshold" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAngularSleepingThreshold());
;
}
CATE(TE,UFOF("RigidBody::getAngularSleepingThreshold.")));
RET CN;
}

SV RigidBody_setLinearSleepingThreshold(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setLinearSleepingThreshold" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setLinearSleepingThreshold(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setLinearSleepingThreshold.")));
RET CN;
}

SV RigidBody_setRollingFriction(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setRollingFriction" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setRollingFriction(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setRollingFriction.")));
RET CN;
}

SV RigidBody_getGravity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getGravity" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGravity());
;
}
CATE(TE,UFOF("RigidBody::getGravity.")));
RET CN;
}

SV RigidBody_setMass(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setMass" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setMass(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setMass.")));
RET CN;
}

SV RigidBody_applyCentralImpulse(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::applyCentralImpulse" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->applyCentralImpulse(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::applyCentralImpulse.")));
RET CN;
}

SV RigidBody_getBulletRigidBody(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getBulletRigidBody" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

CATE(TE,UFOF("RigidBody::getBulletRigidBody.")));
RET CN;
}

SV RigidBody_getRestitution(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getRestitution" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRestitution());
;
}
CATE(TE,UFOF("RigidBody::getRestitution.")));
RET CN;
}

SV RigidBody_getAngularFactor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getAngularFactor" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAngularFactor());
;
}
CATE(TE,UFOF("RigidBody::getAngularFactor.")));
RET CN;
}

SV RigidBody_getAngularDamping(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getAngularDamping" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAngularDamping());
;
}
CATE(TE,UFOF("RigidBody::getAngularDamping.")));
RET CN;
}

SV RigidBody_getLinearSleepingThreshold(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getLinearSleepingThreshold" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getLinearSleepingThreshold());
;
}
CATE(TE,UFOF("RigidBody::getLinearSleepingThreshold.")));
RET CN;
}

SV RigidBody_applyForce(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::applyForce" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],const Vector3D &)&&TS(a[2],const Position3D &))
{
( f->applyForce(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("RigidBody::applyForce.")));
RET CN;
}

SV RigidBody_getEntity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getEntity" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getEntity());
;
}
CATE(TE,UFOF("RigidBody::getEntity.")));
RET CN;
}

SV RigidBody_setRestitution(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setRestitution" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setRestitution(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setRestitution.")));
RET CN;
}

SV RigidBody_setShape(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setShape" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],PhysicsShape *))
{
( f->setShape(val_to_c<std::remove_reference<PhysicsShape *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setShape.")));
RET CN;
}

SV RigidBody_getLinearDamping(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getLinearDamping" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getLinearDamping());
;
}
CATE(TE,UFOF("RigidBody::getLinearDamping.")));
RET CN;
}

void RenderList_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,RenderList))
CATE(TE,"RenderList::__del__ expects RenderList as first argument."));

SCRIPT_DELETE((RenderList*)f->data);
}SV RenderList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderList's constructor" EAOE));
if(!TS(a[0],RenderList))
CATE(TE,"RenderList's constructor expects RenderList as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(RenderList));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(RenderList_funcs,p,EXT->RenderList_typeID);
}CATE(TE,UFOF("RenderList's constructor.")));
RET CN;
}

SV RenderList_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("RenderList");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(RenderList_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(RenderList_new);
else
 CATE(KE,"Unknown member for RenderList."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(RenderList_new);
 EI(keyStr.equals("addDrawCall", CPL_STR_HASH("addDrawCall")))
RET CNF(RenderList_addDrawCall);
 EI(keyStr.equals("addRenderList", CPL_STR_HASH("addRenderList")))
RET CNF(RenderList_addRenderList);
 EI(keyStr.equals("execute", CPL_STR_HASH("execute")))
RET CNF(RenderList_execute);
 EI(keyStr.equals("clear", CPL_STR_HASH("clear")))
RET CNF(RenderList_clear);
 else
 CATE(KE,"Unknown member for RenderList."));
}
}
RET CN;
}

void RenderList_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for RenderList."));
}
}
}

SV RenderList_addRenderList(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderList::addRenderList" EAOE));
RenderList*f;
f=(RenderList*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const RenderList *))
{
( f->addRenderList(val_to_c<std::remove_reference<const RenderList *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RenderList::addRenderList.")));
RET CN;
}

SV RenderList_execute(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderList::execute" EAOE));
RenderList*f;
f=(RenderList*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Camera &))
{
RET CV( f->execute(val_to_c<std::remove_reference<const Camera &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==3)
if(1&&TS(a[1],Light *)&&TS(a[2],size_t))
{
RET CV( f->execute(val_to_c<std::remove_reference<Light *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("RenderList::execute.")));
RET CN;
}

SV RenderList_addDrawCall(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderList::addDrawCall" EAOE));
RenderList*f;
f=(RenderList*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const DrawCall &))
{
( f->addDrawCall(val_to_c<std::remove_reference<const DrawCall &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RenderList::addDrawCall.")));
RET CN;
}

SV RenderList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderList::clear" EAOE));
RenderList*f;
f=(RenderList*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("RenderList::clear.")));
RET CN;
}

void Plane_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Plane))
CATE(TE,"Plane::__del__ expects Plane as first argument."));

SCRIPT_DELETE((Plane*)f->data);
}SV Plane_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Plane's constructor" EAOE));
if(!TS(a[0],Plane))
CATE(TE,"Plane's constructor expects Plane as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(Plane));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Plane_funcs,p,EXT->Plane_typeID);
}if(a.getCount()==4)
if(true&&TS(a[1],const Position3D &)&&TS(a[2],const Position3D &)&&TS(a[3],const Position3D &)){
void *p = (void *)NEW(TYPE(Plane),val_to_c<const Position3D &>::f(ctx,a[1]),val_to_c<const Position3D &>::f(ctx,a[2]),val_to_c<const Position3D &>::f(ctx,a[3]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Plane_funcs,p,EXT->Plane_typeID);
}CATE(TE,UFOF("Plane's constructor.")));
RET CN;
}

SV Plane_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Plane");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Plane_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Plane_new);
else
 CATE(KE,"Unknown member for Plane."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Plane_new);
 EI(keyStr.equals("distanceToPoint", CPL_STR_HASH("distanceToPoint")))
RET CNF(Plane_distanceToPoint);
 EI(keyStr.equals("normal", CPL_STR_HASH("normal")))
{
Plane*obj=(Plane*)f->data;
RET CV(obj->normal);
} EI(keyStr.equals("distance", CPL_STR_HASH("distance")))
{
Plane*obj=(Plane*)f->data;
RET CV(obj->distance);
} else
 CATE(KE,"Unknown member for Plane."));
}
}
RET CN;
}

void Plane_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("normal", CPL_STR_HASH("normal")))
{
Plane*obj=(Plane*)f->data;
obj->normal=val_to_c<decltype(obj->normal)>::f(ctx,value);
} EI(keyStr.equals("distance", CPL_STR_HASH("distance")))
{
Plane*obj=(Plane*)f->data;
obj->distance=val_to_c<decltype(obj->distance)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for Plane."));
}
}
}

SV Plane_distanceToPoint(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Plane::distanceToPoint" EAOE));
Plane*f;
f=(Plane*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Position3D &))
{
RET CV( f->distanceToPoint(val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Plane::distanceToPoint.")));
RET CN;
}

void PhysicsShape_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,PhysicsShape))
CATE(TE,"PhysicsShape::__del__ expects PhysicsShape as first argument."));

PhysicsShape*obj=(PhysicsShape*)f->data;
if(_scriptDeletePart(obj)){obj->release();}
}SV PhysicsShape_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape's constructor" EAOE));
if(!TS(a[0],PhysicsShape))
CATE(TE,"PhysicsShape's constructor expects PhysicsShape as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(PhysicsShape));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(PhysicsShape_funcs,p,EXT->PhysicsShape_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const Str &)){
void *p = (void *)NEW(TYPE(PhysicsShape),val_to_c<const Str &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(PhysicsShape_funcs,p,EXT->PhysicsShape_typeID);
}CATE(TE,UFOF("PhysicsShape's constructor.")));
RET CN;
}

SV PhysicsShape_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("PhysicsShape");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(PhysicsShape_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(PhysicsShape_new);
else
 CATE(KE,"Unknown member for PhysicsShape."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(PhysicsShape_new);
 EI(keyStr.equals("removeContent", CPL_STR_HASH("removeContent")))
RET CNF(PhysicsShape_removeContent);
 EI(keyStr.equals("getImpl", CPL_STR_HASH("getImpl")))
RET CNF(PhysicsShape_getImpl);
 EI(keyStr.equals("getShapeType", CPL_STR_HASH("getShapeType")))
RET CNF(PhysicsShape_getShapeType);
 EI(keyStr.equals("getMargin", CPL_STR_HASH("getMargin")))
RET CNF(PhysicsShape_getMargin);
 EI(keyStr.equals("setMargin", CPL_STR_HASH("setMargin")))
RET CNF(PhysicsShape_setMargin);
 EI(keyStr.equals("getScale", CPL_STR_HASH("getScale")))
RET CNF(PhysicsShape_getScale);
 EI(keyStr.equals("setScale", CPL_STR_HASH("setScale")))
RET CNF(PhysicsShape_setScale);
 EI(keyStr.equals("getBulletShape", CPL_STR_HASH("getBulletShape")))
RET CNF(PhysicsShape_getBulletShape);
 EI(keyStr.equals("setEmpty", CPL_STR_HASH("setEmpty")))
RET CNF(PhysicsShape_setEmpty);
 EI(keyStr.equals("setSphere", CPL_STR_HASH("setSphere")))
RET CNF(PhysicsShape_setSphere);
 EI(keyStr.equals("setBox", CPL_STR_HASH("setBox")))
RET CNF(PhysicsShape_setBox);
 EI(keyStr.equals("setCylinder", CPL_STR_HASH("setCylinder")))
RET CNF(PhysicsShape_setCylinder);
 EI(keyStr.equals("setCapsule", CPL_STR_HASH("setCapsule")))
RET CNF(PhysicsShape_setCapsule);
 EI(keyStr.equals("setCone", CPL_STR_HASH("setCone")))
RET CNF(PhysicsShape_setCone);
 EI(keyStr.equals("setConvexHull", CPL_STR_HASH("setConvexHull")))
RET CNF(PhysicsShape_setConvexHull);
 EI(keyStr.equals("setStaticTriangleMesh", CPL_STR_HASH("setStaticTriangleMesh")))
RET CNF(PhysicsShape_setStaticTriangleMesh);
 EI(keyStr.equals("setHeightfield", CPL_STR_HASH("setHeightfield")))
RET CNF(PhysicsShape_setHeightfield);
 EI(keyStr.equals("setPlane", CPL_STR_HASH("setPlane")))
RET CNF(PhysicsShape_setPlane);
 EI(keyStr.equals("setCompound", CPL_STR_HASH("setCompound")))
RET CNF(PhysicsShape_setCompound);
 EI(keyStr.equals("save", CPL_STR_HASH("save")))
RET CNF(PhysicsShape_save);
 EI(keyStr.equals("load", CPL_STR_HASH("load")))
RET CNF(PhysicsShape_load);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(PhysicsShape_copy);
 EI(keyStr.equals("getType", CPL_STR_HASH("getType")))
RET CNF(PhysicsShape_getType);
 EI(keyStr.equals("release", CPL_STR_HASH("release")))
RET CNF(PhysicsShape_release);
 EI(keyStr.equals("getRefCount", CPL_STR_HASH("getRefCount")))
RET CNF(PhysicsShape_getRefCount);
 EI(keyStr.equals("getFilename", CPL_STR_HASH("getFilename")))
RET CNF(PhysicsShape_getFilename);
 EI(keyStr.equals("setFilename", CPL_STR_HASH("setFilename")))
RET CNF(PhysicsShape_setFilename);
 else
 CATE(KE,"Unknown member for PhysicsShape."));
}
}
RET CN;
}

void PhysicsShape_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for PhysicsShape."));
}
}
}

SV PhysicsShape_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::load" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("PhysicsShape::load.")));
RET CN;
}

SV PhysicsShape_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setFilename" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
( f->setFilename(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("PhysicsShape::setFilename.")));
RET CN;
}

SV PhysicsShape_setScale(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setScale" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->setScale(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("PhysicsShape::setScale.")));
RET CN;
}

SV PhysicsShape_setEmpty(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setEmpty" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->setEmpty());
RET CN;
}
CATE(TE,UFOF("PhysicsShape::setEmpty.")));
RET CN;
}

SV PhysicsShape_getImpl(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::getImpl" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

CATE(TE,UFOF("PhysicsShape::getImpl.")));
RET CN;
}

SV PhysicsShape_setCompound(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setCompound" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

CATE(TE,UFOF("PhysicsShape::setCompound.")));
RET CN;
}

SV PhysicsShape_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::save" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("PhysicsShape::save.")));
RET CN;
}

SV PhysicsShape_setPlane(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setPlane" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],const Vector3D &)&&TS(a[2],float))
{
( f->setPlane(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("PhysicsShape::setPlane.")));
RET CN;
}

SV PhysicsShape_setCapsule(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setCapsule" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],Axis)&&TS(a[2],float)&&TS(a[3],float))
{
( f->setCapsule(val_to_c<std::remove_reference<Axis>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("PhysicsShape::setCapsule.")));
RET CN;
}

SV PhysicsShape_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::getFilename" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("PhysicsShape::getFilename.")));
RET CN;
}

SV PhysicsShape_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::getRefCount" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("PhysicsShape::getRefCount.")));
RET CN;
}

SV PhysicsShape_setBox(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setBox" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->setBox(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("PhysicsShape::setBox.")));
RET CN;
}

SV PhysicsShape_setConvexHull(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setConvexHull" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

CATE(TE,UFOF("PhysicsShape::setConvexHull.")));
RET CN;
}

SV PhysicsShape_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::getType" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("PhysicsShape::getType.")));
RET CN;
}

SV PhysicsShape_getMargin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::getMargin" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getMargin());
;
}
CATE(TE,UFOF("PhysicsShape::getMargin.")));
RET CN;
}

SV PhysicsShape_setStaticTriangleMesh(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setStaticTriangleMesh" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

CATE(TE,UFOF("PhysicsShape::setStaticTriangleMesh.")));
RET CN;
}

SV PhysicsShape_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::removeContent" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("PhysicsShape::removeContent.")));
RET CN;
}

SV PhysicsShape_setMargin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setMargin" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setMargin(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("PhysicsShape::setMargin.")));
RET CN;
}

SV PhysicsShape_getScale(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::getScale" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScale());
;
}
CATE(TE,UFOF("PhysicsShape::getScale.")));
RET CN;
}

SV PhysicsShape_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::copy" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("PhysicsShape::copy.")));
RET CN;
}

SV PhysicsShape_getBulletShape(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::getBulletShape" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

CATE(TE,UFOF("PhysicsShape::getBulletShape.")));
RET CN;
}

SV PhysicsShape_setCylinder(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setCylinder" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],Axis)&&TS(a[2],float)&&TS(a[3],float))
{
( f->setCylinder(val_to_c<std::remove_reference<Axis>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("PhysicsShape::setCylinder.")));
RET CN;
}

SV PhysicsShape_setCone(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setCone" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],Axis)&&TS(a[2],float)&&TS(a[3],float))
{
( f->setCone(val_to_c<std::remove_reference<Axis>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("PhysicsShape::setCone.")));
RET CN;
}

SV PhysicsShape_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::release" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("PhysicsShape::release.")));
RET CN;
}

SV PhysicsShape_setHeightfield(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setHeightfield" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

CATE(TE,UFOF("PhysicsShape::setHeightfield.")));
RET CN;
}

SV PhysicsShape_setSphere(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setSphere" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setSphere(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("PhysicsShape::setSphere.")));
RET CN;
}

SV PhysicsShape_getShapeType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::getShapeType" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0].p)->data;

CATE(TE,UFOF("PhysicsShape::getShapeType.")));
RET CN;
}

void RigidBodyList_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,List<RigidBody*>))
CATE(TE,"RigidBodyList::__del__ expects RigidBodyList as first argument."));

SCRIPT_DELETE((List<RigidBody*>*)f->data);
}SV RigidBodyList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList's constructor" EAOE));
if(!TS(a[0],List<RigidBody*>))
CATE(TE,"RigidBodyList's constructor expects RigidBodyList as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(List<RigidBody*>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(RigidBodyList_funcs,p,EXT->RigidBodyList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],std::size_t)){
void *p = (void *)NEW(TYPE(List<RigidBody*>),val_to_c<std::size_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(RigidBodyList_funcs,p,EXT->RigidBodyList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const List<RigidBody*> &)){
void *p = (void *)NEW(TYPE(List<RigidBody*>),val_to_c<const List<RigidBody*> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(RigidBodyList_funcs,p,EXT->RigidBodyList_typeID);
}CATE(TE,UFOF("RigidBodyList's constructor.")));
RET CN;
}

SV RigidBodyList_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("RigidBodyList");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(RigidBodyList_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(RigidBodyList_new);
else
 CATE(KE,"Unknown member for RigidBodyList."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(RigidBodyList_new);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(RigidBodyList___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(RigidBodyList___neq__);
 EI(keyStr.equals("get", CPL_STR_HASH("get")))
RET CNF(RigidBodyList_get);
 EI(keyStr.equals("set", CPL_STR_HASH("set")))
RET CNF(RigidBodyList_set);
 EI(keyStr.equals("getCount", CPL_STR_HASH("getCount")))
RET CNF(RigidBodyList_getCount);
 EI(keyStr.equals("getData", CPL_STR_HASH("getData")))
RET CNF(RigidBodyList_getData);
 EI(keyStr.equals("append", CPL_STR_HASH("append")))
RET CNF(RigidBodyList_append);
 EI(keyStr.equals("insert", CPL_STR_HASH("insert")))
RET CNF(RigidBodyList_insert);
 EI(keyStr.equals("remove", CPL_STR_HASH("remove")))
RET CNF(RigidBodyList_remove);
 EI(keyStr.equals("clear", CPL_STR_HASH("clear")))
RET CNF(RigidBodyList_clear);
 EI(keyStr.equals("find", CPL_STR_HASH("find")))
RET CNF(RigidBodyList_find);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(RigidBodyList_copy);
 EI(keyStr.equals("in", CPL_STR_HASH("in")))
RET CNF(RigidBodyList_in);
 EI(keyStr.equals("reserve", CPL_STR_HASH("reserve")))
RET CNF(RigidBodyList_reserve);
 EI(keyStr.equals("begin", CPL_STR_HASH("begin")))
RET CNF(RigidBodyList_begin);
 EI(keyStr.equals("end", CPL_STR_HASH("end")))
RET CNF(RigidBodyList_end);
 else
 CATE(KE,"Unknown member for RigidBodyList."));
}
}
RET CN;
}

void RigidBodyList_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for RigidBodyList."));
}
}
}

SV RigidBodyList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::insert" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],RigidBody*))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<RigidBody*>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<RigidBody*> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<RigidBody*> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("RigidBodyList::insert.")));
RET CN;
}

SV RigidBodyList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::begin" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("RigidBodyList::begin.")));
RET CN;
}

SV RigidBodyList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::set" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],RigidBody*))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<RigidBody*>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("RigidBodyList::set.")));
RET CN;
}

SV RigidBodyList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::end" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("RigidBodyList::end.")));
RET CN;
}

SV RigidBodyList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::get" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("RigidBodyList::get.")));
RET CN;
}

SV RigidBodyList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::clear" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("RigidBodyList::clear.")));
RET CN;
}

SV RigidBodyList_reserve(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::reserve" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->reserve(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBodyList::reserve.")));
RET CN;
}

SV RigidBodyList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::copy" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("RigidBodyList::copy.")));
RET CN;
}

SV RigidBodyList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::remove" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("RigidBodyList::remove.")));
RET CN;
}

SV RigidBodyList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::in" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],RigidBody*))
{
RET CV( f->in(val_to_c<std::remove_reference<RigidBody*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("RigidBodyList::in.")));
RET CN;
}

SV RigidBodyList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::getCount" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("RigidBodyList::getCount.")));
RET CN;
}

SV RigidBodyList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::getData" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("RigidBodyList::getData.")));
RET CN;
}

SV RigidBodyList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::__eq__" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<RigidBody*> &))
{
auto v=val_to_c<std::remove_reference<const List<RigidBody*> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("RigidBodyList::__eq__.")));
RET CN;
}

SV RigidBodyList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::find" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],RigidBody*))
{
RET CV( f->find(val_to_c<std::remove_reference<RigidBody*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("RigidBodyList::find.")));
RET CN;
}

SV RigidBodyList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::append" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],RigidBody*))
{
( f->append(val_to_c<std::remove_reference<RigidBody*>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<RigidBody*> &))
{
( f->append(val_to_c<std::remove_reference<const List<RigidBody*> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBodyList::append.")));
RET CN;
}

SV RigidBodyList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::__neq__" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<RigidBody*> &))
{
auto v=val_to_c<std::remove_reference<const List<RigidBody*> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("RigidBodyList::__neq__.")));
RET CN;
}

void Resource_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Resource))
CATE(TE,"Resource::__del__ expects Resource as first argument."));

Resource*obj=(Resource*)f->data;
if(_scriptDeletePart(obj)){obj->release();}
}SV Resource_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Resource's constructor" EAOE));
if(!TS(a[0],Resource))
CATE(TE,"Resource's constructor expects Resource as first argument."));
CATE(TE,UFOF("Resource's constructor.")));
}

SV Resource_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Resource");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Resource_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Resource_new);
else
 CATE(KE,"Unknown member for Resource."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Resource_new);
 EI(keyStr.equals("removeContent", CPL_STR_HASH("removeContent")))
RET CNF(Resource_removeContent);
 EI(keyStr.equals("load", CPL_STR_HASH("load")))
RET CNF(Resource_load);
 EI(keyStr.equals("save", CPL_STR_HASH("save")))
RET CNF(Resource_save);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(Resource_copy);
 EI(keyStr.equals("getType", CPL_STR_HASH("getType")))
RET CNF(Resource_getType);
 EI(keyStr.equals("release", CPL_STR_HASH("release")))
RET CNF(Resource_release);
 EI(keyStr.equals("getRefCount", CPL_STR_HASH("getRefCount")))
RET CNF(Resource_getRefCount);
 EI(keyStr.equals("getFilename", CPL_STR_HASH("getFilename")))
RET CNF(Resource_getFilename);
 EI(keyStr.equals("setFilename", CPL_STR_HASH("setFilename")))
RET CNF(Resource_setFilename);
 else
 CATE(KE,"Unknown member for Resource."));
}
}
RET CN;
}

void Resource_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for Resource."));
}
}
}

SV Resource_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::load" EAOE));
Resource*f;
f=(Resource*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("Resource::load.")));
RET CN;
}

SV Resource_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::getFilename" EAOE));
Resource*f;
f=(Resource*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("Resource::getFilename.")));
RET CN;
}

SV Resource_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::copy" EAOE));
Resource*f;
f=(Resource*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("Resource::copy.")));
RET CN;
}

SV Resource_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::getType" EAOE));
Resource*f;
f=(Resource*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("Resource::getType.")));
RET CN;
}

SV Resource_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::setFilename" EAOE));
Resource*f;
f=(Resource*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
( f->setFilename(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Resource::setFilename.")));
RET CN;
}

SV Resource_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::removeContent" EAOE));
Resource*f;
f=(Resource*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("Resource::removeContent.")));
RET CN;
}

SV Resource_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::getRefCount" EAOE));
Resource*f;
f=(Resource*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("Resource::getRefCount.")));
RET CN;
}

SV Resource_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::release" EAOE));
Resource*f;
f=(Resource*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("Resource::release.")));
RET CN;
}

SV Resource_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::save" EAOE));
Resource*f;
f=(Resource*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("Resource::save.")));
RET CN;
}

void GfxTexture_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GfxTexture))
CATE(TE,"GfxTexture::__del__ expects GfxTexture as first argument."));

GfxTexture*obj=(GfxTexture*)f->data;
if(_scriptDeletePart(obj)){obj->release();}
}SV GfxTexture_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture's constructor" EAOE));
if(!TS(a[0],GfxTexture))
CATE(TE,"GfxTexture's constructor expects GfxTexture as first argument."));
if(a.getCount()==2)
if(true&&TS(a[1],const Str &)){
void *p = (void *)NEW(TYPE(GfxTexture),val_to_c<const Str &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxTexture_funcs,p,EXT->GfxTexture_typeID);
}if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(GfxTexture));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxTexture_funcs,p,EXT->GfxTexture_typeID);
}CATE(TE,UFOF("GfxTexture's constructor.")));
RET CN;
}

SV GfxTexture_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxTexture");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxTexture_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxTexture_new);
else
 CATE(KE,"Unknown member for GfxTexture."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxTexture_new);
 EI(keyStr.equals("removeContent", CPL_STR_HASH("removeContent")))
RET CNF(GfxTexture_removeContent);
 EI(keyStr.equals("startCreation", CPL_STR_HASH("startCreation")))
RET CNF(GfxTexture_startCreation);
 EI(keyStr.equals("allocMipmapFace", CPL_STR_HASH("allocMipmapFace")))
RET CNF(GfxTexture_allocMipmapFace);
 EI(keyStr.equals("allocMipmap", CPL_STR_HASH("allocMipmap")))
RET CNF(GfxTexture_allocMipmap);
 EI(keyStr.equals("getMipmapFace", CPL_STR_HASH("getMipmapFace")))
RET CNF(GfxTexture_getMipmapFace);
 EI(keyStr.equals("getMipmap", CPL_STR_HASH("getMipmap")))
RET CNF(GfxTexture_getMipmap);
 EI(keyStr.equals("generateMipmaps", CPL_STR_HASH("generateMipmaps")))
RET CNF(GfxTexture_generateMipmaps);
 EI(keyStr.equals("getTextureType", CPL_STR_HASH("getTextureType")))
RET CNF(GfxTexture_getTextureType);
 EI(keyStr.equals("getBaseWidth", CPL_STR_HASH("getBaseWidth")))
RET CNF(GfxTexture_getBaseWidth);
 EI(keyStr.equals("getBaseHeight", CPL_STR_HASH("getBaseHeight")))
RET CNF(GfxTexture_getBaseHeight);
 EI(keyStr.equals("getBaseDepth", CPL_STR_HASH("getBaseDepth")))
RET CNF(GfxTexture_getBaseDepth);
 EI(keyStr.equals("getFormat", CPL_STR_HASH("getFormat")))
RET CNF(GfxTexture_getFormat);
 EI(keyStr.equals("getImpl", CPL_STR_HASH("getImpl")))
RET CNF(GfxTexture_getImpl);
 EI(keyStr.equals("save", CPL_STR_HASH("save")))
RET CNF(GfxTexture_save);
 EI(keyStr.equals("load", CPL_STR_HASH("load")))
RET CNF(GfxTexture_load);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(GfxTexture_copy);
 EI(keyStr.equals("getType", CPL_STR_HASH("getType")))
RET CNF(GfxTexture_getType);
 EI(keyStr.equals("release", CPL_STR_HASH("release")))
RET CNF(GfxTexture_release);
 EI(keyStr.equals("getRefCount", CPL_STR_HASH("getRefCount")))
RET CNF(GfxTexture_getRefCount);
 EI(keyStr.equals("getFilename", CPL_STR_HASH("getFilename")))
RET CNF(GfxTexture_getFilename);
 EI(keyStr.equals("setFilename", CPL_STR_HASH("setFilename")))
RET CNF(GfxTexture_setFilename);
 EI(keyStr.equals("sampler", CPL_STR_HASH("sampler")))
{
GfxTexture*obj=(GfxTexture*)f->data;
RET CV(obj->sampler);
} else
 CATE(KE,"Unknown member for GfxTexture."));
}
}
RET CN;
}

void GfxTexture_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("sampler", CPL_STR_HASH("sampler")))
{
GfxTexture*obj=(GfxTexture*)f->data;
obj->sampler=val_to_c<decltype(obj->sampler)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for GfxTexture."));
}
}
}

SV GfxTexture_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::load" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("GfxTexture::load.")));
RET CN;
}

SV GfxTexture_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::save" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("GfxTexture::save.")));
RET CN;
}

SV GfxTexture_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getType" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("GfxTexture::getType.")));
RET CN;
}

SV GfxTexture_getTextureType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getTextureType" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getTextureType());
;
}
CATE(TE,UFOF("GfxTexture::getTextureType.")));
RET CN;
}

SV GfxTexture_getMipmap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getMipmap" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

CATE(TE,UFOF("GfxTexture::getMipmap.")));
RET CN;
}

SV GfxTexture_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::setFilename" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
( f->setFilename(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxTexture::setFilename.")));
RET CN;
}

SV GfxTexture_getImpl(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getImpl" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

CATE(TE,UFOF("GfxTexture::getImpl.")));
RET CN;
}

SV GfxTexture_getMipmapFace(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getMipmapFace" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

CATE(TE,UFOF("GfxTexture::getMipmapFace.")));
RET CN;
}

SV GfxTexture_allocMipmapFace(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::allocMipmapFace" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

CATE(TE,UFOF("GfxTexture::allocMipmapFace.")));
RET CN;
}

SV GfxTexture_allocMipmap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::allocMipmap" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

if(a.getCount()==5)
if(1&&TS(a[1],unsigned int)&&TS(a[2],unsigned int)&&TS(a[3],GfxFace)&&TS(a[4],const ResizableData &))
{
( f->allocMipmap(val_to_c<std::remove_reference<unsigned int>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<unsigned int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<GfxFace>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[4])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],unsigned int)&&TS(a[2],unsigned int)&&TS(a[3],const ResizableData &))
{
( f->allocMipmap(val_to_c<std::remove_reference<unsigned int>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<unsigned int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("GfxTexture::allocMipmap.")));
RET CN;
}

SV GfxTexture_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::copy" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("GfxTexture::copy.")));
RET CN;
}

SV GfxTexture_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getFilename" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("GfxTexture::getFilename.")));
RET CN;
}

SV GfxTexture_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::removeContent" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("GfxTexture::removeContent.")));
RET CN;
}

SV GfxTexture_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getRefCount" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("GfxTexture::getRefCount.")));
RET CN;
}

SV GfxTexture_getBaseDepth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getBaseDepth" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBaseDepth());
;
}
CATE(TE,UFOF("GfxTexture::getBaseDepth.")));
RET CN;
}

SV GfxTexture_getBaseHeight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getBaseHeight" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBaseHeight());
;
}
CATE(TE,UFOF("GfxTexture::getBaseHeight.")));
RET CN;
}

SV GfxTexture_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::release" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("GfxTexture::release.")));
RET CN;
}

SV GfxTexture_startCreation(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::startCreation" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

if(a.getCount()==6)
if(1&&TS(a[1],GfxTextureType)&&TS(a[2],unsigned int)&&TS(a[3],unsigned int)&&TS(a[4],unsigned int)&&TS(a[5],GfxTexFormat))
{
( f->startCreation(val_to_c<std::remove_reference<GfxTextureType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<unsigned int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<unsigned int>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<unsigned int>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<GfxTexFormat>::type>::f(ctx,a[5])));
RET CN;
}
CATE(TE,UFOF("GfxTexture::startCreation.")));
RET CN;
}

SV GfxTexture_generateMipmaps(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::generateMipmaps" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->generateMipmaps());
RET CN;
}
CATE(TE,UFOF("GfxTexture::generateMipmaps.")));
RET CN;
}

SV GfxTexture_getFormat(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getFormat" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFormat());
;
}
CATE(TE,UFOF("GfxTexture::getFormat.")));
RET CN;
}

SV GfxTexture_getBaseWidth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getBaseWidth" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBaseWidth());
;
}
CATE(TE,UFOF("GfxTexture::getBaseWidth.")));
RET CN;
}

void GfxModel_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GfxModel))
CATE(TE,"GfxModel::__del__ expects GfxModel as first argument."));

GfxModel*obj=(GfxModel*)f->data;
if(_scriptDeletePart(obj)){obj->release();}
}SV GfxModel_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel's constructor" EAOE));
if(!TS(a[0],GfxModel))
CATE(TE,"GfxModel's constructor expects GfxModel as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(GfxModel));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxModel_funcs,p,EXT->GfxModel_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const Str &)){
void *p = (void *)NEW(TYPE(GfxModel),val_to_c<const Str &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxModel_funcs,p,EXT->GfxModel_typeID);
}CATE(TE,UFOF("GfxModel's constructor.")));
RET CN;
}

SV GfxModel_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxModel");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxModel_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxModel_new);
else
 CATE(KE,"Unknown member for GfxModel."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxModel_new);
 EI(keyStr.equals("removeContent", CPL_STR_HASH("removeContent")))
RET CNF(GfxModel_removeContent);
 EI(keyStr.equals("save", CPL_STR_HASH("save")))
RET CNF(GfxModel_save);
 EI(keyStr.equals("load", CPL_STR_HASH("load")))
RET CNF(GfxModel_load);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(GfxModel_copy);
 EI(keyStr.equals("getType", CPL_STR_HASH("getType")))
RET CNF(GfxModel_getType);
 EI(keyStr.equals("release", CPL_STR_HASH("release")))
RET CNF(GfxModel_release);
 EI(keyStr.equals("getRefCount", CPL_STR_HASH("getRefCount")))
RET CNF(GfxModel_getRefCount);
 EI(keyStr.equals("getFilename", CPL_STR_HASH("getFilename")))
RET CNF(GfxModel_getFilename);
 EI(keyStr.equals("setFilename", CPL_STR_HASH("setFilename")))
RET CNF(GfxModel_setFilename);
 EI(keyStr.equals("subModels", CPL_STR_HASH("subModels")))
{
GfxModel*obj=(GfxModel*)f->data;
RET CV(obj->subModels);
} else
 CATE(KE,"Unknown member for GfxModel."));
}
}
RET CN;
}

void GfxModel_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("subModels", CPL_STR_HASH("subModels")))
{
GfxModel*obj=(GfxModel*)f->data;
obj->subModels=val_to_c<decltype(obj->subModels)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for GfxModel."));
}
}
}

SV GfxModel_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::load" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("GfxModel::load.")));
RET CN;
}

SV GfxModel_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::getFilename" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("GfxModel::getFilename.")));
RET CN;
}

SV GfxModel_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::copy" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("GfxModel::copy.")));
RET CN;
}

SV GfxModel_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::getType" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("GfxModel::getType.")));
RET CN;
}

SV GfxModel_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::setFilename" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
( f->setFilename(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxModel::setFilename.")));
RET CN;
}

SV GfxModel_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::removeContent" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("GfxModel::removeContent.")));
RET CN;
}

SV GfxModel_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::getRefCount" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("GfxModel::getRefCount.")));
RET CN;
}

SV GfxModel_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::release" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("GfxModel::release.")));
RET CN;
}

SV GfxModel_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::save" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("GfxModel::save.")));
RET CN;
}

void GfxLODList_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,List<GfxLOD>))
CATE(TE,"GfxLODList::__del__ expects GfxLODList as first argument."));

SCRIPT_DELETE((List<GfxLOD>*)f->data);
}SV GfxLODList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList's constructor" EAOE));
if(!TS(a[0],List<GfxLOD>))
CATE(TE,"GfxLODList's constructor expects GfxLODList as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(List<GfxLOD>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxLODList_funcs,p,EXT->GfxLODList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],std::size_t)){
void *p = (void *)NEW(TYPE(List<GfxLOD>),val_to_c<std::size_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxLODList_funcs,p,EXT->GfxLODList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const List<GfxLOD> &)){
void *p = (void *)NEW(TYPE(List<GfxLOD>),val_to_c<const List<GfxLOD> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxLODList_funcs,p,EXT->GfxLODList_typeID);
}CATE(TE,UFOF("GfxLODList's constructor.")));
RET CN;
}

SV GfxLODList_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxLODList");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxLODList_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxLODList_new);
else
 CATE(KE,"Unknown member for GfxLODList."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxLODList_new);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(GfxLODList___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(GfxLODList___neq__);
 EI(keyStr.equals("get", CPL_STR_HASH("get")))
RET CNF(GfxLODList_get);
 EI(keyStr.equals("set", CPL_STR_HASH("set")))
RET CNF(GfxLODList_set);
 EI(keyStr.equals("getCount", CPL_STR_HASH("getCount")))
RET CNF(GfxLODList_getCount);
 EI(keyStr.equals("getData", CPL_STR_HASH("getData")))
RET CNF(GfxLODList_getData);
 EI(keyStr.equals("append", CPL_STR_HASH("append")))
RET CNF(GfxLODList_append);
 EI(keyStr.equals("insert", CPL_STR_HASH("insert")))
RET CNF(GfxLODList_insert);
 EI(keyStr.equals("remove", CPL_STR_HASH("remove")))
RET CNF(GfxLODList_remove);
 EI(keyStr.equals("clear", CPL_STR_HASH("clear")))
RET CNF(GfxLODList_clear);
 EI(keyStr.equals("find", CPL_STR_HASH("find")))
RET CNF(GfxLODList_find);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(GfxLODList_copy);
 EI(keyStr.equals("in", CPL_STR_HASH("in")))
RET CNF(GfxLODList_in);
 EI(keyStr.equals("reserve", CPL_STR_HASH("reserve")))
RET CNF(GfxLODList_reserve);
 EI(keyStr.equals("begin", CPL_STR_HASH("begin")))
RET CNF(GfxLODList_begin);
 EI(keyStr.equals("end", CPL_STR_HASH("end")))
RET CNF(GfxLODList_end);
 else
 CATE(KE,"Unknown member for GfxLODList."));
}
}
RET CN;
}

void GfxLODList_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for GfxLODList."));
}
}
}

SV GfxLODList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::insert" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],GfxLOD))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxLOD>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<GfxLOD> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<GfxLOD> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxLODList::insert.")));
RET CN;
}

SV GfxLODList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::begin" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0].p)->data;

CATE(TE,UFOF("GfxLODList::begin.")));
RET CN;
}

SV GfxLODList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::set" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],GfxLOD))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxLOD>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxLODList::set.")));
RET CN;
}

SV GfxLODList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::end" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0].p)->data;

CATE(TE,UFOF("GfxLODList::end.")));
RET CN;
}

SV GfxLODList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::get" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxLODList::get.")));
RET CN;
}

SV GfxLODList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::clear" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("GfxLODList::clear.")));
RET CN;
}

SV GfxLODList_reserve(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::reserve" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->reserve(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxLODList::reserve.")));
RET CN;
}

SV GfxLODList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::copy" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("GfxLODList::copy.")));
RET CN;
}

SV GfxLODList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::remove" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxLODList::remove.")));
RET CN;
}

SV GfxLODList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::in" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxLOD))
{
RET CV( f->in(val_to_c<std::remove_reference<GfxLOD>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxLODList::in.")));
RET CN;
}

SV GfxLODList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::getCount" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("GfxLODList::getCount.")));
RET CN;
}

SV GfxLODList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::getData" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0].p)->data;

CATE(TE,UFOF("GfxLODList::getData.")));
RET CN;
}

SV GfxLODList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::__eq__" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<GfxLOD> &))
{
auto v=val_to_c<std::remove_reference<const List<GfxLOD> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("GfxLODList::__eq__.")));
RET CN;
}

SV GfxLODList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::find" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxLOD))
{
RET CV( f->find(val_to_c<std::remove_reference<GfxLOD>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxLODList::find.")));
RET CN;
}

SV GfxLODList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::append" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxLOD))
{
( f->append(val_to_c<std::remove_reference<GfxLOD>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<GfxLOD> &))
{
( f->append(val_to_c<std::remove_reference<const List<GfxLOD> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxLODList::append.")));
RET CN;
}

SV GfxLODList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::__neq__" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<GfxLOD> &))
{
auto v=val_to_c<std::remove_reference<const List<GfxLOD> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("GfxLODList::__neq__.")));
RET CN;
}

void RigidBodyConstructionInfo_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,RigidBodyConstructionInfo))
CATE(TE,"RigidBodyConstructionInfo::__del__ expects RigidBodyConstructionInfo as first argument."));

SCRIPT_DELETE((RigidBodyConstructionInfo*)f->data);
}SV RigidBodyConstructionInfo_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyConstructionInfo's constructor" EAOE));
if(!TS(a[0],RigidBodyConstructionInfo))
CATE(TE,"RigidBodyConstructionInfo's constructor expects RigidBodyConstructionInfo as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(RigidBodyConstructionInfo));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(RigidBodyConstructionInfo_funcs,p,EXT->RigidBodyConstructionInfo_typeID);
}CATE(TE,UFOF("RigidBodyConstructionInfo's constructor.")));
RET CN;
}

SV RigidBodyConstructionInfo_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("RigidBodyConstructionInfo");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(RigidBodyConstructionInfo_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(RigidBodyConstructionInfo_new);
else
 CATE(KE,"Unknown member for RigidBodyConstructionInfo."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(RigidBodyConstructionInfo_new);
 EI(keyStr.equals("type", CPL_STR_HASH("type")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->type);
} EI(keyStr.equals("mass", CPL_STR_HASH("mass")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->mass);
} EI(keyStr.equals("entity", CPL_STR_HASH("entity")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->entity);
} EI(keyStr.equals("linearDamping", CPL_STR_HASH("linearDamping")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->linearDamping);
} EI(keyStr.equals("angularDamping", CPL_STR_HASH("angularDamping")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->angularDamping);
} EI(keyStr.equals("friction", CPL_STR_HASH("friction")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->friction);
} EI(keyStr.equals("rollingFriction", CPL_STR_HASH("rollingFriction")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->rollingFriction);
} EI(keyStr.equals("restitution", CPL_STR_HASH("restitution")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->restitution);
} EI(keyStr.equals("linearSleepingThreshold", CPL_STR_HASH("linearSleepingThreshold")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->linearSleepingThreshold);
} EI(keyStr.equals("angularSleepingThreshold", CPL_STR_HASH("angularSleepingThreshold")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->angularSleepingThreshold);
} EI(keyStr.equals("collisionMask", CPL_STR_HASH("collisionMask")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->collisionMask);
} else
 CATE(KE,"Unknown member for RigidBodyConstructionInfo."));
}
}
RET CN;
}

void RigidBodyConstructionInfo_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("type", CPL_STR_HASH("type")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->type=val_to_c<decltype(obj->type)>::f(ctx,value);
} EI(keyStr.equals("mass", CPL_STR_HASH("mass")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->mass=val_to_c<decltype(obj->mass)>::f(ctx,value);
} EI(keyStr.equals("entity", CPL_STR_HASH("entity")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->entity=val_to_c<decltype(obj->entity)>::f(ctx,value);
} EI(keyStr.equals("linearDamping", CPL_STR_HASH("linearDamping")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->linearDamping=val_to_c<decltype(obj->linearDamping)>::f(ctx,value);
} EI(keyStr.equals("angularDamping", CPL_STR_HASH("angularDamping")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->angularDamping=val_to_c<decltype(obj->angularDamping)>::f(ctx,value);
} EI(keyStr.equals("friction", CPL_STR_HASH("friction")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->friction=val_to_c<decltype(obj->friction)>::f(ctx,value);
} EI(keyStr.equals("rollingFriction", CPL_STR_HASH("rollingFriction")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->rollingFriction=val_to_c<decltype(obj->rollingFriction)>::f(ctx,value);
} EI(keyStr.equals("restitution", CPL_STR_HASH("restitution")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->restitution=val_to_c<decltype(obj->restitution)>::f(ctx,value);
} EI(keyStr.equals("linearSleepingThreshold", CPL_STR_HASH("linearSleepingThreshold")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->linearSleepingThreshold=val_to_c<decltype(obj->linearSleepingThreshold)>::f(ctx,value);
} EI(keyStr.equals("angularSleepingThreshold", CPL_STR_HASH("angularSleepingThreshold")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->angularSleepingThreshold=val_to_c<decltype(obj->angularSleepingThreshold)>::f(ctx,value);
} EI(keyStr.equals("collisionMask", CPL_STR_HASH("collisionMask")))
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->collisionMask=val_to_c<decltype(obj->collisionMask)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for RigidBodyConstructionInfo."));
}
}
}

void GfxApi_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GfxApi))
CATE(TE,"GfxApi::__del__ expects GfxApi as first argument."));

SCRIPT_DELETE((GfxApi*)f->data);
}SV GfxApi_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxApi's constructor" EAOE));
if(!TS(a[0],GfxApi))
CATE(TE,"GfxApi's constructor expects GfxApi as first argument."));
CATE(TE,UFOF("GfxApi's constructor.")));
}

SV GfxApi_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxApi");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxApi_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxApi_new);
else
 CATE(KE,"Unknown member for GfxApi."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxApi_new);
 EI(keyStr.equals("getDriver", CPL_STR_HASH("getDriver")))
RET CNF(GfxApi_getDriver);
 EI(keyStr.equals("getMaxTextureSize", CPL_STR_HASH("getMaxTextureSize")))
RET CNF(GfxApi_getMaxTextureSize);
 EI(keyStr.equals("createBuffer", CPL_STR_HASH("createBuffer")))
RET CNF(GfxApi_createBuffer);
 EI(keyStr.equals("createTextureImpl", CPL_STR_HASH("createTextureImpl")))
RET CNF(GfxApi_createTextureImpl);
 EI(keyStr.equals("createFramebuffer", CPL_STR_HASH("createFramebuffer")))
RET CNF(GfxApi_createFramebuffer);
 EI(keyStr.equals("createTimer", CPL_STR_HASH("createTimer")))
RET CNF(GfxApi_createTimer);
 EI(keyStr.equals("setCurrentFramebuffer", CPL_STR_HASH("setCurrentFramebuffer")))
RET CNF(GfxApi_setCurrentFramebuffer);
 EI(keyStr.equals("clearDepth", CPL_STR_HASH("clearDepth")))
RET CNF(GfxApi_clearDepth);
 EI(keyStr.equals("clearColor", CPL_STR_HASH("clearColor")))
RET CNF(GfxApi_clearColor);
 EI(keyStr.equals("begin", CPL_STR_HASH("begin")))
RET CNF(GfxApi_begin);
 EI(keyStr.equals("draw", CPL_STR_HASH("draw")))
RET CNF(GfxApi_draw);
 EI(keyStr.equals("end", CPL_STR_HASH("end")))
RET CNF(GfxApi_end);
 EI(keyStr.equals("setMesh", CPL_STR_HASH("setMesh")))
RET CNF(GfxApi_setMesh);
 EI(keyStr.equals("getVertexShader", CPL_STR_HASH("getVertexShader")))
RET CNF(GfxApi_getVertexShader);
 EI(keyStr.equals("getTessControlShader", CPL_STR_HASH("getTessControlShader")))
RET CNF(GfxApi_getTessControlShader);
 EI(keyStr.equals("getTessEvalShader", CPL_STR_HASH("getTessEvalShader")))
RET CNF(GfxApi_getTessEvalShader);
 EI(keyStr.equals("getGeometryShader", CPL_STR_HASH("getGeometryShader")))
RET CNF(GfxApi_getGeometryShader);
 EI(keyStr.equals("getFragmentShader", CPL_STR_HASH("getFragmentShader")))
RET CNF(GfxApi_getFragmentShader);
 EI(keyStr.equals("uniform", CPL_STR_HASH("uniform")))
RET CNF(GfxApi_uniform);
 EI(keyStr.equals("uniformU", CPL_STR_HASH("uniformU")))
RET CNF(GfxApi_uniformU);
 EI(keyStr.equals("addUBOBinding", CPL_STR_HASH("addUBOBinding")))
RET CNF(GfxApi_addUBOBinding);
 EI(keyStr.equals("addTextureBinding", CPL_STR_HASH("addTextureBinding")))
RET CNF(GfxApi_addTextureBinding);
 EI(keyStr.equals("pushState", CPL_STR_HASH("pushState")))
RET CNF(GfxApi_pushState);
 EI(keyStr.equals("popState", CPL_STR_HASH("popState")))
RET CNF(GfxApi_popState);
 EI(keyStr.equals("resetState", CPL_STR_HASH("resetState")))
RET CNF(GfxApi_resetState);
 EI(keyStr.equals("setBlendingEnabled", CPL_STR_HASH("setBlendingEnabled")))
RET CNF(GfxApi_setBlendingEnabled);
 EI(keyStr.equals("isBlendingEnabled", CPL_STR_HASH("isBlendingEnabled")))
RET CNF(GfxApi_isBlendingEnabled);
 EI(keyStr.equals("setBlendConstantColor", CPL_STR_HASH("setBlendConstantColor")))
RET CNF(GfxApi_setBlendConstantColor);
 EI(keyStr.equals("getBlendConstantColor", CPL_STR_HASH("getBlendConstantColor")))
RET CNF(GfxApi_getBlendConstantColor);
 EI(keyStr.equals("getBlendConstantColorR", CPL_STR_HASH("getBlendConstantColorR")))
RET CNF(GfxApi_getBlendConstantColorR);
 EI(keyStr.equals("getBlendConstantColorG", CPL_STR_HASH("getBlendConstantColorG")))
RET CNF(GfxApi_getBlendConstantColorG);
 EI(keyStr.equals("getBlendConstantColorB", CPL_STR_HASH("getBlendConstantColorB")))
RET CNF(GfxApi_getBlendConstantColorB);
 EI(keyStr.equals("getBlendConstantColorA", CPL_STR_HASH("getBlendConstantColorA")))
RET CNF(GfxApi_getBlendConstantColorA);
 EI(keyStr.equals("setBlendFactors", CPL_STR_HASH("setBlendFactors")))
RET CNF(GfxApi_setBlendFactors);
 EI(keyStr.equals("getBlendSrcFactorRGB", CPL_STR_HASH("getBlendSrcFactorRGB")))
RET CNF(GfxApi_getBlendSrcFactorRGB);
 EI(keyStr.equals("getBlendSrcFactorAlpha", CPL_STR_HASH("getBlendSrcFactorAlpha")))
RET CNF(GfxApi_getBlendSrcFactorAlpha);
 EI(keyStr.equals("getBlendDstFactorRGB", CPL_STR_HASH("getBlendDstFactorRGB")))
RET CNF(GfxApi_getBlendDstFactorRGB);
 EI(keyStr.equals("getBlendDstFactorAlpha", CPL_STR_HASH("getBlendDstFactorAlpha")))
RET CNF(GfxApi_getBlendDstFactorAlpha);
 EI(keyStr.equals("setBlendMode", CPL_STR_HASH("setBlendMode")))
RET CNF(GfxApi_setBlendMode);
 EI(keyStr.equals("getBlendModeRGB", CPL_STR_HASH("getBlendModeRGB")))
RET CNF(GfxApi_getBlendModeRGB);
 EI(keyStr.equals("getBlendModeAlpha", CPL_STR_HASH("getBlendModeAlpha")))
RET CNF(GfxApi_getBlendModeAlpha);
 EI(keyStr.equals("setWriteDepth", CPL_STR_HASH("setWriteDepth")))
RET CNF(GfxApi_setWriteDepth);
 EI(keyStr.equals("getWriteDepth", CPL_STR_HASH("getWriteDepth")))
RET CNF(GfxApi_getWriteDepth);
 EI(keyStr.equals("setDepthFunction", CPL_STR_HASH("setDepthFunction")))
RET CNF(GfxApi_setDepthFunction);
 EI(keyStr.equals("getDepthFunction", CPL_STR_HASH("getDepthFunction")))
RET CNF(GfxApi_getDepthFunction);
 EI(keyStr.equals("setViewport", CPL_STR_HASH("setViewport")))
RET CNF(GfxApi_setViewport);
 EI(keyStr.equals("getViewportLeft", CPL_STR_HASH("getViewportLeft")))
RET CNF(GfxApi_getViewportLeft);
 EI(keyStr.equals("getViewportBottom", CPL_STR_HASH("getViewportBottom")))
RET CNF(GfxApi_getViewportBottom);
 EI(keyStr.equals("getViewportWidth", CPL_STR_HASH("getViewportWidth")))
RET CNF(GfxApi_getViewportWidth);
 EI(keyStr.equals("getViewportHeight", CPL_STR_HASH("getViewportHeight")))
RET CNF(GfxApi_getViewportHeight);
 EI(keyStr.equals("setScissor", CPL_STR_HASH("setScissor")))
RET CNF(GfxApi_setScissor);
 EI(keyStr.equals("getScissorLeft", CPL_STR_HASH("getScissorLeft")))
RET CNF(GfxApi_getScissorLeft);
 EI(keyStr.equals("getScissorBottom", CPL_STR_HASH("getScissorBottom")))
RET CNF(GfxApi_getScissorBottom);
 EI(keyStr.equals("getScissorWidth", CPL_STR_HASH("getScissorWidth")))
RET CNF(GfxApi_getScissorWidth);
 EI(keyStr.equals("getScissorHeight", CPL_STR_HASH("getScissorHeight")))
RET CNF(GfxApi_getScissorHeight);
 EI(keyStr.equals("setScissorEnabled", CPL_STR_HASH("setScissorEnabled")))
RET CNF(GfxApi_setScissorEnabled);
 EI(keyStr.equals("getScissorEnabled", CPL_STR_HASH("getScissorEnabled")))
RET CNF(GfxApi_getScissorEnabled);
 EI(keyStr.equals("setTessPatchSize", CPL_STR_HASH("setTessPatchSize")))
RET CNF(GfxApi_setTessPatchSize);
 EI(keyStr.equals("getTessPatchSize", CPL_STR_HASH("getTessPatchSize")))
RET CNF(GfxApi_getTessPatchSize);
 else
 CATE(KE,"Unknown member for GfxApi."));
}
}
RET CN;
}

void GfxApi_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for GfxApi."));
}
}
}

SV GfxApi_getViewportHeight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getViewportHeight" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getViewportHeight());
;
}
CATE(TE,UFOF("GfxApi::getViewportHeight.")));
RET CN;
}

SV GfxApi_getScissorWidth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getScissorWidth" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScissorWidth());
;
}
CATE(TE,UFOF("GfxApi::getScissorWidth.")));
RET CN;
}

SV GfxApi_setDepthFunction(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setDepthFunction" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxDepthFunction))
{
( f->setDepthFunction(val_to_c<std::remove_reference<GfxDepthFunction>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setDepthFunction.")));
RET CN;
}

SV GfxApi_setCurrentFramebuffer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setCurrentFramebuffer" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxFramebuffer *))
{
( f->setCurrentFramebuffer(val_to_c<std::remove_reference<GfxFramebuffer *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setCurrentFramebuffer.")));
RET CN;
}

SV GfxApi_createTextureImpl(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::createTextureImpl" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

CATE(TE,UFOF("GfxApi::createTextureImpl.")));
RET CN;
}

SV GfxApi_draw(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::draw" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->draw(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::draw.")));
RET CN;
}

SV GfxApi_popState(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::popState" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->popState());
RET CN;
}
CATE(TE,UFOF("GfxApi::popState.")));
RET CN;
}

SV GfxApi_getBlendModeAlpha(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendModeAlpha" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendModeAlpha());
;
}
CATE(TE,UFOF("GfxApi::getBlendModeAlpha.")));
RET CN;
}

SV GfxApi_getDepthFunction(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getDepthFunction" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDepthFunction());
;
}
CATE(TE,UFOF("GfxApi::getDepthFunction.")));
RET CN;
}

SV GfxApi_pushState(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::pushState" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->pushState());
RET CN;
}
CATE(TE,UFOF("GfxApi::pushState.")));
RET CN;
}

SV GfxApi_getTessPatchSize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getTessPatchSize" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getTessPatchSize());
;
}
CATE(TE,UFOF("GfxApi::getTessPatchSize.")));
RET CN;
}

SV GfxApi_getViewportLeft(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getViewportLeft" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getViewportLeft());
;
}
CATE(TE,UFOF("GfxApi::getViewportLeft.")));
RET CN;
}

SV GfxApi_setViewport(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setViewport" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==5)
if(1&&TS(a[1],uint16_t)&&TS(a[2],uint16_t)&&TS(a[3],uint16_t)&&TS(a[4],uint16_t))
{
( f->setViewport(val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[4])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setViewport.")));
RET CN;
}

SV GfxApi_getTessControlShader(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getTessControlShader" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getTessControlShader());
;
}
CATE(TE,UFOF("GfxApi::getTessControlShader.")));
RET CN;
}

SV GfxApi_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::end" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->end());
RET CN;
}
CATE(TE,UFOF("GfxApi::end.")));
RET CN;
}

SV GfxApi_uniformU(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::uniformU" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],uint32_t))
{
( f->uniformU(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("GfxApi::uniformU.")));
RET CN;
}

SV GfxApi_getScissorLeft(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getScissorLeft" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScissorLeft());
;
}
CATE(TE,UFOF("GfxApi::getScissorLeft.")));
RET CN;
}

SV GfxApi_setScissor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setScissor" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==5)
if(1&&TS(a[1],uint16_t)&&TS(a[2],uint16_t)&&TS(a[3],uint16_t)&&TS(a[4],uint16_t))
{
( f->setScissor(val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[4])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setScissor.")));
RET CN;
}

SV GfxApi_clearColor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::clearColor" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],Float4))
{
( f->clearColor(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<Float4>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],Int4))
{
( f->clearColor(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<Int4>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],UInt4))
{
( f->clearColor(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<UInt4>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxApi::clearColor.")));
RET CN;
}

SV GfxApi_getBlendDstFactorAlpha(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendDstFactorAlpha" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendDstFactorAlpha());
;
}
CATE(TE,UFOF("GfxApi::getBlendDstFactorAlpha.")));
RET CN;
}

SV GfxApi_getBlendConstantColorR(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendConstantColorR" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendConstantColorR());
;
}
CATE(TE,UFOF("GfxApi::getBlendConstantColorR.")));
RET CN;
}

SV GfxApi_uniform(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::uniform" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],float))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const Float2 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Float2 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const Float3 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const Float4 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Float4 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],int32_t))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const Int2 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Int2 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const Int3 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Int3 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const Int4 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Int4 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],uint32_t))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const UInt2 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const UInt2 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const UInt3 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const UInt3 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const UInt4 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const UInt4 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const Matrix3x3 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Matrix3x3 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const Matrix4x4 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Matrix4x4 &>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("GfxApi::uniform.")));
RET CN;
}

SV GfxApi_setMesh(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setMesh" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxMesh *))
{
( f->setMesh(val_to_c<std::remove_reference<GfxMesh *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setMesh.")));
RET CN;
}

SV GfxApi_addUBOBinding(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::addUBOBinding" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const GfxBuffer *))
{
( f->addUBOBinding(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const GfxBuffer *>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("GfxApi::addUBOBinding.")));
RET CN;
}

SV GfxApi_getBlendModeRGB(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendModeRGB" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendModeRGB());
;
}
CATE(TE,UFOF("GfxApi::getBlendModeRGB.")));
RET CN;
}

SV GfxApi_setScissorEnabled(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setScissorEnabled" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],bool))
{
( f->setScissorEnabled(val_to_c<std::remove_reference<bool>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setScissorEnabled.")));
RET CN;
}

SV GfxApi_getBlendConstantColorG(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendConstantColorG" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendConstantColorG());
;
}
CATE(TE,UFOF("GfxApi::getBlendConstantColorG.")));
RET CN;
}

SV GfxApi_createFramebuffer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::createFramebuffer" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
GfxFramebuffer * r=f->createFramebuffer();
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("GfxApi::createFramebuffer.")));
RET CN;
}

SV GfxApi_getMaxTextureSize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getMaxTextureSize" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getMaxTextureSize());
;
}
CATE(TE,UFOF("GfxApi::getMaxTextureSize.")));
RET CN;
}

SV GfxApi_getVertexShader(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getVertexShader" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getVertexShader());
;
}
CATE(TE,UFOF("GfxApi::getVertexShader.")));
RET CN;
}

SV GfxApi_getBlendSrcFactorRGB(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendSrcFactorRGB" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendSrcFactorRGB());
;
}
CATE(TE,UFOF("GfxApi::getBlendSrcFactorRGB.")));
RET CN;
}

SV GfxApi_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::begin" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==6)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],GfxCompiledShader *)&&TS(a[3],GfxCompiledShader *)&&TS(a[4],GfxCompiledShader *)&&TS(a[5],GfxCompiledShader *))
{
( f->begin(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[5])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],GfxShaderCombination *))
{
( f->begin(val_to_c<std::remove_reference<GfxShaderCombination *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::begin.")));
RET CN;
}

SV GfxApi_setTessPatchSize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setTessPatchSize" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->setTessPatchSize(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setTessPatchSize.")));
RET CN;
}

SV GfxApi_getViewportWidth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getViewportWidth" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getViewportWidth());
;
}
CATE(TE,UFOF("GfxApi::getViewportWidth.")));
RET CN;
}

SV GfxApi_getWriteDepth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getWriteDepth" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWriteDepth());
;
}
CATE(TE,UFOF("GfxApi::getWriteDepth.")));
RET CN;
}

SV GfxApi_setBlendFactors(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setBlendFactors" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==5)
if(1&&TS(a[1],GfxBlendFactor)&&TS(a[2],GfxBlendFactor)&&TS(a[3],GfxBlendFactor)&&TS(a[4],GfxBlendFactor))
{
( f->setBlendFactors(val_to_c<std::remove_reference<GfxBlendFactor>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxBlendFactor>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<GfxBlendFactor>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<GfxBlendFactor>::type>::f(ctx,a[4])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setBlendFactors.")));
RET CN;
}

SV GfxApi_getViewportBottom(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getViewportBottom" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getViewportBottom());
;
}
CATE(TE,UFOF("GfxApi::getViewportBottom.")));
RET CN;
}

SV GfxApi_getDriver(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getDriver" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDriver());
;
}
CATE(TE,UFOF("GfxApi::getDriver.")));
RET CN;
}

SV GfxApi_setBlendMode(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setBlendMode" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],GfxBlendMode)&&TS(a[2],GfxBlendMode))
{
( f->setBlendMode(val_to_c<std::remove_reference<GfxBlendMode>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxBlendMode>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setBlendMode.")));
RET CN;
}

SV GfxApi_setWriteDepth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setWriteDepth" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],bool))
{
( f->setWriteDepth(val_to_c<std::remove_reference<bool>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setWriteDepth.")));
RET CN;
}

SV GfxApi_createBuffer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::createBuffer" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
GfxBuffer * r=f->createBuffer();
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("GfxApi::createBuffer.")));
RET CN;
}

SV GfxApi_getTessEvalShader(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getTessEvalShader" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getTessEvalShader());
;
}
CATE(TE,UFOF("GfxApi::getTessEvalShader.")));
RET CN;
}

SV GfxApi_getScissorEnabled(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getScissorEnabled" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScissorEnabled());
;
}
CATE(TE,UFOF("GfxApi::getScissorEnabled.")));
RET CN;
}

SV GfxApi_getBlendConstantColor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendConstantColor" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

CATE(TE,UFOF("GfxApi::getBlendConstantColor.")));
RET CN;
}

SV GfxApi_clearDepth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::clearDepth" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->clearDepth(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::clearDepth.")));
RET CN;
}

SV GfxApi_setBlendConstantColor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setBlendConstantColor" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==5)
if(1&&TS(a[1],uint8_t)&&TS(a[2],uint8_t)&&TS(a[3],uint8_t)&&TS(a[4],uint8_t))
{
( f->setBlendConstantColor(val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[4])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setBlendConstantColor.")));
RET CN;
}

SV GfxApi_setBlendingEnabled(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setBlendingEnabled" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],bool))
{
( f->setBlendingEnabled(val_to_c<std::remove_reference<bool>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setBlendingEnabled.")));
RET CN;
}

SV GfxApi_getBlendSrcFactorAlpha(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendSrcFactorAlpha" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendSrcFactorAlpha());
;
}
CATE(TE,UFOF("GfxApi::getBlendSrcFactorAlpha.")));
RET CN;
}

SV GfxApi_createTimer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::createTimer" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
GPUTimer * r=f->createTimer();
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("GfxApi::createTimer.")));
RET CN;
}

SV GfxApi_getScissorBottom(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getScissorBottom" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScissorBottom());
;
}
CATE(TE,UFOF("GfxApi::getScissorBottom.")));
RET CN;
}

SV GfxApi_getBlendDstFactorRGB(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendDstFactorRGB" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendDstFactorRGB());
;
}
CATE(TE,UFOF("GfxApi::getBlendDstFactorRGB.")));
RET CN;
}

SV GfxApi_getFragmentShader(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getFragmentShader" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFragmentShader());
;
}
CATE(TE,UFOF("GfxApi::getFragmentShader.")));
RET CN;
}

SV GfxApi_getBlendConstantColorA(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendConstantColorA" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendConstantColorA());
;
}
CATE(TE,UFOF("GfxApi::getBlendConstantColorA.")));
RET CN;
}

SV GfxApi_addTextureBinding(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::addTextureBinding" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==5)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],GfxTexture *)&&TS(a[4],TextureSampler))
{
( f->addTextureBinding(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<TextureSampler>::type>::f(ctx,a[4])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],GfxTexture *))
{
( f->addTextureBinding(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("GfxApi::addTextureBinding.")));
RET CN;
}

SV GfxApi_getBlendConstantColorB(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendConstantColorB" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendConstantColorB());
;
}
CATE(TE,UFOF("GfxApi::getBlendConstantColorB.")));
RET CN;
}

SV GfxApi_getScissorHeight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getScissorHeight" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScissorHeight());
;
}
CATE(TE,UFOF("GfxApi::getScissorHeight.")));
RET CN;
}

SV GfxApi_isBlendingEnabled(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::isBlendingEnabled" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->isBlendingEnabled());
;
}
CATE(TE,UFOF("GfxApi::isBlendingEnabled.")));
RET CN;
}

SV GfxApi_resetState(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::resetState" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->resetState());
RET CN;
}
CATE(TE,UFOF("GfxApi::resetState.")));
RET CN;
}

SV GfxApi_getGeometryShader(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getGeometryShader" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGeometryShader());
;
}
CATE(TE,UFOF("GfxApi::getGeometryShader.")));
RET CN;
}

void ResourceManager_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,ResourceManager))
CATE(TE,"ResourceManager::__del__ expects ResourceManager as first argument."));

SCRIPT_DELETE((ResourceManager*)f->data);
}SV ResourceManager_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager's constructor" EAOE));
if(!TS(a[0],ResourceManager))
CATE(TE,"ResourceManager's constructor expects ResourceManager as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(ResourceManager));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(ResourceManager_funcs,p,EXT->ResourceManager_typeID);
}CATE(TE,UFOF("ResourceManager's constructor.")));
RET CN;
}

SV ResourceManager_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("ResourceManager");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(ResourceManager_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(ResourceManager_new);
else
 CATE(KE,"Unknown member for ResourceManager."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(ResourceManager_new);
 EI(keyStr.equals("loadShader", CPL_STR_HASH("loadShader")))
RET CNF(ResourceManager_loadShader);
 EI(keyStr.equals("loadTexture", CPL_STR_HASH("loadTexture")))
RET CNF(ResourceManager_loadTexture);
 EI(keyStr.equals("loadMesh", CPL_STR_HASH("loadMesh")))
RET CNF(ResourceManager_loadMesh);
 EI(keyStr.equals("loadMaterial", CPL_STR_HASH("loadMaterial")))
RET CNF(ResourceManager_loadMaterial);
 EI(keyStr.equals("loadModel", CPL_STR_HASH("loadModel")))
RET CNF(ResourceManager_loadModel);
 EI(keyStr.equals("loadScene", CPL_STR_HASH("loadScene")))
RET CNF(ResourceManager_loadScene);
 EI(keyStr.equals("loadScript", CPL_STR_HASH("loadScript")))
RET CNF(ResourceManager_loadScript);
 EI(keyStr.equals("loadPhysicsShape", CPL_STR_HASH("loadPhysicsShape")))
RET CNF(ResourceManager_loadPhysicsShape);
 EI(keyStr.equals("loadAudio", CPL_STR_HASH("loadAudio")))
RET CNF(ResourceManager_loadAudio);
 EI(keyStr.equals("loadFont", CPL_STR_HASH("loadFont")))
RET CNF(ResourceManager_loadFont);
 EI(keyStr.equals("load", CPL_STR_HASH("load")))
RET CNF(ResourceManager_load);
 EI(keyStr.equals("loadShaderAndCopy", CPL_STR_HASH("loadShaderAndCopy")))
RET CNF(ResourceManager_loadShaderAndCopy);
 EI(keyStr.equals("loadTextureAndCopy", CPL_STR_HASH("loadTextureAndCopy")))
RET CNF(ResourceManager_loadTextureAndCopy);
 EI(keyStr.equals("loadMeshAndCopy", CPL_STR_HASH("loadMeshAndCopy")))
RET CNF(ResourceManager_loadMeshAndCopy);
 EI(keyStr.equals("loadMaterialAndCopy", CPL_STR_HASH("loadMaterialAndCopy")))
RET CNF(ResourceManager_loadMaterialAndCopy);
 EI(keyStr.equals("loadModelAndCopy", CPL_STR_HASH("loadModelAndCopy")))
RET CNF(ResourceManager_loadModelAndCopy);
 EI(keyStr.equals("loadSceneAndCopy", CPL_STR_HASH("loadSceneAndCopy")))
RET CNF(ResourceManager_loadSceneAndCopy);
 EI(keyStr.equals("loadScriptAndCopy", CPL_STR_HASH("loadScriptAndCopy")))
RET CNF(ResourceManager_loadScriptAndCopy);
 EI(keyStr.equals("loadPhysicsShapeAndCopy", CPL_STR_HASH("loadPhysicsShapeAndCopy")))
RET CNF(ResourceManager_loadPhysicsShapeAndCopy);
 EI(keyStr.equals("loadAudioAndCopy", CPL_STR_HASH("loadAudioAndCopy")))
RET CNF(ResourceManager_loadAudioAndCopy);
 EI(keyStr.equals("loadFontAndCopy", CPL_STR_HASH("loadFontAndCopy")))
RET CNF(ResourceManager_loadFontAndCopy);
 EI(keyStr.equals("loadAndCopy", CPL_STR_HASH("loadAndCopy")))
RET CNF(ResourceManager_loadAndCopy);
 EI(keyStr.equals("isResource", CPL_STR_HASH("isResource")))
RET CNF(ResourceManager_isResource);
 EI(keyStr.equals("cleanupResources", CPL_STR_HASH("cleanupResources")))
RET CNF(ResourceManager_cleanupResources);
 else
 CATE(KE,"Unknown member for ResourceManager."));
}
}
RET CN;
}

void ResourceManager_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for ResourceManager."));
}
}
}

SV ResourceManager_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::load" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],ResType)&&TS(a[2],const Str &))
{
Resource * r=f->load(val_to_c<std::remove_reference<ResType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[2]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::load.")));
RET CN;
}

SV ResourceManager_loadPhysicsShape(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadPhysicsShape" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
PhysicsShape * r=f->loadPhysicsShape(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadPhysicsShape.")));
RET CN;
}

SV ResourceManager_loadFont(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadFont" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
Font * r=f->loadFont(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadFont.")));
RET CN;
}

SV ResourceManager_loadPhysicsShapeAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadPhysicsShapeAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
PhysicsShape * r=f->loadPhysicsShapeAndCopy(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadPhysicsShapeAndCopy.")));
RET CN;
}

SV ResourceManager_loadAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],ResType)&&TS(a[2],const Str &))
{
Resource * r=f->loadAndCopy(val_to_c<std::remove_reference<ResType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[2]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadAndCopy.")));
RET CN;
}

SV ResourceManager_loadModel(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadModel" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
GfxModel * r=f->loadModel(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadModel.")));
RET CN;
}

SV ResourceManager_loadMeshAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadMeshAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
GfxMesh * r=f->loadMeshAndCopy(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadMeshAndCopy.")));
RET CN;
}

SV ResourceManager_cleanupResources(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::cleanupResources" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->cleanupResources());
RET CN;
}
CATE(TE,UFOF("ResourceManager::cleanupResources.")));
RET CN;
}

SV ResourceManager_loadScene(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadScene" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
Scene * r=f->loadScene(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadScene.")));
RET CN;
}

SV ResourceManager_loadAudioAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadAudioAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
Audio * r=f->loadAudioAndCopy(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadAudioAndCopy.")));
RET CN;
}

SV ResourceManager_loadAudio(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadAudio" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
Audio * r=f->loadAudio(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadAudio.")));
RET CN;
}

SV ResourceManager_loadShader(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadShader" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
GfxShader * r=f->loadShader(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadShader.")));
RET CN;
}

SV ResourceManager_loadTexture(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadTexture" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
GfxTexture * r=f->loadTexture(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadTexture.")));
RET CN;
}

SV ResourceManager_loadMaterialAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadMaterialAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
GfxMaterial * r=f->loadMaterialAndCopy(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadMaterialAndCopy.")));
RET CN;
}

SV ResourceManager_loadMaterial(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadMaterial" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
GfxMaterial * r=f->loadMaterial(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadMaterial.")));
RET CN;
}

SV ResourceManager_loadScriptAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadScriptAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

CATE(TE,UFOF("ResourceManager::loadScriptAndCopy.")));
RET CN;
}

SV ResourceManager_loadShaderAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadShaderAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
GfxShader * r=f->loadShaderAndCopy(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadShaderAndCopy.")));
RET CN;
}

SV ResourceManager_loadScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadScript" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

CATE(TE,UFOF("ResourceManager::loadScript.")));
RET CN;
}

SV ResourceManager_loadFontAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadFontAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
Font * r=f->loadFontAndCopy(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadFontAndCopy.")));
RET CN;
}

SV ResourceManager_loadSceneAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadSceneAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
Scene * r=f->loadSceneAndCopy(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadSceneAndCopy.")));
RET CN;
}

SV ResourceManager_loadMesh(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadMesh" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
GfxMesh * r=f->loadMesh(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadMesh.")));
RET CN;
}

SV ResourceManager_loadModelAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadModelAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
GfxModel * r=f->loadModelAndCopy(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadModelAndCopy.")));
RET CN;
}

SV ResourceManager_isResource(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::isResource" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],ResType)&&TS(a[2],const Str &))
{
RET CV( f->isResource(val_to_c<std::remove_reference<ResType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("ResourceManager::isResource.")));
RET CN;
}

SV ResourceManager_loadTextureAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadTextureAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
GfxTexture * r=f->loadTextureAndCopy(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1]));
setAllocInfo((void*)r,AllocInfo(true,false));
RET CV(r);
}
CATE(TE,UFOF("ResourceManager::loadTextureAndCopy.")));
RET CN;
}

void Font_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Font))
CATE(TE,"Font::__del__ expects Font as first argument."));

Font*obj=(Font*)f->data;
if(_scriptDeletePart(obj)){obj->release();}
}SV Font_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font's constructor" EAOE));
if(!TS(a[0],Font))
CATE(TE,"Font's constructor expects Font as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(Font));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Font_funcs,p,EXT->Font_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const Str &)){
void *p = (void *)NEW(TYPE(Font),val_to_c<const Str &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Font_funcs,p,EXT->Font_typeID);
}CATE(TE,UFOF("Font's constructor.")));
RET CN;
}

SV Font_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Font");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Font_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Font_new);
else
 CATE(KE,"Unknown member for Font."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Font_new);
 EI(keyStr.equals("removeContent", CPL_STR_HASH("removeContent")))
RET CNF(Font_removeContent);
 EI(keyStr.equals("predictWidth", CPL_STR_HASH("predictWidth")))
RET CNF(Font_predictWidth);
 EI(keyStr.equals("render", CPL_STR_HASH("render")))
RET CNF(Font_render);
 EI(keyStr.equals("load", CPL_STR_HASH("load")))
RET CNF(Font_load);
 EI(keyStr.equals("save", CPL_STR_HASH("save")))
RET CNF(Font_save);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(Font_copy);
 EI(keyStr.equals("getType", CPL_STR_HASH("getType")))
RET CNF(Font_getType);
 EI(keyStr.equals("release", CPL_STR_HASH("release")))
RET CNF(Font_release);
 EI(keyStr.equals("getRefCount", CPL_STR_HASH("getRefCount")))
RET CNF(Font_getRefCount);
 EI(keyStr.equals("getFilename", CPL_STR_HASH("getFilename")))
RET CNF(Font_getFilename);
 EI(keyStr.equals("setFilename", CPL_STR_HASH("setFilename")))
RET CNF(Font_setFilename);
 else
 CATE(KE,"Unknown member for Font."));
}
}
RET CN;
}

void Font_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for Font."));
}
}
}

SV Font_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::load" EAOE));
Font*f;
f=(Font*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("Font::load.")));
RET CN;
}

SV Font_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::getFilename" EAOE));
Font*f;
f=(Font*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("Font::getFilename.")));
RET CN;
}

SV Font_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::copy" EAOE));
Font*f;
f=(Font*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("Font::copy.")));
RET CN;
}

SV Font_render(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::render" EAOE));
Font*f;
f=(Font*)((NO)a[0].p)->data;

if(a.getCount()==6)
if(1&&TS(a[1],size_t)&&TS(a[2],const Float2 &)&&TS(a[3],const char *)&&TS(a[4],GfxFramebuffer *)&&TS(a[5],const Float3 &))
{
( f->render(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Float2 &>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<GfxFramebuffer *>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[5])));
RET CN;
}
if(a.getCount()==5)
if(1&&TS(a[1],size_t)&&TS(a[2],const Float2 &)&&TS(a[3],const char *)&&TS(a[4],const Float3 &))
{
( f->render(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Float2 &>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[4])));
RET CN;
}
CATE(TE,UFOF("Font::render.")));
RET CN;
}

SV Font_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::getType" EAOE));
Font*f;
f=(Font*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("Font::getType.")));
RET CN;
}

SV Font_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::setFilename" EAOE));
Font*f;
f=(Font*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
( f->setFilename(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Font::setFilename.")));
RET CN;
}

SV Font_predictWidth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::predictWidth" EAOE));
Font*f;
f=(Font*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],const char *))
{
RET CV( f->predictWidth(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("Font::predictWidth.")));
RET CN;
}

SV Font_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::removeContent" EAOE));
Font*f;
f=(Font*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("Font::removeContent.")));
RET CN;
}

SV Font_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::getRefCount" EAOE));
Font*f;
f=(Font*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("Font::getRefCount.")));
RET CN;
}

SV Font_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::release" EAOE));
Font*f;
f=(Font*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("Font::release.")));
RET CN;
}

SV Font_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::save" EAOE));
Font*f;
f=(Font*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("Font::save.")));
RET CN;
}

void AudioSource_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,AudioSource))
CATE(TE,"AudioSource::__del__ expects AudioSource as first argument."));

SCRIPT_DELETE((AudioSource*)f->data);
}SV AudioSource_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSource's constructor" EAOE));
if(!TS(a[0],AudioSource))
CATE(TE,"AudioSource's constructor expects AudioSource as first argument."));
if(a.getCount()==2)
if(true&&TS(a[1],Audio *)){
void *p = (void *)NEW(TYPE(AudioSource),val_to_c<Audio *>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(AudioSource_funcs,p,EXT->AudioSource_typeID);
}CATE(TE,UFOF("AudioSource's constructor.")));
RET CN;
}

SV AudioSource_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("AudioSource");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(AudioSource_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(AudioSource_new);
else
 CATE(KE,"Unknown member for AudioSource."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(AudioSource_new);
 EI(keyStr.equals("getAudio", CPL_STR_HASH("getAudio")))
RET CNF(AudioSource_getAudio);
 EI(keyStr.equals("setAudio", CPL_STR_HASH("setAudio")))
RET CNF(AudioSource_setAudio);
 EI(keyStr.equals("is3d", CPL_STR_HASH("is3d")))
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->is3d);
} EI(keyStr.equals("position", CPL_STR_HASH("position")))
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->position);
} EI(keyStr.equals("referenceDistance", CPL_STR_HASH("referenceDistance")))
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->referenceDistance);
} EI(keyStr.equals("rolloffFactor", CPL_STR_HASH("rolloffFactor")))
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->rolloffFactor);
} EI(keyStr.equals("maxDistance", CPL_STR_HASH("maxDistance")))
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->maxDistance);
} EI(keyStr.equals("volume", CPL_STR_HASH("volume")))
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->volume);
} EI(keyStr.equals("velocity", CPL_STR_HASH("velocity")))
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->velocity);
} EI(keyStr.equals("dopplerFactor", CPL_STR_HASH("dopplerFactor")))
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->dopplerFactor);
} EI(keyStr.equals("offset", CPL_STR_HASH("offset")))
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->offset);
} EI(keyStr.equals("loop", CPL_STR_HASH("loop")))
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->loop);
} EI(keyStr.equals("playing", CPL_STR_HASH("playing")))
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->playing);
} else
 CATE(KE,"Unknown member for AudioSource."));
}
}
RET CN;
}

void AudioSource_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("is3d", CPL_STR_HASH("is3d")))
{
AudioSource*obj=(AudioSource*)f->data;
obj->is3d=val_to_c<decltype(obj->is3d)>::f(ctx,value);
} EI(keyStr.equals("position", CPL_STR_HASH("position")))
{
AudioSource*obj=(AudioSource*)f->data;
obj->position=val_to_c<decltype(obj->position)>::f(ctx,value);
} EI(keyStr.equals("referenceDistance", CPL_STR_HASH("referenceDistance")))
{
AudioSource*obj=(AudioSource*)f->data;
obj->referenceDistance=val_to_c<decltype(obj->referenceDistance)>::f(ctx,value);
} EI(keyStr.equals("rolloffFactor", CPL_STR_HASH("rolloffFactor")))
{
AudioSource*obj=(AudioSource*)f->data;
obj->rolloffFactor=val_to_c<decltype(obj->rolloffFactor)>::f(ctx,value);
} EI(keyStr.equals("maxDistance", CPL_STR_HASH("maxDistance")))
{
AudioSource*obj=(AudioSource*)f->data;
obj->maxDistance=val_to_c<decltype(obj->maxDistance)>::f(ctx,value);
} EI(keyStr.equals("volume", CPL_STR_HASH("volume")))
{
AudioSource*obj=(AudioSource*)f->data;
obj->volume=val_to_c<decltype(obj->volume)>::f(ctx,value);
} EI(keyStr.equals("velocity", CPL_STR_HASH("velocity")))
{
AudioSource*obj=(AudioSource*)f->data;
obj->velocity=val_to_c<decltype(obj->velocity)>::f(ctx,value);
} EI(keyStr.equals("dopplerFactor", CPL_STR_HASH("dopplerFactor")))
{
AudioSource*obj=(AudioSource*)f->data;
obj->dopplerFactor=val_to_c<decltype(obj->dopplerFactor)>::f(ctx,value);
} EI(keyStr.equals("offset", CPL_STR_HASH("offset")))
{
AudioSource*obj=(AudioSource*)f->data;
obj->offset=val_to_c<decltype(obj->offset)>::f(ctx,value);
} EI(keyStr.equals("loop", CPL_STR_HASH("loop")))
{
AudioSource*obj=(AudioSource*)f->data;
obj->loop=val_to_c<decltype(obj->loop)>::f(ctx,value);
} EI(keyStr.equals("playing", CPL_STR_HASH("playing")))
{
AudioSource*obj=(AudioSource*)f->data;
obj->playing=val_to_c<decltype(obj->playing)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for AudioSource."));
}
}
}

SV AudioSource_getAudio(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSource::getAudio" EAOE));
AudioSource*f;
f=(AudioSource*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAudio());
;
}
CATE(TE,UFOF("AudioSource::getAudio.")));
RET CN;
}

SV AudioSource_setAudio(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSource::setAudio" EAOE));
AudioSource*f;
f=(AudioSource*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Audio *))
{
( f->setAudio(val_to_c<std::remove_reference<Audio *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioSource::setAudio.")));
RET CN;
}

void DrawCall_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,DrawCall))
CATE(TE,"DrawCall::__del__ expects DrawCall as first argument."));

SCRIPT_DELETE((DrawCall*)f->data);
}SV DrawCall_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"DrawCall's constructor" EAOE));
if(!TS(a[0],DrawCall))
CATE(TE,"DrawCall's constructor expects DrawCall as first argument."));
if(a.getCount()==3)
if(true&&TS(a[1],GfxMesh *)&&TS(a[2],GfxMaterial *)){
void *p = (void *)NEW(TYPE(DrawCall),val_to_c<GfxMesh *>::f(ctx,a[1]),val_to_c<GfxMaterial *>::f(ctx,a[2]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(DrawCall_funcs,p,EXT->DrawCall_typeID);
}CATE(TE,UFOF("DrawCall's constructor.")));
RET CN;
}

SV DrawCall_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("DrawCall");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(DrawCall_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(DrawCall_new);
else
 CATE(KE,"Unknown member for DrawCall."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(DrawCall_new);
 EI(keyStr.equals("mesh", CPL_STR_HASH("mesh")))
{
DrawCall*obj=(DrawCall*)f->data;
RET CV(obj->mesh);
} EI(keyStr.equals("material", CPL_STR_HASH("material")))
{
DrawCall*obj=(DrawCall*)f->data;
RET CV(obj->material);
} EI(keyStr.equals("worldMatrix", CPL_STR_HASH("worldMatrix")))
{
DrawCall*obj=(DrawCall*)f->data;
RET CV(obj->worldMatrix);
} EI(keyStr.equals("normalMatrix", CPL_STR_HASH("normalMatrix")))
{
DrawCall*obj=(DrawCall*)f->data;
RET CV(obj->normalMatrix);
} EI(keyStr.equals("animState", CPL_STR_HASH("animState")))
{
DrawCall*obj=(DrawCall*)f->data;
RET CV(obj->animState);
} else
 CATE(KE,"Unknown member for DrawCall."));
}
}
RET CN;
}

void DrawCall_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("mesh", CPL_STR_HASH("mesh")))
{
DrawCall*obj=(DrawCall*)f->data;
obj->mesh=val_to_c<decltype(obj->mesh)>::f(ctx,value);
} EI(keyStr.equals("material", CPL_STR_HASH("material")))
{
DrawCall*obj=(DrawCall*)f->data;
obj->material=val_to_c<decltype(obj->material)>::f(ctx,value);
} EI(keyStr.equals("worldMatrix", CPL_STR_HASH("worldMatrix")))
{
DrawCall*obj=(DrawCall*)f->data;
obj->worldMatrix=val_to_c<decltype(obj->worldMatrix)>::f(ctx,value);
} EI(keyStr.equals("normalMatrix", CPL_STR_HASH("normalMatrix")))
{
DrawCall*obj=(DrawCall*)f->data;
obj->normalMatrix=val_to_c<decltype(obj->normalMatrix)>::f(ctx,value);
} EI(keyStr.equals("animState", CPL_STR_HASH("animState")))
{
DrawCall*obj=(DrawCall*)f->data;
obj->animState=val_to_c<decltype(obj->animState)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for DrawCall."));
}
}
}

void Application_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Application))
CATE(TE,"Application::__del__ expects Application as first argument."));

SCRIPT_DELETE((Application*)f->data);
}SV Application_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application's constructor" EAOE));
if(!TS(a[0],Application))
CATE(TE,"Application's constructor expects Application as first argument."));
if(a.getCount()==2)
if(true&&TS(a[1],const char *)){
void *p = (void *)NEW(TYPE(Application),val_to_c<const char *>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Application_funcs,p,EXT->Application_typeID);
}CATE(TE,UFOF("Application's constructor.")));
RET CN;
}

SV Application_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Application");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Application_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Application_new);
else
 CATE(KE,"Unknown member for Application."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Application_new);
 EI(keyStr.equals("mainloop", CPL_STR_HASH("mainloop")))
RET CNF(Application_mainloop);
 EI(keyStr.equals("getPlatform", CPL_STR_HASH("getPlatform")))
RET CNF(Application_getPlatform);
 EI(keyStr.equals("getResourceManager", CPL_STR_HASH("getResourceManager")))
RET CNF(Application_getResourceManager);
 EI(keyStr.equals("getGfxApi", CPL_STR_HASH("getGfxApi")))
RET CNF(Application_getGfxApi);
 EI(keyStr.equals("getFilesystem", CPL_STR_HASH("getFilesystem")))
RET CNF(Application_getFilesystem);
 EI(keyStr.equals("getDebugDrawer", CPL_STR_HASH("getDebugDrawer")))
RET CNF(Application_getDebugDrawer);
 EI(keyStr.equals("getFreeType", CPL_STR_HASH("getFreeType")))
RET CNF(Application_getFreeType);
 EI(keyStr.equals("getAudioDevice", CPL_STR_HASH("getAudioDevice")))
RET CNF(Application_getAudioDevice);
 EI(keyStr.equals("getScriptEngine", CPL_STR_HASH("getScriptEngine")))
RET CNF(Application_getScriptEngine);
 EI(keyStr.equals("setNextScript", CPL_STR_HASH("setNextScript")))
RET CNF(Application_setNextScript);
 EI(keyStr.equals("getNextScript", CPL_STR_HASH("getNextScript")))
RET CNF(Application_getNextScript);
 EI(keyStr.equals("getScript", CPL_STR_HASH("getScript")))
RET CNF(Application_getScript);
 EI(keyStr.equals("getStats", CPL_STR_HASH("getStats")))
RET CNF(Application_getStats);
 EI(keyStr.equals("getExtensions", CPL_STR_HASH("getExtensions")))
RET CNF(Application_getExtensions);
 EI(keyStr.equals("fixedTimestep", CPL_STR_HASH("fixedTimestep")))
{
Application*obj=(Application*)f->data;
RET CV(obj->fixedTimestep);
} EI(keyStr.equals("running", CPL_STR_HASH("running")))
{
Application*obj=(Application*)f->data;
RET CV(obj->running);
} else
 CATE(KE,"Unknown member for Application."));
}
}
RET CN;
}

void Application_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("fixedTimestep", CPL_STR_HASH("fixedTimestep")))
{
Application*obj=(Application*)f->data;
obj->fixedTimestep=val_to_c<decltype(obj->fixedTimestep)>::f(ctx,value);
} EI(keyStr.equals("running", CPL_STR_HASH("running")))
{
Application*obj=(Application*)f->data;
obj->running=val_to_c<decltype(obj->running)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for Application."));
}
}
}

SV Application_getAudioDevice(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getAudioDevice" EAOE));
Application*f;
f=(Application*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAudioDevice());
;
}
CATE(TE,UFOF("Application::getAudioDevice.")));
RET CN;
}

SV Application_getGfxApi(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getGfxApi" EAOE));
Application*f;
f=(Application*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGfxApi());
;
}
CATE(TE,UFOF("Application::getGfxApi.")));
RET CN;
}

SV Application_getResourceManager(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getResourceManager" EAOE));
Application*f;
f=(Application*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getResourceManager());
;
}
CATE(TE,UFOF("Application::getResourceManager.")));
RET CN;
}

SV Application_mainloop(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::mainloop" EAOE));
Application*f;
f=(Application*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->mainloop());
RET CN;
}
CATE(TE,UFOF("Application::mainloop.")));
RET CN;
}

SV Application_getFilesystem(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getFilesystem" EAOE));
Application*f;
f=(Application*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilesystem());
;
}
CATE(TE,UFOF("Application::getFilesystem.")));
RET CN;
}

SV Application_getPlatform(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getPlatform" EAOE));
Application*f;
f=(Application*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getPlatform());
;
}
CATE(TE,UFOF("Application::getPlatform.")));
RET CN;
}

SV Application_getExtensions(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getExtensions" EAOE));
Application*f;
f=(Application*)((NO)a[0].p)->data;

CATE(TE,UFOF("Application::getExtensions.")));
RET CN;
}

SV Application_getNextScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getNextScript" EAOE));
Application*f;
f=(Application*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getNextScript());
;
}
CATE(TE,UFOF("Application::getNextScript.")));
RET CN;
}

SV Application_getScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getScript" EAOE));
Application*f;
f=(Application*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScript());
;
}
CATE(TE,UFOF("Application::getScript.")));
RET CN;
}

SV Application_getStats(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getStats" EAOE));
Application*f;
f=(Application*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getStats());
;
}
CATE(TE,UFOF("Application::getStats.")));
RET CN;
}

SV Application_setNextScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::setNextScript" EAOE));
Application*f;
f=(Application*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Script *))
{
( f->setNextScript(val_to_c<std::remove_reference<Script *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Application::setNextScript.")));
RET CN;
}

SV Application_getDebugDrawer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getDebugDrawer" EAOE));
Application*f;
f=(Application*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDebugDrawer());
;
}
CATE(TE,UFOF("Application::getDebugDrawer.")));
RET CN;
}

SV Application_getScriptEngine(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getScriptEngine" EAOE));
Application*f;
f=(Application*)((NO)a[0].p)->data;

CATE(TE,UFOF("Application::getScriptEngine.")));
RET CN;
}

SV Application_getFreeType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getFreeType" EAOE));
Application*f;
f=(Application*)((NO)a[0].p)->data;

CATE(TE,UFOF("Application::getFreeType.")));
RET CN;
}

void ResizableData_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,ResizableData))
CATE(TE,"ResizableData::__del__ expects ResizableData as first argument."));

SCRIPT_DELETE((ResizableData*)f->data);
}SV ResizableData_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData's constructor" EAOE));
if(!TS(a[0],ResizableData))
CATE(TE,"ResizableData's constructor expects ResizableData as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(ResizableData));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(ResizableData_funcs,p,EXT->ResizableData_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],std::size_t)){
void *p = (void *)NEW(TYPE(ResizableData),val_to_c<std::size_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(ResizableData_funcs,p,EXT->ResizableData_typeID);
}CATE(TE,UFOF("ResizableData's constructor.")));
RET CN;
}

SV ResizableData_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("ResizableData");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(ResizableData_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(ResizableData_new);
else
 CATE(KE,"Unknown member for ResizableData."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(ResizableData_new);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(ResizableData___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(ResizableData___neq__);
 EI(keyStr.equals("getData", CPL_STR_HASH("getData")))
RET CNF(ResizableData_getData);
 EI(keyStr.equals("getSize", CPL_STR_HASH("getSize")))
RET CNF(ResizableData_getSize);
 EI(keyStr.equals("resize", CPL_STR_HASH("resize")))
RET CNF(ResizableData_resize);
 EI(keyStr.equals("insert", CPL_STR_HASH("insert")))
RET CNF(ResizableData_insert);
 EI(keyStr.equals("append", CPL_STR_HASH("append")))
RET CNF(ResizableData_append);
 EI(keyStr.equals("remove", CPL_STR_HASH("remove")))
RET CNF(ResizableData_remove);
 EI(keyStr.equals("clear", CPL_STR_HASH("clear")))
RET CNF(ResizableData_clear);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(ResizableData_copy);
 EI(keyStr.equals("getUInt8", CPL_STR_HASH("getUInt8")))
RET CNF(ResizableData_getUInt8);
 EI(keyStr.equals("getInt8", CPL_STR_HASH("getInt8")))
RET CNF(ResizableData_getInt8);
 EI(keyStr.equals("getUInt16", CPL_STR_HASH("getUInt16")))
RET CNF(ResizableData_getUInt16);
 EI(keyStr.equals("getInt16", CPL_STR_HASH("getInt16")))
RET CNF(ResizableData_getInt16);
 EI(keyStr.equals("getUInt32", CPL_STR_HASH("getUInt32")))
RET CNF(ResizableData_getUInt32);
 EI(keyStr.equals("getInt32", CPL_STR_HASH("getInt32")))
RET CNF(ResizableData_getInt32);
 EI(keyStr.equals("getUInt64", CPL_STR_HASH("getUInt64")))
RET CNF(ResizableData_getUInt64);
 EI(keyStr.equals("getInt64", CPL_STR_HASH("getInt64")))
RET CNF(ResizableData_getInt64);
 EI(keyStr.equals("getFloat32", CPL_STR_HASH("getFloat32")))
RET CNF(ResizableData_getFloat32);
 EI(keyStr.equals("getFloat64", CPL_STR_HASH("getFloat64")))
RET CNF(ResizableData_getFloat64);
 EI(keyStr.equals("getUInt16LE", CPL_STR_HASH("getUInt16LE")))
RET CNF(ResizableData_getUInt16LE);
 EI(keyStr.equals("getInt16LE", CPL_STR_HASH("getInt16LE")))
RET CNF(ResizableData_getInt16LE);
 EI(keyStr.equals("getUInt32LE", CPL_STR_HASH("getUInt32LE")))
RET CNF(ResizableData_getUInt32LE);
 EI(keyStr.equals("getInt32LE", CPL_STR_HASH("getInt32LE")))
RET CNF(ResizableData_getInt32LE);
 EI(keyStr.equals("getUInt64LE", CPL_STR_HASH("getUInt64LE")))
RET CNF(ResizableData_getUInt64LE);
 EI(keyStr.equals("getInt64LE", CPL_STR_HASH("getInt64LE")))
RET CNF(ResizableData_getInt64LE);
 EI(keyStr.equals("getUInt16BE", CPL_STR_HASH("getUInt16BE")))
RET CNF(ResizableData_getUInt16BE);
 EI(keyStr.equals("getInt16BE", CPL_STR_HASH("getInt16BE")))
RET CNF(ResizableData_getInt16BE);
 EI(keyStr.equals("getUInt32BE", CPL_STR_HASH("getUInt32BE")))
RET CNF(ResizableData_getUInt32BE);
 EI(keyStr.equals("getInt32BE", CPL_STR_HASH("getInt32BE")))
RET CNF(ResizableData_getInt32BE);
 EI(keyStr.equals("getUInt64BE", CPL_STR_HASH("getUInt64BE")))
RET CNF(ResizableData_getUInt64BE);
 EI(keyStr.equals("getInt64BE", CPL_STR_HASH("getInt64BE")))
RET CNF(ResizableData_getInt64BE);
 EI(keyStr.equals("setUInt8", CPL_STR_HASH("setUInt8")))
RET CNF(ResizableData_setUInt8);
 EI(keyStr.equals("setInt8", CPL_STR_HASH("setInt8")))
RET CNF(ResizableData_setInt8);
 EI(keyStr.equals("setUInt16", CPL_STR_HASH("setUInt16")))
RET CNF(ResizableData_setUInt16);
 EI(keyStr.equals("setInt16", CPL_STR_HASH("setInt16")))
RET CNF(ResizableData_setInt16);
 EI(keyStr.equals("setUInt32", CPL_STR_HASH("setUInt32")))
RET CNF(ResizableData_setUInt32);
 EI(keyStr.equals("setInt32", CPL_STR_HASH("setInt32")))
RET CNF(ResizableData_setInt32);
 EI(keyStr.equals("setUInt64", CPL_STR_HASH("setUInt64")))
RET CNF(ResizableData_setUInt64);
 EI(keyStr.equals("setInt64", CPL_STR_HASH("setInt64")))
RET CNF(ResizableData_setInt64);
 EI(keyStr.equals("setFloat32", CPL_STR_HASH("setFloat32")))
RET CNF(ResizableData_setFloat32);
 EI(keyStr.equals("setFloat64", CPL_STR_HASH("setFloat64")))
RET CNF(ResizableData_setFloat64);
 EI(keyStr.equals("setUInt16LE", CPL_STR_HASH("setUInt16LE")))
RET CNF(ResizableData_setUInt16LE);
 EI(keyStr.equals("setInt16LE", CPL_STR_HASH("setInt16LE")))
RET CNF(ResizableData_setInt16LE);
 EI(keyStr.equals("setUInt32LE", CPL_STR_HASH("setUInt32LE")))
RET CNF(ResizableData_setUInt32LE);
 EI(keyStr.equals("setInt32LE", CPL_STR_HASH("setInt32LE")))
RET CNF(ResizableData_setInt32LE);
 EI(keyStr.equals("setUInt64LE", CPL_STR_HASH("setUInt64LE")))
RET CNF(ResizableData_setUInt64LE);
 EI(keyStr.equals("setInt64LE", CPL_STR_HASH("setInt64LE")))
RET CNF(ResizableData_setInt64LE);
 EI(keyStr.equals("setUInt16BE", CPL_STR_HASH("setUInt16BE")))
RET CNF(ResizableData_setUInt16BE);
 EI(keyStr.equals("setInt16BE", CPL_STR_HASH("setInt16BE")))
RET CNF(ResizableData_setInt16BE);
 EI(keyStr.equals("setUInt32BE", CPL_STR_HASH("setUInt32BE")))
RET CNF(ResizableData_setUInt32BE);
 EI(keyStr.equals("setInt32BE", CPL_STR_HASH("setInt32BE")))
RET CNF(ResizableData_setInt32BE);
 EI(keyStr.equals("setUInt64BE", CPL_STR_HASH("setUInt64BE")))
RET CNF(ResizableData_setUInt64BE);
 EI(keyStr.equals("setInt64BE", CPL_STR_HASH("setInt64BE")))
RET CNF(ResizableData_setInt64BE);
 EI(keyStr.equals("getChar", CPL_STR_HASH("getChar")))
RET CNF(ResizableData_getChar);
 EI(keyStr.equals("setChar", CPL_STR_HASH("setChar")))
RET CNF(ResizableData_setChar);
 else
 CATE(KE,"Unknown member for ResizableData."));
}
}
RET CN;
}

void ResizableData_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for ResizableData."));
}
}
}

SV ResizableData_getInt64BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt64BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt64BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt64BE.")));
RET CN;
}

SV ResizableData_setUInt8(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt8" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint8_t))
{
( f->setUInt8(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt8.")));
RET CN;
}

SV ResizableData_getUInt64BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt64BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt64BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt64BE.")));
RET CN;
}

SV ResizableData_getUInt16BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt16BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt16BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt16BE.")));
RET CN;
}

SV ResizableData_getUInt64(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt64" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt64(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt64.")));
RET CN;
}

SV ResizableData_getSize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getSize" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getSize());
;
}
CATE(TE,UFOF("ResizableData::getSize.")));
RET CN;
}

SV ResizableData_setUInt16BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt16BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint16_t))
{
( f->setUInt16BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt16BE.")));
RET CN;
}

SV ResizableData_setFloat32(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setFloat32" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],float))
{
( f->setFloat32(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setFloat32.")));
RET CN;
}

SV ResizableData_getUInt8(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt8" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt8(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt8.")));
RET CN;
}

SV ResizableData_setInt16(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt16" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int16_t))
{
( f->setInt16(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int16_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt16.")));
RET CN;
}

SV ResizableData_setInt64(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt64" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int64_t))
{
( f->setInt64(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int64_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt64.")));
RET CN;
}

SV ResizableData_getInt16LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt16LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt16LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt16LE.")));
RET CN;
}

SV ResizableData_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::append" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const ResizableData &))
{
( f->append(val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("ResizableData::append.")));
RET CN;
}

SV ResizableData___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::__neq__" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const ResizableData &))
{
auto v=val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("ResizableData::__neq__.")));
RET CN;
}

SV ResizableData_getInt64(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt64" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt64(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt64.")));
RET CN;
}

SV ResizableData_getFloat64(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getFloat64" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getFloat64(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getFloat64.")));
RET CN;
}

SV ResizableData_setInt64BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt64BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int64_t))
{
( f->setInt64BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int64_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt64BE.")));
RET CN;
}

SV ResizableData_setInt32(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt32" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int32_t))
{
( f->setInt32(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt32.")));
RET CN;
}

SV ResizableData_getInt64LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt64LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt64LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt64LE.")));
RET CN;
}

SV ResizableData_setInt32LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt32LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int32_t))
{
( f->setInt32LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt32LE.")));
RET CN;
}

SV ResizableData_setUInt32(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt32" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint32_t))
{
( f->setUInt32(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt32.")));
RET CN;
}

SV ResizableData_setChar(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setChar" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],char))
{
( f->setChar(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<char>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setChar.")));
RET CN;
}

SV ResizableData_setUInt64LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt64LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint64_t))
{
( f->setUInt64LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint64_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt64LE.")));
RET CN;
}

SV ResizableData_setUInt64BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt64BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint64_t))
{
( f->setUInt64BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint64_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt64BE.")));
RET CN;
}

SV ResizableData_setUInt16LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt16LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint16_t))
{
( f->setUInt16LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt16LE.")));
RET CN;
}

SV ResizableData_setUInt32LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt32LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint32_t))
{
( f->setUInt32LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt32LE.")));
RET CN;
}

SV ResizableData_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getData" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

CATE(TE,UFOF("ResizableData::getData.")));
RET CN;
}

SV ResizableData_setUInt16(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt16" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint16_t))
{
( f->setUInt16(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt16.")));
RET CN;
}

SV ResizableData_getUInt32(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt32" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt32(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt32.")));
RET CN;
}

SV ResizableData_setInt16LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt16LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int16_t))
{
( f->setInt16LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int16_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt16LE.")));
RET CN;
}

SV ResizableData_getUInt16(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt16" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt16(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt16.")));
RET CN;
}

SV ResizableData_getUInt16LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt16LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt16LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt16LE.")));
RET CN;
}

SV ResizableData_setInt32BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt32BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int32_t))
{
( f->setInt32BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt32BE.")));
RET CN;
}

SV ResizableData_getUInt64LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt64LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt64LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt64LE.")));
RET CN;
}

SV ResizableData_setFloat64(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setFloat64" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],double))
{
( f->setFloat64(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<double>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setFloat64.")));
RET CN;
}

SV ResizableData_getUInt32BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt32BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt32BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt32BE.")));
RET CN;
}

SV ResizableData_setInt16BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt16BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int16_t))
{
( f->setInt16BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int16_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt16BE.")));
RET CN;
}

SV ResizableData_getInt32(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt32" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt32(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt32.")));
RET CN;
}

SV ResizableData_getInt32BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt32BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt32BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt32BE.")));
RET CN;
}

SV ResizableData_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::copy" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("ResizableData::copy.")));
RET CN;
}

SV ResizableData___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::__eq__" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const ResizableData &))
{
auto v=val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("ResizableData::__eq__.")));
RET CN;
}

SV ResizableData_resize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::resize" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],std::size_t))
{
( f->resize(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("ResizableData::resize.")));
RET CN;
}

SV ResizableData_getFloat32(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getFloat32" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getFloat32(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getFloat32.")));
RET CN;
}

SV ResizableData_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::insert" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const ResizableData &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::insert.")));
RET CN;
}

SV ResizableData_getInt16(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt16" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt16(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt16.")));
RET CN;
}

SV ResizableData_getInt16BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt16BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt16BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt16BE.")));
RET CN;
}

SV ResizableData_setUInt32BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt32BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint32_t))
{
( f->setUInt32BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt32BE.")));
RET CN;
}

SV ResizableData_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::clear" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("ResizableData::clear.")));
RET CN;
}

SV ResizableData_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::remove" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::remove.")));
RET CN;
}

SV ResizableData_setUInt64(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt64" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint64_t))
{
( f->setUInt64(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint64_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt64.")));
RET CN;
}

SV ResizableData_setInt64LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt64LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int64_t))
{
( f->setInt64LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int64_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt64LE.")));
RET CN;
}

SV ResizableData_setInt8(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt8" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int8_t))
{
( f->setInt8(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int8_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt8.")));
RET CN;
}

SV ResizableData_getUInt32LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt32LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt32LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt32LE.")));
RET CN;
}

SV ResizableData_getInt8(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt8" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt8(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt8.")));
RET CN;
}

SV ResizableData_getInt32LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt32LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt32LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt32LE.")));
RET CN;
}

SV ResizableData_getChar(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getChar" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getChar(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getChar.")));
RET CN;
}

void GfxBuffer_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GfxBuffer))
CATE(TE,"GfxBuffer::__del__ expects GfxBuffer as first argument."));

SCRIPT_DELETE((GfxBuffer*)f->data);
}SV GfxBuffer_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxBuffer's constructor" EAOE));
if(!TS(a[0],GfxBuffer))
CATE(TE,"GfxBuffer's constructor expects GfxBuffer as first argument."));
CATE(TE,UFOF("GfxBuffer's constructor.")));
}

SV GfxBuffer_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxBuffer");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxBuffer_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxBuffer_new);
else
 CATE(KE,"Unknown member for GfxBuffer."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxBuffer_new);
 EI(keyStr.equals("allocData", CPL_STR_HASH("allocData")))
RET CNF(GfxBuffer_allocData);
 EI(keyStr.equals("setData", CPL_STR_HASH("setData")))
RET CNF(GfxBuffer_setData);
 EI(keyStr.equals("getData", CPL_STR_HASH("getData")))
RET CNF(GfxBuffer_getData);
 EI(keyStr.equals("getSize", CPL_STR_HASH("getSize")))
RET CNF(GfxBuffer_getSize);
 else
 CATE(KE,"Unknown member for GfxBuffer."));
}
}
RET CN;
}

void GfxBuffer_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for GfxBuffer."));
}
}
}

SV GfxBuffer_getSize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxBuffer::getSize" EAOE));
GfxBuffer*f;
f=(GfxBuffer*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getSize());
;
}
CATE(TE,UFOF("GfxBuffer::getSize.")));
RET CN;
}

SV GfxBuffer_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxBuffer::getData" EAOE));
GfxBuffer*f;
f=(GfxBuffer*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t))
{
RET CV( f->getData(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("GfxBuffer::getData.")));
RET CN;
}

SV GfxBuffer_allocData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxBuffer::allocData" EAOE));
GfxBuffer*f;
f=(GfxBuffer*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],const ResizableData &)&&TS(a[2],GfxBufferUsage))
{
( f->allocData(val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxBufferUsage>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxBuffer::allocData.")));
RET CN;
}

SV GfxBuffer_setData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxBuffer::setData" EAOE));
GfxBuffer*f;
f=(GfxBuffer*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],const ResizableData &))
{
( f->setData(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxBuffer::setData.")));
RET CN;
}

void GfxMaterial_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GfxMaterial))
CATE(TE,"GfxMaterial::__del__ expects GfxMaterial as first argument."));

GfxMaterial*obj=(GfxMaterial*)f->data;
if(_scriptDeletePart(obj)){obj->release();}
}SV GfxMaterial_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial's constructor" EAOE));
if(!TS(a[0],GfxMaterial))
CATE(TE,"GfxMaterial's constructor expects GfxMaterial as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(GfxMaterial));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxMaterial_funcs,p,EXT->GfxMaterial_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const Str &)){
void *p = (void *)NEW(TYPE(GfxMaterial),val_to_c<const Str &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxMaterial_funcs,p,EXT->GfxMaterial_typeID);
}CATE(TE,UFOF("GfxMaterial's constructor.")));
RET CN;
}

SV GfxMaterial_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxMaterial");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxMaterial_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxMaterial_new);
else
 CATE(KE,"Unknown member for GfxMaterial."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxMaterial_new);
 EI(keyStr.equals("removeContent", CPL_STR_HASH("removeContent")))
RET CNF(GfxMaterial_removeContent);
 EI(keyStr.equals("save", CPL_STR_HASH("save")))
RET CNF(GfxMaterial_save);
 EI(keyStr.equals("setScript", CPL_STR_HASH("setScript")))
RET CNF(GfxMaterial_setScript);
 EI(keyStr.equals("getScriptInst", CPL_STR_HASH("getScriptInst")))
RET CNF(GfxMaterial_getScriptInst);
 EI(keyStr.equals("setupRender", CPL_STR_HASH("setupRender")))
RET CNF(GfxMaterial_setupRender);
 EI(keyStr.equals("load", CPL_STR_HASH("load")))
RET CNF(GfxMaterial_load);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(GfxMaterial_copy);
 EI(keyStr.equals("getType", CPL_STR_HASH("getType")))
RET CNF(GfxMaterial_getType);
 EI(keyStr.equals("release", CPL_STR_HASH("release")))
RET CNF(GfxMaterial_release);
 EI(keyStr.equals("getRefCount", CPL_STR_HASH("getRefCount")))
RET CNF(GfxMaterial_getRefCount);
 EI(keyStr.equals("getFilename", CPL_STR_HASH("getFilename")))
RET CNF(GfxMaterial_getFilename);
 EI(keyStr.equals("setFilename", CPL_STR_HASH("setFilename")))
RET CNF(GfxMaterial_setFilename);
 EI(keyStr.equals("forward", CPL_STR_HASH("forward")))
{
GfxMaterial*obj=(GfxMaterial*)f->data;
RET CV(obj->forward);
} else
 CATE(KE,"Unknown member for GfxMaterial."));
}
}
RET CN;
}

void GfxMaterial_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("forward", CPL_STR_HASH("forward")))
{
GfxMaterial*obj=(GfxMaterial*)f->data;
obj->forward=val_to_c<decltype(obj->forward)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for GfxMaterial."));
}
}
}

SV GfxMaterial_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::load" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("GfxMaterial::load.")));
RET CN;
}

SV GfxMaterial_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::getFilename" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("GfxMaterial::getFilename.")));
RET CN;
}

SV GfxMaterial_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::copy" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("GfxMaterial::copy.")));
RET CN;
}

SV GfxMaterial_setScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::setScript" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Script *))
{
( f->setScript(val_to_c<std::remove_reference<Script *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxMaterial::setScript.")));
RET CN;
}

SV GfxMaterial_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::setFilename" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
( f->setFilename(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxMaterial::setFilename.")));
RET CN;
}

SV GfxMaterial_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::getType" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("GfxMaterial::getType.")));
RET CN;
}

SV GfxMaterial_setupRender(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::setupRender" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],GfxAnimationState *)&&TS(a[2],const Camera &))
{
( f->setupRender(val_to_c<std::remove_reference<GfxAnimationState *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Camera &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxMaterial::setupRender.")));
RET CN;
}

SV GfxMaterial_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::removeContent" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("GfxMaterial::removeContent.")));
RET CN;
}

SV GfxMaterial_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::getRefCount" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("GfxMaterial::getRefCount.")));
RET CN;
}

SV GfxMaterial_getScriptInst(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::getScriptInst" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScriptInst());
;
}
CATE(TE,UFOF("GfxMaterial::getScriptInst.")));
RET CN;
}

SV GfxMaterial_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::release" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("GfxMaterial::release.")));
RET CN;
}

SV GfxMaterial_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::save" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("GfxMaterial::save.")));
RET CN;
}

void GfxMeshAttrib_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GfxMeshAttrib))
CATE(TE,"GfxMeshAttrib::__del__ expects GfxMeshAttrib as first argument."));

SCRIPT_DELETE((GfxMeshAttrib*)f->data);
}SV GfxMeshAttrib_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxMeshAttrib's constructor" EAOE));
if(!TS(a[0],GfxMeshAttrib))
CATE(TE,"GfxMeshAttrib's constructor expects GfxMeshAttrib as first argument."));
RET STG::createNativeObject(GfxMeshAttrib_funcs,NEW(TYPE(GfxMeshAttrib)),EXT->GfxMeshAttrib_typeID);
}

SV GfxMeshAttrib_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxMeshAttrib");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxMeshAttrib_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxMeshAttrib_new);
else
 CATE(KE,"Unknown member for GfxMeshAttrib."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxMeshAttrib_new);
 EI(keyStr.equals("type", CPL_STR_HASH("type")))
{
GfxMeshAttrib*obj=(GfxMeshAttrib*)f->data;
RET CV(obj->type);
} EI(keyStr.equals("dataType", CPL_STR_HASH("dataType")))
{
GfxMeshAttrib*obj=(GfxMeshAttrib*)f->data;
RET CV(obj->dataType);
} EI(keyStr.equals("data", CPL_STR_HASH("data")))
{
GfxMeshAttrib*obj=(GfxMeshAttrib*)f->data;
RET CV(obj->data);
} else
 CATE(KE,"Unknown member for GfxMeshAttrib."));
}
}
RET CN;
}

void GfxMeshAttrib_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("type", CPL_STR_HASH("type")))
{
GfxMeshAttrib*obj=(GfxMeshAttrib*)f->data;
obj->type=val_to_c<decltype(obj->type)>::f(ctx,value);
} EI(keyStr.equals("dataType", CPL_STR_HASH("dataType")))
{
GfxMeshAttrib*obj=(GfxMeshAttrib*)f->data;
obj->dataType=val_to_c<decltype(obj->dataType)>::f(ctx,value);
} EI(keyStr.equals("data", CPL_STR_HASH("data")))
{
GfxMeshAttrib*obj=(GfxMeshAttrib*)f->data;
obj->data=val_to_c<decltype(obj->data)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for GfxMeshAttrib."));
}
}
}

void Int2_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,T2<int32_t>))
CATE(TE,"Int2::__del__ expects Int2 as first argument."));

SCRIPT_DELETE((T2<int32_t>*)f->data);
}SV Int2_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2's constructor" EAOE));
if(!TS(a[0],T2<int32_t>))
CATE(TE,"Int2's constructor expects Int2 as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(T2<int32_t>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int2_funcs,p,EXT->Int2_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],int32_t)){
void *p = (void *)NEW(TYPE(T2<int32_t>),val_to_c<int32_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int2_funcs,p,EXT->Int2_typeID);
}if(a.getCount()==3)
if(true&&TS(a[1],int32_t)&&TS(a[2],int32_t)){
void *p = (void *)NEW(TYPE(T2<int32_t>),val_to_c<int32_t>::f(ctx,a[1]),val_to_c<int32_t>::f(ctx,a[2]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int2_funcs,p,EXT->Int2_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T2<float> &)){
void *p = (void *)NEW(TYPE(T2<int32_t>),val_to_c<const T2<float> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int2_funcs,p,EXT->Int2_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T2<int32_t> &)){
void *p = (void *)NEW(TYPE(T2<int32_t>),val_to_c<const T2<int32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int2_funcs,p,EXT->Int2_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const T2<uint32_t> &)){
void *p = (void *)NEW(TYPE(T2<int32_t>),val_to_c<const T2<uint32_t> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Int2_funcs,p,EXT->Int2_typeID);
}CATE(TE,UFOF("Int2's constructor.")));
RET CN;
}

SV Int2_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Int2");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Int2_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Int2_new);
else
 CATE(KE,"Unknown member for Int2."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Int2_new);
 EI(keyStr.equals("__add__", CPL_STR_HASH("__add__")))
RET CNF(Int2___add__);
 EI(keyStr.equals("__sub__", CPL_STR_HASH("__sub__")))
RET CNF(Int2___sub__);
 EI(keyStr.equals("__mul__", CPL_STR_HASH("__mul__")))
RET CNF(Int2___mul__);
 EI(keyStr.equals("__div__", CPL_STR_HASH("__div__")))
RET CNF(Int2___div__);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(Int2___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(Int2___neq__);
 EI(keyStr.equals("__less__", CPL_STR_HASH("__less__")))
RET CNF(Int2___less__);
 EI(keyStr.equals("__grtr__", CPL_STR_HASH("__grtr__")))
RET CNF(Int2___grtr__);
 EI(keyStr.equals("__leq__", CPL_STR_HASH("__leq__")))
RET CNF(Int2___leq__);
 EI(keyStr.equals("__geq__", CPL_STR_HASH("__geq__")))
RET CNF(Int2___geq__);
 EI(keyStr.equals("sum", CPL_STR_HASH("sum")))
RET CNF(Int2_sum);
 EI(keyStr.equals("length", CPL_STR_HASH("length")))
RET CNF(Int2_length);
 EI(keyStr.equals("lengthSquared", CPL_STR_HASH("lengthSquared")))
RET CNF(Int2_lengthSquared);
 EI(keyStr.equals("dot", CPL_STR_HASH("dot")))
RET CNF(Int2_dot);
 EI(keyStr.equals("distance", CPL_STR_HASH("distance")))
RET CNF(Int2_distance);
 EI(keyStr.equals("distanceSquared", CPL_STR_HASH("distanceSquared")))
RET CNF(Int2_distanceSquared);
 EI(keyStr.equals("normalize", CPL_STR_HASH("normalize")))
RET CNF(Int2_normalize);
 EI(keyStr.equals("getXY", CPL_STR_HASH("getXY")))
RET CNF(Int2_getXY);
 EI(keyStr.equals("setXY", CPL_STR_HASH("setXY")))
RET CNF(Int2_setXY);
 EI(keyStr.equals("getYX", CPL_STR_HASH("getYX")))
RET CNF(Int2_getYX);
 EI(keyStr.equals("setYX", CPL_STR_HASH("setYX")))
RET CNF(Int2_setYX);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(Int2_copy);
 EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T2<int32_t>*obj=(T2<int32_t>*)f->data;
RET CV(obj->x);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T2<int32_t>*obj=(T2<int32_t>*)f->data;
RET CV(obj->y);
} else
 CATE(KE,"Unknown member for Int2."));
}
}
RET CN;
}

void Int2_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("x", CPL_STR_HASH("x")))
{
T2<int32_t>*obj=(T2<int32_t>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr.equals("y", CPL_STR_HASH("y")))
{
T2<int32_t>*obj=(T2<int32_t>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for Int2."));
}
}
}

SV Int2_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::setYX" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int2::setYX.")));
RET CN;
}

SV Int2_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::distanceSquared" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Int2::distanceSquared.")));
RET CN;
}

SV Int2_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::normalize" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("Int2::normalize.")));
RET CN;
}

SV Int2_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::getYX" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("Int2::getYX.")));
RET CN;
}

SV Int2___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__leq__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("Int2::__leq__.")));
RET CN;
}

SV Int2_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::sum" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("Int2::sum.")));
RET CN;
}

SV Int2___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__div__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("Int2::__div__.")));
RET CN;
}

SV Int2___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__less__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("Int2::__less__.")));
RET CN;
}

SV Int2___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__neq__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("Int2::__neq__.")));
RET CN;
}

SV Int2_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::lengthSquared" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("Int2::lengthSquared.")));
RET CN;
}

SV Int2_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::setXY" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int2::setXY.")));
RET CN;
}

SV Int2___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__add__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("Int2::__add__.")));
RET CN;
}

SV Int2_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::copy" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("Int2::copy.")));
RET CN;
}

SV Int2___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__eq__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Int2::__eq__.")));
RET CN;
}

SV Int2_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::getXY" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("Int2::getXY.")));
RET CN;
}

SV Int2_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::distance" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Int2::distance.")));
RET CN;
}

SV Int2___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__grtr__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("Int2::__grtr__.")));
RET CN;
}

SV Int2_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::length" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("Int2::length.")));
RET CN;
}

SV Int2___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__mul__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Int2::__mul__.")));
RET CN;
}

SV Int2___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__sub__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("Int2::__sub__.")));
RET CN;
}

SV Int2___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__geq__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("Int2::__geq__.")));
RET CN;
}

SV Int2_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::dot" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("Int2::dot.")));
RET CN;
}

void StrStrMap_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,HashMap<Str,Str>))
CATE(TE,"StrStrMap::__del__ expects StrStrMap as first argument."));

SCRIPT_DELETE((HashMap<Str,Str>*)f->data);
}SV StrStrMap_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"StrStrMap's constructor" EAOE));
if(!TS(a[0],HashMap<Str,Str>))
CATE(TE,"StrStrMap's constructor expects StrStrMap as first argument."));
RET STG::createNativeObject(StrStrMap_funcs,NEW(TYPE(HashMap<Str,Str>)),EXT->StrStrMap_typeID);
}

SV StrStrMap_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("StrStrMap");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(StrStrMap_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(StrStrMap_new);
else
 CATE(KE,"Unknown member for StrStrMap."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(StrStrMap_new);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(StrStrMap___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(StrStrMap___neq__);
 EI(keyStr.equals("get", CPL_STR_HASH("get")))
RET CNF(StrStrMap_get);
 EI(keyStr.equals("set", CPL_STR_HASH("set")))
RET CNF(StrStrMap_set);
 EI(keyStr.equals("remove", CPL_STR_HASH("remove")))
RET CNF(StrStrMap_remove);
 EI(keyStr.equals("isEntry", CPL_STR_HASH("isEntry")))
RET CNF(StrStrMap_isEntry);
 EI(keyStr.equals("begin", CPL_STR_HASH("begin")))
RET CNF(StrStrMap_begin);
 EI(keyStr.equals("end", CPL_STR_HASH("end")))
RET CNF(StrStrMap_end);
 EI(keyStr.equals("find", CPL_STR_HASH("find")))
RET CNF(StrStrMap_find);
 EI(keyStr.equals("removeEntry", CPL_STR_HASH("removeEntry")))
RET CNF(StrStrMap_removeEntry);
 EI(keyStr.equals("getCount", CPL_STR_HASH("getCount")))
RET CNF(StrStrMap_getCount);
 EI(keyStr.equals("getKey", CPL_STR_HASH("getKey")))
RET CNF(StrStrMap_getKey);
 EI(keyStr.equals("getValue", CPL_STR_HASH("getValue")))
RET CNF(StrStrMap_getValue);
 EI(keyStr.equals("clear", CPL_STR_HASH("clear")))
RET CNF(StrStrMap_clear);
 else
 CATE(KE,"Unknown member for StrStrMap."));
}
}
RET CN;
}

void StrStrMap_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for StrStrMap."));
}
}
}

SV StrStrMap_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::begin" EAOE));
HashMap<Str,Str>*f;
f=(HashMap<Str,Str>*)((NO)a[0].p)->data;

CATE(TE,UFOF("StrStrMap::begin.")));
RET CN;
}

SV StrStrMap_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::set" EAOE));
HashMap<Str,Str>*f;
f=(HashMap<Str,Str>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],Str)&&TS(a[2],Str))
{
RET CV( f->set(val_to_c<std::remove_reference<Str>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<Str>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("StrStrMap::set.")));
RET CN;
}

SV StrStrMap_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::end" EAOE));
HashMap<Str,Str>*f;
f=(HashMap<Str,Str>*)((NO)a[0].p)->data;

CATE(TE,UFOF("StrStrMap::end.")));
RET CN;
}

SV StrStrMap_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::get" EAOE));
HashMap<Str,Str>*f;
f=(HashMap<Str,Str>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Str))
{
RET CV( f->get(val_to_c<std::remove_reference<Str>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==2)
if(1&&TS(a[1],Str))
{
RET CV( f->get(val_to_c<std::remove_reference<Str>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("StrStrMap::get.")));
RET CN;
}

SV StrStrMap_getValue(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::getValue" EAOE));
HashMap<Str,Str>*f;
f=(HashMap<Str,Str>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getValue(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("StrStrMap::getValue.")));
RET CN;
}

SV StrStrMap_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::clear" EAOE));
HashMap<Str,Str>*f;
f=(HashMap<Str,Str>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("StrStrMap::clear.")));
RET CN;
}

SV StrStrMap_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::remove" EAOE));
HashMap<Str,Str>*f;
f=(HashMap<Str,Str>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Str))
{
( f->remove(val_to_c<std::remove_reference<Str>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("StrStrMap::remove.")));
RET CN;
}

SV StrStrMap_getKey(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::getKey" EAOE));
HashMap<Str,Str>*f;
f=(HashMap<Str,Str>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getKey(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("StrStrMap::getKey.")));
RET CN;
}

SV StrStrMap_isEntry(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::isEntry" EAOE));
HashMap<Str,Str>*f;
f=(HashMap<Str,Str>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Str))
{
RET CV( f->isEntry(val_to_c<std::remove_reference<Str>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("StrStrMap::isEntry.")));
RET CN;
}

SV StrStrMap_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::getCount" EAOE));
HashMap<Str,Str>*f;
f=(HashMap<Str,Str>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("StrStrMap::getCount.")));
RET CN;
}

SV StrStrMap_removeEntry(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::removeEntry" EAOE));
HashMap<Str,Str>*f;
f=(HashMap<Str,Str>*)((NO)a[0].p)->data;

CATE(TE,UFOF("StrStrMap::removeEntry.")));
RET CN;
}

SV StrStrMap___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::__eq__" EAOE));
HashMap<Str,Str>*f;
f=(HashMap<Str,Str>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const HashMap<Str, Str> &))
{
auto v=val_to_c<std::remove_reference<const HashMap<Str, Str> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("StrStrMap::__eq__.")));
RET CN;
}

SV StrStrMap_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::find" EAOE));
HashMap<Str,Str>*f;
f=(HashMap<Str,Str>*)((NO)a[0].p)->data;

CATE(TE,UFOF("StrStrMap::find.")));
RET CN;
}

SV StrStrMap___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::__neq__" EAOE));
HashMap<Str,Str>*f;
f=(HashMap<Str,Str>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const HashMap<Str, Str> &))
{
auto v=val_to_c<std::remove_reference<const HashMap<Str, Str> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("StrStrMap::__neq__.")));
RET CN;
}

void LightPointData_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,LightPointData))
CATE(TE,"LightPointData::__del__ expects LightPointData as first argument."));

SCRIPT_DELETE((LightPointData*)f->data);
}SV LightPointData_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"LightPointData's constructor" EAOE));
if(!TS(a[0],LightPointData))
CATE(TE,"LightPointData's constructor expects LightPointData as first argument."));
RET STG::createNativeObject(LightPointData_funcs,NEW(TYPE(LightPointData)),EXT->LightPointData_typeID);
}

SV LightPointData_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("LightPointData");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(LightPointData_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(LightPointData_new);
else
 CATE(KE,"Unknown member for LightPointData."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(LightPointData_new);
 EI(keyStr.equals("position", CPL_STR_HASH("position")))
{
LightPointData*obj=(LightPointData*)f->data;
RET CV(obj->position);
} EI(keyStr.equals("radius", CPL_STR_HASH("radius")))
{
LightPointData*obj=(LightPointData*)f->data;
RET CV(obj->radius);
} EI(keyStr.equals("singlePassShadowMap", CPL_STR_HASH("singlePassShadowMap")))
{
LightPointData*obj=(LightPointData*)f->data;
RET CV(obj->singlePassShadowMap);
} else
 CATE(KE,"Unknown member for LightPointData."));
}
}
RET CN;
}

void LightPointData_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("position", CPL_STR_HASH("position")))
{
LightPointData*obj=(LightPointData*)f->data;
obj->position=val_to_c<decltype(obj->position)>::f(ctx,value);
} EI(keyStr.equals("radius", CPL_STR_HASH("radius")))
{
LightPointData*obj=(LightPointData*)f->data;
obj->radius=val_to_c<decltype(obj->radius)>::f(ctx,value);
} EI(keyStr.equals("singlePassShadowMap", CPL_STR_HASH("singlePassShadowMap")))
{
LightPointData*obj=(LightPointData*)f->data;
obj->singlePassShadowMap=val_to_c<decltype(obj->singlePassShadowMap)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for LightPointData."));
}
}
}

void Matrix4x4_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Matrix4x4))
CATE(TE,"Matrix4x4::__del__ expects Matrix4x4 as first argument."));

SCRIPT_DELETE((Matrix4x4*)f->data);
}SV Matrix4x4_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4's constructor" EAOE));
if(!TS(a[0],Matrix4x4))
CATE(TE,"Matrix4x4's constructor expects Matrix4x4 as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(Matrix4x4));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Matrix4x4_funcs,p,EXT->Matrix4x4_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const Matrix3x3 &)){
void *p = (void *)NEW(TYPE(Matrix4x4),val_to_c<const Matrix3x3 &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Matrix4x4_funcs,p,EXT->Matrix4x4_typeID);
}if(a.getCount()==5)
if(true&&TS(a[1],const Float4 &)&&TS(a[2],const Float4 &)&&TS(a[3],const Float4 &)&&TS(a[4],const Float4 &)){
void *p = (void *)NEW(TYPE(Matrix4x4),val_to_c<const Float4 &>::f(ctx,a[1]),val_to_c<const Float4 &>::f(ctx,a[2]),val_to_c<const Float4 &>::f(ctx,a[3]),val_to_c<const Float4 &>::f(ctx,a[4]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Matrix4x4_funcs,p,EXT->Matrix4x4_typeID);
}CATE(TE,UFOF("Matrix4x4's constructor.")));
RET CN;
}

SV Matrix4x4_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Matrix4x4");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Matrix4x4_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Matrix4x4_new);
else
 CATE(KE,"Unknown member for Matrix4x4."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Matrix4x4_new);
 EI(keyStr.equals("__mul__", CPL_STR_HASH("__mul__")))
RET CNF(Matrix4x4___mul__);
 EI(keyStr.equals("__div__", CPL_STR_HASH("__div__")))
RET CNF(Matrix4x4___div__);
 EI(keyStr.equals("get", CPL_STR_HASH("get")))
RET CNF(Matrix4x4_get);
 EI(keyStr.equals("set", CPL_STR_HASH("set")))
RET CNF(Matrix4x4_set);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(Matrix4x4___eq__);
 EI(keyStr.equals("transpose", CPL_STR_HASH("transpose")))
RET CNF(Matrix4x4_transpose);
 EI(keyStr.equals("determinant", CPL_STR_HASH("determinant")))
RET CNF(Matrix4x4_determinant);
 EI(keyStr.equals("inverse", CPL_STR_HASH("inverse")))
RET CNF(Matrix4x4_inverse);
 EI(keyStr.equals("multTrans", CPL_STR_HASH("multTrans")))
RET CNF(Matrix4x4_multTrans);
 EI(keyStr.equals("multScale", CPL_STR_HASH("multScale")))
RET CNF(Matrix4x4_multScale);
 EI(keyStr.equals("multQuat", CPL_STR_HASH("multQuat")))
RET CNF(Matrix4x4_multQuat);
 EI(keyStr.equals("translate", CPL_STR_HASH("translate")))
RET CNF(Matrix4x4_translate);
 EI(keyStr.equals("scale", CPL_STR_HASH("scale")))
RET CNF(Matrix4x4_scale);
 EI(keyStr.equals("rotate", CPL_STR_HASH("rotate")))
RET CNF(Matrix4x4_rotate);
 EI(keyStr.equals("rotatex", CPL_STR_HASH("rotatex")))
RET CNF(Matrix4x4_rotatex);
 EI(keyStr.equals("rotatey", CPL_STR_HASH("rotatey")))
RET CNF(Matrix4x4_rotatey);
 EI(keyStr.equals("rotatez", CPL_STR_HASH("rotatez")))
RET CNF(Matrix4x4_rotatez);
 EI(keyStr.equals("perspective", CPL_STR_HASH("perspective")))
RET CNF(Matrix4x4_perspective);
 EI(keyStr.equals("orthographic", CPL_STR_HASH("orthographic")))
RET CNF(Matrix4x4_orthographic);
 EI(keyStr.equals("lookAt", CPL_STR_HASH("lookAt")))
RET CNF(Matrix4x4_lookAt);
 EI(keyStr.equals("lookAtDir", CPL_STR_HASH("lookAtDir")))
RET CNF(Matrix4x4_lookAtDir);
 else
 CATE(KE,"Unknown member for Matrix4x4."));
}
}
RET CN;
}

void Matrix4x4_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for Matrix4x4."));
}
}
}

SV Matrix4x4_perspective(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::perspective" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==5)
if(1&&TS(a[1],float)&&TS(a[2],float)&&TS(a[3],float)&&TS(a[4],float))
{
RET CV( f->perspective(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[4])));
;
}
CATE(TE,UFOF("Matrix4x4::perspective.")));
RET CN;
}

SV Matrix4x4_determinant(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::determinant" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->determinant());
;
}
CATE(TE,UFOF("Matrix4x4::determinant.")));
RET CN;
}

SV Matrix4x4_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::set" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t)&&TS(a[3],float))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("Matrix4x4::set.")));
RET CN;
}

SV Matrix4x4_lookAtDir(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::lookAtDir" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],const Position3D &)&&TS(a[2],const Direction3D &)&&TS(a[3],const Direction3D &))
{
RET CV( f->lookAtDir(val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Direction3D &>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Direction3D &>::type>::f(ctx,a[3])));
;
}
CATE(TE,UFOF("Matrix4x4::lookAtDir.")));
RET CN;
}

SV Matrix4x4_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::get" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("Matrix4x4::get.")));
RET CN;
}

SV Matrix4x4_multTrans(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::multTrans" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
( f->multTrans(val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Matrix4x4::multTrans.")));
RET CN;
}

SV Matrix4x4_rotate(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::rotate" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->rotate(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix4x4::rotate.")));
RET CN;
}

SV Matrix4x4_transpose(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::transpose" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->transpose());
;
}
CATE(TE,UFOF("Matrix4x4::transpose.")));
RET CN;
}

SV Matrix4x4_rotatez(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::rotatez" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->rotatez(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix4x4::rotatez.")));
RET CN;
}

SV Matrix4x4_rotatex(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::rotatex" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->rotatex(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix4x4::rotatex.")));
RET CN;
}

SV Matrix4x4_rotatey(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::rotatey" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->rotatey(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix4x4::rotatey.")));
RET CN;
}

SV Matrix4x4___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::__div__" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("Matrix4x4::__div__.")));
RET CN;
}

SV Matrix4x4_inverse(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::inverse" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->inverse());
;
}
CATE(TE,UFOF("Matrix4x4::inverse.")));
RET CN;
}

SV Matrix4x4_lookAt(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::lookAt" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],const Position3D &)&&TS(a[2],const Position3D &)&&TS(a[3],const Direction3D &))
{
RET CV( f->lookAt(val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Direction3D &>::type>::f(ctx,a[3])));
;
}
CATE(TE,UFOF("Matrix4x4::lookAt.")));
RET CN;
}

SV Matrix4x4___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::__mul__" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Matrix4x4 &))
{
auto v=val_to_c<std::remove_reference<const Matrix4x4 &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],const Float4 &))
{
auto v=val_to_c<std::remove_reference<const Float4 &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
auto v=val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Matrix4x4::__mul__.")));
RET CN;
}

SV Matrix4x4_orthographic(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::orthographic" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==7)
if(1&&TS(a[1],float)&&TS(a[2],float)&&TS(a[3],float)&&TS(a[4],float)&&TS(a[5],float)&&TS(a[6],float))
{
RET CV( f->orthographic(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[5]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[6])));
;
}
CATE(TE,UFOF("Matrix4x4::orthographic.")));
RET CN;
}

SV Matrix4x4_multQuat(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::multQuat" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Quaternion &))
{
( f->multQuat(val_to_c<std::remove_reference<const Quaternion &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Matrix4x4::multQuat.")));
RET CN;
}

SV Matrix4x4_translate(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::translate" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
RET CV( f->translate(val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix4x4::translate.")));
RET CN;
}

SV Matrix4x4___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::__eq__" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Matrix4x4 &))
{
auto v=val_to_c<std::remove_reference<const Matrix4x4 &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Matrix4x4::__eq__.")));
RET CN;
}

SV Matrix4x4_multScale(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::multScale" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
( f->multScale(val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Matrix4x4::multScale.")));
RET CN;
}

SV Matrix4x4_scale(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::scale" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
RET CV( f->scale(val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix4x4::scale.")));
RET CN;
}

void Map_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,HashMap<AutoVal,AutoVal>))
CATE(TE,"Map::__del__ expects Map as first argument."));

SCRIPT_DELETE((HashMap<AutoVal,AutoVal>*)f->data);
}SV Map_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Map's constructor" EAOE));
if(!TS(a[0],HashMap<AutoVal,AutoVal>))
CATE(TE,"Map's constructor expects Map as first argument."));
RET STG::createNativeObject(Map_funcs,NEW(TYPE(HashMap<AutoVal,AutoVal>)),EXT->Map_typeID);
}

SV Map_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Map");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Map_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Map_new);
else
 CATE(KE,"Unknown member for Map."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Map_new);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(Map___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(Map___neq__);
 EI(keyStr.equals("get", CPL_STR_HASH("get")))
RET CNF(Map_get);
 EI(keyStr.equals("set", CPL_STR_HASH("set")))
RET CNF(Map_set);
 EI(keyStr.equals("remove", CPL_STR_HASH("remove")))
RET CNF(Map_remove);
 EI(keyStr.equals("isEntry", CPL_STR_HASH("isEntry")))
RET CNF(Map_isEntry);
 EI(keyStr.equals("begin", CPL_STR_HASH("begin")))
RET CNF(Map_begin);
 EI(keyStr.equals("end", CPL_STR_HASH("end")))
RET CNF(Map_end);
 EI(keyStr.equals("find", CPL_STR_HASH("find")))
RET CNF(Map_find);
 EI(keyStr.equals("removeEntry", CPL_STR_HASH("removeEntry")))
RET CNF(Map_removeEntry);
 EI(keyStr.equals("getCount", CPL_STR_HASH("getCount")))
RET CNF(Map_getCount);
 EI(keyStr.equals("getKey", CPL_STR_HASH("getKey")))
RET CNF(Map_getKey);
 EI(keyStr.equals("getValue", CPL_STR_HASH("getValue")))
RET CNF(Map_getValue);
 EI(keyStr.equals("clear", CPL_STR_HASH("clear")))
RET CNF(Map_clear);
 else
 CATE(KE,"Unknown member for Map."));
}
}
RET CN;
}

void Map_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for Map."));
}
}
}

SV Map_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::begin" EAOE));
HashMap<AutoVal,AutoVal>*f;
f=(HashMap<AutoVal,AutoVal>*)((NO)a[0].p)->data;

CATE(TE,UFOF("Map::begin.")));
RET CN;
}

SV Map_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::set" EAOE));
HashMap<AutoVal,AutoVal>*f;
f=(HashMap<AutoVal,AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],AutoVal)&&TS(a[2],AutoVal))
{
RET CV( f->set(val_to_c<std::remove_reference<AutoVal>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<AutoVal>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("Map::set.")));
RET CN;
}

SV Map_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::end" EAOE));
HashMap<AutoVal,AutoVal>*f;
f=(HashMap<AutoVal,AutoVal>*)((NO)a[0].p)->data;

CATE(TE,UFOF("Map::end.")));
RET CN;
}

SV Map_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::get" EAOE));
HashMap<AutoVal,AutoVal>*f;
f=(HashMap<AutoVal,AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],AutoVal))
{
RET CV( f->get(val_to_c<std::remove_reference<AutoVal>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==2)
if(1&&TS(a[1],AutoVal))
{
RET CV( f->get(val_to_c<std::remove_reference<AutoVal>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Map::get.")));
RET CN;
}

SV Map_getValue(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::getValue" EAOE));
HashMap<AutoVal,AutoVal>*f;
f=(HashMap<AutoVal,AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getValue(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Map::getValue.")));
RET CN;
}

SV Map_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::clear" EAOE));
HashMap<AutoVal,AutoVal>*f;
f=(HashMap<AutoVal,AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("Map::clear.")));
RET CN;
}

SV Map_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::remove" EAOE));
HashMap<AutoVal,AutoVal>*f;
f=(HashMap<AutoVal,AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],AutoVal))
{
( f->remove(val_to_c<std::remove_reference<AutoVal>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Map::remove.")));
RET CN;
}

SV Map_getKey(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::getKey" EAOE));
HashMap<AutoVal,AutoVal>*f;
f=(HashMap<AutoVal,AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getKey(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Map::getKey.")));
RET CN;
}

SV Map_isEntry(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::isEntry" EAOE));
HashMap<AutoVal,AutoVal>*f;
f=(HashMap<AutoVal,AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],AutoVal))
{
RET CV( f->isEntry(val_to_c<std::remove_reference<AutoVal>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Map::isEntry.")));
RET CN;
}

SV Map_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::getCount" EAOE));
HashMap<AutoVal,AutoVal>*f;
f=(HashMap<AutoVal,AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("Map::getCount.")));
RET CN;
}

SV Map_removeEntry(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::removeEntry" EAOE));
HashMap<AutoVal,AutoVal>*f;
f=(HashMap<AutoVal,AutoVal>*)((NO)a[0].p)->data;

CATE(TE,UFOF("Map::removeEntry.")));
RET CN;
}

SV Map___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::__eq__" EAOE));
HashMap<AutoVal,AutoVal>*f;
f=(HashMap<AutoVal,AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const HashMap<AutoVal, AutoVal> &))
{
auto v=val_to_c<std::remove_reference<const HashMap<AutoVal, AutoVal> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Map::__eq__.")));
RET CN;
}

SV Map_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::find" EAOE));
HashMap<AutoVal,AutoVal>*f;
f=(HashMap<AutoVal,AutoVal>*)((NO)a[0].p)->data;

CATE(TE,UFOF("Map::find.")));
RET CN;
}

SV Map___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::__neq__" EAOE));
HashMap<AutoVal,AutoVal>*f;
f=(HashMap<AutoVal,AutoVal>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const HashMap<AutoVal, AutoVal> &))
{
auto v=val_to_c<std::remove_reference<const HashMap<AutoVal, AutoVal> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("Map::__neq__.")));
RET CN;
}

void ScriptInstanceList_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,List<ScriptInstance*>))
CATE(TE,"ScriptInstanceList::__del__ expects ScriptInstanceList as first argument."));

SCRIPT_DELETE((List<ScriptInstance*>*)f->data);
}SV ScriptInstanceList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstanceList's constructor" EAOE));
if(!TS(a[0],List<ScriptInstance*>))
CATE(TE,"ScriptInstanceList's constructor expects ScriptInstanceList as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(List<ScriptInstance*>));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(ScriptInstanceList_funcs,p,EXT->ScriptInstanceList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],std::size_t)){
void *p = (void *)NEW(TYPE(List<ScriptInstance*>),val_to_c<std::size_t>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(ScriptInstanceList_funcs,p,EXT->ScriptInstanceList_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const List<ScriptInstance*> &)){
void *p = (void *)NEW(TYPE(List<ScriptInstance*>),val_to_c<const List<ScriptInstance*> &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(ScriptInstanceList_funcs,p,EXT->ScriptInstanceList_typeID);
}CATE(TE,UFOF("ScriptInstanceList's constructor.")));
RET CN;
}

SV ScriptInstanceList_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("ScriptInstanceList");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(ScriptInstanceList_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(ScriptInstanceList_new);
else
 CATE(KE,"Unknown member for ScriptInstanceList."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(ScriptInstanceList_new);
 EI(keyStr.equals("__eq__", CPL_STR_HASH("__eq__")))
RET CNF(ScriptInstanceList___eq__);
 EI(keyStr.equals("__neq__", CPL_STR_HASH("__neq__")))
RET CNF(ScriptInstanceList___neq__);
 EI(keyStr.equals("get", CPL_STR_HASH("get")))
RET CNF(ScriptInstanceList_get);
 EI(keyStr.equals("set", CPL_STR_HASH("set")))
RET CNF(ScriptInstanceList_set);
 EI(keyStr.equals("getCount", CPL_STR_HASH("getCount")))
RET CNF(ScriptInstanceList_getCount);
 EI(keyStr.equals("getData", CPL_STR_HASH("getData")))
RET CNF(ScriptInstanceList_getData);
 EI(keyStr.equals("append", CPL_STR_HASH("append")))
RET CNF(ScriptInstanceList_append);
 EI(keyStr.equals("insert", CPL_STR_HASH("insert")))
RET CNF(ScriptInstanceList_insert);
 EI(keyStr.equals("remove", CPL_STR_HASH("remove")))
RET CNF(ScriptInstanceList_remove);
 EI(keyStr.equals("clear", CPL_STR_HASH("clear")))
RET CNF(ScriptInstanceList_clear);
 EI(keyStr.equals("find", CPL_STR_HASH("find")))
RET CNF(ScriptInstanceList_find);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(ScriptInstanceList_copy);
 EI(keyStr.equals("in", CPL_STR_HASH("in")))
RET CNF(ScriptInstanceList_in);
 EI(keyStr.equals("reserve", CPL_STR_HASH("reserve")))
RET CNF(ScriptInstanceList_reserve);
 EI(keyStr.equals("begin", CPL_STR_HASH("begin")))
RET CNF(ScriptInstanceList_begin);
 EI(keyStr.equals("end", CPL_STR_HASH("end")))
RET CNF(ScriptInstanceList_end);
 else
 CATE(KE,"Unknown member for ScriptInstanceList."));
}
}
RET CN;
}

void ScriptInstanceList_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for ScriptInstanceList."));
}
}
}

SV ScriptInstanceList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstanceList::insert" EAOE));
List<ScriptInstance*>*f;
f=(List<ScriptInstance*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],ScriptInstance*))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<ScriptInstance*>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<ScriptInstance*> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<ScriptInstance*> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ScriptInstanceList::insert.")));
RET CN;
}

SV ScriptInstanceList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstanceList::begin" EAOE));
List<ScriptInstance*>*f;
f=(List<ScriptInstance*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("ScriptInstanceList::begin.")));
RET CN;
}

SV ScriptInstanceList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstanceList::set" EAOE));
List<ScriptInstance*>*f;
f=(List<ScriptInstance*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],ScriptInstance*))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<ScriptInstance*>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ScriptInstanceList::set.")));
RET CN;
}

SV ScriptInstanceList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstanceList::end" EAOE));
List<ScriptInstance*>*f;
f=(List<ScriptInstance*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("ScriptInstanceList::end.")));
RET CN;
}

SV ScriptInstanceList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstanceList::get" EAOE));
List<ScriptInstance*>*f;
f=(List<ScriptInstance*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ScriptInstanceList::get.")));
RET CN;
}

SV ScriptInstanceList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstanceList::clear" EAOE));
List<ScriptInstance*>*f;
f=(List<ScriptInstance*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("ScriptInstanceList::clear.")));
RET CN;
}

SV ScriptInstanceList_reserve(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstanceList::reserve" EAOE));
List<ScriptInstance*>*f;
f=(List<ScriptInstance*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->reserve(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("ScriptInstanceList::reserve.")));
RET CN;
}

SV ScriptInstanceList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstanceList::copy" EAOE));
List<ScriptInstance*>*f;
f=(List<ScriptInstance*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("ScriptInstanceList::copy.")));
RET CN;
}

SV ScriptInstanceList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstanceList::remove" EAOE));
List<ScriptInstance*>*f;
f=(List<ScriptInstance*>*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ScriptInstanceList::remove.")));
RET CN;
}

SV ScriptInstanceList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstanceList::in" EAOE));
List<ScriptInstance*>*f;
f=(List<ScriptInstance*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],ScriptInstance*))
{
RET CV( f->in(val_to_c<std::remove_reference<ScriptInstance*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ScriptInstanceList::in.")));
RET CN;
}

SV ScriptInstanceList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstanceList::getCount" EAOE));
List<ScriptInstance*>*f;
f=(List<ScriptInstance*>*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("ScriptInstanceList::getCount.")));
RET CN;
}

SV ScriptInstanceList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstanceList::getData" EAOE));
List<ScriptInstance*>*f;
f=(List<ScriptInstance*>*)((NO)a[0].p)->data;

CATE(TE,UFOF("ScriptInstanceList::getData.")));
RET CN;
}

SV ScriptInstanceList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstanceList::__eq__" EAOE));
List<ScriptInstance*>*f;
f=(List<ScriptInstance*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<ScriptInstance*> &))
{
auto v=val_to_c<std::remove_reference<const List<ScriptInstance*> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("ScriptInstanceList::__eq__.")));
RET CN;
}

SV ScriptInstanceList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstanceList::find" EAOE));
List<ScriptInstance*>*f;
f=(List<ScriptInstance*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],ScriptInstance*))
{
RET CV( f->find(val_to_c<std::remove_reference<ScriptInstance*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ScriptInstanceList::find.")));
RET CN;
}

SV ScriptInstanceList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstanceList::append" EAOE));
List<ScriptInstance*>*f;
f=(List<ScriptInstance*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],ScriptInstance*))
{
( f->append(val_to_c<std::remove_reference<ScriptInstance*>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<ScriptInstance*> &))
{
( f->append(val_to_c<std::remove_reference<const List<ScriptInstance*> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("ScriptInstanceList::append.")));
RET CN;
}

SV ScriptInstanceList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScriptInstanceList::__neq__" EAOE));
List<ScriptInstance*>*f;
f=(List<ScriptInstance*>*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<ScriptInstance*> &))
{
auto v=val_to_c<std::remove_reference<const List<ScriptInstance*> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("ScriptInstanceList::__neq__.")));
RET CN;
}

void AudioWorld_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,AudioWorld))
CATE(TE,"AudioWorld::__del__ expects AudioWorld as first argument."));

SCRIPT_DELETE((AudioWorld*)f->data);
}SV AudioWorld_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioWorld's constructor" EAOE));
if(!TS(a[0],AudioWorld))
CATE(TE,"AudioWorld's constructor expects AudioWorld as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(AudioWorld));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(AudioWorld_funcs,p,EXT->AudioWorld_typeID);
}CATE(TE,UFOF("AudioWorld's constructor.")));
RET CN;
}

SV AudioWorld_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("AudioWorld");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(AudioWorld_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(AudioWorld_new);
else
 CATE(KE,"Unknown member for AudioWorld."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(AudioWorld_new);
 EI(keyStr.equals("createSource", CPL_STR_HASH("createSource")))
RET CNF(AudioWorld_createSource);
 EI(keyStr.equals("destroySource", CPL_STR_HASH("destroySource")))
RET CNF(AudioWorld_destroySource);
 EI(keyStr.equals("clearSources", CPL_STR_HASH("clearSources")))
RET CNF(AudioWorld_clearSources);
 EI(keyStr.equals("getSources", CPL_STR_HASH("getSources")))
RET CNF(AudioWorld_getSources);
 EI(keyStr.equals("addToAudioDevice", CPL_STR_HASH("addToAudioDevice")))
RET CNF(AudioWorld_addToAudioDevice);
 EI(keyStr.equals("removeFromAudioDevice", CPL_STR_HASH("removeFromAudioDevice")))
RET CNF(AudioWorld_removeFromAudioDevice);
 EI(keyStr.equals("listenerVelocity", CPL_STR_HASH("listenerVelocity")))
{
AudioWorld*obj=(AudioWorld*)f->data;
RET CV(obj->listenerVelocity);
} EI(keyStr.equals("dopplerFactor", CPL_STR_HASH("dopplerFactor")))
{
AudioWorld*obj=(AudioWorld*)f->data;
RET CV(obj->dopplerFactor);
} EI(keyStr.equals("listenerPosition", CPL_STR_HASH("listenerPosition")))
{
AudioWorld*obj=(AudioWorld*)f->data;
RET CV(obj->listenerPosition);
} EI(keyStr.equals("speedOfSound", CPL_STR_HASH("speedOfSound")))
{
AudioWorld*obj=(AudioWorld*)f->data;
RET CV(obj->speedOfSound);
} else
 CATE(KE,"Unknown member for AudioWorld."));
}
}
RET CN;
}

void AudioWorld_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("listenerVelocity", CPL_STR_HASH("listenerVelocity")))
{
AudioWorld*obj=(AudioWorld*)f->data;
obj->listenerVelocity=val_to_c<decltype(obj->listenerVelocity)>::f(ctx,value);
} EI(keyStr.equals("dopplerFactor", CPL_STR_HASH("dopplerFactor")))
{
AudioWorld*obj=(AudioWorld*)f->data;
obj->dopplerFactor=val_to_c<decltype(obj->dopplerFactor)>::f(ctx,value);
} EI(keyStr.equals("listenerPosition", CPL_STR_HASH("listenerPosition")))
{
AudioWorld*obj=(AudioWorld*)f->data;
obj->listenerPosition=val_to_c<decltype(obj->listenerPosition)>::f(ctx,value);
} EI(keyStr.equals("speedOfSound", CPL_STR_HASH("speedOfSound")))
{
AudioWorld*obj=(AudioWorld*)f->data;
obj->speedOfSound=val_to_c<decltype(obj->speedOfSound)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for AudioWorld."));
}
}
}

SV AudioWorld_destroySource(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioWorld::destroySource" EAOE));
AudioWorld*f;
f=(AudioWorld*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],AudioSource *))
{
( f->destroySource(val_to_c<std::remove_reference<AudioSource *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioWorld::destroySource.")));
RET CN;
}

SV AudioWorld_getSources(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioWorld::getSources" EAOE));
AudioWorld*f;
f=(AudioWorld*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getSources());
;
}
CATE(TE,UFOF("AudioWorld::getSources.")));
RET CN;
}

SV AudioWorld_addToAudioDevice(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioWorld::addToAudioDevice" EAOE));
AudioWorld*f;
f=(AudioWorld*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],AudioDevice *))
{
( f->addToAudioDevice(val_to_c<std::remove_reference<AudioDevice *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioWorld::addToAudioDevice.")));
RET CN;
}

SV AudioWorld_createSource(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioWorld::createSource" EAOE));
AudioWorld*f;
f=(AudioWorld*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],Audio *))
{
RET CV( f->createSource(val_to_c<std::remove_reference<Audio *>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("AudioWorld::createSource.")));
RET CN;
}

SV AudioWorld_removeFromAudioDevice(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioWorld::removeFromAudioDevice" EAOE));
AudioWorld*f;
f=(AudioWorld*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],AudioDevice *))
{
( f->removeFromAudioDevice(val_to_c<std::remove_reference<AudioDevice *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioWorld::removeFromAudioDevice.")));
RET CN;
}

SV AudioWorld_clearSources(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioWorld::clearSources" EAOE));
AudioWorld*f;
f=(AudioWorld*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->clearSources());
RET CN;
}
CATE(TE,UFOF("AudioWorld::clearSources.")));
RET CN;
}

void Audio_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,Audio))
CATE(TE,"Audio::__del__ expects Audio as first argument."));

Audio*obj=(Audio*)f->data;
if(_scriptDeletePart(obj)){obj->release();}
}SV Audio_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio's constructor" EAOE));
if(!TS(a[0],Audio))
CATE(TE,"Audio's constructor expects Audio as first argument."));
if(a.getCount()==1)
if(true){
void *p = (void *)NEW(TYPE(Audio));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Audio_funcs,p,EXT->Audio_typeID);
}if(a.getCount()==2)
if(true&&TS(a[1],const Str &)){
void *p = (void *)NEW(TYPE(Audio),val_to_c<const Str &>::f(ctx,a[1]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(Audio_funcs,p,EXT->Audio_typeID);
}CATE(TE,UFOF("Audio's constructor.")));
RET CN;
}

SV Audio_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("Audio");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(Audio_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(Audio_new);
else
 CATE(KE,"Unknown member for Audio."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(Audio_new);
 EI(keyStr.equals("removeContent", CPL_STR_HASH("removeContent")))
RET CNF(Audio_removeContent);
 EI(keyStr.equals("changeSampleFrequency", CPL_STR_HASH("changeSampleFrequency")))
RET CNF(Audio_changeSampleFrequency);
 EI(keyStr.equals("getNumSamples", CPL_STR_HASH("getNumSamples")))
RET CNF(Audio_getNumSamples);
 EI(keyStr.equals("getSample", CPL_STR_HASH("getSample")))
RET CNF(Audio_getSample);
 EI(keyStr.equals("getMonoSample", CPL_STR_HASH("getMonoSample")))
RET CNF(Audio_getMonoSample);
 EI(keyStr.equals("setSample", CPL_STR_HASH("setSample")))
RET CNF(Audio_setSample);
 EI(keyStr.equals("setMonoSample", CPL_STR_HASH("setMonoSample")))
RET CNF(Audio_setMonoSample);
 EI(keyStr.equals("getDuration", CPL_STR_HASH("getDuration")))
RET CNF(Audio_getDuration);
 EI(keyStr.equals("getSampleIndex", CPL_STR_HASH("getSampleIndex")))
RET CNF(Audio_getSampleIndex);
 EI(keyStr.equals("load", CPL_STR_HASH("load")))
RET CNF(Audio_load);
 EI(keyStr.equals("save", CPL_STR_HASH("save")))
RET CNF(Audio_save);
 EI(keyStr.equals("copy", CPL_STR_HASH("copy")))
RET CNF(Audio_copy);
 EI(keyStr.equals("getType", CPL_STR_HASH("getType")))
RET CNF(Audio_getType);
 EI(keyStr.equals("release", CPL_STR_HASH("release")))
RET CNF(Audio_release);
 EI(keyStr.equals("getRefCount", CPL_STR_HASH("getRefCount")))
RET CNF(Audio_getRefCount);
 EI(keyStr.equals("getFilename", CPL_STR_HASH("getFilename")))
RET CNF(Audio_getFilename);
 EI(keyStr.equals("setFilename", CPL_STR_HASH("setFilename")))
RET CNF(Audio_setFilename);
 EI(keyStr.equals("frequency", CPL_STR_HASH("frequency")))
{
Audio*obj=(Audio*)f->data;
RET CV(obj->frequency);
} EI(keyStr.equals("data", CPL_STR_HASH("data")))
{
Audio*obj=(Audio*)f->data;
RET CV(obj->data);
} else
 CATE(KE,"Unknown member for Audio."));
}
}
RET CN;
}

void Audio_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr.equals("frequency", CPL_STR_HASH("frequency")))
{
Audio*obj=(Audio*)f->data;
obj->frequency=val_to_c<decltype(obj->frequency)>::f(ctx,value);
} EI(keyStr.equals("data", CPL_STR_HASH("data")))
{
Audio*obj=(Audio*)f->data;
obj->data=val_to_c<decltype(obj->data)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only for Audio."));
}
}
}

SV Audio_getSampleIndex(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::getSampleIndex" EAOE));
Audio*f;
f=(Audio*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->getSampleIndex(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==4)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t)&&TS(a[3],float))
{
RET CV( f->getSampleIndex(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
;
}
CATE(TE,UFOF("Audio::getSampleIndex.")));
RET CN;
}

SV Audio_changeSampleFrequency(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::changeSampleFrequency" EAOE));
Audio*f;
f=(Audio*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t)&&TS(a[3],size_t))
{
RET CV( f->changeSampleFrequency(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[3])));
;
}
CATE(TE,UFOF("Audio::changeSampleFrequency.")));
RET CN;
}

SV Audio_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::save" EAOE));
Audio*f;
f=(Audio*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("Audio::save.")));
RET CN;
}

SV Audio_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::setFilename" EAOE));
Audio*f;
f=(Audio*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Str &))
{
( f->setFilename(val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Audio::setFilename.")));
RET CN;
}

SV Audio_setMonoSample(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::setMonoSample" EAOE));
Audio*f;
f=(Audio*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],float))
{
( f->setMonoSample(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("Audio::setMonoSample.")));
RET CN;
}

SV Audio_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::getType" EAOE));
Audio*f;
f=(Audio*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("Audio::getType.")));
RET CN;
}

SV Audio_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::load" EAOE));
Audio*f;
f=(Audio*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("Audio::load.")));
RET CN;
}

SV Audio_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::copy" EAOE));
Audio*f;
f=(Audio*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("Audio::copy.")));
RET CN;
}

SV Audio_getMonoSample(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::getMonoSample" EAOE));
Audio*f;
f=(Audio*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getMonoSample(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Audio::getMonoSample.")));
RET CN;
}

SV Audio_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::release" EAOE));
Audio*f;
f=(Audio*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("Audio::release.")));
RET CN;
}

SV Audio_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::removeContent" EAOE));
Audio*f;
f=(Audio*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("Audio::removeContent.")));
RET CN;
}

SV Audio_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::getRefCount" EAOE));
Audio*f;
f=(Audio*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("Audio::getRefCount.")));
RET CN;
}

SV Audio_getDuration(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::getDuration" EAOE));
Audio*f;
f=(Audio*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDuration());
;
}
CATE(TE,UFOF("Audio::getDuration.")));
RET CN;
}

SV Audio_getNumSamples(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::getNumSamples" EAOE));
Audio*f;
f=(Audio*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getNumSamples());
;
}
CATE(TE,UFOF("Audio::getNumSamples.")));
RET CN;
}

SV Audio_getSample(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::getSample" EAOE));
Audio*f;
f=(Audio*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t))
{
RET CV( f->getSample(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("Audio::getSample.")));
RET CN;
}

SV Audio_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::getFilename" EAOE));
Audio*f;
f=(Audio*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("Audio::getFilename.")));
RET CN;
}

SV Audio_setSample(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::setSample" EAOE));
Audio*f;
f=(Audio*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t)&&TS(a[3],float))
{
( f->setSample(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("Audio::setSample.")));
RET CN;
}

void GfxShaderCombination_destroy(CTX ctx,const SV&f_)
{
NO f=(NO)f_.p;
if(!TS(f_,GfxShaderCombination))
CATE(TE,"GfxShaderCombination::__del__ expects GfxShaderCombination as first argument."));

SCRIPT_DELETE((GfxShaderCombination*)f->data);
}SV GfxShaderCombination_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShaderCombination's constructor" EAOE));
if(!TS(a[0],GfxShaderCombination))
CATE(TE,"GfxShaderCombination's constructor expects GfxShaderCombination as first argument."));
if(a.getCount()==3)
if(true&&TS(a[1],GfxShader *)&&TS(a[2],GfxShader *)){
void *p = (void *)NEW(TYPE(GfxShaderCombination),val_to_c<GfxShader *>::f(ctx,a[1]),val_to_c<GfxShader *>::f(ctx,a[2]));
setAllocInfo(p, AllocInfo(true, false));
RET STG::createNativeObject(GfxShaderCombination_funcs,p,EXT->GfxShaderCombination_typeID);
}CATE(TE,UFOF("GfxShaderCombination's constructor.")));
RET CN;
}

SV GfxShaderCombination_get_member(CTX ctx,const SV&f_,const SV&key)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
{
if(keyStr.equals("__typeID__", CPL_STR_HASH("__typeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__name__", CPL_STR_HASH("__name__")))
RET STG::createString("GfxShaderCombination");
EI(keyStr.equals("__new__", CPL_STR_HASH("__new__")))
RET CNF(GfxShaderCombination_new);
EI(keyStr.equals("__call__", CPL_STR_HASH("__call__")))
RET CNF(GfxShaderCombination_new);
else
 CATE(KE,"Unknown member for GfxShaderCombination."));
} else
{
if(keyStr.equals("__classTypeID__", CPL_STR_HASH("__classTypeID__")))
RET STG::createInt(f->typeID);
EI(keyStr.equals("__init__", CPL_STR_HASH("__init__")))
RET CNF(GfxShaderCombination_new);
 EI(keyStr.equals("setDefine", CPL_STR_HASH("setDefine")))
RET CNF(GfxShaderCombination_setDefine);
 EI(keyStr.equals("getDefine", CPL_STR_HASH("getDefine")))
RET CNF(GfxShaderCombination_getDefine);
 EI(keyStr.equals("removeDefine", CPL_STR_HASH("removeDefine")))
RET CNF(GfxShaderCombination_removeDefine);
 EI(keyStr.equals("getShader", CPL_STR_HASH("getShader")))
RET CNF(GfxShaderCombination_getShader);
 EI(keyStr.equals("setShader", CPL_STR_HASH("setShader")))
RET CNF(GfxShaderCombination_setShader);
 EI(keyStr.equals("getCompiled", CPL_STR_HASH("getCompiled")))
RET CNF(GfxShaderCombination_getCompiled);
 EI(keyStr.equals("getGLPipeline", CPL_STR_HASH("getGLPipeline")))
RET CNF(GfxShaderCombination_getGLPipeline);
 else
 CATE(KE,"Unknown member for GfxShaderCombination."));
}
}
RET CN;
}

void GfxShaderCombination_set_member(CTX ctx,const SV&f_,const SV&key,const SV&value)
{
NO f=(NO)f_.p;
if (key.type==STG::ValueType::StringType)
{
Str keyStr=key.getStr();
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only for GfxShaderCombination."));
}
}
}

SV GfxShaderCombination_setShader(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShaderCombination::setShader" EAOE));
GfxShaderCombination*f;
f=(GfxShaderCombination*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],GfxShaderType)&&TS(a[2],GfxShader *))
{
( f->setShader(val_to_c<std::remove_reference<GfxShaderType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxShader *>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxShaderCombination::setShader.")));
RET CN;
}

SV GfxShaderCombination_getShader(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShaderCombination::getShader" EAOE));
GfxShaderCombination*f;
f=(GfxShaderCombination*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxShaderType))
{
RET CV( f->getShader(val_to_c<std::remove_reference<GfxShaderType>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxShaderCombination::getShader.")));
RET CN;
}

SV GfxShaderCombination_getCompiled(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShaderCombination::getCompiled" EAOE));
GfxShaderCombination*f;
f=(GfxShaderCombination*)((NO)a[0].p)->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxShaderType))
{
RET CV( f->getCompiled(val_to_c<std::remove_reference<GfxShaderType>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxShaderCombination::getCompiled.")));
RET CN;
}

SV GfxShaderCombination_getDefine(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShaderCombination::getDefine" EAOE));
GfxShaderCombination*f;
f=(GfxShaderCombination*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],GfxShaderType)&&TS(a[2],const Str &))
{
RET CV( f->getDefine(val_to_c<std::remove_reference<GfxShaderType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("GfxShaderCombination::getDefine.")));
RET CN;
}

SV GfxShaderCombination_removeDefine(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShaderCombination::removeDefine" EAOE));
GfxShaderCombination*f;
f=(GfxShaderCombination*)((NO)a[0].p)->data;

if(a.getCount()==3)
if(1&&TS(a[1],GfxShaderType)&&TS(a[2],const Str &))
{
( f->removeDefine(val_to_c<std::remove_reference<GfxShaderType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxShaderCombination::removeDefine.")));
RET CN;
}

SV GfxShaderCombination_getGLPipeline(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShaderCombination::getGLPipeline" EAOE));
GfxShaderCombination*f;
f=(GfxShaderCombination*)((NO)a[0].p)->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGLPipeline());
;
}
CATE(TE,UFOF("GfxShaderCombination::getGLPipeline.")));
RET CN;
}

SV GfxShaderCombination_setDefine(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShaderCombination::setDefine" EAOE));
GfxShaderCombination*f;
f=(GfxShaderCombination*)((NO)a[0].p)->data;

if(a.getCount()==4)
if(1&&TS(a[1],GfxShaderType)&&TS(a[2],const Str &)&&TS(a[3],const Str &))
{
( f->setDefine(val_to_c<std::remove_reference<GfxShaderType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Str &>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("GfxShaderCombination::setDefine.")));
RET CN;
}

SV lookAtDirMat_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==3)
if(1&&TS(a[0],const Position3D &)&&TS(a[1],const Direction3D &)&&TS(a[2],const Direction3D &))
{
RET CV( lookAtDirMat(val_to_c<const Position3D &>::f(ctx,a[0]), val_to_c<const Direction3D &>::f(ctx,a[1]), val_to_c<const Direction3D &>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("lookAtDirMat")));
RET CN;
}

SV getFileSys_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==0)
if(1)
{
RET CV( getFileSys());
;
}
CATE(TE,UFOF("getFileSys")));
RET CN;
}

SV getAudioDevice_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==0)
if(1)
{
RET CV( getAudioDevice());
;
}
CATE(TE,UFOF("getAudioDevice")));
RET CN;
}

SV listFiles_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==1)
if(1&&TS(a[0],const char *))
{
RET CV( listFiles(val_to_c<const char *>::f(ctx,a[0])));
;
}
CATE(TE,UFOF("listFiles")));
RET CN;
}

SV getResMgr_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==0)
if(1)
{
RET CV( getResMgr());
;
}
CATE(TE,UFOF("getResMgr")));
RET CN;
}

SV getApp_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==0)
if(1)
{
RET CV( getApp());
;
}
CATE(TE,UFOF("getApp")));
RET CN;
}

SV getDebugDrawer_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==0)
if(1)
{
RET CV( getDebugDrawer());
;
}
CATE(TE,UFOF("getDebugDrawer")));
RET CN;
}

SV getPlatform_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==0)
if(1)
{
RET CV( getPlatform());
;
}
CATE(TE,UFOF("getPlatform")));
RET CN;
}

SV getGfxApi_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==0)
if(1)
{
RET CV( getGfxApi());
;
}
CATE(TE,UFOF("getGfxApi")));
RET CN;
}

SV doesFileExist_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==1)
if(1&&TS(a[0],const char *))
{
RET CV( doesFileExist(val_to_c<const char *>::f(ctx,a[0])));
;
}
CATE(TE,UFOF("doesFileExist")));
RET CN;
}

namespace scripting
{
SV create(CTX ctx,const GfxCompiledShader& value){RET CV(value);}
SV create(CTX ctx,const RayCastResult& value){RET CV(value);}
SV create(CTX ctx,const Stats& value){RET CV(value);}
SV create(CTX ctx,const Camera& value){RET CV(value);}
SV create(CTX ctx,const List<Entity*>& value){RET CV(value);}
SV create(CTX ctx,const TextureSampler& value){RET CV(value);}
SV create(CTX ctx,const List<RayCastResult>& value){RET CV(value);}
SV create(CTX ctx,const RenderStats& value){RET CV(value);}
SV create(CTX ctx,const Quaternion& value){RET CV(value);}
SV create(CTX ctx,const ImGui& value){RET CV(value);}
SV create(CTX ctx,const LightDirectionalData& value){RET CV(value);}
SV create(CTX ctx,const LightSpotData& value){RET CV(value);}
SV create(CTX ctx,const List<float>& value){RET CV(value);}
SV create(CTX ctx,const GfxLOD& value){RET CV(value);}
SV create(CTX ctx,const List<AutoVal>& value){RET CV(value);}
SV create(CTX ctx,const Matrix3x3& value){RET CV(value);}
SV create(CTX ctx,const Filesystem& value){RET CV(value);}
SV create(CTX ctx,const Event& value){RET CV(value);}
SV create(CTX ctx,const List<Str>& value){RET CV(value);}
SV create(CTX ctx,const T4<float>& value){RET CV(value);}
SV create(CTX ctx,const List<Light*>& value){RET CV(value);}
SV create(CTX ctx,const T2<float>& value){RET CV(value);}
SV create(CTX ctx,const T3<float>& value){RET CV(value);}
SV create(CTX ctx,const Container& value){RET CV(value);}
SV create(CTX ctx,const Frustum& value){RET CV(value);}
SV create(CTX ctx,const AudioDevice& value){RET CV(value);}
SV create(CTX ctx,const T4<uint32_t>& value){RET CV(value);}
SV create(CTX ctx,const T3<uint32_t>& value){RET CV(value);}
SV create(CTX ctx,const T2<uint32_t>& value){RET CV(value);}
SV create(CTX ctx,const AABB& value){RET CV(value);}
SV create(CTX ctx,const List<GfxModel::SubModel>& value){RET CV(value);}
SV create(CTX ctx,const GuiPlacer& value){RET CV(value);}
SV create(CTX ctx,const List<GhostObject*>& value){RET CV(value);}
SV create(CTX ctx,const GfxObject& value){RET CV(value);}
SV create(CTX ctx,const Transform& value){RET CV(value);}
SV create(CTX ctx,const List<AudioSource*>& value){RET CV(value);}
SV create(CTX ctx,const T4<int32_t>& value){RET CV(value);}
SV create(CTX ctx,const ScrollBar& value){RET CV(value);}
SV create(CTX ctx,const T3<int32_t>& value){RET CV(value);}
SV create(CTX ctx,const Plane& value){RET CV(value);}
SV create(CTX ctx,const List<RigidBody*>& value){RET CV(value);}
SV create(CTX ctx,const List<GfxLOD>& value){RET CV(value);}
SV create(CTX ctx,const RigidBodyConstructionInfo& value){RET CV(value);}
SV create(CTX ctx,const AudioSource& value){RET CV(value);}
SV create(CTX ctx,const DrawCall& value){RET CV(value);}
SV create(CTX ctx,const ResizableData& value){RET CV(value);}
SV create(CTX ctx,const GfxMeshAttrib& value){RET CV(value);}
SV create(CTX ctx,const T2<int32_t>& value){RET CV(value);}
SV create(CTX ctx,const HashMap<Str,Str>& value){RET CV(value);}
SV create(CTX ctx,const LightPointData& value){RET CV(value);}
SV create(CTX ctx,const Matrix4x4& value){RET CV(value);}
SV create(CTX ctx,const HashMap<AutoVal,AutoVal>& value){RET CV(value);}
SV create(CTX ctx,const List<ScriptInstance*>& value){RET CV(value);}
SV create(CTX ctx,const AudioWorld& value){RET CV(value);}
SV create(CTX ctx,MCChunk *value){RET CV(value);}
SV create(CTX ctx,GfxCompiledShader *value){RET CV(value);}
SV create(CTX ctx,RayCastResult *value){RET CV(value);}
SV create(CTX ctx,Entity *value){RET CV(value);}
SV create(CTX ctx,Stats *value){RET CV(value);}
SV create(CTX ctx,Camera *value){RET CV(value);}
SV create(CTX ctx,List<Entity*> *value){RET CV(value);}
SV create(CTX ctx,Light *value){RET CV(value);}
SV create(CTX ctx,TextureSampler *value){RET CV(value);}
SV create(CTX ctx,GhostObject *value){RET CV(value);}
SV create(CTX ctx,List<RayCastResult> *value){RET CV(value);}
SV create(CTX ctx,RenderStats *value){RET CV(value);}
SV create(CTX ctx,Quaternion *value){RET CV(value);}
SV create(CTX ctx,ImGui *value){RET CV(value);}
SV create(CTX ctx,LightDirectionalData *value){RET CV(value);}
SV create(CTX ctx,LightSpotData *value){RET CV(value);}
SV create(CTX ctx,List<float> *value){RET CV(value);}
SV create(CTX ctx,GfxLOD *value){RET CV(value);}
SV create(CTX ctx,List<AutoVal> *value){RET CV(value);}
SV create(CTX ctx,File *value){RET CV(value);}
SV create(CTX ctx,Matrix3x3 *value){RET CV(value);}
SV create(CTX ctx,GPUTimer *value){RET CV(value);}
SV create(CTX ctx,Filesystem *value){RET CV(value);}
SV create(CTX ctx,GfxFramebuffer *value){RET CV(value);}
SV create(CTX ctx,Event *value){RET CV(value);}
SV create(CTX ctx,Platform *value){RET CV(value);}
SV create(CTX ctx,GfxMesh *value){RET CV(value);}
SV create(CTX ctx,GfxShader *value){RET CV(value);}
SV create(CTX ctx,GfxAnimationState *value){RET CV(value);}
SV create(CTX ctx,List<Str> *value){RET CV(value);}
SV create(CTX ctx,GfxRenderer *value){RET CV(value);}
SV create(CTX ctx,T4<float> *value){RET CV(value);}
SV create(CTX ctx,List<Light*> *value){RET CV(value);}
SV create(CTX ctx,T2<float> *value){RET CV(value);}
SV create(CTX ctx,T3<float> *value){RET CV(value);}
SV create(CTX ctx,Container *value){RET CV(value);}
SV create(CTX ctx,Frustum *value){RET CV(value);}
SV create(CTX ctx,AudioDevice *value){RET CV(value);}
SV create(CTX ctx,T4<uint32_t> *value){RET CV(value);}
SV create(CTX ctx,T3<uint32_t> *value){RET CV(value);}
SV create(CTX ctx,T2<uint32_t> *value){RET CV(value);}
SV create(CTX ctx,AABB *value){RET CV(value);}
SV create(CTX ctx,Scene *value){RET CV(value);}
SV create(CTX ctx,List<GfxModel::SubModel> *value){RET CV(value);}
SV create(CTX ctx,GfxDebugDrawer *value){RET CV(value);}
SV create(CTX ctx,GuiPlacer *value){RET CV(value);}
SV create(CTX ctx,List<GhostObject*> *value){RET CV(value);}
SV create(CTX ctx,PhysicsWorld *value){RET CV(value);}
SV create(CTX ctx,Script *value){RET CV(value);}
SV create(CTX ctx,MCWorld *value){RET CV(value);}
SV create(CTX ctx,GfxObject *value){RET CV(value);}
SV create(CTX ctx,Transform *value){RET CV(value);}
SV create(CTX ctx,List<AudioSource*> *value){RET CV(value);}
SV create(CTX ctx,T4<int32_t> *value){RET CV(value);}
SV create(CTX ctx,ScrollBar *value){RET CV(value);}
SV create(CTX ctx,T3<int32_t> *value){RET CV(value);}
SV create(CTX ctx,ScriptInstance *value){RET CV(value);}
SV create(CTX ctx,RenderComponent *value){RET CV(value);}
SV create(CTX ctx,RigidBody *value){RET CV(value);}
SV create(CTX ctx,RenderList *value){RET CV(value);}
SV create(CTX ctx,Plane *value){RET CV(value);}
SV create(CTX ctx,PhysicsShape *value){RET CV(value);}
SV create(CTX ctx,List<RigidBody*> *value){RET CV(value);}
SV create(CTX ctx,Resource *value){RET CV(value);}
SV create(CTX ctx,GfxTexture *value){RET CV(value);}
SV create(CTX ctx,GfxModel *value){RET CV(value);}
SV create(CTX ctx,List<GfxLOD> *value){RET CV(value);}
SV create(CTX ctx,RigidBodyConstructionInfo *value){RET CV(value);}
SV create(CTX ctx,GfxApi *value){RET CV(value);}
SV create(CTX ctx,ResourceManager *value){RET CV(value);}
SV create(CTX ctx,Font *value){RET CV(value);}
SV create(CTX ctx,AudioSource *value){RET CV(value);}
SV create(CTX ctx,DrawCall *value){RET CV(value);}
SV create(CTX ctx,Application *value){RET CV(value);}
SV create(CTX ctx,ResizableData *value){RET CV(value);}
SV create(CTX ctx,GfxBuffer *value){RET CV(value);}
SV create(CTX ctx,GfxMaterial *value){RET CV(value);}
SV create(CTX ctx,GfxMeshAttrib *value){RET CV(value);}
SV create(CTX ctx,T2<int32_t> *value){RET CV(value);}
SV create(CTX ctx,HashMap<Str,Str> *value){RET CV(value);}
SV create(CTX ctx,LightPointData *value){RET CV(value);}
SV create(CTX ctx,Matrix4x4 *value){RET CV(value);}
SV create(CTX ctx,HashMap<AutoVal,AutoVal> *value){RET CV(value);}
SV create(CTX ctx,List<ScriptInstance*> *value){RET CV(value);}
SV create(CTX ctx,AudioWorld *value){RET CV(value);}
SV create(CTX ctx,Audio *value){RET CV(value);}
SV create(CTX ctx,GfxShaderCombination *value){RET CV(value);}
SV create(CTX ctx,Key value){RET CV(value);}
SV create(CTX ctx,MouseButton value){RET CV(value);}
SV create(CTX ctx,EventType value){RET CV(value);}
SV create(CTX ctx,FileOrigin value){RET CV(value);}
SV create(CTX ctx,ResType value){RET CV(value);}
SV create(CTX ctx,GfxTextureType value){RET CV(value);}
SV create(CTX ctx,GfxFilter value){RET CV(value);}
SV create(CTX ctx,GfxMipmapMode value){RET CV(value);}
SV create(CTX ctx,GfxWrapMode value){RET CV(value);}
SV create(CTX ctx,GfxTexFormat value){RET CV(value);}
SV create(CTX ctx,GfxFace value){RET CV(value);}
SV create(CTX ctx,GfxBufferUsage value){RET CV(value);}
SV create(CTX ctx,GfxShaderType value){RET CV(value);}
SV create(CTX ctx,GfxPrimitive value){RET CV(value);}
SV create(CTX ctx,GfxDepthFunction value){RET CV(value);}
SV create(CTX ctx,GfxBlendMode value){RET CV(value);}
SV create(CTX ctx,GfxBlendFactor value){RET CV(value);}
SV create(CTX ctx,GfxCullMode value){RET CV(value);}
SV create(CTX ctx,GfxWinding value){RET CV(value);}
SV create(CTX ctx,GfxVertexAttribPurpose value){RET CV(value);}
SV create(CTX ctx,GfxVertexAttribType value){RET CV(value);}
SV create(CTX ctx,GfxMeshIndexDataType value){RET CV(value);}
SV create(CTX ctx,GfxMeshAttribType value){RET CV(value);}
SV create(CTX ctx,GfxMeshAttribDataType value){RET CV(value);}
SV create(CTX ctx,XOrigin value){RET CV(value);}
SV create(CTX ctx,GfxShadowmapPrecision value){RET CV(value);}
SV create(CTX ctx,GfxLightType value){RET CV(value);}
SV create(CTX ctx,GfxDriver value){RET CV(value);}
SV create(CTX ctx,CameraType value){RET CV(value);}
SV create(CTX ctx,Axis value){RET CV(value);}
SV create(CTX ctx,RigidBodyType value){RET CV(value);}
SV create(CTX ctx,PhysicsObjectType value){RET CV(value);}
SV create(CTX ctx,RenderMode value){RET CV(value);}
}
void *initBindings(scripting::Engine *engine, void *data)
{
    BindingsExt *ext = NEW(BindingsExt);

    int64_t typeID;
    
    typeID = engine->createNewTypeID();
    ext->MCChunk_typeID = typeID;
    ext->MCChunk = scripting::createNativeObject(MCChunk_funcs, NULL, typeID);
    engine->getGlobalVars().set("MCChunk", ext->MCChunk);
    
    typeID = engine->createNewTypeID();
    ext->GfxCompiledShader_typeID = typeID;
    ext->GfxCompiledShader = scripting::createNativeObject(GfxCompiledShader_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxCompiledShader", ext->GfxCompiledShader);
    
    typeID = engine->createNewTypeID();
    ext->RayCastResult_typeID = typeID;
    ext->RayCastResult = scripting::createNativeObject(RayCastResult_funcs, NULL, typeID);
    engine->getGlobalVars().set("RayCastResult", ext->RayCastResult);
    
    typeID = engine->createNewTypeID();
    ext->Entity_typeID = typeID;
    ext->Entity = scripting::createNativeObject(Entity_funcs, NULL, typeID);
    engine->getGlobalVars().set("Entity", ext->Entity);
    
    typeID = engine->createNewTypeID();
    ext->Stats_typeID = typeID;
    ext->Stats = scripting::createNativeObject(Stats_funcs, NULL, typeID);
    engine->getGlobalVars().set("Stats", ext->Stats);
    
    typeID = engine->createNewTypeID();
    ext->Camera_typeID = typeID;
    ext->Camera = scripting::createNativeObject(Camera_funcs, NULL, typeID);
    engine->getGlobalVars().set("Camera", ext->Camera);
    
    typeID = engine->createNewTypeID();
    ext->EntityList_typeID = typeID;
    ext->EntityList = scripting::createNativeObject(EntityList_funcs, NULL, typeID);
    engine->getGlobalVars().set("EntityList", ext->EntityList);
    
    typeID = engine->createNewTypeID();
    ext->Light_typeID = typeID;
    ext->Light = scripting::createNativeObject(Light_funcs, NULL, typeID);
    engine->getGlobalVars().set("Light", ext->Light);
    
    typeID = engine->createNewTypeID();
    ext->TextureSampler_typeID = typeID;
    ext->TextureSampler = scripting::createNativeObject(TextureSampler_funcs, NULL, typeID);
    engine->getGlobalVars().set("TextureSampler", ext->TextureSampler);
    
    typeID = engine->createNewTypeID();
    ext->GhostObject_typeID = typeID;
    ext->GhostObject = scripting::createNativeObject(GhostObject_funcs, NULL, typeID);
    engine->getGlobalVars().set("GhostObject", ext->GhostObject);
    
    typeID = engine->createNewTypeID();
    ext->RayCastResultList_typeID = typeID;
    ext->RayCastResultList = scripting::createNativeObject(RayCastResultList_funcs, NULL, typeID);
    engine->getGlobalVars().set("RayCastResultList", ext->RayCastResultList);
    
    typeID = engine->createNewTypeID();
    ext->RenderStats_typeID = typeID;
    ext->RenderStats = scripting::createNativeObject(RenderStats_funcs, NULL, typeID);
    engine->getGlobalVars().set("RenderStats", ext->RenderStats);
    
    typeID = engine->createNewTypeID();
    ext->Quaternion_typeID = typeID;
    ext->Quaternion = scripting::createNativeObject(Quaternion_funcs, NULL, typeID);
    engine->getGlobalVars().set("Quaternion", ext->Quaternion);
    
    typeID = engine->createNewTypeID();
    ext->ImGui_typeID = typeID;
    ext->ImGui = scripting::createNativeObject(ImGui_funcs, NULL, typeID);
    engine->getGlobalVars().set("ImGui", ext->ImGui);
    
    typeID = engine->createNewTypeID();
    ext->LightDirectionalData_typeID = typeID;
    ext->LightDirectionalData = scripting::createNativeObject(LightDirectionalData_funcs, NULL, typeID);
    engine->getGlobalVars().set("LightDirectionalData", ext->LightDirectionalData);
    
    typeID = engine->createNewTypeID();
    ext->LightSpotData_typeID = typeID;
    ext->LightSpotData = scripting::createNativeObject(LightSpotData_funcs, NULL, typeID);
    engine->getGlobalVars().set("LightSpotData", ext->LightSpotData);
    
    typeID = engine->createNewTypeID();
    ext->FloatList_typeID = typeID;
    ext->FloatList = scripting::createNativeObject(FloatList_funcs, NULL, typeID);
    engine->getGlobalVars().set("FloatList", ext->FloatList);
    
    typeID = engine->createNewTypeID();
    ext->GfxLOD_typeID = typeID;
    ext->GfxLOD = scripting::createNativeObject(GfxLOD_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxLOD", ext->GfxLOD);
    
    typeID = engine->createNewTypeID();
    ext->List_typeID = typeID;
    ext->List = scripting::createNativeObject(List_funcs, NULL, typeID);
    engine->getGlobalVars().set("List", ext->List);
    
    typeID = engine->createNewTypeID();
    ext->File_typeID = typeID;
    ext->File = scripting::createNativeObject(File_funcs, NULL, typeID);
    engine->getGlobalVars().set("File", ext->File);
    
    typeID = engine->createNewTypeID();
    ext->Matrix3x3_typeID = typeID;
    ext->Matrix3x3 = scripting::createNativeObject(Matrix3x3_funcs, NULL, typeID);
    engine->getGlobalVars().set("Matrix3x3", ext->Matrix3x3);
    
    typeID = engine->createNewTypeID();
    ext->GPUTimer_typeID = typeID;
    ext->GPUTimer = scripting::createNativeObject(GPUTimer_funcs, NULL, typeID);
    engine->getGlobalVars().set("GPUTimer", ext->GPUTimer);
    
    typeID = engine->createNewTypeID();
    ext->Filesystem_typeID = typeID;
    ext->Filesystem = scripting::createNativeObject(Filesystem_funcs, NULL, typeID);
    engine->getGlobalVars().set("Filesystem", ext->Filesystem);
    
    typeID = engine->createNewTypeID();
    ext->GfxFramebuffer_typeID = typeID;
    ext->GfxFramebuffer = scripting::createNativeObject(GfxFramebuffer_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxFramebuffer", ext->GfxFramebuffer);
    
    typeID = engine->createNewTypeID();
    ext->Event_typeID = typeID;
    ext->Event = scripting::createNativeObject(Event_funcs, NULL, typeID);
    engine->getGlobalVars().set("Event", ext->Event);
    
    typeID = engine->createNewTypeID();
    ext->Platform_typeID = typeID;
    ext->Platform = scripting::createNativeObject(Platform_funcs, NULL, typeID);
    engine->getGlobalVars().set("Platform", ext->Platform);
    
    typeID = engine->createNewTypeID();
    ext->GfxMesh_typeID = typeID;
    ext->GfxMesh = scripting::createNativeObject(GfxMesh_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxMesh", ext->GfxMesh);
    
    typeID = engine->createNewTypeID();
    ext->GfxShader_typeID = typeID;
    ext->GfxShader = scripting::createNativeObject(GfxShader_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxShader", ext->GfxShader);
    
    typeID = engine->createNewTypeID();
    ext->GfxAnimationState_typeID = typeID;
    ext->GfxAnimationState = scripting::createNativeObject(GfxAnimationState_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxAnimationState", ext->GfxAnimationState);
    
    typeID = engine->createNewTypeID();
    ext->StringList_typeID = typeID;
    ext->StringList = scripting::createNativeObject(StringList_funcs, NULL, typeID);
    engine->getGlobalVars().set("StringList", ext->StringList);
    
    typeID = engine->createNewTypeID();
    ext->GfxRenderer_typeID = typeID;
    ext->GfxRenderer = scripting::createNativeObject(GfxRenderer_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxRenderer", ext->GfxRenderer);
    
    typeID = engine->createNewTypeID();
    ext->Float4_typeID = typeID;
    ext->Float4 = scripting::createNativeObject(Float4_funcs, NULL, typeID);
    engine->getGlobalVars().set("Float4", ext->Float4);
    
    typeID = engine->createNewTypeID();
    ext->LightList_typeID = typeID;
    ext->LightList = scripting::createNativeObject(LightList_funcs, NULL, typeID);
    engine->getGlobalVars().set("LightList", ext->LightList);
    
    typeID = engine->createNewTypeID();
    ext->Float2_typeID = typeID;
    ext->Float2 = scripting::createNativeObject(Float2_funcs, NULL, typeID);
    engine->getGlobalVars().set("Float2", ext->Float2);
    
    typeID = engine->createNewTypeID();
    ext->Float3_typeID = typeID;
    ext->Float3 = scripting::createNativeObject(Float3_funcs, NULL, typeID);
    engine->getGlobalVars().set("Float3", ext->Float3);
    
    typeID = engine->createNewTypeID();
    ext->Container_typeID = typeID;
    ext->Container = scripting::createNativeObject(Container_funcs, NULL, typeID);
    engine->getGlobalVars().set("Container", ext->Container);
    
    typeID = engine->createNewTypeID();
    ext->Frustum_typeID = typeID;
    ext->Frustum = scripting::createNativeObject(Frustum_funcs, NULL, typeID);
    engine->getGlobalVars().set("Frustum", ext->Frustum);
    
    typeID = engine->createNewTypeID();
    ext->AudioDevice_typeID = typeID;
    ext->AudioDevice = scripting::createNativeObject(AudioDevice_funcs, NULL, typeID);
    engine->getGlobalVars().set("AudioDevice", ext->AudioDevice);
    
    typeID = engine->createNewTypeID();
    ext->UInt4_typeID = typeID;
    ext->UInt4 = scripting::createNativeObject(UInt4_funcs, NULL, typeID);
    engine->getGlobalVars().set("UInt4", ext->UInt4);
    
    typeID = engine->createNewTypeID();
    ext->UInt3_typeID = typeID;
    ext->UInt3 = scripting::createNativeObject(UInt3_funcs, NULL, typeID);
    engine->getGlobalVars().set("UInt3", ext->UInt3);
    
    typeID = engine->createNewTypeID();
    ext->UInt2_typeID = typeID;
    ext->UInt2 = scripting::createNativeObject(UInt2_funcs, NULL, typeID);
    engine->getGlobalVars().set("UInt2", ext->UInt2);
    
    typeID = engine->createNewTypeID();
    ext->AABB_typeID = typeID;
    ext->AABB = scripting::createNativeObject(AABB_funcs, NULL, typeID);
    engine->getGlobalVars().set("AABB", ext->AABB);
    
    typeID = engine->createNewTypeID();
    ext->Scene_typeID = typeID;
    ext->Scene = scripting::createNativeObject(Scene_funcs, NULL, typeID);
    engine->getGlobalVars().set("Scene", ext->Scene);
    
    typeID = engine->createNewTypeID();
    ext->GfxSubModelList_typeID = typeID;
    ext->GfxSubModelList = scripting::createNativeObject(GfxSubModelList_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxSubModelList", ext->GfxSubModelList);
    
    typeID = engine->createNewTypeID();
    ext->GfxDebugDrawer_typeID = typeID;
    ext->GfxDebugDrawer = scripting::createNativeObject(GfxDebugDrawer_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxDebugDrawer", ext->GfxDebugDrawer);
    
    typeID = engine->createNewTypeID();
    ext->GuiPlacer_typeID = typeID;
    ext->GuiPlacer = scripting::createNativeObject(GuiPlacer_funcs, NULL, typeID);
    engine->getGlobalVars().set("GuiPlacer", ext->GuiPlacer);
    
    typeID = engine->createNewTypeID();
    ext->GhostObjList_typeID = typeID;
    ext->GhostObjList = scripting::createNativeObject(GhostObjList_funcs, NULL, typeID);
    engine->getGlobalVars().set("GhostObjList", ext->GhostObjList);
    
    typeID = engine->createNewTypeID();
    ext->PhysicsWorld_typeID = typeID;
    ext->PhysicsWorld = scripting::createNativeObject(PhysicsWorld_funcs, NULL, typeID);
    engine->getGlobalVars().set("PhysicsWorld", ext->PhysicsWorld);
    
    typeID = engine->createNewTypeID();
    ext->Script_typeID = typeID;
    ext->Script = scripting::createNativeObject(Script_funcs, NULL, typeID);
    engine->getGlobalVars().set("Script", ext->Script);
    
    typeID = engine->createNewTypeID();
    ext->MCWorld_typeID = typeID;
    ext->MCWorld = scripting::createNativeObject(MCWorld_funcs, NULL, typeID);
    engine->getGlobalVars().set("MCWorld", ext->MCWorld);
    
    typeID = engine->createNewTypeID();
    ext->GfxObject_typeID = typeID;
    ext->GfxObject = scripting::createNativeObject(GfxObject_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxObject", ext->GfxObject);
    
    typeID = engine->createNewTypeID();
    ext->Transform_typeID = typeID;
    ext->Transform = scripting::createNativeObject(Transform_funcs, NULL, typeID);
    engine->getGlobalVars().set("Transform", ext->Transform);
    
    typeID = engine->createNewTypeID();
    ext->AudioSourceList_typeID = typeID;
    ext->AudioSourceList = scripting::createNativeObject(AudioSourceList_funcs, NULL, typeID);
    engine->getGlobalVars().set("AudioSourceList", ext->AudioSourceList);
    
    typeID = engine->createNewTypeID();
    ext->Int4_typeID = typeID;
    ext->Int4 = scripting::createNativeObject(Int4_funcs, NULL, typeID);
    engine->getGlobalVars().set("Int4", ext->Int4);
    
    typeID = engine->createNewTypeID();
    ext->ScrollBar_typeID = typeID;
    ext->ScrollBar = scripting::createNativeObject(ScrollBar_funcs, NULL, typeID);
    engine->getGlobalVars().set("ScrollBar", ext->ScrollBar);
    
    typeID = engine->createNewTypeID();
    ext->Int3_typeID = typeID;
    ext->Int3 = scripting::createNativeObject(Int3_funcs, NULL, typeID);
    engine->getGlobalVars().set("Int3", ext->Int3);
    
    typeID = engine->createNewTypeID();
    ext->ScriptInstance_typeID = typeID;
    ext->ScriptInstance = scripting::createNativeObject(ScriptInstance_funcs, NULL, typeID);
    engine->getGlobalVars().set("ScriptInstance", ext->ScriptInstance);
    
    typeID = engine->createNewTypeID();
    ext->RenderComponent_typeID = typeID;
    ext->RenderComponent = scripting::createNativeObject(RenderComponent_funcs, NULL, typeID);
    engine->getGlobalVars().set("RenderComponent", ext->RenderComponent);
    
    typeID = engine->createNewTypeID();
    ext->RigidBody_typeID = typeID;
    ext->RigidBody = scripting::createNativeObject(RigidBody_funcs, NULL, typeID);
    engine->getGlobalVars().set("RigidBody", ext->RigidBody);
    
    typeID = engine->createNewTypeID();
    ext->RenderList_typeID = typeID;
    ext->RenderList = scripting::createNativeObject(RenderList_funcs, NULL, typeID);
    engine->getGlobalVars().set("RenderList", ext->RenderList);
    
    typeID = engine->createNewTypeID();
    ext->Plane_typeID = typeID;
    ext->Plane = scripting::createNativeObject(Plane_funcs, NULL, typeID);
    engine->getGlobalVars().set("Plane", ext->Plane);
    
    typeID = engine->createNewTypeID();
    ext->PhysicsShape_typeID = typeID;
    ext->PhysicsShape = scripting::createNativeObject(PhysicsShape_funcs, NULL, typeID);
    engine->getGlobalVars().set("PhysicsShape", ext->PhysicsShape);
    
    typeID = engine->createNewTypeID();
    ext->RigidBodyList_typeID = typeID;
    ext->RigidBodyList = scripting::createNativeObject(RigidBodyList_funcs, NULL, typeID);
    engine->getGlobalVars().set("RigidBodyList", ext->RigidBodyList);
    
    typeID = engine->createNewTypeID();
    ext->Resource_typeID = typeID;
    ext->Resource = scripting::createNativeObject(Resource_funcs, NULL, typeID);
    engine->getGlobalVars().set("Resource", ext->Resource);
    
    typeID = engine->createNewTypeID();
    ext->GfxTexture_typeID = typeID;
    ext->GfxTexture = scripting::createNativeObject(GfxTexture_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxTexture", ext->GfxTexture);
    
    typeID = engine->createNewTypeID();
    ext->GfxModel_typeID = typeID;
    ext->GfxModel = scripting::createNativeObject(GfxModel_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxModel", ext->GfxModel);
    
    typeID = engine->createNewTypeID();
    ext->GfxLODList_typeID = typeID;
    ext->GfxLODList = scripting::createNativeObject(GfxLODList_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxLODList", ext->GfxLODList);
    
    typeID = engine->createNewTypeID();
    ext->RigidBodyConstructionInfo_typeID = typeID;
    ext->RigidBodyConstructionInfo = scripting::createNativeObject(RigidBodyConstructionInfo_funcs, NULL, typeID);
    engine->getGlobalVars().set("RigidBodyConstructionInfo", ext->RigidBodyConstructionInfo);
    
    typeID = engine->createNewTypeID();
    ext->GfxApi_typeID = typeID;
    ext->GfxApi = scripting::createNativeObject(GfxApi_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxApi", ext->GfxApi);
    
    typeID = engine->createNewTypeID();
    ext->ResourceManager_typeID = typeID;
    ext->ResourceManager = scripting::createNativeObject(ResourceManager_funcs, NULL, typeID);
    engine->getGlobalVars().set("ResourceManager", ext->ResourceManager);
    
    typeID = engine->createNewTypeID();
    ext->Font_typeID = typeID;
    ext->Font = scripting::createNativeObject(Font_funcs, NULL, typeID);
    engine->getGlobalVars().set("Font", ext->Font);
    
    typeID = engine->createNewTypeID();
    ext->AudioSource_typeID = typeID;
    ext->AudioSource = scripting::createNativeObject(AudioSource_funcs, NULL, typeID);
    engine->getGlobalVars().set("AudioSource", ext->AudioSource);
    
    typeID = engine->createNewTypeID();
    ext->DrawCall_typeID = typeID;
    ext->DrawCall = scripting::createNativeObject(DrawCall_funcs, NULL, typeID);
    engine->getGlobalVars().set("DrawCall", ext->DrawCall);
    
    typeID = engine->createNewTypeID();
    ext->Application_typeID = typeID;
    ext->Application = scripting::createNativeObject(Application_funcs, NULL, typeID);
    engine->getGlobalVars().set("Application", ext->Application);
    
    typeID = engine->createNewTypeID();
    ext->ResizableData_typeID = typeID;
    ext->ResizableData = scripting::createNativeObject(ResizableData_funcs, NULL, typeID);
    engine->getGlobalVars().set("ResizableData", ext->ResizableData);
    
    typeID = engine->createNewTypeID();
    ext->GfxBuffer_typeID = typeID;
    ext->GfxBuffer = scripting::createNativeObject(GfxBuffer_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxBuffer", ext->GfxBuffer);
    
    typeID = engine->createNewTypeID();
    ext->GfxMaterial_typeID = typeID;
    ext->GfxMaterial = scripting::createNativeObject(GfxMaterial_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxMaterial", ext->GfxMaterial);
    
    typeID = engine->createNewTypeID();
    ext->GfxMeshAttrib_typeID = typeID;
    ext->GfxMeshAttrib = scripting::createNativeObject(GfxMeshAttrib_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxMeshAttrib", ext->GfxMeshAttrib);
    
    typeID = engine->createNewTypeID();
    ext->Int2_typeID = typeID;
    ext->Int2 = scripting::createNativeObject(Int2_funcs, NULL, typeID);
    engine->getGlobalVars().set("Int2", ext->Int2);
    
    typeID = engine->createNewTypeID();
    ext->StrStrMap_typeID = typeID;
    ext->StrStrMap = scripting::createNativeObject(StrStrMap_funcs, NULL, typeID);
    engine->getGlobalVars().set("StrStrMap", ext->StrStrMap);
    
    typeID = engine->createNewTypeID();
    ext->LightPointData_typeID = typeID;
    ext->LightPointData = scripting::createNativeObject(LightPointData_funcs, NULL, typeID);
    engine->getGlobalVars().set("LightPointData", ext->LightPointData);
    
    typeID = engine->createNewTypeID();
    ext->Matrix4x4_typeID = typeID;
    ext->Matrix4x4 = scripting::createNativeObject(Matrix4x4_funcs, NULL, typeID);
    engine->getGlobalVars().set("Matrix4x4", ext->Matrix4x4);
    
    typeID = engine->createNewTypeID();
    ext->Map_typeID = typeID;
    ext->Map = scripting::createNativeObject(Map_funcs, NULL, typeID);
    engine->getGlobalVars().set("Map", ext->Map);
    
    typeID = engine->createNewTypeID();
    ext->ScriptInstanceList_typeID = typeID;
    ext->ScriptInstanceList = scripting::createNativeObject(ScriptInstanceList_funcs, NULL, typeID);
    engine->getGlobalVars().set("ScriptInstanceList", ext->ScriptInstanceList);
    
    typeID = engine->createNewTypeID();
    ext->AudioWorld_typeID = typeID;
    ext->AudioWorld = scripting::createNativeObject(AudioWorld_funcs, NULL, typeID);
    engine->getGlobalVars().set("AudioWorld", ext->AudioWorld);
    
    typeID = engine->createNewTypeID();
    ext->Audio_typeID = typeID;
    ext->Audio = scripting::createNativeObject(Audio_funcs, NULL, typeID);
    engine->getGlobalVars().set("Audio", ext->Audio);
    
    typeID = engine->createNewTypeID();
    ext->GfxShaderCombination_typeID = typeID;
    ext->GfxShaderCombination = scripting::createNativeObject(GfxShaderCombination_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxShaderCombination", ext->GfxShaderCombination);
    
    engine->getGlobalVars().set("lookAtDirMat", scripting::createNativeFunction(lookAtDirMat_binding));
    engine->getGlobalVars().set("getFileSys", scripting::createNativeFunction(getFileSys_binding));
    engine->getGlobalVars().set("getAudioDevice", scripting::createNativeFunction(getAudioDevice_binding));
    engine->getGlobalVars().set("listFiles", scripting::createNativeFunction(listFiles_binding));
    engine->getGlobalVars().set("getResMgr", scripting::createNativeFunction(getResMgr_binding));
    engine->getGlobalVars().set("getApp", scripting::createNativeFunction(getApp_binding));
    engine->getGlobalVars().set("getDebugDrawer", scripting::createNativeFunction(getDebugDrawer_binding));
    engine->getGlobalVars().set("getPlatform", scripting::createNativeFunction(getPlatform_binding));
    engine->getGlobalVars().set("getGfxApi", scripting::createNativeFunction(getGfxApi_binding));
    engine->getGlobalVars().set("doesFileExist", scripting::createNativeFunction(doesFileExist_binding));
    typeID = engine->createNewTypeID();
    ext->Key_typeID = typeID;
    ext->Key = scripting::createNativeObject(Key_funcs, NULL, typeID);
    engine->getGlobalVars().set("Key", ext->Key);
    
    typeID = engine->createNewTypeID();
    ext->MouseButton_typeID = typeID;
    ext->MouseButton = scripting::createNativeObject(MouseButton_funcs, NULL, typeID);
    engine->getGlobalVars().set("MouseButton", ext->MouseButton);
    
    typeID = engine->createNewTypeID();
    ext->EventType_typeID = typeID;
    ext->EventType = scripting::createNativeObject(EventType_funcs, NULL, typeID);
    engine->getGlobalVars().set("EventType", ext->EventType);
    
    typeID = engine->createNewTypeID();
    ext->FileOrigin_typeID = typeID;
    ext->FileOrigin = scripting::createNativeObject(FileOrigin_funcs, NULL, typeID);
    engine->getGlobalVars().set("FileOrigin", ext->FileOrigin);
    
    typeID = engine->createNewTypeID();
    ext->ResType_typeID = typeID;
    ext->ResType = scripting::createNativeObject(ResType_funcs, NULL, typeID);
    engine->getGlobalVars().set("ResType", ext->ResType);
    
    typeID = engine->createNewTypeID();
    ext->GfxTextureType_typeID = typeID;
    ext->GfxTextureType = scripting::createNativeObject(GfxTextureType_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxTextureType", ext->GfxTextureType);
    
    typeID = engine->createNewTypeID();
    ext->GfxFilter_typeID = typeID;
    ext->GfxFilter = scripting::createNativeObject(GfxFilter_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxFilter", ext->GfxFilter);
    
    typeID = engine->createNewTypeID();
    ext->GfxMipmapMode_typeID = typeID;
    ext->GfxMipmapMode = scripting::createNativeObject(GfxMipmapMode_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxMipmapMode", ext->GfxMipmapMode);
    
    typeID = engine->createNewTypeID();
    ext->GfxWrapMode_typeID = typeID;
    ext->GfxWrapMode = scripting::createNativeObject(GfxWrapMode_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxWrapMode", ext->GfxWrapMode);
    
    typeID = engine->createNewTypeID();
    ext->GfxTexFormat_typeID = typeID;
    ext->GfxTexFormat = scripting::createNativeObject(GfxTexFormat_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxTexFormat", ext->GfxTexFormat);
    
    typeID = engine->createNewTypeID();
    ext->GfxFace_typeID = typeID;
    ext->GfxFace = scripting::createNativeObject(GfxFace_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxFace", ext->GfxFace);
    
    typeID = engine->createNewTypeID();
    ext->GfxBufferUsage_typeID = typeID;
    ext->GfxBufferUsage = scripting::createNativeObject(GfxBufferUsage_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxBufferUsage", ext->GfxBufferUsage);
    
    typeID = engine->createNewTypeID();
    ext->GfxShaderType_typeID = typeID;
    ext->GfxShaderType = scripting::createNativeObject(GfxShaderType_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxShaderType", ext->GfxShaderType);
    
    typeID = engine->createNewTypeID();
    ext->GfxPrimitive_typeID = typeID;
    ext->GfxPrimitive = scripting::createNativeObject(GfxPrimitive_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxPrimitive", ext->GfxPrimitive);
    
    typeID = engine->createNewTypeID();
    ext->GfxDepthFunction_typeID = typeID;
    ext->GfxDepthFunction = scripting::createNativeObject(GfxDepthFunction_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxDepthFunction", ext->GfxDepthFunction);
    
    typeID = engine->createNewTypeID();
    ext->GfxBlendMode_typeID = typeID;
    ext->GfxBlendMode = scripting::createNativeObject(GfxBlendMode_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxBlendMode", ext->GfxBlendMode);
    
    typeID = engine->createNewTypeID();
    ext->GfxBlendFactor_typeID = typeID;
    ext->GfxBlendFactor = scripting::createNativeObject(GfxBlendFactor_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxBlendFactor", ext->GfxBlendFactor);
    
    typeID = engine->createNewTypeID();
    ext->GfxCullMode_typeID = typeID;
    ext->GfxCullMode = scripting::createNativeObject(GfxCullMode_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxCullMode", ext->GfxCullMode);
    
    typeID = engine->createNewTypeID();
    ext->GfxWinding_typeID = typeID;
    ext->GfxWinding = scripting::createNativeObject(GfxWinding_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxWinding", ext->GfxWinding);
    
    typeID = engine->createNewTypeID();
    ext->GfxVertexAttribPurpose_typeID = typeID;
    ext->GfxVertexAttribPurpose = scripting::createNativeObject(GfxVertexAttribPurpose_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxVertexAttribPurpose", ext->GfxVertexAttribPurpose);
    
    typeID = engine->createNewTypeID();
    ext->GfxVertexAttribType_typeID = typeID;
    ext->GfxVertexAttribType = scripting::createNativeObject(GfxVertexAttribType_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxVertexAttribType", ext->GfxVertexAttribType);
    
    typeID = engine->createNewTypeID();
    ext->GfxMeshIndexDataType_typeID = typeID;
    ext->GfxMeshIndexDataType = scripting::createNativeObject(GfxMeshIndexDataType_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxMeshIndexDataType", ext->GfxMeshIndexDataType);
    
    typeID = engine->createNewTypeID();
    ext->GfxMeshAttribType_typeID = typeID;
    ext->GfxMeshAttribType = scripting::createNativeObject(GfxMeshAttribType_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxMeshAttribType", ext->GfxMeshAttribType);
    
    typeID = engine->createNewTypeID();
    ext->GfxMeshAttribDataType_typeID = typeID;
    ext->GfxMeshAttribDataType = scripting::createNativeObject(GfxMeshAttribDataType_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxMeshAttribDataType", ext->GfxMeshAttribDataType);
    
    typeID = engine->createNewTypeID();
    ext->XOrigin_typeID = typeID;
    ext->XOrigin = scripting::createNativeObject(XOrigin_funcs, NULL, typeID);
    engine->getGlobalVars().set("XOrigin", ext->XOrigin);
    
    typeID = engine->createNewTypeID();
    ext->GfxShadowmapPrecision_typeID = typeID;
    ext->GfxShadowmapPrecision = scripting::createNativeObject(GfxShadowmapPrecision_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxShadowmapPrecision", ext->GfxShadowmapPrecision);
    
    typeID = engine->createNewTypeID();
    ext->GfxLightType_typeID = typeID;
    ext->GfxLightType = scripting::createNativeObject(GfxLightType_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxLightType", ext->GfxLightType);
    
    typeID = engine->createNewTypeID();
    ext->GfxDriver_typeID = typeID;
    ext->GfxDriver = scripting::createNativeObject(GfxDriver_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxDriver", ext->GfxDriver);
    
    typeID = engine->createNewTypeID();
    ext->CameraType_typeID = typeID;
    ext->CameraType = scripting::createNativeObject(CameraType_funcs, NULL, typeID);
    engine->getGlobalVars().set("CameraType", ext->CameraType);
    
    typeID = engine->createNewTypeID();
    ext->Axis_typeID = typeID;
    ext->Axis = scripting::createNativeObject(Axis_funcs, NULL, typeID);
    engine->getGlobalVars().set("Axis", ext->Axis);
    
    typeID = engine->createNewTypeID();
    ext->RigidBodyType_typeID = typeID;
    ext->RigidBodyType = scripting::createNativeObject(RigidBodyType_funcs, NULL, typeID);
    engine->getGlobalVars().set("RigidBodyType", ext->RigidBodyType);
    
    typeID = engine->createNewTypeID();
    ext->PhysicsObjectType_typeID = typeID;
    ext->PhysicsObjectType = scripting::createNativeObject(PhysicsObjectType_funcs, NULL, typeID);
    engine->getGlobalVars().set("PhysicsObjectType", ext->PhysicsObjectType);
    
    typeID = engine->createNewTypeID();
    ext->RenderMode_typeID = typeID;
    ext->RenderMode = scripting::createNativeObject(RenderMode_funcs, NULL, typeID);
    engine->getGlobalVars().set("RenderMode", ext->RenderMode);
    
    return ext;
}

void deinitBindings(scripting::Engine *engine, void *data)
{
    DELETE((BindingsExt *)data);
}

namespace scripting
{
void registerBindings(scripting::Engine *engine)
{
    scripting::Extension ext;

    ext.init = initBindings;
    ext.deinit = deinitBindings;

    engine->addExtension("bindings", ext);
}
}

#pragma GCC diagnostic pop
