//Generated from script_binding_generator2.py. Do not edit. Edit script_binding_generator2.py instead.
#include "platform.h"
#include "filesystem.h"
#include "serialization.h"
#include "misc_macros.h"
#include "error.h"
#include "globals.h"
#include "memory.h"
#include "imgui.h"
#include "application.h"
#include "endian_utils.h"
#include "logging.h"
#include "backtrace.h"
#include "file.h"
#include "graphics/gfxdefs.h"
#include "graphics/gfxmaterial.h"
#include "graphics/gfxdebugdrawer.h"
#include "graphics/light.h"
#include "graphics/gfxterrain.h"
#include "graphics/gputimer.h"
#include "graphics/gfxbuffer.h"
#include "graphics/gfxframebuffer.h"
#include "graphics/gfxapi.h"
#include "graphics/font.h"
#include "graphics/gfxtexture.h"
#include "graphics/gfxmesh.h"
#include "graphics/gfxrenderer.h"
#include "graphics/gfxshader.h"
#include "graphics/camera.h"
#include "graphics/gfxmodel.h"
#include "graphics/GL/gfxglframebuffer.h"
#include "graphics/GL/glfl.h"
#include "graphics/GL/glgputimer.h"
#include "graphics/GL/gfxglbuffer.h"
#include "graphics/GL/gfxglapi.h"
#include "graphics/GL/gfxgltextureimpl.h"
#include "audio/audioworld.h"
#include "audio/audio.h"
#include "audio/audiodevice.h"
#include "resource/resourcemanager.h"
#include "resource/resource.h"
#include "physics/ghostobject.h"
#include "physics/physicsshape.h"
#include "physics/rigidbody.h"
#include "physics/physicsworld.h"
#include "physics/physicsdebugdrawer.h"
#include "math/quaternion.h"
#include "math/aabb.h"
#include "math/t2.h"
#include "math/t3.h"
#include "math/t4.h"
#include "math/matrix4x4.h"
#include "math/matrix3x3.h"
#include "scene/entity.h"
#include "scene/scene.h"
#include "scene/transform.h"
#include "containers/resizabledata.h"
#include "containers/hashmap.h"
#include "containers/list.h"
#include "containers/string.h"
#include "scripting/script_new.h"
#include "scripting/parser.h"
#include "scripting/bytecodegen.h"
#include "scripting/bindings.h"
#include "scripting/disasm.h"
#include "scripting/script.h"
#include "scripting/vm/engine.h"
#include "scripting/vm/context.h"
#include "scripting/vm/bytecode.h"
#include "scripting/vm/types.h"
#include <stdint.h>

#include "scripting/vm/engine.h"
#include "scripting/vm/context.h"
#include "scripting/vm/bytecode.h"
#include "scripting/vm/types.h"
#include "scripting/parser.h"
#include "scripting/bytecodegen.h"
#include <type_traits>

struct BindingsExt
{
    int64_t GhostObject_typeID, GhostObject_ptr_typeID, Filesystem_typeID, Filesystem_ptr_typeID, StrStrMap_typeID, StrStrMap_ptr_typeID, GfxApi_typeID, GfxApi_ptr_typeID, GfxCompiledShader_typeID, GfxCompiledShader_ptr_typeID, ScrollBar_typeID, ScrollBar_ptr_typeID, GhostObjList_typeID, GhostObjList_ptr_typeID, GPUTimer_typeID, GPUTimer_ptr_typeID, RigidBody_typeID, RigidBody_ptr_typeID, UInt2_typeID, UInt2_ptr_typeID, LightList_typeID, LightList_ptr_typeID, ResourceManager_typeID, ResourceManager_ptr_typeID, Entity_typeID, Entity_ptr_typeID, GfxRenderer_typeID, GfxRenderer_ptr_typeID, Float2_typeID, Float2_ptr_typeID, GfxFramebuffer_typeID, GfxFramebuffer_ptr_typeID, Font_typeID, Font_ptr_typeID, Event_typeID, Event_ptr_typeID, PhysicsWorld_typeID, PhysicsWorld_ptr_typeID, Stats_typeID, Stats_ptr_typeID, AudioSource_typeID, AudioSource_ptr_typeID, RayCastResultList_typeID, RayCastResultList_ptr_typeID, Platform_typeID, Platform_ptr_typeID, Camera_typeID, Camera_ptr_typeID, GfxMesh_typeID, GfxMesh_ptr_typeID, Resource_typeID, Resource_ptr_typeID, GfxShader_typeID, GfxShader_ptr_typeID, Light_typeID, Light_ptr_typeID, TextureSampler_typeID, TextureSampler_ptr_typeID, Scene_typeID, Scene_ptr_typeID, Int3_typeID, Int3_ptr_typeID, ResizableData_typeID, ResizableData_ptr_typeID, Int4_typeID, Int4_ptr_typeID, Float3_typeID, Float3_ptr_typeID, GfxBuffer_typeID, GfxBuffer_ptr_typeID, Transform_typeID, Transform_ptr_typeID, AudioSourceList_typeID, AudioSourceList_ptr_typeID, GfxMaterial_typeID, GfxMaterial_ptr_typeID, Quaternion_typeID, Quaternion_ptr_typeID, GfxMeshAttrib_typeID, GfxMeshAttrib_ptr_typeID, RenderComponent_typeID, RenderComponent_ptr_typeID, Int2_typeID, Int2_ptr_typeID, AudioWorld_typeID, AudioWorld_ptr_typeID, GuiPlacer_typeID, GuiPlacer_ptr_typeID, ImGui_typeID, ImGui_ptr_typeID, StringList_typeID, StringList_ptr_typeID, Application_typeID, Application_ptr_typeID, LightPointData_typeID, LightPointData_ptr_typeID, Float4_typeID, Float4_ptr_typeID, FloatList_typeID, FloatList_ptr_typeID, Container_typeID, Container_ptr_typeID, LightDirectionalData_typeID, LightDirectionalData_ptr_typeID, Matrix4x4_typeID, Matrix4x4_ptr_typeID, Map_typeID, Map_ptr_typeID, UInt3_typeID, UInt3_ptr_typeID, LightSpotData_typeID, LightSpotData_ptr_typeID, PhysicsShape_typeID, PhysicsShape_ptr_typeID, AudioDevice_typeID, AudioDevice_ptr_typeID, RigidBodyList_typeID, RigidBodyList_ptr_typeID, UInt4_typeID, UInt4_ptr_typeID, RayCastResult_typeID, RayCastResult_ptr_typeID, GfxLOD_typeID, GfxLOD_ptr_typeID, File_typeID, File_ptr_typeID, AABB_typeID, AABB_ptr_typeID, RigidBodyConstructionInfo_typeID, RigidBodyConstructionInfo_ptr_typeID, List_typeID, List_ptr_typeID, Audio_typeID, Audio_ptr_typeID, GfxTexture_typeID, GfxTexture_ptr_typeID, GfxSubModelList_typeID, GfxSubModelList_ptr_typeID, GfxModel_typeID, GfxModel_ptr_typeID, GfxLODList_typeID, GfxLODList_ptr_typeID, EntityList_typeID, EntityList_ptr_typeID, GfxShaderCombination_typeID, GfxShaderCombination_ptr_typeID, Matrix3x3_typeID, Matrix3x3_ptr_typeID, GfxDebugDrawer_typeID, GfxDebugDrawer_ptr_typeID, Key_typeID, MouseButton_typeID, EventType_typeID, FileOrigin_typeID, XOrigin_typeID, ResType_typeID, GfxPrimitive_typeID, GfxDepthFunction_typeID, GfxBlendMode_typeID, GfxBlendFactor_typeID, GfxCullMode_typeID, GfxWinding_typeID, GfxVertexAttribPurpose_typeID, GfxVertexAttribType_typeID, GfxTextureType_typeID, GfxFilter_typeID, GfxMipmapMode_typeID, GfxWrapMode_typeID, GfxTexFormat_typeID, GfxTexPurpose_typeID, GfxFace_typeID, GfxShaderType_typeID, GfxBufferUsage_typeID, GfxMeshIndexDataType_typeID, GfxMeshAttribType_typeID, GfxMeshAttribDataType_typeID, GfxShadowmapPrecision_typeID, GfxLightType_typeID, GfxDriver_typeID, CameraType_typeID, RigidBodyType_typeID, PhysicsObjectType_typeID, RenderMode_typeID;
    scripting::Value *GhostObject, *GhostObject_ptr, *Filesystem, *Filesystem_ptr, *StrStrMap, *StrStrMap_ptr, *GfxApi, *GfxApi_ptr, *GfxCompiledShader, *GfxCompiledShader_ptr, *ScrollBar, *ScrollBar_ptr, *GhostObjList, *GhostObjList_ptr, *GPUTimer, *GPUTimer_ptr, *RigidBody, *RigidBody_ptr, *UInt2, *UInt2_ptr, *LightList, *LightList_ptr, *ResourceManager, *ResourceManager_ptr, *Entity, *Entity_ptr, *GfxRenderer, *GfxRenderer_ptr, *Float2, *Float2_ptr, *GfxFramebuffer, *GfxFramebuffer_ptr, *Font, *Font_ptr, *Event, *Event_ptr, *PhysicsWorld, *PhysicsWorld_ptr, *Stats, *Stats_ptr, *AudioSource, *AudioSource_ptr, *RayCastResultList, *RayCastResultList_ptr, *Platform, *Platform_ptr, *Camera, *Camera_ptr, *GfxMesh, *GfxMesh_ptr, *Resource, *Resource_ptr, *GfxShader, *GfxShader_ptr, *Light, *Light_ptr, *TextureSampler, *TextureSampler_ptr, *Scene, *Scene_ptr, *Int3, *Int3_ptr, *ResizableData, *ResizableData_ptr, *Int4, *Int4_ptr, *Float3, *Float3_ptr, *GfxBuffer, *GfxBuffer_ptr, *Transform, *Transform_ptr, *AudioSourceList, *AudioSourceList_ptr, *GfxMaterial, *GfxMaterial_ptr, *Quaternion, *Quaternion_ptr, *GfxMeshAttrib, *GfxMeshAttrib_ptr, *RenderComponent, *RenderComponent_ptr, *Int2, *Int2_ptr, *AudioWorld, *AudioWorld_ptr, *GuiPlacer, *GuiPlacer_ptr, *ImGui, *ImGui_ptr, *StringList, *StringList_ptr, *Application, *Application_ptr, *LightPointData, *LightPointData_ptr, *Float4, *Float4_ptr, *FloatList, *FloatList_ptr, *Container, *Container_ptr, *LightDirectionalData, *LightDirectionalData_ptr, *Matrix4x4, *Matrix4x4_ptr, *Map, *Map_ptr, *UInt3, *UInt3_ptr, *LightSpotData, *LightSpotData_ptr, *PhysicsShape, *PhysicsShape_ptr, *AudioDevice, *AudioDevice_ptr, *RigidBodyList, *RigidBodyList_ptr, *UInt4, *UInt4_ptr, *RayCastResult, *RayCastResult_ptr, *GfxLOD, *GfxLOD_ptr, *File, *File_ptr, *AABB, *AABB_ptr, *RigidBodyConstructionInfo, *RigidBodyConstructionInfo_ptr, *List, *List_ptr, *Audio, *Audio_ptr, *GfxTexture, *GfxTexture_ptr, *GfxSubModelList, *GfxSubModelList_ptr, *GfxModel, *GfxModel_ptr, *GfxLODList, *GfxLODList_ptr, *EntityList, *EntityList_ptr, *GfxShaderCombination, *GfxShaderCombination_ptr, *Matrix3x3, *Matrix3x3_ptr, *GfxDebugDrawer, *GfxDebugDrawer_ptr, *Key, *MouseButton, *EventType, *FileOrigin, *XOrigin, *ResType, *GfxPrimitive, *GfxDepthFunction, *GfxBlendMode, *GfxBlendFactor, *GfxCullMode, *GfxWinding, *GfxVertexAttribPurpose, *GfxVertexAttribType, *GfxTextureType, *GfxFilter, *GfxMipmapMode, *GfxWrapMode, *GfxTexFormat, *GfxTexPurpose, *GfxFace, *GfxShaderType, *GfxBufferUsage, *GfxMeshIndexDataType, *GfxMeshAttribType, *GfxMeshAttribDataType, *GfxShadowmapPrecision, *GfxLightType, *GfxDriver, *CameraType, *RigidBodyType, *PhysicsObjectType, *RenderMode;
};


#define CATE ctx->throwException(scripting::createException
#define SV scripting::Value*
#define NO scripting::NativeObject*
#define CV(expr) create_val<std::remove_reference<decltype(expr)>::type>::f(ctx, expr)
#define TS(expr, ...) type_same<std::remove_reference<__VA_ARGS__>::type>::f(ctx, expr)
#define VE scripting::ExcType::ValueError
#define TE scripting::ExcType::TypeError
#define KE scripting::ExcType::KeyError
#define CTX scripting::Context*
#define EXT ((BindingsExt *)ctx->getEngine()->getExtension("bindings").data)
#define STG scripting
#define EI else if
#define RET return
#define UFOF(cm) "Unable to find overload for " cm
#define FAE(meth, cls) meth " expects " cls " as first argument."
#define EAOE " expects at least one argument."
#define CN STG::createNil()
#define CNF STG::createNativeFunction

template <typename T>
struct val_to_c {};

#define VAL_TO_C_INT(T, T2, min, max) template <>struct val_to_c<T2>{    static T f(scripting::Context *ctx, const SV head)    {        int64_t v;                if (head->type == scripting::ValueType::Int)        {            v = ((scripting::IntValue *)head)->value;        } else if (head->type == scripting::ValueType::Float)        {            v = ((scripting::FloatValue *)head)->value;        } else        {            CATE(scripting::ExcType::TypeError, "Value can not be converted to int."));        }                if (v < min or v > max)        {            CATE(scripting::ExcType::TypeError, "Value out of bounds."));        }                return v;    }};

VAL_TO_C_INT(uint8_t, uint8_t, 0, UINT8_MAX)
VAL_TO_C_INT(int8_t, int8_t, INT8_MIN, INT8_MAX)
VAL_TO_C_INT(uint16_t, uint16_t, 0, UINT16_MAX)
VAL_TO_C_INT(int16_t, int16_t, INT16_MIN, INT16_MAX)
VAL_TO_C_INT(uint32_t, uint32_t, 0, UINT32_MAX)
VAL_TO_C_INT(int32_t, int32_t, INT32_MIN, INT32_MAX)
VAL_TO_C_INT(uint64_t, uint64_t, 0, UINT64_MAX)
VAL_TO_C_INT(int64_t, int64_t, INT64_MIN, INT64_MAX)
VAL_TO_C_INT(uint8_t, const uint8_t&, 0, UINT8_MAX)
VAL_TO_C_INT(int8_t, const int8_t&, INT8_MIN, INT8_MAX)
VAL_TO_C_INT(uint16_t, const uint16_t&, 0, UINT16_MAX)
VAL_TO_C_INT(int16_t, const int16_t&, INT16_MIN, INT16_MAX)
VAL_TO_C_INT(uint32_t, const uint32_t&, 0, UINT32_MAX)
VAL_TO_C_INT(int32_t, const int32_t&, INT32_MIN, INT32_MAX)
VAL_TO_C_INT(uint64_t, const uint64_t&, 0, UINT64_MAX)
VAL_TO_C_INT(int64_t, const int64_t&, INT64_MIN, INT64_MAX)

template <>
struct val_to_c<float>
{
    static float f(scripting::Context *ctx, const SV head)
    {
        float v;
        
        if (head->type == scripting::ValueType::Int)
        {
            v = ((scripting::IntValue *)head)->value;
        } else if (head->type == scripting::ValueType::Float)
        {
            v = ((scripting::FloatValue *)head)->value;
        } else
        {
            CATE(scripting::ExcType::TypeError, "Value can not be converted to float."));
        }
        
        return v;
    }
};

template <>
struct val_to_c<double>
{
    static double f(scripting::Context *ctx, const SV head)
    {
        double v;
        
        if (head->type == scripting::ValueType::Int)
        {
            v = ((scripting::IntValue *)head)->value;
        } else if (head->type == scripting::ValueType::Float)
        {
            v = ((scripting::FloatValue *)head)->value;
        } else
        {
            CATE(scripting::ExcType::TypeError, "Value can not be converted to float."));
        }
        
        return v;
    }
};

template <>
struct val_to_c<bool>
{
    static bool f(scripting::Context *ctx, const SV head)
    {
        if (head->type == scripting::ValueType::Boolean)
        {
            return ((scripting::BooleanValue *)head)->value;
        } else
        {
            CATE(scripting::ExcType::TypeError, "Value can not be converted to bool."));
        }
    }
};

template <>
struct val_to_c<String>
{
    static String f(scripting::Context *ctx, const SV head)
    {
        if (head->type == scripting::ValueType::StringType)
        {
            return ((scripting::StringValue *)head)->value;
        } else
        {
            CATE(scripting::ExcType::TypeError, "Value can not be converted to string."));
        }
    }
};

template <>
struct val_to_c<const String>
{
    static const String f(scripting::Context *ctx, const SV head)
    {
        if (head->type == scripting::ValueType::StringType)
        {
            return ((scripting::StringValue *)head)->value;
        } else
        {
            CATE(scripting::ExcType::TypeError, "Value can not be converted to string."));
        }
    }
};

template <>
struct val_to_c<const char *>
{
    static const char *f(scripting::Context *ctx, const SV head)
    {
        if (head->type == scripting::ValueType::StringType)
        {
            return ((scripting::StringValue *)head)->value.getData();
        } else
        {
            CATE(scripting::ExcType::TypeError, "Value can not be converted to string."));
        }
    }
};

template <>
struct val_to_c<char>
{
    static char f(scripting::Context *ctx, const SV head)
    {
        if (head->type == scripting::ValueType::StringType)
        {
            if (((scripting::StringValue *)head)->value.getLength() == 1)
            {
                return ((scripting::StringValue *)head)->value[0];
            } else
            {
                CATE(scripting::ExcType::ValueError, "Value can not be converted to character."));
            }
        } else
        {
            CATE(scripting::ExcType::TypeError, "Value can not be converted to character."));
        }
    }
};

template <>
struct val_to_c<SV>
{
    static SV f(scripting::Context *ctx, const SV head)
    {
        return scripting::createCopy(ctx, head);
    }
};

template <>
struct val_to_c<const SV>
{
    static SV f(scripting::Context *ctx, const SV head)
    {
        return scripting::createCopy(ctx, head);
    }
};

template <>
struct val_to_c<const SV&>
{
    static SV f(scripting::Context *ctx, const SV head)
    {
        return scripting::createCopy(ctx, head);
    }
};

template <typename T>
struct val_to_c<const T&> {
    static T f(scripting::Context *ctx, const SV head)
    {
        return val_to_c<T>::f(ctx, head);
    }
};

template <typename T>
struct create_val {};

#define CREATE_VAL(T, func) template <>struct create_val<T>{    static SV f(scripting::Context *ctx, const T& v)    {        return scripting::func(v);    }};

template <>
struct create_val<SV>
{
    static scripting::Value *f(scripting::Context *ctx, const SV head)
    {
        return scripting::createCopy(ctx, head);
    }
};

template <>
struct create_val<const char *>
{
    static SV f(scripting::Context *ctx, const char *data)
    {
        return scripting::createString(String(data));
    }
};

template <>
struct create_val<char>
{
    static SV f(scripting::Context *ctx, char data)
    {
        return scripting::createString(String(data));
    }
};

template <>
struct create_val<const String>
{
    static SV f(scripting::Context *ctx, const String& data)
    {
        return scripting::createString(data);
    }
};

CREATE_VAL(uint8_t, createInt)
CREATE_VAL(int8_t, createInt)
CREATE_VAL(uint16_t, createInt)
CREATE_VAL(int16_t, createInt)
CREATE_VAL(uint32_t, createInt)
CREATE_VAL(int32_t, createInt)
CREATE_VAL(uint64_t, createInt)
CREATE_VAL(int64_t, createInt)
CREATE_VAL(float, createFloat)
CREATE_VAL(double, createFloat)
CREATE_VAL(bool, createBoolean)
CREATE_VAL(String, createString)

template <typename T>
struct type_same;

template <typename T>
struct type_same<const T&>
{
    static bool f(scripting::Context *ctx, const SV head)
    {
        return type_same<T>::f(ctx, head);
    }
};

template <typename T>
struct type_same<const T>
{
    static bool f(scripting::Context *ctx, const SV head)
    {
        return type_same<T>::f(ctx, head);
    }
};

template <>
struct type_same<SV>
{
    static bool f(scripting::Context *ctx, const SV head)
    {
        return true;
    }
};

template <>
struct type_same<const SV&>
{
    static bool f(scripting::Context *ctx, const SV head)
    {
        return true;
    }
};

template <>
struct type_same<const SV>
{
    static bool f(scripting::Context *ctx, const SV head)
    {
        return true;
    }
};

template <>
struct type_same<char>
{
    static bool f(scripting::Context *ctx, const SV head)
    {
        if (head->type == scripting::ValueType::StringType)
        {
            return ((const scripting::StringValue *)head)->value.getLength() == 1;
        } else
        {
            return false;
        }
    }
};

#define TYPE_SAME_HELPER(T, enumValue) template <>struct type_same<T>{    static bool f(scripting::Context *ctx, const SV head)    {        return head->type == scripting::ValueType::enumValue;    }};

TYPE_SAME_HELPER(uint8_t, Int)
TYPE_SAME_HELPER(int8_t, Int)
TYPE_SAME_HELPER(uint16_t, Int)
TYPE_SAME_HELPER(int16_t, Int)
TYPE_SAME_HELPER(uint32_t, Int)
TYPE_SAME_HELPER(int32_t, Int)
TYPE_SAME_HELPER(uint64_t, Int)
TYPE_SAME_HELPER(int64_t, Int)
TYPE_SAME_HELPER(float, Float)
TYPE_SAME_HELPER(double, Float)
TYPE_SAME_HELPER(bool, Boolean)
TYPE_SAME_HELPER(String, StringType)
TYPE_SAME_HELPER(const char *, StringType)

template <typename T>
T *own(scripting::Context *ctx, SV value)
{
    if (type_same<T *>::f(ctx, value))
    {
        void *ptr = ((NO)value)->data;
        AllocInfo i = getAllocInfo(ptr);
        i.cppRef = true;
        setAllocInfo(ptr, i);

        return (T *)ptr;
    }

    CATE(scripting::ExcType::TypeError, "Argument's value can not be converted."));
}
void Key_destroy(CTX,NO) {}
SV Key_get_member(CTX,NO,SV);
void Key_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Key_funcs={
.destroy = Key_destroy,
.getMember = Key_get_member,
.setMember = Key_set_member
};
template <>
struct create_val<Key>
{
static SV f(CTX ctx,Key v)
{
RET STG::createNativeObject(Key_funcs,(void *)v,EXT->Key_typeID);
}
};
template <>
struct val_to_c<Key>
{
static Key f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to Key."));

NO obj=(NO)head;
if(obj->typeID!=EXT->Key_typeID)
CATE(TE,"Value can not be converted to Key."));
size_t v=size_t(obj->data);
if(v==271)return Key::ScrollLock;
if(v==93)return Key::RightBracket;
if(v==274)return Key::Pause;
if(v==92)return Key::Backslash;
if(v==91)return Key::LeftBracket;
if(v==32)return Key::Space;
if(v==292)return Key::Menu;
if(v==257)return Key::Enter;
if(v==277)return Key::F3;
if(v==50)return Key::_2;
if(v==289)return Key::RightControl;
if(v==259)return Key::Backspace;
if(v==47)return Key::Slash;
if(v==120)return Key::X;
if(v==269)return Key::End;
if(v==265)return Key::Up;
if(v==291)return Key::RightSuper;
if(v==283)return Key::F9;
if(v==287)return Key::LeftSuper;
if(v==273)return Key::PrintScreen;
if(v==122)return Key::Z;
if(v==290)return Key::RightAlt;
if(v==279)return Key::F5;
if(v==266)return Key::PageUp;
if(v==284)return Key::LeftShift;
if(v==281)return Key::F7;
if(v==286)return Key::LeftAlt;
if(v==285)return Key::LeftControl;
if(v==293)return Key::Unknown;
if(v==263)return Key::Left;
if(v==97)return Key::A;
if(v==260)return Key::Insert;
if(v==99)return Key::C;
if(v==98)return Key::B;
if(v==101)return Key::E;
if(v==100)return Key::D;
if(v==103)return Key::G;
if(v==102)return Key::F;
if(v==105)return Key::I;
if(v==104)return Key::H;
if(v==107)return Key::K;
if(v==106)return Key::J;
if(v==109)return Key::M;
if(v==61)return Key::Equal;
if(v==111)return Key::O;
if(v==108)return Key::L;
if(v==113)return Key::Q;
if(v==112)return Key::P;
if(v==115)return Key::S;
if(v==114)return Key::R;
if(v==117)return Key::U;
if(v==116)return Key::T;
if(v==119)return Key::W;
if(v==118)return Key::V;
if(v==121)return Key::Y;
if(v==39)return Key::Apostrophe;
if(v==272)return Key::NumLock;
if(v==110)return Key::N;
if(v==270)return Key::CapsLock;
if(v==45)return Key::Minus;
if(v==261)return Key::Delete;
if(v==275)return Key::F1;
if(v==276)return Key::F2;
if(v==262)return Key::Right;
if(v==278)return Key::F4;
if(v==57)return Key::_9;
if(v==59)return Key::Semicolon;
if(v==56)return Key::_8;
if(v==55)return Key::_7;
if(v==54)return Key::_6;
if(v==53)return Key::_5;
if(v==52)return Key::_4;
if(v==51)return Key::_3;
if(v==46)return Key::Period;
if(v==49)return Key::_1;
if(v==48)return Key::_0;
if(v==264)return Key::Down;
if(v==282)return Key::F8;
if(v==44)return Key::Comma;
if(v==267)return Key::PageDown;
if(v==258)return Key::Tab;
if(v==256)return Key::Escape;
if(v==268)return Key::Home;
if(v==280)return Key::F6;
if(v==288)return Key::RightShift;
}
};
template <>
struct type_same<Key>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Key_typeID;
else
 RET false;
}
};void MouseButton_destroy(CTX,NO) {}
SV MouseButton_get_member(CTX,NO,SV);
void MouseButton_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs MouseButton_funcs={
.destroy = MouseButton_destroy,
.getMember = MouseButton_get_member,
.setMember = MouseButton_set_member
};
template <>
struct create_val<MouseButton>
{
static SV f(CTX ctx,MouseButton v)
{
RET STG::createNativeObject(MouseButton_funcs,(void *)v,EXT->MouseButton_typeID);
}
};
template <>
struct val_to_c<MouseButton>
{
static MouseButton f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to MouseButton."));

NO obj=(NO)head;
if(obj->typeID!=EXT->MouseButton_typeID)
CATE(TE,"Value can not be converted to MouseButton."));
size_t v=size_t(obj->data);
if(v==1)return MouseButton::Middle;
if(v==2)return MouseButton::Right;
if(v==3)return MouseButton::Unknown;
if(v==0)return MouseButton::Left;
}
};
template <>
struct type_same<MouseButton>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->MouseButton_typeID;
else
 RET false;
}
};void EventType_destroy(CTX,NO) {}
SV EventType_get_member(CTX,NO,SV);
void EventType_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs EventType_funcs={
.destroy = EventType_destroy,
.getMember = EventType_get_member,
.setMember = EventType_set_member
};
template <>
struct create_val<EventType>
{
static SV f(CTX ctx,EventType v)
{
RET STG::createNativeObject(EventType_funcs,(void *)v,EXT->EventType_typeID);
}
};
template <>
struct val_to_c<EventType>
{
static EventType f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to EventType."));

NO obj=(NO)head;
if(obj->typeID!=EXT->EventType_typeID)
CATE(TE,"Value can not be converted to EventType."));
size_t v=size_t(obj->data);
if(v==1)return EventType::WindowResize;
if(v==0)return EventType::Quit;
if(v==7)return EventType::MouseWheel;
if(v==4)return EventType::MouseMotion;
if(v==8)return EventType::Unknown;
if(v==5)return EventType::MouseButtonDown;
if(v==3)return EventType::KeyUp;
if(v==2)return EventType::KeyDown;
if(v==6)return EventType::MouseButtonUp;
}
};
template <>
struct type_same<EventType>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->EventType_typeID;
else
 RET false;
}
};void FileOrigin_destroy(CTX,NO) {}
SV FileOrigin_get_member(CTX,NO,SV);
void FileOrigin_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs FileOrigin_funcs={
.destroy = FileOrigin_destroy,
.getMember = FileOrigin_get_member,
.setMember = FileOrigin_set_member
};
template <>
struct create_val<FileOrigin>
{
static SV f(CTX ctx,FileOrigin v)
{
RET STG::createNativeObject(FileOrigin_funcs,(void *)v,EXT->FileOrigin_typeID);
}
};
template <>
struct val_to_c<FileOrigin>
{
static FileOrigin f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to FileOrigin."));

NO obj=(NO)head;
if(obj->typeID!=EXT->FileOrigin_typeID)
CATE(TE,"Value can not be converted to FileOrigin."));
size_t v=size_t(obj->data);
if(v==1)return FileOrigin::Current;
if(v==0)return FileOrigin::Set;
if(v==2)return FileOrigin::End;
}
};
template <>
struct type_same<FileOrigin>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->FileOrigin_typeID;
else
 RET false;
}
};void XOrigin_destroy(CTX,NO) {}
SV XOrigin_get_member(CTX,NO,SV);
void XOrigin_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs XOrigin_funcs={
.destroy = XOrigin_destroy,
.getMember = XOrigin_get_member,
.setMember = XOrigin_set_member
};
template <>
struct create_val<XOrigin>
{
static SV f(CTX ctx,XOrigin v)
{
RET STG::createNativeObject(XOrigin_funcs,(void *)v,EXT->XOrigin_typeID);
}
};
template <>
struct val_to_c<XOrigin>
{
static XOrigin f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to XOrigin."));

NO obj=(NO)head;
if(obj->typeID!=EXT->XOrigin_typeID)
CATE(TE,"Value can not be converted to XOrigin."));
size_t v=size_t(obj->data);
if(v==1)return XOrigin::Right;
if(v==0)return XOrigin::Left;
}
};
template <>
struct type_same<XOrigin>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->XOrigin_typeID;
else
 RET false;
}
};void ResType_destroy(CTX,NO) {}
SV ResType_get_member(CTX,NO,SV);
void ResType_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs ResType_funcs={
.destroy = ResType_destroy,
.getMember = ResType_get_member,
.setMember = ResType_set_member
};
template <>
struct create_val<ResType>
{
static SV f(CTX ctx,ResType v)
{
RET STG::createNativeObject(ResType_funcs,(void *)v,EXT->ResType_typeID);
}
};
template <>
struct val_to_c<ResType>
{
static ResType f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to ResType."));

NO obj=(NO)head;
if(obj->typeID!=EXT->ResType_typeID)
CATE(TE,"Value can not be converted to ResType."));
size_t v=size_t(obj->data);
if(v==3)return ResType::GfxMaterialType;
if(v==6)return ResType::ScriptType;
if(v==1)return ResType::GfxTextureType;
if(v==2)return ResType::GfxMeshType;
if(v==8)return ResType::AudioType;
if(v==9)return ResType::FontType;
if(v==4)return ResType::GfxModelType;
if(v==7)return ResType::PhysicsShapeType;
if(v==0)return ResType::GfxShaderType;
if(v==5)return ResType::SceneType;
}
};
template <>
struct type_same<ResType>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->ResType_typeID;
else
 RET false;
}
};void GfxPrimitive_destroy(CTX,NO) {}
SV GfxPrimitive_get_member(CTX,NO,SV);
void GfxPrimitive_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxPrimitive_funcs={
.destroy = GfxPrimitive_destroy,
.getMember = GfxPrimitive_get_member,
.setMember = GfxPrimitive_set_member
};
template <>
struct create_val<GfxPrimitive>
{
static SV f(CTX ctx,GfxPrimitive v)
{
RET STG::createNativeObject(GfxPrimitive_funcs,(void *)v,EXT->GfxPrimitive_typeID);
}
};
template <>
struct val_to_c<GfxPrimitive>
{
static GfxPrimitive f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxPrimitive."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxPrimitive_typeID)
CATE(TE,"Value can not be converted to GfxPrimitive."));
size_t v=size_t(obj->data);
if(v==1)return GfxLineStrip;
if(v==5)return GfxTriangleFan;
if(v==6)return GfxTriangles;
if(v==0)return GfxPoints;
if(v==3)return GfxLines;
if(v==2)return GfxLineLoop;
if(v==4)return GfxTriangleStrip;
if(v==7)return GfxPatches;
}
};
template <>
struct type_same<GfxPrimitive>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxPrimitive_typeID;
else
 RET false;
}
};void GfxDepthFunction_destroy(CTX,NO) {}
SV GfxDepthFunction_get_member(CTX,NO,SV);
void GfxDepthFunction_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxDepthFunction_funcs={
.destroy = GfxDepthFunction_destroy,
.getMember = GfxDepthFunction_get_member,
.setMember = GfxDepthFunction_set_member
};
template <>
struct create_val<GfxDepthFunction>
{
static SV f(CTX ctx,GfxDepthFunction v)
{
RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)v,EXT->GfxDepthFunction_typeID);
}
};
template <>
struct val_to_c<GfxDepthFunction>
{
static GfxDepthFunction f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxDepthFunction."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxDepthFunction_typeID)
CATE(TE,"Value can not be converted to GfxDepthFunction."));
size_t v=size_t(obj->data);
if(v==6)return GfxGreaterEqual;
if(v==0)return GfxNever;
if(v==3)return GfxLessEqual;
if(v==7)return GfxAlways;
if(v==1)return GfxLess;
if(v==4)return GfxGreater;
if(v==2)return GfxEqual;
if(v==5)return GfxNotEqual;
}
};
template <>
struct type_same<GfxDepthFunction>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxDepthFunction_typeID;
else
 RET false;
}
};void GfxBlendMode_destroy(CTX,NO) {}
SV GfxBlendMode_get_member(CTX,NO,SV);
void GfxBlendMode_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxBlendMode_funcs={
.destroy = GfxBlendMode_destroy,
.getMember = GfxBlendMode_get_member,
.setMember = GfxBlendMode_set_member
};
template <>
struct create_val<GfxBlendMode>
{
static SV f(CTX ctx,GfxBlendMode v)
{
RET STG::createNativeObject(GfxBlendMode_funcs,(void *)v,EXT->GfxBlendMode_typeID);
}
};
template <>
struct val_to_c<GfxBlendMode>
{
static GfxBlendMode f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxBlendMode."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxBlendMode_typeID)
CATE(TE,"Value can not be converted to GfxBlendMode."));
size_t v=size_t(obj->data);
if(v==2)return GfxReverseSubtract;
if(v==0)return GfxAdd;
if(v==1)return GfxSubtract;
}
};
template <>
struct type_same<GfxBlendMode>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxBlendMode_typeID;
else
 RET false;
}
};void GfxBlendFactor_destroy(CTX,NO) {}
SV GfxBlendFactor_get_member(CTX,NO,SV);
void GfxBlendFactor_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxBlendFactor_funcs={
.destroy = GfxBlendFactor_destroy,
.getMember = GfxBlendFactor_get_member,
.setMember = GfxBlendFactor_set_member
};
template <>
struct create_val<GfxBlendFactor>
{
static SV f(CTX ctx,GfxBlendFactor v)
{
RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)v,EXT->GfxBlendFactor_typeID);
}
};
template <>
struct val_to_c<GfxBlendFactor>
{
static GfxBlendFactor f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxBlendFactor."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxBlendFactor_typeID)
CATE(TE,"Value can not be converted to GfxBlendFactor."));
size_t v=size_t(obj->data);
if(v==0)return GfxZero;
if(v==2)return GfxSrcColor;
if(v==7)return GfxOneMinusSrcAlpha;
if(v==12)return GfxConstantAlpha;
if(v==8)return GfxDstAlpha;
if(v==6)return GfxSrcAlpha;
if(v==5)return GfxOneMinusDstColor;
if(v==4)return GfxDstColor;
if(v==11)return GfxOneMinusConstantColor;
if(v==3)return GfxOneMinusSrcColor;
if(v==10)return GfxConstantColor;
if(v==13)return GfxOneMinusConstantAlpha;
if(v==1)return GfxOne;
if(v==9)return GfxOneMinusDstAlpha;
}
};
template <>
struct type_same<GfxBlendFactor>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxBlendFactor_typeID;
else
 RET false;
}
};void GfxCullMode_destroy(CTX,NO) {}
SV GfxCullMode_get_member(CTX,NO,SV);
void GfxCullMode_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxCullMode_funcs={
.destroy = GfxCullMode_destroy,
.getMember = GfxCullMode_get_member,
.setMember = GfxCullMode_set_member
};
template <>
struct create_val<GfxCullMode>
{
static SV f(CTX ctx,GfxCullMode v)
{
RET STG::createNativeObject(GfxCullMode_funcs,(void *)v,EXT->GfxCullMode_typeID);
}
};
template <>
struct val_to_c<GfxCullMode>
{
static GfxCullMode f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxCullMode."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxCullMode_typeID)
CATE(TE,"Value can not be converted to GfxCullMode."));
size_t v=size_t(obj->data);
if(v==0)return GfxCullNone;
if(v==2)return GfxCullBack;
if(v==1)return GfxCullFront;
}
};
template <>
struct type_same<GfxCullMode>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxCullMode_typeID;
else
 RET false;
}
};void GfxWinding_destroy(CTX,NO) {}
SV GfxWinding_get_member(CTX,NO,SV);
void GfxWinding_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxWinding_funcs={
.destroy = GfxWinding_destroy,
.getMember = GfxWinding_get_member,
.setMember = GfxWinding_set_member
};
template <>
struct create_val<GfxWinding>
{
static SV f(CTX ctx,GfxWinding v)
{
RET STG::createNativeObject(GfxWinding_funcs,(void *)v,EXT->GfxWinding_typeID);
}
};
template <>
struct val_to_c<GfxWinding>
{
static GfxWinding f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxWinding."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxWinding_typeID)
CATE(TE,"Value can not be converted to GfxWinding."));
size_t v=size_t(obj->data);
if(v==1)return GfxCCW;
if(v==0)return GfxCW;
}
};
template <>
struct type_same<GfxWinding>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxWinding_typeID;
else
 RET false;
}
};void GfxVertexAttribPurpose_destroy(CTX,NO) {}
SV GfxVertexAttribPurpose_get_member(CTX,NO,SV);
void GfxVertexAttribPurpose_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxVertexAttribPurpose_funcs={
.destroy = GfxVertexAttribPurpose_destroy,
.getMember = GfxVertexAttribPurpose_get_member,
.setMember = GfxVertexAttribPurpose_set_member
};
template <>
struct create_val<GfxVertexAttribPurpose>
{
static SV f(CTX ctx,GfxVertexAttribPurpose v)
{
RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)v,EXT->GfxVertexAttribPurpose_typeID);
}
};
template <>
struct val_to_c<GfxVertexAttribPurpose>
{
static GfxVertexAttribPurpose f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxVertexAttribPurpose."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxVertexAttribPurpose_typeID)
CATE(TE,"Value can not be converted to GfxVertexAttribPurpose."));
size_t v=size_t(obj->data);
if(v==4)return GfxTexCoord;
if(v==2)return GfxTangent;
if(v==0)return GfxPosition;
if(v==1)return GfxNormal;
if(v==3)return GfxColor;
}
};
template <>
struct type_same<GfxVertexAttribPurpose>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxVertexAttribPurpose_typeID;
else
 RET false;
}
};void GfxVertexAttribType_destroy(CTX,NO) {}
SV GfxVertexAttribType_get_member(CTX,NO,SV);
void GfxVertexAttribType_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxVertexAttribType_funcs={
.destroy = GfxVertexAttribType_destroy,
.getMember = GfxVertexAttribType_get_member,
.setMember = GfxVertexAttribType_set_member
};
template <>
struct create_val<GfxVertexAttribType>
{
static SV f(CTX ctx,GfxVertexAttribType v)
{
RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)v,EXT->GfxVertexAttribType_typeID);
}
};
template <>
struct val_to_c<GfxVertexAttribType>
{
static GfxVertexAttribType f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxVertexAttribType."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxVertexAttribType_typeID)
CATE(TE,"Value can not be converted to GfxVertexAttribType."));
size_t v=size_t(obj->data);
if(v==8)return GfxUnsignedInteger;
if(v==10)return GfxNormalizedUnsignedByte;
if(v==1)return GfxFloat;
if(v==14)return GfxNormalizedUnsignedInteger;
if(v==5)return GfxShort;
if(v==7)return GfxInteger;
if(v==3)return GfxByte;
if(v==9)return GfxNormalizedByte;
if(v==6)return GfxUnsignedShort;
if(v==2)return GfxDouble;
if(v==0)return GfxHalfFloat;
if(v==11)return GfxNormalizedShort;
if(v==13)return GfxNormalizedInteger;
if(v==4)return GfxUnsignedByte;
if(v==12)return GfxNormalizedUnsignedShort;
}
};
template <>
struct type_same<GfxVertexAttribType>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxVertexAttribType_typeID;
else
 RET false;
}
};void GfxTextureType_destroy(CTX,NO) {}
SV GfxTextureType_get_member(CTX,NO,SV);
void GfxTextureType_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxTextureType_funcs={
.destroy = GfxTextureType_destroy,
.getMember = GfxTextureType_get_member,
.setMember = GfxTextureType_set_member
};
template <>
struct create_val<GfxTextureType>
{
static SV f(CTX ctx,GfxTextureType v)
{
RET STG::createNativeObject(GfxTextureType_funcs,(void *)v,EXT->GfxTextureType_typeID);
}
};
template <>
struct val_to_c<GfxTextureType>
{
static GfxTextureType f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxTextureType."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxTextureType_typeID)
CATE(TE,"Value can not be converted to GfxTextureType."));
size_t v=size_t(obj->data);
if(v==1)return GfxTextureType::CubeMap;
if(v==2)return GfxTextureType::Texture3D;
if(v==0)return GfxTextureType::Texture2D;
}
};
template <>
struct type_same<GfxTextureType>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxTextureType_typeID;
else
 RET false;
}
};void GfxFilter_destroy(CTX,NO) {}
SV GfxFilter_get_member(CTX,NO,SV);
void GfxFilter_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxFilter_funcs={
.destroy = GfxFilter_destroy,
.getMember = GfxFilter_get_member,
.setMember = GfxFilter_set_member
};
template <>
struct create_val<GfxFilter>
{
static SV f(CTX ctx,GfxFilter v)
{
RET STG::createNativeObject(GfxFilter_funcs,(void *)v,EXT->GfxFilter_typeID);
}
};
template <>
struct val_to_c<GfxFilter>
{
static GfxFilter f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxFilter."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxFilter_typeID)
CATE(TE,"Value can not be converted to GfxFilter."));
size_t v=size_t(obj->data);
if(v==1)return GfxFilter::Bilinear;
if(v==0)return GfxFilter::Nearest;
}
};
template <>
struct type_same<GfxFilter>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxFilter_typeID;
else
 RET false;
}
};void GfxMipmapMode_destroy(CTX,NO) {}
SV GfxMipmapMode_get_member(CTX,NO,SV);
void GfxMipmapMode_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxMipmapMode_funcs={
.destroy = GfxMipmapMode_destroy,
.getMember = GfxMipmapMode_get_member,
.setMember = GfxMipmapMode_set_member
};
template <>
struct create_val<GfxMipmapMode>
{
static SV f(CTX ctx,GfxMipmapMode v)
{
RET STG::createNativeObject(GfxMipmapMode_funcs,(void *)v,EXT->GfxMipmapMode_typeID);
}
};
template <>
struct val_to_c<GfxMipmapMode>
{
static GfxMipmapMode f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxMipmapMode."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxMipmapMode_typeID)
CATE(TE,"Value can not be converted to GfxMipmapMode."));
size_t v=size_t(obj->data);
if(v==1)return GfxMipmapMode::Nearest;
if(v==0)return GfxMipmapMode::None;
if(v==2)return GfxMipmapMode::Linear;
}
};
template <>
struct type_same<GfxMipmapMode>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxMipmapMode_typeID;
else
 RET false;
}
};void GfxWrapMode_destroy(CTX,NO) {}
SV GfxWrapMode_get_member(CTX,NO,SV);
void GfxWrapMode_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxWrapMode_funcs={
.destroy = GfxWrapMode_destroy,
.getMember = GfxWrapMode_get_member,
.setMember = GfxWrapMode_set_member
};
template <>
struct create_val<GfxWrapMode>
{
static SV f(CTX ctx,GfxWrapMode v)
{
RET STG::createNativeObject(GfxWrapMode_funcs,(void *)v,EXT->GfxWrapMode_typeID);
}
};
template <>
struct val_to_c<GfxWrapMode>
{
static GfxWrapMode f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxWrapMode."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxWrapMode_typeID)
CATE(TE,"Value can not be converted to GfxWrapMode."));
size_t v=size_t(obj->data);
if(v==0)return GfxWrapMode::Stretch;
if(v==1)return GfxWrapMode::Repeat;
if(v==2)return GfxWrapMode::Mirror;
}
};
template <>
struct type_same<GfxWrapMode>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxWrapMode_typeID;
else
 RET false;
}
};void GfxTexFormat_destroy(CTX,NO) {}
SV GfxTexFormat_get_member(CTX,NO,SV);
void GfxTexFormat_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxTexFormat_funcs={
.destroy = GfxTexFormat_destroy,
.getMember = GfxTexFormat_get_member,
.setMember = GfxTexFormat_set_member
};
template <>
struct create_val<GfxTexFormat>
{
static SV f(CTX ctx,GfxTexFormat v)
{
RET STG::createNativeObject(GfxTexFormat_funcs,(void *)v,EXT->GfxTexFormat_typeID);
}
};
template <>
struct val_to_c<GfxTexFormat>
{
static GfxTexFormat f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxTexFormat."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxTexFormat_typeID)
CATE(TE,"Value can not be converted to GfxTexFormat."));
size_t v=size_t(obj->data);
if(v==29)return GfxTexFormat::RGBAF32_F16;
if(v==13)return GfxTexFormat::LuminanceAlphaI8;
if(v==9)return GfxTexFormat::LuminanceI16;
if(v==1)return GfxTexFormat::AlphaI8;
if(v==36)return GfxTexFormat::Int2_8;
if(v==70)return GfxTexFormat::RedF32_F16;
if(v==34)return GfxTexFormat::Int_32;
if(v==39)return GfxTexFormat::UInt2_16;
if(v==12)return GfxTexFormat::LuminanceAlphaU8;
if(v==41)return GfxTexFormat::UInt2_32;
if(v==19)return GfxTexFormat::RGBI8;
if(v==68)return GfxTexFormat::RedI16;
if(v==67)return GfxTexFormat::RedU16;
if(v==7)return GfxTexFormat::LuminanceI8;
if(v==38)return GfxTexFormat::Int2_16;
if(v==26)return GfxTexFormat::RGBAU16;
if(v==23)return GfxTexFormat::RGBF32_F16;
if(v==62)return GfxTexFormat::RedGreenI16;
if(v==65)return GfxTexFormat::RedU8;
if(v==42)return GfxTexFormat::Int3_8;
if(v==30)return GfxTexFormat::Int_8;
if(v==8)return GfxTexFormat::LuminanceU16;
if(v==3)return GfxTexFormat::AlphaI16;
if(v==21)return GfxTexFormat::RGBI16;
if(v==11)return GfxTexFormat::LuminanceF32_F16;
if(v==6)return GfxTexFormat::LuminanceU8;
if(v==31)return GfxTexFormat::UInt_8;
if(v==37)return GfxTexFormat::UInt2_8;
if(v==44)return GfxTexFormat::Int3_16;
if(v==24)return GfxTexFormat::RGBAU8;
if(v==20)return GfxTexFormat::RGBU16;
if(v==16)return GfxTexFormat::LuminanceAlphaF32;
if(v==28)return GfxTexFormat::RGBAF32;
if(v==43)return GfxTexFormat::UInt3_8;
if(v==48)return GfxTexFormat::Int4_8;
if(v==14)return GfxTexFormat::LuminanceAlphaU16;
if(v==40)return GfxTexFormat::Int2_32;
if(v==33)return GfxTexFormat::UInt_16;
if(v==49)return GfxTexFormat::UInt4_8;
if(v==2)return GfxTexFormat::AlphaU16;
if(v==60)return GfxTexFormat::RedGreenI8;
if(v==17)return GfxTexFormat::LuminanceAlphaF32_F16;
if(v==46)return GfxTexFormat::Int3_32;
if(v==64)return GfxTexFormat::RedGreenF32_F16;
if(v==18)return GfxTexFormat::RGBU8;
if(v==54)return GfxTexFormat::SRGBU8;
if(v==59)return GfxTexFormat::RedGreenU8;
if(v==58)return GfxTexFormat::DepthF32;
if(v==4)return GfxTexFormat::AlphaF32;
if(v==35)return GfxTexFormat::UInt_32;
if(v==0)return GfxTexFormat::AlphaU8;
if(v==57)return GfxTexFormat::DepthF32_F24;
if(v==69)return GfxTexFormat::RedF32;
if(v==63)return GfxTexFormat::RedGreenF32;
if(v==50)return GfxTexFormat::Int4_16;
if(v==25)return GfxTexFormat::RGBAI8;
if(v==53)return GfxTexFormat::UInt4_32;
if(v==51)return GfxTexFormat::UInt4_16;
if(v==45)return GfxTexFormat::UInt3_16;
if(v==47)return GfxTexFormat::UInt3_32;
if(v==66)return GfxTexFormat::RedI8;
if(v==52)return GfxTexFormat::Int4_32;
if(v==55)return GfxTexFormat::SRGBAU8;
if(v==10)return GfxTexFormat::LuminanceF32;
if(v==22)return GfxTexFormat::RGBF32;
if(v==32)return GfxTexFormat::Int_16;
if(v==61)return GfxTexFormat::RedGreenU16;
if(v==15)return GfxTexFormat::LuminanceAlphaI16;
if(v==27)return GfxTexFormat::RGBAI16;
if(v==56)return GfxTexFormat::DepthF32_F16;
if(v==5)return GfxTexFormat::AlphaF32_F16;
}
};
template <>
struct type_same<GfxTexFormat>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxTexFormat_typeID;
else
 RET false;
}
};void GfxTexPurpose_destroy(CTX,NO) {}
SV GfxTexPurpose_get_member(CTX,NO,SV);
void GfxTexPurpose_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxTexPurpose_funcs={
.destroy = GfxTexPurpose_destroy,
.getMember = GfxTexPurpose_get_member,
.setMember = GfxTexPurpose_set_member
};
template <>
struct create_val<GfxTexPurpose>
{
static SV f(CTX ctx,GfxTexPurpose v)
{
RET STG::createNativeObject(GfxTexPurpose_funcs,(void *)v,EXT->GfxTexPurpose_typeID);
}
};
template <>
struct val_to_c<GfxTexPurpose>
{
static GfxTexPurpose f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxTexPurpose."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxTexPurpose_typeID)
CATE(TE,"Value can not be converted to GfxTexPurpose."));
size_t v=size_t(obj->data);
if(v==0)return GfxTexPurpose::Color;
if(v==2)return GfxTexPurpose::Other;
if(v==1)return GfxTexPurpose::Normal;
}
};
template <>
struct type_same<GfxTexPurpose>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxTexPurpose_typeID;
else
 RET false;
}
};void GfxFace_destroy(CTX,NO) {}
SV GfxFace_get_member(CTX,NO,SV);
void GfxFace_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxFace_funcs={
.destroy = GfxFace_destroy,
.getMember = GfxFace_get_member,
.setMember = GfxFace_set_member
};
template <>
struct create_val<GfxFace>
{
static SV f(CTX ctx,GfxFace v)
{
RET STG::createNativeObject(GfxFace_funcs,(void *)v,EXT->GfxFace_typeID);
}
};
template <>
struct val_to_c<GfxFace>
{
static GfxFace f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxFace."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxFace_typeID)
CATE(TE,"Value can not be converted to GfxFace."));
size_t v=size_t(obj->data);
if(v==4)return GfxFace::PositiveZ;
if(v==0)return GfxFace::PositiveX;
if(v==2)return GfxFace::PositiveY;
if(v==5)return GfxFace::NegativeZ;
if(v==1)return GfxFace::NegativeX;
if(v==3)return GfxFace::NegativeY;
}
};
template <>
struct type_same<GfxFace>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxFace_typeID;
else
 RET false;
}
};void GfxShaderType_destroy(CTX,NO) {}
SV GfxShaderType_get_member(CTX,NO,SV);
void GfxShaderType_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxShaderType_funcs={
.destroy = GfxShaderType_destroy,
.getMember = GfxShaderType_get_member,
.setMember = GfxShaderType_set_member
};
template <>
struct create_val<GfxShaderType>
{
static SV f(CTX ctx,GfxShaderType v)
{
RET STG::createNativeObject(GfxShaderType_funcs,(void *)v,EXT->GfxShaderType_typeID);
}
};
template <>
struct val_to_c<GfxShaderType>
{
static GfxShaderType f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxShaderType."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxShaderType_typeID)
CATE(TE,"Value can not be converted to GfxShaderType."));
size_t v=size_t(obj->data);
if(v==5)return GfxShaderType::Compute;
if(v==3)return GfxShaderType::Geometry;
if(v==0)return GfxShaderType::Vertex;
if(v==4)return GfxShaderType::Fragment;
if(v==1)return GfxShaderType::TessControl;
if(v==2)return GfxShaderType::TessEval;
}
};
template <>
struct type_same<GfxShaderType>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxShaderType_typeID;
else
 RET false;
}
};void GfxBufferUsage_destroy(CTX,NO) {}
SV GfxBufferUsage_get_member(CTX,NO,SV);
void GfxBufferUsage_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxBufferUsage_funcs={
.destroy = GfxBufferUsage_destroy,
.getMember = GfxBufferUsage_get_member,
.setMember = GfxBufferUsage_set_member
};
template <>
struct create_val<GfxBufferUsage>
{
static SV f(CTX ctx,GfxBufferUsage v)
{
RET STG::createNativeObject(GfxBufferUsage_funcs,(void *)v,EXT->GfxBufferUsage_typeID);
}
};
template <>
struct val_to_c<GfxBufferUsage>
{
static GfxBufferUsage f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxBufferUsage."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxBufferUsage_typeID)
CATE(TE,"Value can not be converted to GfxBufferUsage."));
size_t v=size_t(obj->data);
if(v==2)return GfxBufferUsage::Dynamic;
if(v==1)return GfxBufferUsage::Static;
if(v==0)return GfxBufferUsage::Stream;
}
};
template <>
struct type_same<GfxBufferUsage>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxBufferUsage_typeID;
else
 RET false;
}
};void GfxMeshIndexDataType_destroy(CTX,NO) {}
SV GfxMeshIndexDataType_get_member(CTX,NO,SV);
void GfxMeshIndexDataType_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxMeshIndexDataType_funcs={
.destroy = GfxMeshIndexDataType_destroy,
.getMember = GfxMeshIndexDataType_get_member,
.setMember = GfxMeshIndexDataType_set_member
};
template <>
struct create_val<GfxMeshIndexDataType>
{
static SV f(CTX ctx,GfxMeshIndexDataType v)
{
RET STG::createNativeObject(GfxMeshIndexDataType_funcs,(void *)v,EXT->GfxMeshIndexDataType_typeID);
}
};
template <>
struct val_to_c<GfxMeshIndexDataType>
{
static GfxMeshIndexDataType f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxMeshIndexDataType."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxMeshIndexDataType_typeID)
CATE(TE,"Value can not be converted to GfxMeshIndexDataType."));
size_t v=size_t(obj->data);
if(v==2)return GfxMeshIndexDataType::U32;
if(v==0)return GfxMeshIndexDataType::U8;
if(v==1)return GfxMeshIndexDataType::U16;
}
};
template <>
struct type_same<GfxMeshIndexDataType>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxMeshIndexDataType_typeID;
else
 RET false;
}
};void GfxMeshAttribType_destroy(CTX,NO) {}
SV GfxMeshAttribType_get_member(CTX,NO,SV);
void GfxMeshAttribType_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxMeshAttribType_funcs={
.destroy = GfxMeshAttribType_destroy,
.getMember = GfxMeshAttribType_get_member,
.setMember = GfxMeshAttribType_set_member
};
template <>
struct create_val<GfxMeshAttribType>
{
static SV f(CTX ctx,GfxMeshAttribType v)
{
RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)v,EXT->GfxMeshAttribType_typeID);
}
};
template <>
struct val_to_c<GfxMeshAttribType>
{
static GfxMeshAttribType f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxMeshAttribType."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxMeshAttribType_typeID)
CATE(TE,"Value can not be converted to GfxMeshAttribType."));
size_t v=size_t(obj->data);
if(v==1)return GfxMeshAttribType::Normal;
if(v==3)return GfxMeshAttribType::Color;
if(v==4)return GfxMeshAttribType::TexCoord;
if(v==2)return GfxMeshAttribType::Tangent;
if(v==6)return GfxMeshAttribType::BoneWeight;
if(v==0)return GfxMeshAttribType::Position;
if(v==5)return GfxMeshAttribType::BoneIndex;
}
};
template <>
struct type_same<GfxMeshAttribType>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxMeshAttribType_typeID;
else
 RET false;
}
};void GfxMeshAttribDataType_destroy(CTX,NO) {}
SV GfxMeshAttribDataType_get_member(CTX,NO,SV);
void GfxMeshAttribDataType_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxMeshAttribDataType_funcs={
.destroy = GfxMeshAttribDataType_destroy,
.getMember = GfxMeshAttribDataType_get_member,
.setMember = GfxMeshAttribDataType_set_member
};
template <>
struct create_val<GfxMeshAttribDataType>
{
static SV f(CTX ctx,GfxMeshAttribDataType v)
{
RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)v,EXT->GfxMeshAttribDataType_typeID);
}
};
template <>
struct val_to_c<GfxMeshAttribDataType>
{
static GfxMeshAttribDataType f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxMeshAttribDataType."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxMeshAttribDataType_typeID)
CATE(TE,"Value can not be converted to GfxMeshAttribDataType."));
size_t v=size_t(obj->data);
if(v==54)return GfxMeshAttribDataType::S32_3Norm;
if(v==21)return GfxMeshAttribDataType::S16_2;
if(v==22)return GfxMeshAttribDataType::S16_3;
if(v==20)return GfxMeshAttribDataType::S16_1;
if(v==37)return GfxMeshAttribDataType::S8_2Norm;
if(v==23)return GfxMeshAttribDataType::S16_4;
if(v==53)return GfxMeshAttribDataType::S32_2Norm;
if(v==42)return GfxMeshAttribDataType::U16_3Norm;
if(v==55)return GfxMeshAttribDataType::S32_4Norm;
if(v==38)return GfxMeshAttribDataType::S8_3Norm;
if(v==25)return GfxMeshAttribDataType::U32_2;
if(v==26)return GfxMeshAttribDataType::U32_3;
if(v==24)return GfxMeshAttribDataType::U32_1;
if(v==27)return GfxMeshAttribDataType::U32_4;
if(v==36)return GfxMeshAttribDataType::S8_1Norm;
if(v==9)return GfxMeshAttribDataType::U8_2;
if(v==10)return GfxMeshAttribDataType::U8_3;
if(v==8)return GfxMeshAttribDataType::U8_1;
if(v==39)return GfxMeshAttribDataType::S8_4Norm;
if(v==11)return GfxMeshAttribDataType::U8_4;
if(v==34)return GfxMeshAttribDataType::U8_3Norm;
if(v==2)return GfxMeshAttribDataType::F16_3;
if(v==1)return GfxMeshAttribDataType::F16_2;
if(v==0)return GfxMeshAttribDataType::F16_1;
if(v==52)return GfxMeshAttribDataType::S32_1Norm;
if(v==3)return GfxMeshAttribDataType::F16_4;
if(v==50)return GfxMeshAttribDataType::U32_3Norm;
if(v==41)return GfxMeshAttribDataType::U16_2Norm;
if(v==40)return GfxMeshAttribDataType::U16_1Norm;
if(v==33)return GfxMeshAttribDataType::U8_2Norm;
if(v==35)return GfxMeshAttribDataType::U8_4Norm;
if(v==51)return GfxMeshAttribDataType::U32_4Norm;
if(v==48)return GfxMeshAttribDataType::U32_1Norm;
if(v==45)return GfxMeshAttribDataType::S16_2Norm;
if(v==19)return GfxMeshAttribDataType::U16_4;
if(v==16)return GfxMeshAttribDataType::U16_1;
if(v==17)return GfxMeshAttribDataType::U16_2;
if(v==18)return GfxMeshAttribDataType::U16_3;
if(v==47)return GfxMeshAttribDataType::S16_4Norm;
if(v==32)return GfxMeshAttribDataType::U8_1Norm;
if(v==31)return GfxMeshAttribDataType::S32_4;
if(v==12)return GfxMeshAttribDataType::S8_1;
if(v==13)return GfxMeshAttribDataType::S8_2;
if(v==14)return GfxMeshAttribDataType::S8_3;
if(v==15)return GfxMeshAttribDataType::S8_4;
if(v==28)return GfxMeshAttribDataType::S32_1;
if(v==29)return GfxMeshAttribDataType::S32_2;
if(v==30)return GfxMeshAttribDataType::S32_3;
if(v==49)return GfxMeshAttribDataType::U32_2Norm;
if(v==46)return GfxMeshAttribDataType::S16_3Norm;
if(v==4)return GfxMeshAttribDataType::F32_1;
if(v==6)return GfxMeshAttribDataType::F32_3;
if(v==5)return GfxMeshAttribDataType::F32_2;
if(v==7)return GfxMeshAttribDataType::F32_4;
if(v==43)return GfxMeshAttribDataType::U16_4Norm;
if(v==44)return GfxMeshAttribDataType::S16_1Norm;
}
};
template <>
struct type_same<GfxMeshAttribDataType>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxMeshAttribDataType_typeID;
else
 RET false;
}
};void GfxShadowmapPrecision_destroy(CTX,NO) {}
SV GfxShadowmapPrecision_get_member(CTX,NO,SV);
void GfxShadowmapPrecision_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxShadowmapPrecision_funcs={
.destroy = GfxShadowmapPrecision_destroy,
.getMember = GfxShadowmapPrecision_get_member,
.setMember = GfxShadowmapPrecision_set_member
};
template <>
struct create_val<GfxShadowmapPrecision>
{
static SV f(CTX ctx,GfxShadowmapPrecision v)
{
RET STG::createNativeObject(GfxShadowmapPrecision_funcs,(void *)v,EXT->GfxShadowmapPrecision_typeID);
}
};
template <>
struct val_to_c<GfxShadowmapPrecision>
{
static GfxShadowmapPrecision f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxShadowmapPrecision."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxShadowmapPrecision_typeID)
CATE(TE,"Value can not be converted to GfxShadowmapPrecision."));
size_t v=size_t(obj->data);
if(v==2)return GfxShadowmapPrecision::High;
if(v==1)return GfxShadowmapPrecision::Medium;
if(v==0)return GfxShadowmapPrecision::Low;
}
};
template <>
struct type_same<GfxShadowmapPrecision>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxShadowmapPrecision_typeID;
else
 RET false;
}
};void GfxLightType_destroy(CTX,NO) {}
SV GfxLightType_get_member(CTX,NO,SV);
void GfxLightType_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxLightType_funcs={
.destroy = GfxLightType_destroy,
.getMember = GfxLightType_get_member,
.setMember = GfxLightType_set_member
};
template <>
struct create_val<GfxLightType>
{
static SV f(CTX ctx,GfxLightType v)
{
RET STG::createNativeObject(GfxLightType_funcs,(void *)v,EXT->GfxLightType_typeID);
}
};
template <>
struct val_to_c<GfxLightType>
{
static GfxLightType f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxLightType."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxLightType_typeID)
CATE(TE,"Value can not be converted to GfxLightType."));
size_t v=size_t(obj->data);
if(v==2)return GfxLightType::Point;
if(v==1)return GfxLightType::Spot;
if(v==0)return GfxLightType::Directional;
}
};
template <>
struct type_same<GfxLightType>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxLightType_typeID;
else
 RET false;
}
};void GfxDriver_destroy(CTX,NO) {}
SV GfxDriver_get_member(CTX,NO,SV);
void GfxDriver_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxDriver_funcs={
.destroy = GfxDriver_destroy,
.getMember = GfxDriver_get_member,
.setMember = GfxDriver_set_member
};
template <>
struct create_val<GfxDriver>
{
static SV f(CTX ctx,GfxDriver v)
{
RET STG::createNativeObject(GfxDriver_funcs,(void *)v,EXT->GfxDriver_typeID);
}
};
template <>
struct val_to_c<GfxDriver>
{
static GfxDriver f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to GfxDriver."));

NO obj=(NO)head;
if(obj->typeID!=EXT->GfxDriver_typeID)
CATE(TE,"Value can not be converted to GfxDriver."));
size_t v=size_t(obj->data);
if(v==2)return GfxDriver::Unknown;
if(v==1)return GfxDriver::Mesa;
if(v==0)return GfxDriver::Nvidia;
}
};
template <>
struct type_same<GfxDriver>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxDriver_typeID;
else
 RET false;
}
};void CameraType_destroy(CTX,NO) {}
SV CameraType_get_member(CTX,NO,SV);
void CameraType_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs CameraType_funcs={
.destroy = CameraType_destroy,
.getMember = CameraType_get_member,
.setMember = CameraType_set_member
};
template <>
struct create_val<CameraType>
{
static SV f(CTX ctx,CameraType v)
{
RET STG::createNativeObject(CameraType_funcs,(void *)v,EXT->CameraType_typeID);
}
};
template <>
struct val_to_c<CameraType>
{
static CameraType f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to CameraType."));

NO obj=(NO)head;
if(obj->typeID!=EXT->CameraType_typeID)
CATE(TE,"Value can not be converted to CameraType."));
size_t v=size_t(obj->data);
if(v==0)return CameraType::Perspective;
if(v==1)return CameraType::Orthographic;
}
};
template <>
struct type_same<CameraType>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->CameraType_typeID;
else
 RET false;
}
};void RigidBodyType_destroy(CTX,NO) {}
SV RigidBodyType_get_member(CTX,NO,SV);
void RigidBodyType_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs RigidBodyType_funcs={
.destroy = RigidBodyType_destroy,
.getMember = RigidBodyType_get_member,
.setMember = RigidBodyType_set_member
};
template <>
struct create_val<RigidBodyType>
{
static SV f(CTX ctx,RigidBodyType v)
{
RET STG::createNativeObject(RigidBodyType_funcs,(void *)v,EXT->RigidBodyType_typeID);
}
};
template <>
struct val_to_c<RigidBodyType>
{
static RigidBodyType f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to RigidBodyType."));

NO obj=(NO)head;
if(obj->typeID!=EXT->RigidBodyType_typeID)
CATE(TE,"Value can not be converted to RigidBodyType."));
size_t v=size_t(obj->data);
if(v==1)return RigidBodyType::Dynamic;
if(v==0)return RigidBodyType::Static;
if(v==2)return RigidBodyType::Kinematic;
}
};
template <>
struct type_same<RigidBodyType>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RigidBodyType_typeID;
else
 RET false;
}
};void PhysicsObjectType_destroy(CTX,NO) {}
SV PhysicsObjectType_get_member(CTX,NO,SV);
void PhysicsObjectType_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs PhysicsObjectType_funcs={
.destroy = PhysicsObjectType_destroy,
.getMember = PhysicsObjectType_get_member,
.setMember = PhysicsObjectType_set_member
};
template <>
struct create_val<PhysicsObjectType>
{
static SV f(CTX ctx,PhysicsObjectType v)
{
RET STG::createNativeObject(PhysicsObjectType_funcs,(void *)v,EXT->PhysicsObjectType_typeID);
}
};
template <>
struct val_to_c<PhysicsObjectType>
{
static PhysicsObjectType f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to PhysicsObjectType."));

NO obj=(NO)head;
if(obj->typeID!=EXT->PhysicsObjectType_typeID)
CATE(TE,"Value can not be converted to PhysicsObjectType."));
size_t v=size_t(obj->data);
if(v==0)return PhysicsObjectType::Body;
if(v==1)return PhysicsObjectType::Ghost;
}
};
template <>
struct type_same<PhysicsObjectType>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->PhysicsObjectType_typeID;
else
 RET false;
}
};void RenderMode_destroy(CTX,NO) {}
SV RenderMode_get_member(CTX,NO,SV);
void RenderMode_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs RenderMode_funcs={
.destroy = RenderMode_destroy,
.getMember = RenderMode_get_member,
.setMember = RenderMode_set_member
};
template <>
struct create_val<RenderMode>
{
static SV f(CTX ctx,RenderMode v)
{
RET STG::createNativeObject(RenderMode_funcs,(void *)v,EXT->RenderMode_typeID);
}
};
template <>
struct val_to_c<RenderMode>
{
static RenderMode f(CTX ctx,const SV head)
{
if(head->type!=STG::ValueType::NativeObject)
CATE(TE,"Value can not be converted to RenderMode."));

NO obj=(NO)head;
if(obj->typeID!=EXT->RenderMode_typeID)
CATE(TE,"Value can not be converted to RenderMode."));
size_t v=size_t(obj->data);
if(v==0)return RenderMode::Nothing;
if(v==1)return RenderMode::Model;
if(v==2)return RenderMode::Overlay;
}
};
template <>
struct type_same<RenderMode>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RenderMode_typeID;
else
 RET false;
}
};void GhostObject_destroy(CTX,NO);
SV GhostObject_get_member(CTX,NO,SV);
void GhostObject_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GhostObject_funcs={
.destroy = GhostObject_destroy,
.getMember = GhostObject_get_member,
.setMember = GhostObject_set_member
};
template <>
struct type_same<GhostObject>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GhostObject_typeID;
else
 RET false;
}
};

SV GhostObject_getBulletGhostObject(CTX ctx,const List<SV>&a);
SV GhostObject_getTransform(CTX ctx,const List<SV>&a);
SV GhostObject_setTransform(CTX ctx,const List<SV>&a);
SV GhostObject_getWorld(CTX ctx,const List<SV>&a);
SV GhostObject_getCollisionMask(CTX ctx,const List<SV>&a);
SV GhostObject_setShape(CTX ctx,const List<SV>&a);
SV GhostObject_getCollisions(CTX ctx,const List<SV>&a);
SV GhostObject_getRigidBodyCollisions(CTX ctx,const List<SV>&a);
SV GhostObject_getGhostCollisions(CTX ctx,const List<SV>&a);
SV GhostObject_getShape(CTX ctx,const List<SV>&a);
void Filesystem_destroy(CTX,NO);
SV Filesystem_get_member(CTX,NO,SV);
void Filesystem_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Filesystem_funcs={
.destroy = Filesystem_destroy,
.getMember = Filesystem_get_member,
.setMember = Filesystem_set_member
};
template <>
struct create_val<Filesystem>
{
static SV f(CTX ctx,const Filesystem&obj)
{
#define ghfj Filesystem
RET STG::createNativeObject(Filesystem_funcs,NEW(ghfj, obj),EXT->Filesystem_typeID);
}
};
template <>
struct val_to_c<Filesystem>
{
static Filesystem f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Filesystem_typeID)
RET*((Filesystem*)obj->data);
else
 CATE(TE,"Value can not be converted to Filesystem."));
} else
 CATE(TE,"Value can not be converted to Filesystem."));
}
};

template <>
struct val_to_c<const Filesystem>
{
static Filesystem f(CTX ctx,const SV head) {return val_to_c<Filesystem>::f(ctx, head);}
};

template <>
struct create_val<const Filesystem>
{
static SV f(CTX ctx,const Filesystem&obj) {return create_val<Filesystem>::f(ctx,obj);}
};

template <>
struct type_same<Filesystem>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Filesystem_typeID;
else
 RET false;
}
};

SV Filesystem_pushSearchPaths(CTX ctx,const List<SV>&a);
SV Filesystem_popSearchPaths(CTX ctx,const List<SV>&a);
SV Filesystem_addSearchPath(CTX ctx,const List<SV>&a);
SV Filesystem_getAbsolutePath(CTX ctx,const List<SV>&a);
void StrStrMap_destroy(CTX,NO);
SV StrStrMap_get_member(CTX,NO,SV);
void StrStrMap_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs StrStrMap_funcs={
.destroy = StrStrMap_destroy,
.getMember = StrStrMap_get_member,
.setMember = StrStrMap_set_member
};
template <>
struct create_val<HashMap<String,String>>
{
static SV f(CTX ctx,const HashMap<String,String>&obj)
{
#define ghfj HashMap<String,String>
RET STG::createNativeObject(StrStrMap_funcs,NEW(ghfj, obj),EXT->StrStrMap_typeID);
}
};
template <>
struct val_to_c<HashMap<String,String>>
{
static HashMap<String,String> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->StrStrMap_typeID)
RET*((HashMap<String,String>*)obj->data);
else
 CATE(TE,"Value can not be converted to StrStrMap."));
} else
 CATE(TE,"Value can not be converted to StrStrMap."));
}
};

template <>
struct val_to_c<const HashMap<String,String>>
{
static HashMap<String,String> f(CTX ctx,const SV head) {return val_to_c<HashMap<String,String>>::f(ctx, head);}
};

template <>
struct create_val<const HashMap<String,String>>
{
static SV f(CTX ctx,const HashMap<String,String>&obj) {return create_val<HashMap<String,String>>::f(ctx,obj);}
};

template <>
struct type_same<HashMap<String,String>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->StrStrMap_typeID;
else
 RET false;
}
};

SV StrStrMap___eq__(CTX ctx,const List<SV>&a);
SV StrStrMap___neq__(CTX ctx,const List<SV>&a);
SV StrStrMap_getEntryCount(CTX ctx,const List<SV>&a);
SV StrStrMap_findEntry(CTX ctx,const List<SV>&a);
SV StrStrMap_getKey(CTX ctx,const List<SV>&a);
SV StrStrMap_getValue(CTX ctx,const List<SV>&a);
SV StrStrMap_getKeyHash(CTX ctx,const List<SV>&a);
SV StrStrMap_get(CTX ctx,const List<SV>&a);
SV StrStrMap_set(CTX ctx,const List<SV>&a);
SV StrStrMap_removeEntry(CTX ctx,const List<SV>&a);
SV StrStrMap_remove(CTX ctx,const List<SV>&a);
SV StrStrMap_clear(CTX ctx,const List<SV>&a);
SV StrStrMap_append(CTX ctx,const List<SV>&a);
void GfxApi_destroy(CTX,NO);
SV GfxApi_get_member(CTX,NO,SV);
void GfxApi_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxApi_funcs={
.destroy = GfxApi_destroy,
.getMember = GfxApi_get_member,
.setMember = GfxApi_set_member
};
template <>
struct type_same<GfxApi>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxApi_typeID;
else
 RET false;
}
};

SV GfxApi_getDriver(CTX ctx,const List<SV>&a);
SV GfxApi_tesselationSupported(CTX ctx,const List<SV>&a);
SV GfxApi_createBuffer(CTX ctx,const List<SV>&a);
SV GfxApi_createTextureImpl(CTX ctx,const List<SV>&a);
SV GfxApi_createFramebuffer(CTX ctx,const List<SV>&a);
SV GfxApi_createTimer(CTX ctx,const List<SV>&a);
SV GfxApi_setCurrentFramebuffer(CTX ctx,const List<SV>&a);
SV GfxApi_clearDepth(CTX ctx,const List<SV>&a);
SV GfxApi_clearColor(CTX ctx,const List<SV>&a);
SV GfxApi_begin(CTX ctx,const List<SV>&a);
SV GfxApi_draw(CTX ctx,const List<SV>&a);
SV GfxApi_end(CTX ctx,const List<SV>&a);
SV GfxApi_uniform(CTX ctx,const List<SV>&a);
SV GfxApi_addUBOBinding(CTX ctx,const List<SV>&a);
SV GfxApi_addTextureBinding(CTX ctx,const List<SV>&a);
SV GfxApi_pushState(CTX ctx,const List<SV>&a);
SV GfxApi_popState(CTX ctx,const List<SV>&a);
SV GfxApi_resetState(CTX ctx,const List<SV>&a);
SV GfxApi_setBlendingEnabled(CTX ctx,const List<SV>&a);
SV GfxApi_isBlendingEnabled(CTX ctx,const List<SV>&a);
SV GfxApi_setBlendConstantColor(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendConstantColor(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendConstantColorR(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendConstantColorG(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendConstantColorB(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendConstantColorA(CTX ctx,const List<SV>&a);
SV GfxApi_setBlendFactors(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendSrcFactorRGB(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendSrcFactorAlpha(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendDstFactorRGB(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendDstFactorAlpha(CTX ctx,const List<SV>&a);
SV GfxApi_setBlendMode(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendModeRGB(CTX ctx,const List<SV>&a);
SV GfxApi_getBlendModeAlpha(CTX ctx,const List<SV>&a);
SV GfxApi_setWriteDepth(CTX ctx,const List<SV>&a);
SV GfxApi_getWriteDepth(CTX ctx,const List<SV>&a);
SV GfxApi_setDepthFunction(CTX ctx,const List<SV>&a);
SV GfxApi_getDepthFunction(CTX ctx,const List<SV>&a);
SV GfxApi_setCullMode(CTX ctx,const List<SV>&a);
SV GfxApi_getCullMode(CTX ctx,const List<SV>&a);
SV GfxApi_setViewport(CTX ctx,const List<SV>&a);
SV GfxApi_getViewportLeft(CTX ctx,const List<SV>&a);
SV GfxApi_getViewportBottom(CTX ctx,const List<SV>&a);
SV GfxApi_getViewportWidth(CTX ctx,const List<SV>&a);
SV GfxApi_getViewportHeight(CTX ctx,const List<SV>&a);
SV GfxApi_setScissor(CTX ctx,const List<SV>&a);
SV GfxApi_getScissorLeft(CTX ctx,const List<SV>&a);
SV GfxApi_getScissorBottom(CTX ctx,const List<SV>&a);
SV GfxApi_getScissorWidth(CTX ctx,const List<SV>&a);
SV GfxApi_getScissorHeight(CTX ctx,const List<SV>&a);
SV GfxApi_setScissorEnabled(CTX ctx,const List<SV>&a);
SV GfxApi_getScissorEnabled(CTX ctx,const List<SV>&a);
SV GfxApi_setTessPatchSize(CTX ctx,const List<SV>&a);
SV GfxApi_getTessPatchSize(CTX ctx,const List<SV>&a);
void GfxCompiledShader_destroy(CTX,NO);
SV GfxCompiledShader_get_member(CTX,NO,SV);
void GfxCompiledShader_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxCompiledShader_funcs={
.destroy = GfxCompiledShader_destroy,
.getMember = GfxCompiledShader_get_member,
.setMember = GfxCompiledShader_set_member
};
template <>
struct create_val<GfxCompiledShader>
{
static SV f(CTX ctx,const GfxCompiledShader&obj)
{
#define ghfj GfxCompiledShader
RET STG::createNativeObject(GfxCompiledShader_funcs,NEW(ghfj, obj),EXT->GfxCompiledShader_typeID);
}
};
template <>
struct val_to_c<GfxCompiledShader>
{
static GfxCompiledShader f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxCompiledShader_typeID)
RET*((GfxCompiledShader*)obj->data);
else
 CATE(TE,"Value can not be converted to GfxCompiledShader."));
} else
 CATE(TE,"Value can not be converted to GfxCompiledShader."));
}
};

template <>
struct val_to_c<const GfxCompiledShader>
{
static GfxCompiledShader f(CTX ctx,const SV head) {return val_to_c<GfxCompiledShader>::f(ctx, head);}
};

template <>
struct create_val<const GfxCompiledShader>
{
static SV f(CTX ctx,const GfxCompiledShader&obj) {return create_val<GfxCompiledShader>::f(ctx,obj);}
};

template <>
struct type_same<GfxCompiledShader>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxCompiledShader_typeID;
else
 RET false;
}
};

SV GfxCompiledShader_getShader(CTX ctx,const List<SV>&a);
SV GfxCompiledShader_getGLProgram(CTX ctx,const List<SV>&a);
SV GfxCompiledShader_getGLShader(CTX ctx,const List<SV>&a);
void ScrollBar_destroy(CTX,NO);
SV ScrollBar_get_member(CTX,NO,SV);
void ScrollBar_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs ScrollBar_funcs={
.destroy = ScrollBar_destroy,
.getMember = ScrollBar_get_member,
.setMember = ScrollBar_set_member
};
template <>
struct create_val<ScrollBar>
{
static SV f(CTX ctx,const ScrollBar&obj)
{
#define ghfj ScrollBar
RET STG::createNativeObject(ScrollBar_funcs,NEW(ghfj, obj),EXT->ScrollBar_typeID);
}
};
template <>
struct val_to_c<ScrollBar>
{
static ScrollBar f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->ScrollBar_typeID)
RET*((ScrollBar*)obj->data);
else
 CATE(TE,"Value can not be converted to ScrollBar."));
} else
 CATE(TE,"Value can not be converted to ScrollBar."));
}
};

template <>
struct val_to_c<const ScrollBar>
{
static ScrollBar f(CTX ctx,const SV head) {return val_to_c<ScrollBar>::f(ctx, head);}
};

template <>
struct create_val<const ScrollBar>
{
static SV f(CTX ctx,const ScrollBar&obj) {return create_val<ScrollBar>::f(ctx,obj);}
};

template <>
struct type_same<ScrollBar>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->ScrollBar_typeID;
else
 RET false;
}
};

SV ScrollBar_getValue(CTX ctx,const List<SV>&a);
SV ScrollBar_setValue(CTX ctx,const List<SV>&a);
void GhostObjList_destroy(CTX,NO);
SV GhostObjList_get_member(CTX,NO,SV);
void GhostObjList_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GhostObjList_funcs={
.destroy = GhostObjList_destroy,
.getMember = GhostObjList_get_member,
.setMember = GhostObjList_set_member
};
template <>
struct create_val<List<GhostObject*>>
{
static SV f(CTX ctx,const List<GhostObject*>&obj)
{
#define ghfj List<GhostObject*>
RET STG::createNativeObject(GhostObjList_funcs,NEW(ghfj, obj),EXT->GhostObjList_typeID);
}
};
template <>
struct val_to_c<List<GhostObject*>>
{
static List<GhostObject*> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GhostObjList_typeID)
RET*((List<GhostObject*>*)obj->data);
else
 CATE(TE,"Value can not be converted to GhostObjList."));
} else
 CATE(TE,"Value can not be converted to GhostObjList."));
}
};

template <>
struct val_to_c<const List<GhostObject*>>
{
static List<GhostObject*> f(CTX ctx,const SV head) {return val_to_c<List<GhostObject*>>::f(ctx, head);}
};

template <>
struct create_val<const List<GhostObject*>>
{
static SV f(CTX ctx,const List<GhostObject*>&obj) {return create_val<List<GhostObject*>>::f(ctx,obj);}
};

template <>
struct type_same<List<GhostObject*>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GhostObjList_typeID;
else
 RET false;
}
};

SV GhostObjList___eq__(CTX ctx,const List<SV>&a);
SV GhostObjList___neq__(CTX ctx,const List<SV>&a);
SV GhostObjList_get(CTX ctx,const List<SV>&a);
SV GhostObjList_set(CTX ctx,const List<SV>&a);
SV GhostObjList_getCount(CTX ctx,const List<SV>&a);
SV GhostObjList_getData(CTX ctx,const List<SV>&a);
SV GhostObjList_append(CTX ctx,const List<SV>&a);
SV GhostObjList_insert(CTX ctx,const List<SV>&a);
SV GhostObjList_remove(CTX ctx,const List<SV>&a);
SV GhostObjList_clear(CTX ctx,const List<SV>&a);
SV GhostObjList_find(CTX ctx,const List<SV>&a);
SV GhostObjList_copy(CTX ctx,const List<SV>&a);
SV GhostObjList_in(CTX ctx,const List<SV>&a);
SV GhostObjList_begin(CTX ctx,const List<SV>&a);
SV GhostObjList_end(CTX ctx,const List<SV>&a);
void GPUTimer_destroy(CTX,NO);
SV GPUTimer_get_member(CTX,NO,SV);
void GPUTimer_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GPUTimer_funcs={
.destroy = GPUTimer_destroy,
.getMember = GPUTimer_get_member,
.setMember = GPUTimer_set_member
};
template <>
struct type_same<GPUTimer>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GPUTimer_typeID;
else
 RET false;
}
};

SV GPUTimer_resultAvailable(CTX ctx,const List<SV>&a);
SV GPUTimer_getResult(CTX ctx,const List<SV>&a);
SV GPUTimer_getResultResolution(CTX ctx,const List<SV>&a);
SV GPUTimer_begin(CTX ctx,const List<SV>&a);
SV GPUTimer_end(CTX ctx,const List<SV>&a);
void RigidBody_destroy(CTX,NO);
SV RigidBody_get_member(CTX,NO,SV);
void RigidBody_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs RigidBody_funcs={
.destroy = RigidBody_destroy,
.getMember = RigidBody_get_member,
.setMember = RigidBody_set_member
};
template <>
struct type_same<RigidBody>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RigidBody_typeID;
else
 RET false;
}
};

SV RigidBody_getBulletRigidBody(CTX ctx,const List<SV>&a);
SV RigidBody_getType(CTX ctx,const List<SV>&a);
SV RigidBody_getGravity(CTX ctx,const List<SV>&a);
SV RigidBody_setGravity(CTX ctx,const List<SV>&a);
SV RigidBody_setLinearDamping(CTX ctx,const List<SV>&a);
SV RigidBody_getLinearDamping(CTX ctx,const List<SV>&a);
SV RigidBody_setAngularDamping(CTX ctx,const List<SV>&a);
SV RigidBody_getAngularDamping(CTX ctx,const List<SV>&a);
SV RigidBody_setMass(CTX ctx,const List<SV>&a);
SV RigidBody_getMass(CTX ctx,const List<SV>&a);
SV RigidBody_getLinearSleepingThreshold(CTX ctx,const List<SV>&a);
SV RigidBody_setLinearSleepingThreshold(CTX ctx,const List<SV>&a);
SV RigidBody_getAngularSleepingThreshold(CTX ctx,const List<SV>&a);
SV RigidBody_setAngularSleepingThreshold(CTX ctx,const List<SV>&a);
SV RigidBody_applyTorque(CTX ctx,const List<SV>&a);
SV RigidBody_applyForce(CTX ctx,const List<SV>&a);
SV RigidBody_applyCentralImpulse(CTX ctx,const List<SV>&a);
SV RigidBody_applyTorqueImpulse(CTX ctx,const List<SV>&a);
SV RigidBody_applyImpulse(CTX ctx,const List<SV>&a);
SV RigidBody_clearForces(CTX ctx,const List<SV>&a);
SV RigidBody_getLinearVelocity(CTX ctx,const List<SV>&a);
SV RigidBody_setLinearVelocity(CTX ctx,const List<SV>&a);
SV RigidBody_getAngularVelocity(CTX ctx,const List<SV>&a);
SV RigidBody_setAngularVelocity(CTX ctx,const List<SV>&a);
SV RigidBody_getVelocityOfPoint(CTX ctx,const List<SV>&a);
SV RigidBody_getRestitution(CTX ctx,const List<SV>&a);
SV RigidBody_setRestitution(CTX ctx,const List<SV>&a);
SV RigidBody_getFriction(CTX ctx,const List<SV>&a);
SV RigidBody_setFriction(CTX ctx,const List<SV>&a);
SV RigidBody_getRollingFriction(CTX ctx,const List<SV>&a);
SV RigidBody_setRollingFriction(CTX ctx,const List<SV>&a);
SV RigidBody_getLinearFactor(CTX ctx,const List<SV>&a);
SV RigidBody_setLinearFactor(CTX ctx,const List<SV>&a);
SV RigidBody_getAngularFactor(CTX ctx,const List<SV>&a);
SV RigidBody_setAngularFactor(CTX ctx,const List<SV>&a);
SV RigidBody_setTransform(CTX ctx,const List<SV>&a);
SV RigidBody_getWorld(CTX ctx,const List<SV>&a);
SV RigidBody_getCollisionMask(CTX ctx,const List<SV>&a);
SV RigidBody_setShape(CTX ctx,const List<SV>&a);
SV RigidBody_getShape(CTX ctx,const List<SV>&a);
SV RigidBody_getEntity(CTX ctx,const List<SV>&a);
void UInt2_destroy(CTX,NO);
SV UInt2_get_member(CTX,NO,SV);
void UInt2_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs UInt2_funcs={
.destroy = UInt2_destroy,
.getMember = UInt2_get_member,
.setMember = UInt2_set_member
};
template <>
struct create_val<T2<uint32_t>>
{
static SV f(CTX ctx,const T2<uint32_t>&obj)
{
#define ghfj T2<uint32_t>
RET STG::createNativeObject(UInt2_funcs,NEW(ghfj, obj),EXT->UInt2_typeID);
}
};
template <>
struct val_to_c<T2<uint32_t>>
{
static T2<uint32_t> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->UInt2_typeID)
RET*((T2<uint32_t>*)obj->data);
else
 CATE(TE,"Value can not be converted to UInt2."));
} else
 CATE(TE,"Value can not be converted to UInt2."));
}
};

template <>
struct val_to_c<const T2<uint32_t>>
{
static T2<uint32_t> f(CTX ctx,const SV head) {return val_to_c<T2<uint32_t>>::f(ctx, head);}
};

template <>
struct create_val<const T2<uint32_t>>
{
static SV f(CTX ctx,const T2<uint32_t>&obj) {return create_val<T2<uint32_t>>::f(ctx,obj);}
};

template <>
struct type_same<T2<uint32_t>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->UInt2_typeID;
else
 RET false;
}
};

SV UInt2___add__(CTX ctx,const List<SV>&a);
SV UInt2___sub__(CTX ctx,const List<SV>&a);
SV UInt2___mul__(CTX ctx,const List<SV>&a);
SV UInt2___div__(CTX ctx,const List<SV>&a);
SV UInt2___eq__(CTX ctx,const List<SV>&a);
SV UInt2___neq__(CTX ctx,const List<SV>&a);
SV UInt2___less__(CTX ctx,const List<SV>&a);
SV UInt2___grtr__(CTX ctx,const List<SV>&a);
SV UInt2___leq__(CTX ctx,const List<SV>&a);
SV UInt2___geq__(CTX ctx,const List<SV>&a);
SV UInt2_sum(CTX ctx,const List<SV>&a);
SV UInt2_length(CTX ctx,const List<SV>&a);
SV UInt2_lengthSquared(CTX ctx,const List<SV>&a);
SV UInt2_dot(CTX ctx,const List<SV>&a);
SV UInt2_distance(CTX ctx,const List<SV>&a);
SV UInt2_distanceSquared(CTX ctx,const List<SV>&a);
SV UInt2_normalize(CTX ctx,const List<SV>&a);
SV UInt2_getXY(CTX ctx,const List<SV>&a);
SV UInt2_setXY(CTX ctx,const List<SV>&a);
SV UInt2_getYX(CTX ctx,const List<SV>&a);
SV UInt2_setYX(CTX ctx,const List<SV>&a);
void LightList_destroy(CTX,NO);
SV LightList_get_member(CTX,NO,SV);
void LightList_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs LightList_funcs={
.destroy = LightList_destroy,
.getMember = LightList_get_member,
.setMember = LightList_set_member
};
template <>
struct create_val<List<Light*>>
{
static SV f(CTX ctx,const List<Light*>&obj)
{
#define ghfj List<Light*>
RET STG::createNativeObject(LightList_funcs,NEW(ghfj, obj),EXT->LightList_typeID);
}
};
template <>
struct val_to_c<List<Light*>>
{
static List<Light*> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->LightList_typeID)
RET*((List<Light*>*)obj->data);
else
 CATE(TE,"Value can not be converted to LightList."));
} else
 CATE(TE,"Value can not be converted to LightList."));
}
};

template <>
struct val_to_c<const List<Light*>>
{
static List<Light*> f(CTX ctx,const SV head) {return val_to_c<List<Light*>>::f(ctx, head);}
};

template <>
struct create_val<const List<Light*>>
{
static SV f(CTX ctx,const List<Light*>&obj) {return create_val<List<Light*>>::f(ctx,obj);}
};

template <>
struct type_same<List<Light*>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->LightList_typeID;
else
 RET false;
}
};

SV LightList___eq__(CTX ctx,const List<SV>&a);
SV LightList___neq__(CTX ctx,const List<SV>&a);
SV LightList_get(CTX ctx,const List<SV>&a);
SV LightList_set(CTX ctx,const List<SV>&a);
SV LightList_getCount(CTX ctx,const List<SV>&a);
SV LightList_getData(CTX ctx,const List<SV>&a);
SV LightList_append(CTX ctx,const List<SV>&a);
SV LightList_insert(CTX ctx,const List<SV>&a);
SV LightList_remove(CTX ctx,const List<SV>&a);
SV LightList_clear(CTX ctx,const List<SV>&a);
SV LightList_find(CTX ctx,const List<SV>&a);
SV LightList_copy(CTX ctx,const List<SV>&a);
SV LightList_in(CTX ctx,const List<SV>&a);
SV LightList_begin(CTX ctx,const List<SV>&a);
SV LightList_end(CTX ctx,const List<SV>&a);
void ResourceManager_destroy(CTX,NO);
SV ResourceManager_get_member(CTX,NO,SV);
void ResourceManager_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs ResourceManager_funcs={
.destroy = ResourceManager_destroy,
.getMember = ResourceManager_get_member,
.setMember = ResourceManager_set_member
};
template <>
struct type_same<ResourceManager>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->ResourceManager_typeID;
else
 RET false;
}
};

SV ResourceManager_loadShader(CTX ctx,const List<SV>&a);
SV ResourceManager_loadTexture(CTX ctx,const List<SV>&a);
SV ResourceManager_loadMesh(CTX ctx,const List<SV>&a);
SV ResourceManager_loadMaterial(CTX ctx,const List<SV>&a);
SV ResourceManager_loadModel(CTX ctx,const List<SV>&a);
SV ResourceManager_loadScene(CTX ctx,const List<SV>&a);
SV ResourceManager_loadScript(CTX ctx,const List<SV>&a);
SV ResourceManager_loadPhysicsShape(CTX ctx,const List<SV>&a);
SV ResourceManager_loadAudio(CTX ctx,const List<SV>&a);
SV ResourceManager_loadFont(CTX ctx,const List<SV>&a);
SV ResourceManager_load(CTX ctx,const List<SV>&a);
SV ResourceManager_loadShaderAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadTextureAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadMeshAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadMaterialAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadModelAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadSceneAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadScriptAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadPhysicsShapeAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadAudioAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadFontAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_loadAndCopy(CTX ctx,const List<SV>&a);
SV ResourceManager_isResource(CTX ctx,const List<SV>&a);
SV ResourceManager_cleanupResources(CTX ctx,const List<SV>&a);
void Entity_destroy(CTX,NO);
SV Entity_get_member(CTX,NO,SV);
void Entity_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Entity_funcs={
.destroy = Entity_destroy,
.getMember = Entity_get_member,
.setMember = Entity_set_member
};
template <>
struct type_same<Entity>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Entity_typeID;
else
 RET false;
}
};

SV Entity_addScript(CTX ctx,const List<SV>&a);
SV Entity_removeScript(CTX ctx,const List<SV>&a);
SV Entity_getScripts(CTX ctx,const List<SV>&a);
SV Entity_findScriptInstanceByName(CTX ctx,const List<SV>&a);
SV Entity_addRigidBody(CTX ctx,const List<SV>&a);
SV Entity_getRigidBody(CTX ctx,const List<SV>&a);
SV Entity_removeRigidBody(CTX ctx,const List<SV>&a);
SV Entity_hasRigidBody(CTX ctx,const List<SV>&a);
SV Entity_addModel(CTX ctx,const List<SV>&a);
SV Entity_addOverlay(CTX ctx,const List<SV>&a);
SV Entity_removeRenderComponent(CTX ctx,const List<SV>&a);
SV Entity_getRenderComponent(CTX ctx,const List<SV>&a);
SV Entity_hasRenderComponent(CTX ctx,const List<SV>&a);
SV Entity_getScene(CTX ctx,const List<SV>&a);
SV Entity_createEntity(CTX ctx,const List<SV>&a);
SV Entity_removeEntity(CTX ctx,const List<SV>&a);
SV Entity_getEntities(CTX ctx,const List<SV>&a);
SV Entity_getParent(CTX ctx,const List<SV>&a);
SV Entity_updateFinalTransform(CTX ctx,const List<SV>&a);
SV Entity_getFinalTransform(CTX ctx,const List<SV>&a);
SV Entity_getAudioSources(CTX ctx,const List<SV>&a);
SV Entity_addAudioSource(CTX ctx,const List<SV>&a);
SV Entity_removeAudioSource(CTX ctx,const List<SV>&a);
void GfxRenderer_destroy(CTX,NO);
SV GfxRenderer_get_member(CTX,NO,SV);
void GfxRenderer_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxRenderer_funcs={
.destroy = GfxRenderer_destroy,
.getMember = GfxRenderer_get_member,
.setMember = GfxRenderer_set_member
};
template <>
struct create_val<GfxRenderer>
{
static SV f(CTX ctx,const GfxRenderer&obj)
{
#define ghfj GfxRenderer
RET STG::createNativeObject(GfxRenderer_funcs,NEW(ghfj, obj),EXT->GfxRenderer_typeID);
}
};
template <>
struct val_to_c<GfxRenderer>
{
static GfxRenderer f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxRenderer_typeID)
RET*((GfxRenderer*)obj->data);
else
 CATE(TE,"Value can not be converted to GfxRenderer."));
} else
 CATE(TE,"Value can not be converted to GfxRenderer."));
}
};

template <>
struct val_to_c<const GfxRenderer>
{
static GfxRenderer f(CTX ctx,const SV head) {return val_to_c<GfxRenderer>::f(ctx, head);}
};

template <>
struct create_val<const GfxRenderer>
{
static SV f(CTX ctx,const GfxRenderer&obj) {return create_val<GfxRenderer>::f(ctx,obj);}
};

template <>
struct type_same<GfxRenderer>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxRenderer_typeID;
else
 RET false;
}
};

SV GfxRenderer_resize(CTX ctx,const List<SV>&a);
SV GfxRenderer_render(CTX ctx,const List<SV>&a);
SV GfxRenderer_getNumLights(CTX ctx,const List<SV>&a);
SV GfxRenderer_getLightBuffer(CTX ctx,const List<SV>&a);
SV GfxRenderer_getStats(CTX ctx,const List<SV>&a);
SV GfxRenderer_addLight(CTX ctx,const List<SV>&a);
SV GfxRenderer_removeLight(CTX ctx,const List<SV>&a);
SV GfxRenderer_getLights(CTX ctx,const List<SV>&a);
SV GfxRenderer_computeSceneAABB(CTX ctx,const List<SV>&a);
SV GfxRenderer_computeShadowCasterAABB(CTX ctx,const List<SV>&a);
SV GfxRenderer_updateStats(CTX ctx,const List<SV>&a);
SV GfxRenderer_updateColorModifierShader(CTX ctx,const List<SV>&a);
SV GfxRenderer_setSkybox(CTX ctx,const List<SV>&a);
SV GfxRenderer_getSkybox(CTX ctx,const List<SV>&a);
SV GfxRenderer_addTerrain(CTX ctx,const List<SV>&a);
SV GfxRenderer_removeTerrain(CTX ctx,const List<SV>&a);
SV GfxRenderer_getTerrain(CTX ctx,const List<SV>&a);
void Float2_destroy(CTX,NO);
SV Float2_get_member(CTX,NO,SV);
void Float2_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Float2_funcs={
.destroy = Float2_destroy,
.getMember = Float2_get_member,
.setMember = Float2_set_member
};
template <>
struct create_val<T2<float>>
{
static SV f(CTX ctx,const T2<float>&obj)
{
#define ghfj T2<float>
RET STG::createNativeObject(Float2_funcs,NEW(ghfj, obj),EXT->Float2_typeID);
}
};
template <>
struct val_to_c<T2<float>>
{
static T2<float> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Float2_typeID)
RET*((T2<float>*)obj->data);
else
 CATE(TE,"Value can not be converted to Float2."));
} else
 CATE(TE,"Value can not be converted to Float2."));
}
};

template <>
struct val_to_c<const T2<float>>
{
static T2<float> f(CTX ctx,const SV head) {return val_to_c<T2<float>>::f(ctx, head);}
};

template <>
struct create_val<const T2<float>>
{
static SV f(CTX ctx,const T2<float>&obj) {return create_val<T2<float>>::f(ctx,obj);}
};

template <>
struct type_same<T2<float>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Float2_typeID;
else
 RET false;
}
};

SV Float2___add__(CTX ctx,const List<SV>&a);
SV Float2___sub__(CTX ctx,const List<SV>&a);
SV Float2___mul__(CTX ctx,const List<SV>&a);
SV Float2___div__(CTX ctx,const List<SV>&a);
SV Float2___eq__(CTX ctx,const List<SV>&a);
SV Float2___neq__(CTX ctx,const List<SV>&a);
SV Float2___less__(CTX ctx,const List<SV>&a);
SV Float2___grtr__(CTX ctx,const List<SV>&a);
SV Float2___leq__(CTX ctx,const List<SV>&a);
SV Float2___geq__(CTX ctx,const List<SV>&a);
SV Float2_sum(CTX ctx,const List<SV>&a);
SV Float2_length(CTX ctx,const List<SV>&a);
SV Float2_lengthSquared(CTX ctx,const List<SV>&a);
SV Float2_dot(CTX ctx,const List<SV>&a);
SV Float2_distance(CTX ctx,const List<SV>&a);
SV Float2_distanceSquared(CTX ctx,const List<SV>&a);
SV Float2_normalize(CTX ctx,const List<SV>&a);
SV Float2_getXY(CTX ctx,const List<SV>&a);
SV Float2_setXY(CTX ctx,const List<SV>&a);
SV Float2_getYX(CTX ctx,const List<SV>&a);
SV Float2_setYX(CTX ctx,const List<SV>&a);
void GfxFramebuffer_destroy(CTX,NO);
SV GfxFramebuffer_get_member(CTX,NO,SV);
void GfxFramebuffer_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxFramebuffer_funcs={
.destroy = GfxFramebuffer_destroy,
.getMember = GfxFramebuffer_get_member,
.setMember = GfxFramebuffer_set_member
};
template <>
struct type_same<GfxFramebuffer>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxFramebuffer_typeID;
else
 RET false;
}
};

SV GfxFramebuffer_addColorAttachment(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_removeColorAttachment(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_getNumColorAttachments(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_getColorRT(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_getColorAttachment(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_getColorAttachmentMipmapLevel(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_getColorAttachmentLayer(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_setDepthAttachment(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_removeDepthAttachment(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_hasDepthAttachment(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_getDepthTexture(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_getDepthTextureMipmapLevel(CTX ctx,const List<SV>&a);
SV GfxFramebuffer_getDepthAttachmentLayer(CTX ctx,const List<SV>&a);
void Font_destroy(CTX,NO);
SV Font_get_member(CTX,NO,SV);
void Font_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Font_funcs={
.destroy = Font_destroy,
.getMember = Font_get_member,
.setMember = Font_set_member
};
template <>
struct type_same<Font>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Font_typeID;
else
 RET false;
}
};

SV Font_removeContent(CTX ctx,const List<SV>&a);
SV Font_predictWidth(CTX ctx,const List<SV>&a);
SV Font_render(CTX ctx,const List<SV>&a);
SV Font_load(CTX ctx,const List<SV>&a);
SV Font_save(CTX ctx,const List<SV>&a);
SV Font_copy(CTX ctx,const List<SV>&a);
SV Font_getType(CTX ctx,const List<SV>&a);
SV Font_release(CTX ctx,const List<SV>&a);
SV Font_getRefCount(CTX ctx,const List<SV>&a);
SV Font_getFilename(CTX ctx,const List<SV>&a);
SV Font_setFilename(CTX ctx,const List<SV>&a);
void Event_destroy(CTX,NO);
SV Event_get_member(CTX,NO,SV);
void Event_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Event_funcs={
.destroy = Event_destroy,
.getMember = Event_get_member,
.setMember = Event_set_member
};
template <>
struct create_val<Event>
{
static SV f(CTX ctx,const Event&obj)
{
#define ghfj Event
RET STG::createNativeObject(Event_funcs,NEW(ghfj, obj),EXT->Event_typeID);
}
};
template <>
struct val_to_c<Event>
{
static Event f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Event_typeID)
RET*((Event*)obj->data);
else
 CATE(TE,"Value can not be converted to Event."));
} else
 CATE(TE,"Value can not be converted to Event."));
}
};

template <>
struct val_to_c<const Event>
{
static Event f(CTX ctx,const SV head) {return val_to_c<Event>::f(ctx, head);}
};

template <>
struct create_val<const Event>
{
static SV f(CTX ctx,const Event&obj) {return create_val<Event>::f(ctx,obj);}
};

template <>
struct type_same<Event>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Event_typeID;
else
 RET false;
}
};

SV Event_getWidth(CTX ctx,const List<SV>&a);
SV Event_getHeight(CTX ctx,const List<SV>&a);
SV Event_getKey(CTX ctx,const List<SV>&a);
SV Event_getX(CTX ctx,const List<SV>&a);
SV Event_getY(CTX ctx,const List<SV>&a);
SV Event_getRelX(CTX ctx,const List<SV>&a);
SV Event_getRelY(CTX ctx,const List<SV>&a);
SV Event_getButton(CTX ctx,const List<SV>&a);
SV Event_getDoubleClicked(CTX ctx,const List<SV>&a);
void PhysicsWorld_destroy(CTX,NO);
SV PhysicsWorld_get_member(CTX,NO,SV);
void PhysicsWorld_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs PhysicsWorld_funcs={
.destroy = PhysicsWorld_destroy,
.getMember = PhysicsWorld_get_member,
.setMember = PhysicsWorld_set_member
};
template <>
struct type_same<PhysicsWorld>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->PhysicsWorld_typeID;
else
 RET false;
}
};

SV PhysicsWorld_addDebugDrawer(CTX ctx,const List<SV>&a);
SV PhysicsWorld_setGravity(CTX ctx,const List<SV>&a);
SV PhysicsWorld_getGravity(CTX ctx,const List<SV>&a);
SV PhysicsWorld_getRigidBodies(CTX ctx,const List<SV>&a);
SV PhysicsWorld_getGhostObjects(CTX ctx,const List<SV>&a);
SV PhysicsWorld_createRigidBody(CTX ctx,const List<SV>&a);
SV PhysicsWorld_destroyRigidBody(CTX ctx,const List<SV>&a);
SV PhysicsWorld_createGhostObject(CTX ctx,const List<SV>&a);
SV PhysicsWorld_destroyGhostObject(CTX ctx,const List<SV>&a);
SV PhysicsWorld_stepSimulation(CTX ctx,const List<SV>&a);
SV PhysicsWorld_debugDraw(CTX ctx,const List<SV>&a);
SV PhysicsWorld_castRay(CTX ctx,const List<SV>&a);
SV PhysicsWorld_getBulletWorld(CTX ctx,const List<SV>&a);
void Stats_destroy(CTX,NO);
SV Stats_get_member(CTX,NO,SV);
void Stats_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Stats_funcs={
.destroy = Stats_destroy,
.getMember = Stats_get_member,
.setMember = Stats_set_member
};
template <>
struct create_val<Stats>
{
static SV f(CTX ctx,const Stats&obj)
{
#define ghfj Stats
RET STG::createNativeObject(Stats_funcs,NEW(ghfj, obj),EXT->Stats_typeID);
}
};
template <>
struct val_to_c<Stats>
{
static Stats f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Stats_typeID)
RET*((Stats*)obj->data);
else
 CATE(TE,"Value can not be converted to Stats."));
} else
 CATE(TE,"Value can not be converted to Stats."));
}
};

template <>
struct val_to_c<const Stats>
{
static Stats f(CTX ctx,const SV head) {return val_to_c<Stats>::f(ctx, head);}
};

template <>
struct create_val<const Stats>
{
static SV f(CTX ctx,const Stats&obj) {return create_val<Stats>::f(ctx,obj);}
};

template <>
struct type_same<Stats>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Stats_typeID;
else
 RET false;
}
};

void AudioSource_destroy(CTX,NO);
SV AudioSource_get_member(CTX,NO,SV);
void AudioSource_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs AudioSource_funcs={
.destroy = AudioSource_destroy,
.getMember = AudioSource_get_member,
.setMember = AudioSource_set_member
};
template <>
struct create_val<AudioSource>
{
static SV f(CTX ctx,const AudioSource&obj)
{
#define ghfj AudioSource
RET STG::createNativeObject(AudioSource_funcs,NEW(ghfj, obj),EXT->AudioSource_typeID);
}
};
template <>
struct val_to_c<AudioSource>
{
static AudioSource f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->AudioSource_typeID)
RET*((AudioSource*)obj->data);
else
 CATE(TE,"Value can not be converted to AudioSource."));
} else
 CATE(TE,"Value can not be converted to AudioSource."));
}
};

template <>
struct val_to_c<const AudioSource>
{
static AudioSource f(CTX ctx,const SV head) {return val_to_c<AudioSource>::f(ctx, head);}
};

template <>
struct create_val<const AudioSource>
{
static SV f(CTX ctx,const AudioSource&obj) {return create_val<AudioSource>::f(ctx,obj);}
};

template <>
struct type_same<AudioSource>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->AudioSource_typeID;
else
 RET false;
}
};

SV AudioSource_getAudio(CTX ctx,const List<SV>&a);
SV AudioSource_setAudio(CTX ctx,const List<SV>&a);
void RayCastResultList_destroy(CTX,NO);
SV RayCastResultList_get_member(CTX,NO,SV);
void RayCastResultList_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs RayCastResultList_funcs={
.destroy = RayCastResultList_destroy,
.getMember = RayCastResultList_get_member,
.setMember = RayCastResultList_set_member
};
template <>
struct create_val<List<RayCastResult>>
{
static SV f(CTX ctx,const List<RayCastResult>&obj)
{
#define ghfj List<RayCastResult>
RET STG::createNativeObject(RayCastResultList_funcs,NEW(ghfj, obj),EXT->RayCastResultList_typeID);
}
};
template <>
struct val_to_c<List<RayCastResult>>
{
static List<RayCastResult> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->RayCastResultList_typeID)
RET*((List<RayCastResult>*)obj->data);
else
 CATE(TE,"Value can not be converted to RayCastResultList."));
} else
 CATE(TE,"Value can not be converted to RayCastResultList."));
}
};

template <>
struct val_to_c<const List<RayCastResult>>
{
static List<RayCastResult> f(CTX ctx,const SV head) {return val_to_c<List<RayCastResult>>::f(ctx, head);}
};

template <>
struct create_val<const List<RayCastResult>>
{
static SV f(CTX ctx,const List<RayCastResult>&obj) {return create_val<List<RayCastResult>>::f(ctx,obj);}
};

template <>
struct type_same<List<RayCastResult>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RayCastResultList_typeID;
else
 RET false;
}
};

SV RayCastResultList___eq__(CTX ctx,const List<SV>&a);
SV RayCastResultList___neq__(CTX ctx,const List<SV>&a);
SV RayCastResultList_get(CTX ctx,const List<SV>&a);
SV RayCastResultList_set(CTX ctx,const List<SV>&a);
SV RayCastResultList_getCount(CTX ctx,const List<SV>&a);
SV RayCastResultList_getData(CTX ctx,const List<SV>&a);
SV RayCastResultList_append(CTX ctx,const List<SV>&a);
SV RayCastResultList_insert(CTX ctx,const List<SV>&a);
SV RayCastResultList_remove(CTX ctx,const List<SV>&a);
SV RayCastResultList_clear(CTX ctx,const List<SV>&a);
SV RayCastResultList_find(CTX ctx,const List<SV>&a);
SV RayCastResultList_copy(CTX ctx,const List<SV>&a);
SV RayCastResultList_in(CTX ctx,const List<SV>&a);
SV RayCastResultList_begin(CTX ctx,const List<SV>&a);
SV RayCastResultList_end(CTX ctx,const List<SV>&a);
void Platform_destroy(CTX,NO);
SV Platform_get_member(CTX,NO,SV);
void Platform_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Platform_funcs={
.destroy = Platform_destroy,
.getMember = Platform_get_member,
.setMember = Platform_set_member
};
template <>
struct type_same<Platform>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Platform_typeID;
else
 RET false;
}
};

SV Platform_initWindow(CTX ctx,const List<SV>&a);
SV Platform_destroyWindow(CTX ctx,const List<SV>&a);
SV Platform_run(CTX ctx,const List<SV>&a);
SV Platform_pollEvent(CTX ctx,const List<SV>&a);
SV Platform_eventsLeft(CTX ctx,const List<SV>&a);
SV Platform_popEvent(CTX ctx,const List<SV>&a);
SV Platform_getTime(CTX ctx,const List<SV>&a);
SV Platform_getTimerFrequency(CTX ctx,const List<SV>&a);
SV Platform_getWindowWidth(CTX ctx,const List<SV>&a);
SV Platform_getWindowHeight(CTX ctx,const List<SV>&a);
SV Platform_getMousePosition(CTX ctx,const List<SV>&a);
SV Platform_setMousePosition(CTX ctx,const List<SV>&a);
SV Platform_isLeftMouseButtonPressed(CTX ctx,const List<SV>&a);
SV Platform_isRightMouseButtonPressed(CTX ctx,const List<SV>&a);
SV Platform_isMiddleMouseButtonPressed(CTX ctx,const List<SV>&a);
SV Platform_getMouseWheel(CTX ctx,const List<SV>&a);
SV Platform_isCursorVisible(CTX ctx,const List<SV>&a);
SV Platform_setCursorVisible(CTX ctx,const List<SV>&a);
SV Platform_isKeyPressed(CTX ctx,const List<SV>&a);
SV Platform_getFullscreen(CTX ctx,const List<SV>&a);
SV Platform_setFullscreen(CTX ctx,const List<SV>&a);
SV Platform_getFrametime(CTX ctx,const List<SV>&a);
SV Platform_getGPUFrametime(CTX ctx,const List<SV>&a);
SV Platform_getCPUFrametime(CTX ctx,const List<SV>&a);
void Camera_destroy(CTX,NO);
SV Camera_get_member(CTX,NO,SV);
void Camera_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Camera_funcs={
.destroy = Camera_destroy,
.getMember = Camera_get_member,
.setMember = Camera_set_member
};
template <>
struct create_val<Camera>
{
static SV f(CTX ctx,const Camera&obj)
{
#define ghfj Camera
RET STG::createNativeObject(Camera_funcs,NEW(ghfj, obj),EXT->Camera_typeID);
}
};
template <>
struct val_to_c<Camera>
{
static Camera f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Camera_typeID)
RET*((Camera*)obj->data);
else
 CATE(TE,"Value can not be converted to Camera."));
} else
 CATE(TE,"Value can not be converted to Camera."));
}
};

template <>
struct val_to_c<const Camera>
{
static Camera f(CTX ctx,const SV head) {return val_to_c<Camera>::f(ctx, head);}
};

template <>
struct create_val<const Camera>
{
static SV f(CTX ctx,const Camera&obj) {return create_val<Camera>::f(ctx,obj);}
};

template <>
struct type_same<Camera>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Camera_typeID;
else
 RET false;
}
};

SV Camera_setType(CTX ctx,const List<SV>&a);
SV Camera_setPosition(CTX ctx,const List<SV>&a);
SV Camera_setDirection(CTX ctx,const List<SV>&a);
SV Camera_setUp(CTX ctx,const List<SV>&a);
SV Camera_setWidth(CTX ctx,const List<SV>&a);
SV Camera_setHeight(CTX ctx,const List<SV>&a);
SV Camera_setFieldOfView(CTX ctx,const List<SV>&a);
SV Camera_setLeft(CTX ctx,const List<SV>&a);
SV Camera_setRight(CTX ctx,const List<SV>&a);
SV Camera_setBottom(CTX ctx,const List<SV>&a);
SV Camera_setTop(CTX ctx,const List<SV>&a);
SV Camera_setNear(CTX ctx,const List<SV>&a);
SV Camera_setFar(CTX ctx,const List<SV>&a);
SV Camera_getType(CTX ctx,const List<SV>&a);
SV Camera_getPosition(CTX ctx,const List<SV>&a);
SV Camera_getDirection(CTX ctx,const List<SV>&a);
SV Camera_getUp(CTX ctx,const List<SV>&a);
SV Camera_getWidth(CTX ctx,const List<SV>&a);
SV Camera_getHeight(CTX ctx,const List<SV>&a);
SV Camera_getFieldOfView(CTX ctx,const List<SV>&a);
SV Camera_getLeft(CTX ctx,const List<SV>&a);
SV Camera_getRight(CTX ctx,const List<SV>&a);
SV Camera_getBottom(CTX ctx,const List<SV>&a);
SV Camera_getTop(CTX ctx,const List<SV>&a);
SV Camera_getNear(CTX ctx,const List<SV>&a);
SV Camera_getFar(CTX ctx,const List<SV>&a);
SV Camera_getViewMatrix(CTX ctx,const List<SV>&a);
SV Camera_getProjectionMatrix(CTX ctx,const List<SV>&a);
void GfxMesh_destroy(CTX,NO);
SV GfxMesh_get_member(CTX,NO,SV);
void GfxMesh_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxMesh_funcs={
.destroy = GfxMesh_destroy,
.getMember = GfxMesh_get_member,
.setMember = GfxMesh_set_member
};
template <>
struct type_same<GfxMesh>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxMesh_typeID;
else
 RET false;
}
};

SV GfxMesh_addIndices(CTX ctx,const List<SV>&a);
SV GfxMesh_removeIndices(CTX ctx,const List<SV>&a);
SV GfxMesh_setAttribute(CTX ctx,const List<SV>&a);
SV GfxMesh_removeAttribute(CTX ctx,const List<SV>&a);
SV GfxMesh_getIndexed(CTX ctx,const List<SV>&a);
SV GfxMesh_getIndexType(CTX ctx,const List<SV>&a);
SV GfxMesh_getIndices(CTX ctx,const List<SV>&a);
SV GfxMesh_getAttribs(CTX ctx,const List<SV>&a);
SV GfxMesh_getAttribCount(CTX ctx,const List<SV>&a);
SV GfxMesh_getAttrib(CTX ctx,const List<SV>&a);
SV GfxMesh_getGLVAO(CTX ctx,const List<SV>&a);
SV GfxMesh_getGLIndexBuffer(CTX ctx,const List<SV>&a);
SV GfxMesh_removeContent(CTX ctx,const List<SV>&a);
SV GfxMesh_save(CTX ctx,const List<SV>&a);
SV GfxMesh_load(CTX ctx,const List<SV>&a);
SV GfxMesh_copy(CTX ctx,const List<SV>&a);
SV GfxMesh_getType(CTX ctx,const List<SV>&a);
SV GfxMesh_release(CTX ctx,const List<SV>&a);
SV GfxMesh_getRefCount(CTX ctx,const List<SV>&a);
SV GfxMesh_getFilename(CTX ctx,const List<SV>&a);
SV GfxMesh_setFilename(CTX ctx,const List<SV>&a);
void Resource_destroy(CTX,NO);
SV Resource_get_member(CTX,NO,SV);
void Resource_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Resource_funcs={
.destroy = Resource_destroy,
.getMember = Resource_get_member,
.setMember = Resource_set_member
};
template <>
struct type_same<Resource>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Resource_typeID;
else
 RET false;
}
};

SV Resource_removeContent(CTX ctx,const List<SV>&a);
SV Resource_load(CTX ctx,const List<SV>&a);
SV Resource_save(CTX ctx,const List<SV>&a);
SV Resource_copy(CTX ctx,const List<SV>&a);
SV Resource_getType(CTX ctx,const List<SV>&a);
SV Resource_release(CTX ctx,const List<SV>&a);
SV Resource_getRefCount(CTX ctx,const List<SV>&a);
SV Resource_getFilename(CTX ctx,const List<SV>&a);
SV Resource_setFilename(CTX ctx,const List<SV>&a);
void GfxShader_destroy(CTX,NO);
SV GfxShader_get_member(CTX,NO,SV);
void GfxShader_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxShader_funcs={
.destroy = GfxShader_destroy,
.getMember = GfxShader_get_member,
.setMember = GfxShader_set_member
};
template <>
struct type_same<GfxShader>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxShader_typeID;
else
 RET false;
}
};

SV GfxShader_removeContent(CTX ctx,const List<SV>&a);
SV GfxShader_save(CTX ctx,const List<SV>&a);
SV GfxShader_compile(CTX ctx,const List<SV>&a);
SV GfxShader_getSource(CTX ctx,const List<SV>&a);
SV GfxShader_getShaderType(CTX ctx,const List<SV>&a);
SV GfxShader_getCompiled(CTX ctx,const List<SV>&a);
SV GfxShader_load(CTX ctx,const List<SV>&a);
SV GfxShader_copy(CTX ctx,const List<SV>&a);
SV GfxShader_getType(CTX ctx,const List<SV>&a);
SV GfxShader_release(CTX ctx,const List<SV>&a);
SV GfxShader_getRefCount(CTX ctx,const List<SV>&a);
SV GfxShader_getFilename(CTX ctx,const List<SV>&a);
SV GfxShader_setFilename(CTX ctx,const List<SV>&a);
void Light_destroy(CTX,NO);
SV Light_get_member(CTX,NO,SV);
void Light_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Light_funcs={
.destroy = Light_destroy,
.getMember = Light_get_member,
.setMember = Light_set_member
};
template <>
struct type_same<Light>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Light_typeID;
else
 RET false;
}
};

SV Light_addShadowmap(CTX ctx,const List<SV>&a);
SV Light_removeShadowmap(CTX ctx,const List<SV>&a);
SV Light_getShadowmap(CTX ctx,const List<SV>&a);
SV Light_getShadowmapFramebuffer(CTX ctx,const List<SV>&a);
SV Light_getPointLightFramebuffers(CTX ctx,const List<SV>&a);
SV Light_getPointLightFramebuffer(CTX ctx,const List<SV>&a);
SV Light_getShadowmapResolution(CTX ctx,const List<SV>&a);
SV Light_getShadowmapPrecision(CTX ctx,const List<SV>&a);
SV Light_updateMatrices(CTX ctx,const List<SV>&a);
SV Light_getViewMatrix(CTX ctx,const List<SV>&a);
SV Light_getProjectionMatrix(CTX ctx,const List<SV>&a);
void TextureSampler_destroy(CTX,NO);
SV TextureSampler_get_member(CTX,NO,SV);
void TextureSampler_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs TextureSampler_funcs={
.destroy = TextureSampler_destroy,
.getMember = TextureSampler_get_member,
.setMember = TextureSampler_set_member
};
template <>
struct create_val<TextureSampler>
{
static SV f(CTX ctx,const TextureSampler&obj)
{
#define ghfj TextureSampler
RET STG::createNativeObject(TextureSampler_funcs,NEW(ghfj, obj),EXT->TextureSampler_typeID);
}
};
template <>
struct val_to_c<TextureSampler>
{
static TextureSampler f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->TextureSampler_typeID)
RET*((TextureSampler*)obj->data);
else
 CATE(TE,"Value can not be converted to TextureSampler."));
} else
 CATE(TE,"Value can not be converted to TextureSampler."));
}
};

template <>
struct val_to_c<const TextureSampler>
{
static TextureSampler f(CTX ctx,const SV head) {return val_to_c<TextureSampler>::f(ctx, head);}
};

template <>
struct create_val<const TextureSampler>
{
static SV f(CTX ctx,const TextureSampler&obj) {return create_val<TextureSampler>::f(ctx,obj);}
};

template <>
struct type_same<TextureSampler>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->TextureSampler_typeID;
else
 RET false;
}
};

SV TextureSampler_createShadowmap(CTX ctx,const List<SV>&a);
void Scene_destroy(CTX,NO);
SV Scene_get_member(CTX,NO,SV);
void Scene_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Scene_funcs={
.destroy = Scene_destroy,
.getMember = Scene_get_member,
.setMember = Scene_set_member
};
template <>
struct type_same<Scene>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Scene_typeID;
else
 RET false;
}
};

SV Scene_removeContent(CTX ctx,const List<SV>&a);
SV Scene_handleInput(CTX ctx,const List<SV>&a);
SV Scene_update(CTX ctx,const List<SV>&a);
SV Scene_fixedUpdate(CTX ctx,const List<SV>&a);
SV Scene_render(CTX ctx,const List<SV>&a);
SV Scene_getPhysicsWorld(CTX ctx,const List<SV>&a);
SV Scene_getRenderer(CTX ctx,const List<SV>&a);
SV Scene_getAudioWorld(CTX ctx,const List<SV>&a);
SV Scene_save(CTX ctx,const List<SV>&a);
SV Scene_createEntity(CTX ctx,const List<SV>&a);
SV Scene_removeEntity(CTX ctx,const List<SV>&a);
SV Scene_getEntities(CTX ctx,const List<SV>&a);
SV Scene_addScript(CTX ctx,const List<SV>&a);
SV Scene_removeScript(CTX ctx,const List<SV>&a);
SV Scene_getScripts(CTX ctx,const List<SV>&a);
SV Scene_findScriptInstanceByName(CTX ctx,const List<SV>&a);
SV Scene_load(CTX ctx,const List<SV>&a);
SV Scene_copy(CTX ctx,const List<SV>&a);
SV Scene_getType(CTX ctx,const List<SV>&a);
SV Scene_release(CTX ctx,const List<SV>&a);
SV Scene_getRefCount(CTX ctx,const List<SV>&a);
SV Scene_getFilename(CTX ctx,const List<SV>&a);
SV Scene_setFilename(CTX ctx,const List<SV>&a);
void Int3_destroy(CTX,NO);
SV Int3_get_member(CTX,NO,SV);
void Int3_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Int3_funcs={
.destroy = Int3_destroy,
.getMember = Int3_get_member,
.setMember = Int3_set_member
};
template <>
struct create_val<T3<int32_t>>
{
static SV f(CTX ctx,const T3<int32_t>&obj)
{
#define ghfj T3<int32_t>
RET STG::createNativeObject(Int3_funcs,NEW(ghfj, obj),EXT->Int3_typeID);
}
};
template <>
struct val_to_c<T3<int32_t>>
{
static T3<int32_t> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Int3_typeID)
RET*((T3<int32_t>*)obj->data);
else
 CATE(TE,"Value can not be converted to Int3."));
} else
 CATE(TE,"Value can not be converted to Int3."));
}
};

template <>
struct val_to_c<const T3<int32_t>>
{
static T3<int32_t> f(CTX ctx,const SV head) {return val_to_c<T3<int32_t>>::f(ctx, head);}
};

template <>
struct create_val<const T3<int32_t>>
{
static SV f(CTX ctx,const T3<int32_t>&obj) {return create_val<T3<int32_t>>::f(ctx,obj);}
};

template <>
struct type_same<T3<int32_t>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Int3_typeID;
else
 RET false;
}
};

SV Int3___add__(CTX ctx,const List<SV>&a);
SV Int3___sub__(CTX ctx,const List<SV>&a);
SV Int3___mul__(CTX ctx,const List<SV>&a);
SV Int3___div__(CTX ctx,const List<SV>&a);
SV Int3___eq__(CTX ctx,const List<SV>&a);
SV Int3___neq__(CTX ctx,const List<SV>&a);
SV Int3___less__(CTX ctx,const List<SV>&a);
SV Int3___grtr__(CTX ctx,const List<SV>&a);
SV Int3___leq__(CTX ctx,const List<SV>&a);
SV Int3___geq__(CTX ctx,const List<SV>&a);
SV Int3_sum(CTX ctx,const List<SV>&a);
SV Int3_length(CTX ctx,const List<SV>&a);
SV Int3_lengthSquared(CTX ctx,const List<SV>&a);
SV Int3_dot(CTX ctx,const List<SV>&a);
SV Int3_distance(CTX ctx,const List<SV>&a);
SV Int3_distanceSquared(CTX ctx,const List<SV>&a);
SV Int3_normalize(CTX ctx,const List<SV>&a);
SV Int3_cross(CTX ctx,const List<SV>&a);
SV Int3_getXY(CTX ctx,const List<SV>&a);
SV Int3_setXY(CTX ctx,const List<SV>&a);
SV Int3_getXZ(CTX ctx,const List<SV>&a);
SV Int3_setXZ(CTX ctx,const List<SV>&a);
SV Int3_getYX(CTX ctx,const List<SV>&a);
SV Int3_setYX(CTX ctx,const List<SV>&a);
SV Int3_getYZ(CTX ctx,const List<SV>&a);
SV Int3_setYZ(CTX ctx,const List<SV>&a);
SV Int3_getZX(CTX ctx,const List<SV>&a);
SV Int3_setZX(CTX ctx,const List<SV>&a);
SV Int3_getZY(CTX ctx,const List<SV>&a);
SV Int3_setZY(CTX ctx,const List<SV>&a);
SV Int3_getXYZ(CTX ctx,const List<SV>&a);
SV Int3_setXYZ(CTX ctx,const List<SV>&a);
SV Int3_getXZY(CTX ctx,const List<SV>&a);
SV Int3_setXZY(CTX ctx,const List<SV>&a);
SV Int3_getYXZ(CTX ctx,const List<SV>&a);
SV Int3_setYXZ(CTX ctx,const List<SV>&a);
SV Int3_getYZX(CTX ctx,const List<SV>&a);
SV Int3_setYZX(CTX ctx,const List<SV>&a);
SV Int3_getZXY(CTX ctx,const List<SV>&a);
SV Int3_setZXY(CTX ctx,const List<SV>&a);
SV Int3_getZYX(CTX ctx,const List<SV>&a);
SV Int3_setZYX(CTX ctx,const List<SV>&a);
void ResizableData_destroy(CTX,NO);
SV ResizableData_get_member(CTX,NO,SV);
void ResizableData_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs ResizableData_funcs={
.destroy = ResizableData_destroy,
.getMember = ResizableData_get_member,
.setMember = ResizableData_set_member
};
template <>
struct create_val<ResizableData>
{
static SV f(CTX ctx,const ResizableData&obj)
{
#define ghfj ResizableData
RET STG::createNativeObject(ResizableData_funcs,NEW(ghfj, obj),EXT->ResizableData_typeID);
}
};
template <>
struct val_to_c<ResizableData>
{
static ResizableData f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->ResizableData_typeID)
RET*((ResizableData*)obj->data);
else
 CATE(TE,"Value can not be converted to ResizableData."));
} else
 CATE(TE,"Value can not be converted to ResizableData."));
}
};

template <>
struct val_to_c<const ResizableData>
{
static ResizableData f(CTX ctx,const SV head) {return val_to_c<ResizableData>::f(ctx, head);}
};

template <>
struct create_val<const ResizableData>
{
static SV f(CTX ctx,const ResizableData&obj) {return create_val<ResizableData>::f(ctx,obj);}
};

template <>
struct type_same<ResizableData>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->ResizableData_typeID;
else
 RET false;
}
};

SV ResizableData___eq__(CTX ctx,const List<SV>&a);
SV ResizableData___neq__(CTX ctx,const List<SV>&a);
SV ResizableData_getData(CTX ctx,const List<SV>&a);
SV ResizableData_getSize(CTX ctx,const List<SV>&a);
SV ResizableData_resize(CTX ctx,const List<SV>&a);
SV ResizableData_insert(CTX ctx,const List<SV>&a);
SV ResizableData_append(CTX ctx,const List<SV>&a);
SV ResizableData_remove(CTX ctx,const List<SV>&a);
SV ResizableData_clear(CTX ctx,const List<SV>&a);
SV ResizableData_copy(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt8(CTX ctx,const List<SV>&a);
SV ResizableData_getInt8(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt16(CTX ctx,const List<SV>&a);
SV ResizableData_getInt16(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt32(CTX ctx,const List<SV>&a);
SV ResizableData_getInt32(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt64(CTX ctx,const List<SV>&a);
SV ResizableData_getInt64(CTX ctx,const List<SV>&a);
SV ResizableData_getFloat32(CTX ctx,const List<SV>&a);
SV ResizableData_getFloat64(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt16LE(CTX ctx,const List<SV>&a);
SV ResizableData_getInt16LE(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt32LE(CTX ctx,const List<SV>&a);
SV ResizableData_getInt32LE(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt64LE(CTX ctx,const List<SV>&a);
SV ResizableData_getInt64LE(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt16BE(CTX ctx,const List<SV>&a);
SV ResizableData_getInt16BE(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt32BE(CTX ctx,const List<SV>&a);
SV ResizableData_getInt32BE(CTX ctx,const List<SV>&a);
SV ResizableData_getUInt64BE(CTX ctx,const List<SV>&a);
SV ResizableData_getInt64BE(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt8(CTX ctx,const List<SV>&a);
SV ResizableData_setInt8(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt16(CTX ctx,const List<SV>&a);
SV ResizableData_setInt16(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt32(CTX ctx,const List<SV>&a);
SV ResizableData_setInt32(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt64(CTX ctx,const List<SV>&a);
SV ResizableData_setInt64(CTX ctx,const List<SV>&a);
SV ResizableData_setFloat32(CTX ctx,const List<SV>&a);
SV ResizableData_setFloat64(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt16LE(CTX ctx,const List<SV>&a);
SV ResizableData_setInt16LE(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt32LE(CTX ctx,const List<SV>&a);
SV ResizableData_setInt32LE(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt64LE(CTX ctx,const List<SV>&a);
SV ResizableData_setInt64LE(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt16BE(CTX ctx,const List<SV>&a);
SV ResizableData_setInt16BE(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt32BE(CTX ctx,const List<SV>&a);
SV ResizableData_setInt32BE(CTX ctx,const List<SV>&a);
SV ResizableData_setUInt64BE(CTX ctx,const List<SV>&a);
SV ResizableData_setInt64BE(CTX ctx,const List<SV>&a);
SV ResizableData_getChar(CTX ctx,const List<SV>&a);
SV ResizableData_setChar(CTX ctx,const List<SV>&a);
void Int4_destroy(CTX,NO);
SV Int4_get_member(CTX,NO,SV);
void Int4_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Int4_funcs={
.destroy = Int4_destroy,
.getMember = Int4_get_member,
.setMember = Int4_set_member
};
template <>
struct create_val<T4<int32_t>>
{
static SV f(CTX ctx,const T4<int32_t>&obj)
{
#define ghfj T4<int32_t>
RET STG::createNativeObject(Int4_funcs,NEW(ghfj, obj),EXT->Int4_typeID);
}
};
template <>
struct val_to_c<T4<int32_t>>
{
static T4<int32_t> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Int4_typeID)
RET*((T4<int32_t>*)obj->data);
else
 CATE(TE,"Value can not be converted to Int4."));
} else
 CATE(TE,"Value can not be converted to Int4."));
}
};

template <>
struct val_to_c<const T4<int32_t>>
{
static T4<int32_t> f(CTX ctx,const SV head) {return val_to_c<T4<int32_t>>::f(ctx, head);}
};

template <>
struct create_val<const T4<int32_t>>
{
static SV f(CTX ctx,const T4<int32_t>&obj) {return create_val<T4<int32_t>>::f(ctx,obj);}
};

template <>
struct type_same<T4<int32_t>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Int4_typeID;
else
 RET false;
}
};

SV Int4___add__(CTX ctx,const List<SV>&a);
SV Int4___sub__(CTX ctx,const List<SV>&a);
SV Int4___mul__(CTX ctx,const List<SV>&a);
SV Int4___div__(CTX ctx,const List<SV>&a);
SV Int4___eq__(CTX ctx,const List<SV>&a);
SV Int4___neq__(CTX ctx,const List<SV>&a);
SV Int4___less__(CTX ctx,const List<SV>&a);
SV Int4___grtr__(CTX ctx,const List<SV>&a);
SV Int4___leq__(CTX ctx,const List<SV>&a);
SV Int4___geq__(CTX ctx,const List<SV>&a);
SV Int4_sum(CTX ctx,const List<SV>&a);
SV Int4_length(CTX ctx,const List<SV>&a);
SV Int4_lengthSquared(CTX ctx,const List<SV>&a);
SV Int4_dot(CTX ctx,const List<SV>&a);
SV Int4_distance(CTX ctx,const List<SV>&a);
SV Int4_distanceSquared(CTX ctx,const List<SV>&a);
SV Int4_normalize(CTX ctx,const List<SV>&a);
SV Int4_getXY(CTX ctx,const List<SV>&a);
SV Int4_setXY(CTX ctx,const List<SV>&a);
SV Int4_getXZ(CTX ctx,const List<SV>&a);
SV Int4_setXZ(CTX ctx,const List<SV>&a);
SV Int4_getXW(CTX ctx,const List<SV>&a);
SV Int4_setXW(CTX ctx,const List<SV>&a);
SV Int4_getYX(CTX ctx,const List<SV>&a);
SV Int4_setYX(CTX ctx,const List<SV>&a);
SV Int4_getYZ(CTX ctx,const List<SV>&a);
SV Int4_setYZ(CTX ctx,const List<SV>&a);
SV Int4_getYW(CTX ctx,const List<SV>&a);
SV Int4_setYW(CTX ctx,const List<SV>&a);
SV Int4_getZX(CTX ctx,const List<SV>&a);
SV Int4_setZX(CTX ctx,const List<SV>&a);
SV Int4_getZY(CTX ctx,const List<SV>&a);
SV Int4_setZY(CTX ctx,const List<SV>&a);
SV Int4_getZW(CTX ctx,const List<SV>&a);
SV Int4_setZW(CTX ctx,const List<SV>&a);
SV Int4_getWX(CTX ctx,const List<SV>&a);
SV Int4_setWX(CTX ctx,const List<SV>&a);
SV Int4_getWY(CTX ctx,const List<SV>&a);
SV Int4_setWY(CTX ctx,const List<SV>&a);
SV Int4_getWZ(CTX ctx,const List<SV>&a);
SV Int4_setWZ(CTX ctx,const List<SV>&a);
SV Int4_getXYZ(CTX ctx,const List<SV>&a);
SV Int4_setXYZ(CTX ctx,const List<SV>&a);
SV Int4_getXYW(CTX ctx,const List<SV>&a);
SV Int4_setXYW(CTX ctx,const List<SV>&a);
SV Int4_getXZY(CTX ctx,const List<SV>&a);
SV Int4_setXZY(CTX ctx,const List<SV>&a);
SV Int4_getXZW(CTX ctx,const List<SV>&a);
SV Int4_setXZW(CTX ctx,const List<SV>&a);
SV Int4_getXWZ(CTX ctx,const List<SV>&a);
SV Int4_setXWZ(CTX ctx,const List<SV>&a);
SV Int4_getXWY(CTX ctx,const List<SV>&a);
SV Int4_setXWY(CTX ctx,const List<SV>&a);
SV Int4_getYXZ(CTX ctx,const List<SV>&a);
SV Int4_setYXZ(CTX ctx,const List<SV>&a);
SV Int4_getYXW(CTX ctx,const List<SV>&a);
SV Int4_setYXW(CTX ctx,const List<SV>&a);
SV Int4_getYZX(CTX ctx,const List<SV>&a);
SV Int4_setYZX(CTX ctx,const List<SV>&a);
SV Int4_getYZW(CTX ctx,const List<SV>&a);
SV Int4_setYZW(CTX ctx,const List<SV>&a);
SV Int4_getYWZ(CTX ctx,const List<SV>&a);
SV Int4_setYWZ(CTX ctx,const List<SV>&a);
SV Int4_getYWX(CTX ctx,const List<SV>&a);
SV Int4_setYWX(CTX ctx,const List<SV>&a);
SV Int4_getZXY(CTX ctx,const List<SV>&a);
SV Int4_setZXY(CTX ctx,const List<SV>&a);
SV Int4_getZXW(CTX ctx,const List<SV>&a);
SV Int4_setZXW(CTX ctx,const List<SV>&a);
SV Int4_getZYX(CTX ctx,const List<SV>&a);
SV Int4_setZYX(CTX ctx,const List<SV>&a);
SV Int4_getZYW(CTX ctx,const List<SV>&a);
SV Int4_setZYW(CTX ctx,const List<SV>&a);
SV Int4_getZWY(CTX ctx,const List<SV>&a);
SV Int4_setZWY(CTX ctx,const List<SV>&a);
SV Int4_getZWX(CTX ctx,const List<SV>&a);
SV Int4_setZWX(CTX ctx,const List<SV>&a);
SV Int4_getWXY(CTX ctx,const List<SV>&a);
SV Int4_setWXY(CTX ctx,const List<SV>&a);
SV Int4_getWXZ(CTX ctx,const List<SV>&a);
SV Int4_setWXZ(CTX ctx,const List<SV>&a);
SV Int4_getWYX(CTX ctx,const List<SV>&a);
SV Int4_setWYX(CTX ctx,const List<SV>&a);
SV Int4_getWYZ(CTX ctx,const List<SV>&a);
SV Int4_setWYZ(CTX ctx,const List<SV>&a);
SV Int4_getWZY(CTX ctx,const List<SV>&a);
SV Int4_setWZY(CTX ctx,const List<SV>&a);
SV Int4_getWZX(CTX ctx,const List<SV>&a);
SV Int4_setWZX(CTX ctx,const List<SV>&a);
SV Int4_getXYZW(CTX ctx,const List<SV>&a);
SV Int4_setXYZW(CTX ctx,const List<SV>&a);
SV Int4_getXYWZ(CTX ctx,const List<SV>&a);
SV Int4_setXYWZ(CTX ctx,const List<SV>&a);
SV Int4_getXZYW(CTX ctx,const List<SV>&a);
SV Int4_setXZYW(CTX ctx,const List<SV>&a);
SV Int4_getXZWY(CTX ctx,const List<SV>&a);
SV Int4_setXZWY(CTX ctx,const List<SV>&a);
SV Int4_getXWZY(CTX ctx,const List<SV>&a);
SV Int4_setXWZY(CTX ctx,const List<SV>&a);
SV Int4_getXWYZ(CTX ctx,const List<SV>&a);
SV Int4_setXWYZ(CTX ctx,const List<SV>&a);
SV Int4_getYXZW(CTX ctx,const List<SV>&a);
SV Int4_setYXZW(CTX ctx,const List<SV>&a);
SV Int4_getYXWZ(CTX ctx,const List<SV>&a);
SV Int4_setYXWZ(CTX ctx,const List<SV>&a);
SV Int4_getYZXW(CTX ctx,const List<SV>&a);
SV Int4_setYZXW(CTX ctx,const List<SV>&a);
SV Int4_getYZWX(CTX ctx,const List<SV>&a);
SV Int4_setYZWX(CTX ctx,const List<SV>&a);
SV Int4_getYWZX(CTX ctx,const List<SV>&a);
SV Int4_setYWZX(CTX ctx,const List<SV>&a);
SV Int4_getYWXZ(CTX ctx,const List<SV>&a);
SV Int4_setYWXZ(CTX ctx,const List<SV>&a);
SV Int4_getZYXW(CTX ctx,const List<SV>&a);
SV Int4_setZYXW(CTX ctx,const List<SV>&a);
SV Int4_getZYWX(CTX ctx,const List<SV>&a);
SV Int4_setZYWX(CTX ctx,const List<SV>&a);
SV Int4_getZXYW(CTX ctx,const List<SV>&a);
SV Int4_setZXYW(CTX ctx,const List<SV>&a);
SV Int4_getZXWY(CTX ctx,const List<SV>&a);
SV Int4_setZXWY(CTX ctx,const List<SV>&a);
SV Int4_getZWXY(CTX ctx,const List<SV>&a);
SV Int4_setZWXY(CTX ctx,const List<SV>&a);
SV Int4_getZWYX(CTX ctx,const List<SV>&a);
SV Int4_setZWYX(CTX ctx,const List<SV>&a);
SV Int4_getWYZX(CTX ctx,const List<SV>&a);
SV Int4_setWYZX(CTX ctx,const List<SV>&a);
SV Int4_getWYXZ(CTX ctx,const List<SV>&a);
SV Int4_setWYXZ(CTX ctx,const List<SV>&a);
SV Int4_getWZYX(CTX ctx,const List<SV>&a);
SV Int4_setWZYX(CTX ctx,const List<SV>&a);
SV Int4_getWZXY(CTX ctx,const List<SV>&a);
SV Int4_setWZXY(CTX ctx,const List<SV>&a);
SV Int4_getWXZY(CTX ctx,const List<SV>&a);
SV Int4_setWXZY(CTX ctx,const List<SV>&a);
SV Int4_getWXYZ(CTX ctx,const List<SV>&a);
SV Int4_setWXYZ(CTX ctx,const List<SV>&a);
void Float3_destroy(CTX,NO);
SV Float3_get_member(CTX,NO,SV);
void Float3_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Float3_funcs={
.destroy = Float3_destroy,
.getMember = Float3_get_member,
.setMember = Float3_set_member
};
template <>
struct create_val<T3<float>>
{
static SV f(CTX ctx,const T3<float>&obj)
{
#define ghfj T3<float>
RET STG::createNativeObject(Float3_funcs,NEW(ghfj, obj),EXT->Float3_typeID);
}
};
template <>
struct val_to_c<T3<float>>
{
static T3<float> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Float3_typeID)
RET*((T3<float>*)obj->data);
else
 CATE(TE,"Value can not be converted to Float3."));
} else
 CATE(TE,"Value can not be converted to Float3."));
}
};

template <>
struct val_to_c<const T3<float>>
{
static T3<float> f(CTX ctx,const SV head) {return val_to_c<T3<float>>::f(ctx, head);}
};

template <>
struct create_val<const T3<float>>
{
static SV f(CTX ctx,const T3<float>&obj) {return create_val<T3<float>>::f(ctx,obj);}
};

template <>
struct type_same<T3<float>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Float3_typeID;
else
 RET false;
}
};

SV Float3___add__(CTX ctx,const List<SV>&a);
SV Float3___sub__(CTX ctx,const List<SV>&a);
SV Float3___mul__(CTX ctx,const List<SV>&a);
SV Float3___div__(CTX ctx,const List<SV>&a);
SV Float3___eq__(CTX ctx,const List<SV>&a);
SV Float3___neq__(CTX ctx,const List<SV>&a);
SV Float3___less__(CTX ctx,const List<SV>&a);
SV Float3___grtr__(CTX ctx,const List<SV>&a);
SV Float3___leq__(CTX ctx,const List<SV>&a);
SV Float3___geq__(CTX ctx,const List<SV>&a);
SV Float3_sum(CTX ctx,const List<SV>&a);
SV Float3_length(CTX ctx,const List<SV>&a);
SV Float3_lengthSquared(CTX ctx,const List<SV>&a);
SV Float3_dot(CTX ctx,const List<SV>&a);
SV Float3_distance(CTX ctx,const List<SV>&a);
SV Float3_distanceSquared(CTX ctx,const List<SV>&a);
SV Float3_normalize(CTX ctx,const List<SV>&a);
SV Float3_cross(CTX ctx,const List<SV>&a);
SV Float3_getXY(CTX ctx,const List<SV>&a);
SV Float3_setXY(CTX ctx,const List<SV>&a);
SV Float3_getXZ(CTX ctx,const List<SV>&a);
SV Float3_setXZ(CTX ctx,const List<SV>&a);
SV Float3_getYX(CTX ctx,const List<SV>&a);
SV Float3_setYX(CTX ctx,const List<SV>&a);
SV Float3_getYZ(CTX ctx,const List<SV>&a);
SV Float3_setYZ(CTX ctx,const List<SV>&a);
SV Float3_getZX(CTX ctx,const List<SV>&a);
SV Float3_setZX(CTX ctx,const List<SV>&a);
SV Float3_getZY(CTX ctx,const List<SV>&a);
SV Float3_setZY(CTX ctx,const List<SV>&a);
SV Float3_getXYZ(CTX ctx,const List<SV>&a);
SV Float3_setXYZ(CTX ctx,const List<SV>&a);
SV Float3_getXZY(CTX ctx,const List<SV>&a);
SV Float3_setXZY(CTX ctx,const List<SV>&a);
SV Float3_getYXZ(CTX ctx,const List<SV>&a);
SV Float3_setYXZ(CTX ctx,const List<SV>&a);
SV Float3_getYZX(CTX ctx,const List<SV>&a);
SV Float3_setYZX(CTX ctx,const List<SV>&a);
SV Float3_getZXY(CTX ctx,const List<SV>&a);
SV Float3_setZXY(CTX ctx,const List<SV>&a);
SV Float3_getZYX(CTX ctx,const List<SV>&a);
SV Float3_setZYX(CTX ctx,const List<SV>&a);
void GfxBuffer_destroy(CTX,NO);
SV GfxBuffer_get_member(CTX,NO,SV);
void GfxBuffer_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxBuffer_funcs={
.destroy = GfxBuffer_destroy,
.getMember = GfxBuffer_get_member,
.setMember = GfxBuffer_set_member
};
template <>
struct type_same<GfxBuffer>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxBuffer_typeID;
else
 RET false;
}
};

SV GfxBuffer_allocData(CTX ctx,const List<SV>&a);
SV GfxBuffer_setData(CTX ctx,const List<SV>&a);
SV GfxBuffer_getData(CTX ctx,const List<SV>&a);
SV GfxBuffer_getSize(CTX ctx,const List<SV>&a);
void Transform_destroy(CTX,NO);
SV Transform_get_member(CTX,NO,SV);
void Transform_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Transform_funcs={
.destroy = Transform_destroy,
.getMember = Transform_get_member,
.setMember = Transform_set_member
};
template <>
struct create_val<Transform>
{
static SV f(CTX ctx,const Transform&obj)
{
#define ghfj Transform
RET STG::createNativeObject(Transform_funcs,NEW(ghfj, obj),EXT->Transform_typeID);
}
};
template <>
struct val_to_c<Transform>
{
static Transform f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Transform_typeID)
RET*((Transform*)obj->data);
else
 CATE(TE,"Value can not be converted to Transform."));
} else
 CATE(TE,"Value can not be converted to Transform."));
}
};

template <>
struct val_to_c<const Transform>
{
static Transform f(CTX ctx,const SV head) {return val_to_c<Transform>::f(ctx, head);}
};

template <>
struct create_val<const Transform>
{
static SV f(CTX ctx,const Transform&obj) {return create_val<Transform>::f(ctx,obj);}
};

template <>
struct type_same<Transform>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Transform_typeID;
else
 RET false;
}
};

SV Transform_createMatrix(CTX ctx,const List<SV>&a);
void AudioSourceList_destroy(CTX,NO);
SV AudioSourceList_get_member(CTX,NO,SV);
void AudioSourceList_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs AudioSourceList_funcs={
.destroy = AudioSourceList_destroy,
.getMember = AudioSourceList_get_member,
.setMember = AudioSourceList_set_member
};
template <>
struct create_val<List<AudioSource*>>
{
static SV f(CTX ctx,const List<AudioSource*>&obj)
{
#define ghfj List<AudioSource*>
RET STG::createNativeObject(AudioSourceList_funcs,NEW(ghfj, obj),EXT->AudioSourceList_typeID);
}
};
template <>
struct val_to_c<List<AudioSource*>>
{
static List<AudioSource*> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->AudioSourceList_typeID)
RET*((List<AudioSource*>*)obj->data);
else
 CATE(TE,"Value can not be converted to AudioSourceList."));
} else
 CATE(TE,"Value can not be converted to AudioSourceList."));
}
};

template <>
struct val_to_c<const List<AudioSource*>>
{
static List<AudioSource*> f(CTX ctx,const SV head) {return val_to_c<List<AudioSource*>>::f(ctx, head);}
};

template <>
struct create_val<const List<AudioSource*>>
{
static SV f(CTX ctx,const List<AudioSource*>&obj) {return create_val<List<AudioSource*>>::f(ctx,obj);}
};

template <>
struct type_same<List<AudioSource*>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->AudioSourceList_typeID;
else
 RET false;
}
};

SV AudioSourceList___eq__(CTX ctx,const List<SV>&a);
SV AudioSourceList___neq__(CTX ctx,const List<SV>&a);
SV AudioSourceList_get(CTX ctx,const List<SV>&a);
SV AudioSourceList_set(CTX ctx,const List<SV>&a);
SV AudioSourceList_getCount(CTX ctx,const List<SV>&a);
SV AudioSourceList_getData(CTX ctx,const List<SV>&a);
SV AudioSourceList_append(CTX ctx,const List<SV>&a);
SV AudioSourceList_insert(CTX ctx,const List<SV>&a);
SV AudioSourceList_remove(CTX ctx,const List<SV>&a);
SV AudioSourceList_clear(CTX ctx,const List<SV>&a);
SV AudioSourceList_find(CTX ctx,const List<SV>&a);
SV AudioSourceList_copy(CTX ctx,const List<SV>&a);
SV AudioSourceList_in(CTX ctx,const List<SV>&a);
SV AudioSourceList_begin(CTX ctx,const List<SV>&a);
SV AudioSourceList_end(CTX ctx,const List<SV>&a);
void GfxMaterial_destroy(CTX,NO);
SV GfxMaterial_get_member(CTX,NO,SV);
void GfxMaterial_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxMaterial_funcs={
.destroy = GfxMaterial_destroy,
.getMember = GfxMaterial_get_member,
.setMember = GfxMaterial_set_member
};
template <>
struct type_same<GfxMaterial>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxMaterial_typeID;
else
 RET false;
}
};

SV GfxMaterial_removeContent(CTX ctx,const List<SV>&a);
SV GfxMaterial_save(CTX ctx,const List<SV>&a);
SV GfxMaterial_getShaderComb(CTX ctx,const List<SV>&a);
SV GfxMaterial_setMaterialMap(CTX ctx,const List<SV>&a);
SV GfxMaterial_getMaterialMap(CTX ctx,const List<SV>&a);
SV GfxMaterial_setAlbedoMap(CTX ctx,const List<SV>&a);
SV GfxMaterial_getAlbedoMap(CTX ctx,const List<SV>&a);
SV GfxMaterial_setNormalMap(CTX ctx,const List<SV>&a);
SV GfxMaterial_getNormalMap(CTX ctx,const List<SV>&a);
SV GfxMaterial_setParallaxHeightMap(CTX ctx,const List<SV>&a);
SV GfxMaterial_getParallaxHeightMap(CTX ctx,const List<SV>&a);
SV GfxMaterial_setPOMHeightMap(CTX ctx,const List<SV>&a);
SV GfxMaterial_getPOMHeightMap(CTX ctx,const List<SV>&a);
SV GfxMaterial_setDisplacementMap(CTX ctx,const List<SV>&a);
SV GfxMaterial_getDisplacementMap(CTX ctx,const List<SV>&a);
SV GfxMaterial_isForward(CTX ctx,const List<SV>&a);
SV GfxMaterial_setForward(CTX ctx,const List<SV>&a);
SV GfxMaterial_load(CTX ctx,const List<SV>&a);
SV GfxMaterial_copy(CTX ctx,const List<SV>&a);
SV GfxMaterial_getType(CTX ctx,const List<SV>&a);
SV GfxMaterial_release(CTX ctx,const List<SV>&a);
SV GfxMaterial_getRefCount(CTX ctx,const List<SV>&a);
SV GfxMaterial_getFilename(CTX ctx,const List<SV>&a);
SV GfxMaterial_setFilename(CTX ctx,const List<SV>&a);
void Quaternion_destroy(CTX,NO);
SV Quaternion_get_member(CTX,NO,SV);
void Quaternion_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Quaternion_funcs={
.destroy = Quaternion_destroy,
.getMember = Quaternion_get_member,
.setMember = Quaternion_set_member
};
template <>
struct create_val<Quaternion>
{
static SV f(CTX ctx,const Quaternion&obj)
{
#define ghfj Quaternion
RET STG::createNativeObject(Quaternion_funcs,NEW(ghfj, obj),EXT->Quaternion_typeID);
}
};
template <>
struct val_to_c<Quaternion>
{
static Quaternion f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Quaternion_typeID)
RET*((Quaternion*)obj->data);
else
 CATE(TE,"Value can not be converted to Quaternion."));
} else
 CATE(TE,"Value can not be converted to Quaternion."));
}
};

template <>
struct val_to_c<const Quaternion>
{
static Quaternion f(CTX ctx,const SV head) {return val_to_c<Quaternion>::f(ctx, head);}
};

template <>
struct create_val<const Quaternion>
{
static SV f(CTX ctx,const Quaternion&obj) {return create_val<Quaternion>::f(ctx,obj);}
};

template <>
struct type_same<Quaternion>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Quaternion_typeID;
else
 RET false;
}
};

SV Quaternion___mul__(CTX ctx,const List<SV>&a);
SV Quaternion_toMatrix(CTX ctx,const List<SV>&a);
SV Quaternion___eq__(CTX ctx,const List<SV>&a);
SV Quaternion_normalize(CTX ctx,const List<SV>&a);
SV Quaternion_getAngle(CTX ctx,const List<SV>&a);
SV Quaternion_getXAxis(CTX ctx,const List<SV>&a);
SV Quaternion_getYAxis(CTX ctx,const List<SV>&a);
SV Quaternion_getZAxis(CTX ctx,const List<SV>&a);
SV Quaternion_getAxis(CTX ctx,const List<SV>&a);
SV Quaternion_getAxisAndAngle(CTX ctx,const List<SV>&a);
SV Quaternion_setAngle(CTX ctx,const List<SV>&a);
SV Quaternion_setXAxis(CTX ctx,const List<SV>&a);
SV Quaternion_setYAxis(CTX ctx,const List<SV>&a);
SV Quaternion_setZAxis(CTX ctx,const List<SV>&a);
SV Quaternion_setAxis(CTX ctx,const List<SV>&a);
SV Quaternion_setAxisAndAngle(CTX ctx,const List<SV>&a);
SV Quaternion_setEulerAngles(CTX ctx,const List<SV>&a);
SV Quaternion_getEulerAngles(CTX ctx,const List<SV>&a);
void GfxMeshAttrib_destroy(CTX,NO);
SV GfxMeshAttrib_get_member(CTX,NO,SV);
void GfxMeshAttrib_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxMeshAttrib_funcs={
.destroy = GfxMeshAttrib_destroy,
.getMember = GfxMeshAttrib_get_member,
.setMember = GfxMeshAttrib_set_member
};
template <>
struct create_val<GfxMeshAttrib>
{
static SV f(CTX ctx,const GfxMeshAttrib&obj)
{
#define ghfj GfxMeshAttrib
RET STG::createNativeObject(GfxMeshAttrib_funcs,NEW(ghfj, obj),EXT->GfxMeshAttrib_typeID);
}
};
template <>
struct val_to_c<GfxMeshAttrib>
{
static GfxMeshAttrib f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxMeshAttrib_typeID)
RET*((GfxMeshAttrib*)obj->data);
else
 CATE(TE,"Value can not be converted to GfxMeshAttrib."));
} else
 CATE(TE,"Value can not be converted to GfxMeshAttrib."));
}
};

template <>
struct val_to_c<const GfxMeshAttrib>
{
static GfxMeshAttrib f(CTX ctx,const SV head) {return val_to_c<GfxMeshAttrib>::f(ctx, head);}
};

template <>
struct create_val<const GfxMeshAttrib>
{
static SV f(CTX ctx,const GfxMeshAttrib&obj) {return create_val<GfxMeshAttrib>::f(ctx,obj);}
};

template <>
struct type_same<GfxMeshAttrib>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxMeshAttrib_typeID;
else
 RET false;
}
};

void RenderComponent_destroy(CTX,NO);
SV RenderComponent_get_member(CTX,NO,SV);
void RenderComponent_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs RenderComponent_funcs={
.destroy = RenderComponent_destroy,
.getMember = RenderComponent_get_member,
.setMember = RenderComponent_set_member
};
template <>
struct type_same<RenderComponent>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RenderComponent_typeID;
else
 RET false;
}
};

SV RenderComponent_getShadowCaster(CTX ctx,const List<SV>&a);
SV RenderComponent_setShadowCaster(CTX ctx,const List<SV>&a);
SV RenderComponent_getOverlayColor(CTX ctx,const List<SV>&a);
SV RenderComponent_setOverlayColor(CTX ctx,const List<SV>&a);
SV RenderComponent_setAnimationState(CTX ctx,const List<SV>&a);
SV RenderComponent_removeAnimationState(CTX ctx,const List<SV>&a);
SV RenderComponent_getAnimationState(CTX ctx,const List<SV>&a);
void Int2_destroy(CTX,NO);
SV Int2_get_member(CTX,NO,SV);
void Int2_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Int2_funcs={
.destroy = Int2_destroy,
.getMember = Int2_get_member,
.setMember = Int2_set_member
};
template <>
struct create_val<T2<int32_t>>
{
static SV f(CTX ctx,const T2<int32_t>&obj)
{
#define ghfj T2<int32_t>
RET STG::createNativeObject(Int2_funcs,NEW(ghfj, obj),EXT->Int2_typeID);
}
};
template <>
struct val_to_c<T2<int32_t>>
{
static T2<int32_t> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Int2_typeID)
RET*((T2<int32_t>*)obj->data);
else
 CATE(TE,"Value can not be converted to Int2."));
} else
 CATE(TE,"Value can not be converted to Int2."));
}
};

template <>
struct val_to_c<const T2<int32_t>>
{
static T2<int32_t> f(CTX ctx,const SV head) {return val_to_c<T2<int32_t>>::f(ctx, head);}
};

template <>
struct create_val<const T2<int32_t>>
{
static SV f(CTX ctx,const T2<int32_t>&obj) {return create_val<T2<int32_t>>::f(ctx,obj);}
};

template <>
struct type_same<T2<int32_t>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Int2_typeID;
else
 RET false;
}
};

SV Int2___add__(CTX ctx,const List<SV>&a);
SV Int2___sub__(CTX ctx,const List<SV>&a);
SV Int2___mul__(CTX ctx,const List<SV>&a);
SV Int2___div__(CTX ctx,const List<SV>&a);
SV Int2___eq__(CTX ctx,const List<SV>&a);
SV Int2___neq__(CTX ctx,const List<SV>&a);
SV Int2___less__(CTX ctx,const List<SV>&a);
SV Int2___grtr__(CTX ctx,const List<SV>&a);
SV Int2___leq__(CTX ctx,const List<SV>&a);
SV Int2___geq__(CTX ctx,const List<SV>&a);
SV Int2_sum(CTX ctx,const List<SV>&a);
SV Int2_length(CTX ctx,const List<SV>&a);
SV Int2_lengthSquared(CTX ctx,const List<SV>&a);
SV Int2_dot(CTX ctx,const List<SV>&a);
SV Int2_distance(CTX ctx,const List<SV>&a);
SV Int2_distanceSquared(CTX ctx,const List<SV>&a);
SV Int2_normalize(CTX ctx,const List<SV>&a);
SV Int2_getXY(CTX ctx,const List<SV>&a);
SV Int2_setXY(CTX ctx,const List<SV>&a);
SV Int2_getYX(CTX ctx,const List<SV>&a);
SV Int2_setYX(CTX ctx,const List<SV>&a);
void AudioWorld_destroy(CTX,NO);
SV AudioWorld_get_member(CTX,NO,SV);
void AudioWorld_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs AudioWorld_funcs={
.destroy = AudioWorld_destroy,
.getMember = AudioWorld_get_member,
.setMember = AudioWorld_set_member
};
template <>
struct create_val<AudioWorld>
{
static SV f(CTX ctx,const AudioWorld&obj)
{
#define ghfj AudioWorld
RET STG::createNativeObject(AudioWorld_funcs,NEW(ghfj, obj),EXT->AudioWorld_typeID);
}
};
template <>
struct val_to_c<AudioWorld>
{
static AudioWorld f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->AudioWorld_typeID)
RET*((AudioWorld*)obj->data);
else
 CATE(TE,"Value can not be converted to AudioWorld."));
} else
 CATE(TE,"Value can not be converted to AudioWorld."));
}
};

template <>
struct val_to_c<const AudioWorld>
{
static AudioWorld f(CTX ctx,const SV head) {return val_to_c<AudioWorld>::f(ctx, head);}
};

template <>
struct create_val<const AudioWorld>
{
static SV f(CTX ctx,const AudioWorld&obj) {return create_val<AudioWorld>::f(ctx,obj);}
};

template <>
struct type_same<AudioWorld>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->AudioWorld_typeID;
else
 RET false;
}
};

SV AudioWorld_createSource(CTX ctx,const List<SV>&a);
SV AudioWorld_destroySource(CTX ctx,const List<SV>&a);
SV AudioWorld_clearSources(CTX ctx,const List<SV>&a);
SV AudioWorld_getSources(CTX ctx,const List<SV>&a);
SV AudioWorld_addToAudioDevice(CTX ctx,const List<SV>&a);
SV AudioWorld_removeFromAudioDevice(CTX ctx,const List<SV>&a);
void GuiPlacer_destroy(CTX,NO);
SV GuiPlacer_get_member(CTX,NO,SV);
void GuiPlacer_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GuiPlacer_funcs={
.destroy = GuiPlacer_destroy,
.getMember = GuiPlacer_get_member,
.setMember = GuiPlacer_set_member
};
template <>
struct create_val<GuiPlacer>
{
static SV f(CTX ctx,const GuiPlacer&obj)
{
#define ghfj GuiPlacer
RET STG::createNativeObject(GuiPlacer_funcs,NEW(ghfj, obj),EXT->GuiPlacer_typeID);
}
};
template <>
struct val_to_c<GuiPlacer>
{
static GuiPlacer f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GuiPlacer_typeID)
RET*((GuiPlacer*)obj->data);
else
 CATE(TE,"Value can not be converted to GuiPlacer."));
} else
 CATE(TE,"Value can not be converted to GuiPlacer."));
}
};

template <>
struct val_to_c<const GuiPlacer>
{
static GuiPlacer f(CTX ctx,const SV head) {return val_to_c<GuiPlacer>::f(ctx, head);}
};

template <>
struct create_val<const GuiPlacer>
{
static SV f(CTX ctx,const GuiPlacer&obj) {return create_val<GuiPlacer>::f(ctx,obj);}
};

template <>
struct type_same<GuiPlacer>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GuiPlacer_typeID;
else
 RET false;
}
};

SV GuiPlacer_button(CTX ctx,const List<SV>&a);
SV GuiPlacer_label(CTX ctx,const List<SV>&a);
SV GuiPlacer_placer(CTX ctx,const List<SV>&a);
SV GuiPlacer_advanceY(CTX ctx,const List<SV>&a);
SV GuiPlacer_resetY(CTX ctx,const List<SV>&a);
SV GuiPlacer_setXOrigin(CTX ctx,const List<SV>&a);
SV GuiPlacer_getXOriginMode(CTX ctx,const List<SV>&a);
SV GuiPlacer_getXOrigin(CTX ctx,const List<SV>&a);
SV GuiPlacer_getPadding(CTX ctx,const List<SV>&a);
void ImGui_destroy(CTX,NO);
SV ImGui_get_member(CTX,NO,SV);
void ImGui_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs ImGui_funcs={
.destroy = ImGui_destroy,
.getMember = ImGui_get_member,
.setMember = ImGui_set_member
};
template <>
struct create_val<ImGui>
{
static SV f(CTX ctx,const ImGui&obj)
{
#define ghfj ImGui
RET STG::createNativeObject(ImGui_funcs,NEW(ghfj, obj),EXT->ImGui_typeID);
}
};
template <>
struct val_to_c<ImGui>
{
static ImGui f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->ImGui_typeID)
RET*((ImGui*)obj->data);
else
 CATE(TE,"Value can not be converted to ImGui."));
} else
 CATE(TE,"Value can not be converted to ImGui."));
}
};

template <>
struct val_to_c<const ImGui>
{
static ImGui f(CTX ctx,const SV head) {return val_to_c<ImGui>::f(ctx, head);}
};

template <>
struct create_val<const ImGui>
{
static SV f(CTX ctx,const ImGui&obj) {return create_val<ImGui>::f(ctx,obj);}
};

template <>
struct type_same<ImGui>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->ImGui_typeID;
else
 RET false;
}
};

SV ImGui_rectangle(CTX ctx,const List<SV>&a);
SV ImGui_beginContainer(CTX ctx,const List<SV>&a);
SV ImGui_endContainer(CTX ctx,const List<SV>&a);
SV ImGui_verticalScrollBar(CTX ctx,const List<SV>&a);
SV ImGui_horizontalScrollBar(CTX ctx,const List<SV>&a);
SV ImGui_button(CTX ctx,const List<SV>&a);
SV ImGui_label(CTX ctx,const List<SV>&a);
SV ImGui_render(CTX ctx,const List<SV>&a);
void StringList_destroy(CTX,NO);
SV StringList_get_member(CTX,NO,SV);
void StringList_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs StringList_funcs={
.destroy = StringList_destroy,
.getMember = StringList_get_member,
.setMember = StringList_set_member
};
template <>
struct create_val<List<String>>
{
static SV f(CTX ctx,const List<String>&obj)
{
#define ghfj List<String>
RET STG::createNativeObject(StringList_funcs,NEW(ghfj, obj),EXT->StringList_typeID);
}
};
template <>
struct val_to_c<List<String>>
{
static List<String> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->StringList_typeID)
RET*((List<String>*)obj->data);
else
 CATE(TE,"Value can not be converted to StringList."));
} else
 CATE(TE,"Value can not be converted to StringList."));
}
};

template <>
struct val_to_c<const List<String>>
{
static List<String> f(CTX ctx,const SV head) {return val_to_c<List<String>>::f(ctx, head);}
};

template <>
struct create_val<const List<String>>
{
static SV f(CTX ctx,const List<String>&obj) {return create_val<List<String>>::f(ctx,obj);}
};

template <>
struct type_same<List<String>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->StringList_typeID;
else
 RET false;
}
};

SV StringList___eq__(CTX ctx,const List<SV>&a);
SV StringList___neq__(CTX ctx,const List<SV>&a);
SV StringList_get(CTX ctx,const List<SV>&a);
SV StringList_set(CTX ctx,const List<SV>&a);
SV StringList_getCount(CTX ctx,const List<SV>&a);
SV StringList_getData(CTX ctx,const List<SV>&a);
SV StringList_append(CTX ctx,const List<SV>&a);
SV StringList_insert(CTX ctx,const List<SV>&a);
SV StringList_remove(CTX ctx,const List<SV>&a);
SV StringList_clear(CTX ctx,const List<SV>&a);
SV StringList_find(CTX ctx,const List<SV>&a);
SV StringList_copy(CTX ctx,const List<SV>&a);
SV StringList_in(CTX ctx,const List<SV>&a);
SV StringList_begin(CTX ctx,const List<SV>&a);
SV StringList_end(CTX ctx,const List<SV>&a);
void Application_destroy(CTX,NO);
SV Application_get_member(CTX,NO,SV);
void Application_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Application_funcs={
.destroy = Application_destroy,
.getMember = Application_get_member,
.setMember = Application_set_member
};
template <>
struct type_same<Application>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Application_typeID;
else
 RET false;
}
};

SV Application_mainloop(CTX ctx,const List<SV>&a);
SV Application_getPlatform(CTX ctx,const List<SV>&a);
SV Application_getResourceManager(CTX ctx,const List<SV>&a);
SV Application_getGfxApi(CTX ctx,const List<SV>&a);
SV Application_getFilesystem(CTX ctx,const List<SV>&a);
SV Application_getDebugDrawer(CTX ctx,const List<SV>&a);
SV Application_getFreeType(CTX ctx,const List<SV>&a);
SV Application_getAudioDevice(CTX ctx,const List<SV>&a);
SV Application_getScriptEngine(CTX ctx,const List<SV>&a);
SV Application_setNextScript(CTX ctx,const List<SV>&a);
SV Application_getNextScript(CTX ctx,const List<SV>&a);
SV Application_getScript(CTX ctx,const List<SV>&a);
SV Application_getStats(CTX ctx,const List<SV>&a);
void LightPointData_destroy(CTX,NO);
SV LightPointData_get_member(CTX,NO,SV);
void LightPointData_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs LightPointData_funcs={
.destroy = LightPointData_destroy,
.getMember = LightPointData_get_member,
.setMember = LightPointData_set_member
};
template <>
struct create_val<LightPointData>
{
static SV f(CTX ctx,const LightPointData&obj)
{
#define ghfj LightPointData
RET STG::createNativeObject(LightPointData_funcs,NEW(ghfj, obj),EXT->LightPointData_typeID);
}
};
template <>
struct val_to_c<LightPointData>
{
static LightPointData f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->LightPointData_typeID)
RET*((LightPointData*)obj->data);
else
 CATE(TE,"Value can not be converted to LightPointData."));
} else
 CATE(TE,"Value can not be converted to LightPointData."));
}
};

template <>
struct val_to_c<const LightPointData>
{
static LightPointData f(CTX ctx,const SV head) {return val_to_c<LightPointData>::f(ctx, head);}
};

template <>
struct create_val<const LightPointData>
{
static SV f(CTX ctx,const LightPointData&obj) {return create_val<LightPointData>::f(ctx,obj);}
};

template <>
struct type_same<LightPointData>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->LightPointData_typeID;
else
 RET false;
}
};

void Float4_destroy(CTX,NO);
SV Float4_get_member(CTX,NO,SV);
void Float4_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Float4_funcs={
.destroy = Float4_destroy,
.getMember = Float4_get_member,
.setMember = Float4_set_member
};
template <>
struct create_val<T4<float>>
{
static SV f(CTX ctx,const T4<float>&obj)
{
#define ghfj T4<float>
RET STG::createNativeObject(Float4_funcs,NEW(ghfj, obj),EXT->Float4_typeID);
}
};
template <>
struct val_to_c<T4<float>>
{
static T4<float> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Float4_typeID)
RET*((T4<float>*)obj->data);
else
 CATE(TE,"Value can not be converted to Float4."));
} else
 CATE(TE,"Value can not be converted to Float4."));
}
};

template <>
struct val_to_c<const T4<float>>
{
static T4<float> f(CTX ctx,const SV head) {return val_to_c<T4<float>>::f(ctx, head);}
};

template <>
struct create_val<const T4<float>>
{
static SV f(CTX ctx,const T4<float>&obj) {return create_val<T4<float>>::f(ctx,obj);}
};

template <>
struct type_same<T4<float>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Float4_typeID;
else
 RET false;
}
};

SV Float4___add__(CTX ctx,const List<SV>&a);
SV Float4___sub__(CTX ctx,const List<SV>&a);
SV Float4___mul__(CTX ctx,const List<SV>&a);
SV Float4___div__(CTX ctx,const List<SV>&a);
SV Float4___eq__(CTX ctx,const List<SV>&a);
SV Float4___neq__(CTX ctx,const List<SV>&a);
SV Float4___less__(CTX ctx,const List<SV>&a);
SV Float4___grtr__(CTX ctx,const List<SV>&a);
SV Float4___leq__(CTX ctx,const List<SV>&a);
SV Float4___geq__(CTX ctx,const List<SV>&a);
SV Float4_sum(CTX ctx,const List<SV>&a);
SV Float4_length(CTX ctx,const List<SV>&a);
SV Float4_lengthSquared(CTX ctx,const List<SV>&a);
SV Float4_dot(CTX ctx,const List<SV>&a);
SV Float4_distance(CTX ctx,const List<SV>&a);
SV Float4_distanceSquared(CTX ctx,const List<SV>&a);
SV Float4_normalize(CTX ctx,const List<SV>&a);
SV Float4_getXY(CTX ctx,const List<SV>&a);
SV Float4_setXY(CTX ctx,const List<SV>&a);
SV Float4_getXZ(CTX ctx,const List<SV>&a);
SV Float4_setXZ(CTX ctx,const List<SV>&a);
SV Float4_getXW(CTX ctx,const List<SV>&a);
SV Float4_setXW(CTX ctx,const List<SV>&a);
SV Float4_getYX(CTX ctx,const List<SV>&a);
SV Float4_setYX(CTX ctx,const List<SV>&a);
SV Float4_getYZ(CTX ctx,const List<SV>&a);
SV Float4_setYZ(CTX ctx,const List<SV>&a);
SV Float4_getYW(CTX ctx,const List<SV>&a);
SV Float4_setYW(CTX ctx,const List<SV>&a);
SV Float4_getZX(CTX ctx,const List<SV>&a);
SV Float4_setZX(CTX ctx,const List<SV>&a);
SV Float4_getZY(CTX ctx,const List<SV>&a);
SV Float4_setZY(CTX ctx,const List<SV>&a);
SV Float4_getZW(CTX ctx,const List<SV>&a);
SV Float4_setZW(CTX ctx,const List<SV>&a);
SV Float4_getWX(CTX ctx,const List<SV>&a);
SV Float4_setWX(CTX ctx,const List<SV>&a);
SV Float4_getWY(CTX ctx,const List<SV>&a);
SV Float4_setWY(CTX ctx,const List<SV>&a);
SV Float4_getWZ(CTX ctx,const List<SV>&a);
SV Float4_setWZ(CTX ctx,const List<SV>&a);
SV Float4_getXYZ(CTX ctx,const List<SV>&a);
SV Float4_setXYZ(CTX ctx,const List<SV>&a);
SV Float4_getXYW(CTX ctx,const List<SV>&a);
SV Float4_setXYW(CTX ctx,const List<SV>&a);
SV Float4_getXZY(CTX ctx,const List<SV>&a);
SV Float4_setXZY(CTX ctx,const List<SV>&a);
SV Float4_getXZW(CTX ctx,const List<SV>&a);
SV Float4_setXZW(CTX ctx,const List<SV>&a);
SV Float4_getXWZ(CTX ctx,const List<SV>&a);
SV Float4_setXWZ(CTX ctx,const List<SV>&a);
SV Float4_getXWY(CTX ctx,const List<SV>&a);
SV Float4_setXWY(CTX ctx,const List<SV>&a);
SV Float4_getYXZ(CTX ctx,const List<SV>&a);
SV Float4_setYXZ(CTX ctx,const List<SV>&a);
SV Float4_getYXW(CTX ctx,const List<SV>&a);
SV Float4_setYXW(CTX ctx,const List<SV>&a);
SV Float4_getYZX(CTX ctx,const List<SV>&a);
SV Float4_setYZX(CTX ctx,const List<SV>&a);
SV Float4_getYZW(CTX ctx,const List<SV>&a);
SV Float4_setYZW(CTX ctx,const List<SV>&a);
SV Float4_getYWZ(CTX ctx,const List<SV>&a);
SV Float4_setYWZ(CTX ctx,const List<SV>&a);
SV Float4_getYWX(CTX ctx,const List<SV>&a);
SV Float4_setYWX(CTX ctx,const List<SV>&a);
SV Float4_getZXY(CTX ctx,const List<SV>&a);
SV Float4_setZXY(CTX ctx,const List<SV>&a);
SV Float4_getZXW(CTX ctx,const List<SV>&a);
SV Float4_setZXW(CTX ctx,const List<SV>&a);
SV Float4_getZYX(CTX ctx,const List<SV>&a);
SV Float4_setZYX(CTX ctx,const List<SV>&a);
SV Float4_getZYW(CTX ctx,const List<SV>&a);
SV Float4_setZYW(CTX ctx,const List<SV>&a);
SV Float4_getZWY(CTX ctx,const List<SV>&a);
SV Float4_setZWY(CTX ctx,const List<SV>&a);
SV Float4_getZWX(CTX ctx,const List<SV>&a);
SV Float4_setZWX(CTX ctx,const List<SV>&a);
SV Float4_getWXY(CTX ctx,const List<SV>&a);
SV Float4_setWXY(CTX ctx,const List<SV>&a);
SV Float4_getWXZ(CTX ctx,const List<SV>&a);
SV Float4_setWXZ(CTX ctx,const List<SV>&a);
SV Float4_getWYX(CTX ctx,const List<SV>&a);
SV Float4_setWYX(CTX ctx,const List<SV>&a);
SV Float4_getWYZ(CTX ctx,const List<SV>&a);
SV Float4_setWYZ(CTX ctx,const List<SV>&a);
SV Float4_getWZY(CTX ctx,const List<SV>&a);
SV Float4_setWZY(CTX ctx,const List<SV>&a);
SV Float4_getWZX(CTX ctx,const List<SV>&a);
SV Float4_setWZX(CTX ctx,const List<SV>&a);
SV Float4_getXYZW(CTX ctx,const List<SV>&a);
SV Float4_setXYZW(CTX ctx,const List<SV>&a);
SV Float4_getXYWZ(CTX ctx,const List<SV>&a);
SV Float4_setXYWZ(CTX ctx,const List<SV>&a);
SV Float4_getXZYW(CTX ctx,const List<SV>&a);
SV Float4_setXZYW(CTX ctx,const List<SV>&a);
SV Float4_getXZWY(CTX ctx,const List<SV>&a);
SV Float4_setXZWY(CTX ctx,const List<SV>&a);
SV Float4_getXWZY(CTX ctx,const List<SV>&a);
SV Float4_setXWZY(CTX ctx,const List<SV>&a);
SV Float4_getXWYZ(CTX ctx,const List<SV>&a);
SV Float4_setXWYZ(CTX ctx,const List<SV>&a);
SV Float4_getYXZW(CTX ctx,const List<SV>&a);
SV Float4_setYXZW(CTX ctx,const List<SV>&a);
SV Float4_getYXWZ(CTX ctx,const List<SV>&a);
SV Float4_setYXWZ(CTX ctx,const List<SV>&a);
SV Float4_getYZXW(CTX ctx,const List<SV>&a);
SV Float4_setYZXW(CTX ctx,const List<SV>&a);
SV Float4_getYZWX(CTX ctx,const List<SV>&a);
SV Float4_setYZWX(CTX ctx,const List<SV>&a);
SV Float4_getYWZX(CTX ctx,const List<SV>&a);
SV Float4_setYWZX(CTX ctx,const List<SV>&a);
SV Float4_getYWXZ(CTX ctx,const List<SV>&a);
SV Float4_setYWXZ(CTX ctx,const List<SV>&a);
SV Float4_getZYXW(CTX ctx,const List<SV>&a);
SV Float4_setZYXW(CTX ctx,const List<SV>&a);
SV Float4_getZYWX(CTX ctx,const List<SV>&a);
SV Float4_setZYWX(CTX ctx,const List<SV>&a);
SV Float4_getZXYW(CTX ctx,const List<SV>&a);
SV Float4_setZXYW(CTX ctx,const List<SV>&a);
SV Float4_getZXWY(CTX ctx,const List<SV>&a);
SV Float4_setZXWY(CTX ctx,const List<SV>&a);
SV Float4_getZWXY(CTX ctx,const List<SV>&a);
SV Float4_setZWXY(CTX ctx,const List<SV>&a);
SV Float4_getZWYX(CTX ctx,const List<SV>&a);
SV Float4_setZWYX(CTX ctx,const List<SV>&a);
SV Float4_getWYZX(CTX ctx,const List<SV>&a);
SV Float4_setWYZX(CTX ctx,const List<SV>&a);
SV Float4_getWYXZ(CTX ctx,const List<SV>&a);
SV Float4_setWYXZ(CTX ctx,const List<SV>&a);
SV Float4_getWZYX(CTX ctx,const List<SV>&a);
SV Float4_setWZYX(CTX ctx,const List<SV>&a);
SV Float4_getWZXY(CTX ctx,const List<SV>&a);
SV Float4_setWZXY(CTX ctx,const List<SV>&a);
SV Float4_getWXZY(CTX ctx,const List<SV>&a);
SV Float4_setWXZY(CTX ctx,const List<SV>&a);
SV Float4_getWXYZ(CTX ctx,const List<SV>&a);
SV Float4_setWXYZ(CTX ctx,const List<SV>&a);
void FloatList_destroy(CTX,NO);
SV FloatList_get_member(CTX,NO,SV);
void FloatList_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs FloatList_funcs={
.destroy = FloatList_destroy,
.getMember = FloatList_get_member,
.setMember = FloatList_set_member
};
template <>
struct create_val<List<float>>
{
static SV f(CTX ctx,const List<float>&obj)
{
#define ghfj List<float>
RET STG::createNativeObject(FloatList_funcs,NEW(ghfj, obj),EXT->FloatList_typeID);
}
};
template <>
struct val_to_c<List<float>>
{
static List<float> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->FloatList_typeID)
RET*((List<float>*)obj->data);
else
 CATE(TE,"Value can not be converted to FloatList."));
} else
 CATE(TE,"Value can not be converted to FloatList."));
}
};

template <>
struct val_to_c<const List<float>>
{
static List<float> f(CTX ctx,const SV head) {return val_to_c<List<float>>::f(ctx, head);}
};

template <>
struct create_val<const List<float>>
{
static SV f(CTX ctx,const List<float>&obj) {return create_val<List<float>>::f(ctx,obj);}
};

template <>
struct type_same<List<float>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->FloatList_typeID;
else
 RET false;
}
};

SV FloatList___eq__(CTX ctx,const List<SV>&a);
SV FloatList___neq__(CTX ctx,const List<SV>&a);
SV FloatList_get(CTX ctx,const List<SV>&a);
SV FloatList_set(CTX ctx,const List<SV>&a);
SV FloatList_getCount(CTX ctx,const List<SV>&a);
SV FloatList_getData(CTX ctx,const List<SV>&a);
SV FloatList_append(CTX ctx,const List<SV>&a);
SV FloatList_insert(CTX ctx,const List<SV>&a);
SV FloatList_remove(CTX ctx,const List<SV>&a);
SV FloatList_clear(CTX ctx,const List<SV>&a);
SV FloatList_find(CTX ctx,const List<SV>&a);
SV FloatList_copy(CTX ctx,const List<SV>&a);
SV FloatList_in(CTX ctx,const List<SV>&a);
SV FloatList_begin(CTX ctx,const List<SV>&a);
SV FloatList_end(CTX ctx,const List<SV>&a);
void Container_destroy(CTX,NO);
SV Container_get_member(CTX,NO,SV);
void Container_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Container_funcs={
.destroy = Container_destroy,
.getMember = Container_get_member,
.setMember = Container_set_member
};
template <>
struct create_val<Container>
{
static SV f(CTX ctx,const Container&obj)
{
#define ghfj Container
RET STG::createNativeObject(Container_funcs,NEW(ghfj, obj),EXT->Container_typeID);
}
};
template <>
struct val_to_c<Container>
{
static Container f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Container_typeID)
RET*((Container*)obj->data);
else
 CATE(TE,"Value can not be converted to Container."));
} else
 CATE(TE,"Value can not be converted to Container."));
}
};

template <>
struct val_to_c<const Container>
{
static Container f(CTX ctx,const SV head) {return val_to_c<Container>::f(ctx, head);}
};

template <>
struct create_val<const Container>
{
static SV f(CTX ctx,const Container&obj) {return create_val<Container>::f(ctx,obj);}
};

template <>
struct type_same<Container>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Container_typeID;
else
 RET false;
}
};

void LightDirectionalData_destroy(CTX,NO);
SV LightDirectionalData_get_member(CTX,NO,SV);
void LightDirectionalData_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs LightDirectionalData_funcs={
.destroy = LightDirectionalData_destroy,
.getMember = LightDirectionalData_get_member,
.setMember = LightDirectionalData_set_member
};
template <>
struct create_val<LightDirectionalData>
{
static SV f(CTX ctx,const LightDirectionalData&obj)
{
#define ghfj LightDirectionalData
RET STG::createNativeObject(LightDirectionalData_funcs,NEW(ghfj, obj),EXT->LightDirectionalData_typeID);
}
};
template <>
struct val_to_c<LightDirectionalData>
{
static LightDirectionalData f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->LightDirectionalData_typeID)
RET*((LightDirectionalData*)obj->data);
else
 CATE(TE,"Value can not be converted to LightDirectionalData."));
} else
 CATE(TE,"Value can not be converted to LightDirectionalData."));
}
};

template <>
struct val_to_c<const LightDirectionalData>
{
static LightDirectionalData f(CTX ctx,const SV head) {return val_to_c<LightDirectionalData>::f(ctx, head);}
};

template <>
struct create_val<const LightDirectionalData>
{
static SV f(CTX ctx,const LightDirectionalData&obj) {return create_val<LightDirectionalData>::f(ctx,obj);}
};

template <>
struct type_same<LightDirectionalData>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->LightDirectionalData_typeID;
else
 RET false;
}
};

void Matrix4x4_destroy(CTX,NO);
SV Matrix4x4_get_member(CTX,NO,SV);
void Matrix4x4_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Matrix4x4_funcs={
.destroy = Matrix4x4_destroy,
.getMember = Matrix4x4_get_member,
.setMember = Matrix4x4_set_member
};
template <>
struct create_val<Matrix4x4>
{
static SV f(CTX ctx,const Matrix4x4&obj)
{
#define ghfj Matrix4x4
RET STG::createNativeObject(Matrix4x4_funcs,NEW(ghfj, obj),EXT->Matrix4x4_typeID);
}
};
template <>
struct val_to_c<Matrix4x4>
{
static Matrix4x4 f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Matrix4x4_typeID)
RET*((Matrix4x4*)obj->data);
else
 CATE(TE,"Value can not be converted to Matrix4x4."));
} else
 CATE(TE,"Value can not be converted to Matrix4x4."));
}
};

template <>
struct val_to_c<const Matrix4x4>
{
static Matrix4x4 f(CTX ctx,const SV head) {return val_to_c<Matrix4x4>::f(ctx, head);}
};

template <>
struct create_val<const Matrix4x4>
{
static SV f(CTX ctx,const Matrix4x4&obj) {return create_val<Matrix4x4>::f(ctx,obj);}
};

template <>
struct type_same<Matrix4x4>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Matrix4x4_typeID;
else
 RET false;
}
};

SV Matrix4x4___mul__(CTX ctx,const List<SV>&a);
SV Matrix4x4___div__(CTX ctx,const List<SV>&a);
SV Matrix4x4_get(CTX ctx,const List<SV>&a);
SV Matrix4x4_set(CTX ctx,const List<SV>&a);
SV Matrix4x4___eq__(CTX ctx,const List<SV>&a);
SV Matrix4x4_transpose(CTX ctx,const List<SV>&a);
SV Matrix4x4_inverse(CTX ctx,const List<SV>&a);
SV Matrix4x4_translate(CTX ctx,const List<SV>&a);
SV Matrix4x4_scale(CTX ctx,const List<SV>&a);
SV Matrix4x4_rotate(CTX ctx,const List<SV>&a);
SV Matrix4x4_rotatex(CTX ctx,const List<SV>&a);
SV Matrix4x4_rotatey(CTX ctx,const List<SV>&a);
SV Matrix4x4_rotatez(CTX ctx,const List<SV>&a);
SV Matrix4x4_perspective(CTX ctx,const List<SV>&a);
SV Matrix4x4_orthographic(CTX ctx,const List<SV>&a);
SV Matrix4x4_lookAt(CTX ctx,const List<SV>&a);
SV Matrix4x4_lookAtDir(CTX ctx,const List<SV>&a);
void Map_destroy(CTX,NO);
SV Map_get_member(CTX,NO,SV);
void Map_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Map_funcs={
.destroy = Map_destroy,
.getMember = Map_get_member,
.setMember = Map_set_member
};
template <>
struct create_val<HashMap<scripting::Value*,scripting::Value*>>
{
static SV f(CTX ctx,const HashMap<scripting::Value*,scripting::Value*>&obj)
{
#define ghfj HashMap<scripting::Value*,scripting::Value*>
RET STG::createNativeObject(Map_funcs,NEW(ghfj, obj),EXT->Map_typeID);
}
};
template <>
struct val_to_c<HashMap<scripting::Value*,scripting::Value*>>
{
static HashMap<scripting::Value*,scripting::Value*> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Map_typeID)
RET*((HashMap<scripting::Value*,scripting::Value*>*)obj->data);
else
 CATE(TE,"Value can not be converted to Map."));
} else
 CATE(TE,"Value can not be converted to Map."));
}
};

template <>
struct val_to_c<const HashMap<scripting::Value*,scripting::Value*>>
{
static HashMap<scripting::Value*,scripting::Value*> f(CTX ctx,const SV head) {return val_to_c<HashMap<scripting::Value*,scripting::Value*>>::f(ctx, head);}
};

template <>
struct create_val<const HashMap<scripting::Value*,scripting::Value*>>
{
static SV f(CTX ctx,const HashMap<scripting::Value*,scripting::Value*>&obj) {return create_val<HashMap<scripting::Value*,scripting::Value*>>::f(ctx,obj);}
};

template <>
struct type_same<HashMap<scripting::Value*,scripting::Value*>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Map_typeID;
else
 RET false;
}
};

SV Map___eq__(CTX ctx,const List<SV>&a);
SV Map___neq__(CTX ctx,const List<SV>&a);
SV Map_getEntryCount(CTX ctx,const List<SV>&a);
SV Map_findEntry(CTX ctx,const List<SV>&a);
SV Map_getKey(CTX ctx,const List<SV>&a);
SV Map_getValue(CTX ctx,const List<SV>&a);
SV Map_getKeyHash(CTX ctx,const List<SV>&a);
SV Map_get(CTX ctx,const List<SV>&a);
SV Map_set(CTX ctx,const List<SV>&a);
SV Map_removeEntry(CTX ctx,const List<SV>&a);
SV Map_remove(CTX ctx,const List<SV>&a);
SV Map_clear(CTX ctx,const List<SV>&a);
SV Map_append(CTX ctx,const List<SV>&a);
void UInt3_destroy(CTX,NO);
SV UInt3_get_member(CTX,NO,SV);
void UInt3_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs UInt3_funcs={
.destroy = UInt3_destroy,
.getMember = UInt3_get_member,
.setMember = UInt3_set_member
};
template <>
struct create_val<T3<uint32_t>>
{
static SV f(CTX ctx,const T3<uint32_t>&obj)
{
#define ghfj T3<uint32_t>
RET STG::createNativeObject(UInt3_funcs,NEW(ghfj, obj),EXT->UInt3_typeID);
}
};
template <>
struct val_to_c<T3<uint32_t>>
{
static T3<uint32_t> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->UInt3_typeID)
RET*((T3<uint32_t>*)obj->data);
else
 CATE(TE,"Value can not be converted to UInt3."));
} else
 CATE(TE,"Value can not be converted to UInt3."));
}
};

template <>
struct val_to_c<const T3<uint32_t>>
{
static T3<uint32_t> f(CTX ctx,const SV head) {return val_to_c<T3<uint32_t>>::f(ctx, head);}
};

template <>
struct create_val<const T3<uint32_t>>
{
static SV f(CTX ctx,const T3<uint32_t>&obj) {return create_val<T3<uint32_t>>::f(ctx,obj);}
};

template <>
struct type_same<T3<uint32_t>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->UInt3_typeID;
else
 RET false;
}
};

SV UInt3___add__(CTX ctx,const List<SV>&a);
SV UInt3___sub__(CTX ctx,const List<SV>&a);
SV UInt3___mul__(CTX ctx,const List<SV>&a);
SV UInt3___div__(CTX ctx,const List<SV>&a);
SV UInt3___eq__(CTX ctx,const List<SV>&a);
SV UInt3___neq__(CTX ctx,const List<SV>&a);
SV UInt3___less__(CTX ctx,const List<SV>&a);
SV UInt3___grtr__(CTX ctx,const List<SV>&a);
SV UInt3___leq__(CTX ctx,const List<SV>&a);
SV UInt3___geq__(CTX ctx,const List<SV>&a);
SV UInt3_sum(CTX ctx,const List<SV>&a);
SV UInt3_length(CTX ctx,const List<SV>&a);
SV UInt3_lengthSquared(CTX ctx,const List<SV>&a);
SV UInt3_dot(CTX ctx,const List<SV>&a);
SV UInt3_distance(CTX ctx,const List<SV>&a);
SV UInt3_distanceSquared(CTX ctx,const List<SV>&a);
SV UInt3_normalize(CTX ctx,const List<SV>&a);
SV UInt3_cross(CTX ctx,const List<SV>&a);
SV UInt3_getXY(CTX ctx,const List<SV>&a);
SV UInt3_setXY(CTX ctx,const List<SV>&a);
SV UInt3_getXZ(CTX ctx,const List<SV>&a);
SV UInt3_setXZ(CTX ctx,const List<SV>&a);
SV UInt3_getYX(CTX ctx,const List<SV>&a);
SV UInt3_setYX(CTX ctx,const List<SV>&a);
SV UInt3_getYZ(CTX ctx,const List<SV>&a);
SV UInt3_setYZ(CTX ctx,const List<SV>&a);
SV UInt3_getZX(CTX ctx,const List<SV>&a);
SV UInt3_setZX(CTX ctx,const List<SV>&a);
SV UInt3_getZY(CTX ctx,const List<SV>&a);
SV UInt3_setZY(CTX ctx,const List<SV>&a);
SV UInt3_getXYZ(CTX ctx,const List<SV>&a);
SV UInt3_setXYZ(CTX ctx,const List<SV>&a);
SV UInt3_getXZY(CTX ctx,const List<SV>&a);
SV UInt3_setXZY(CTX ctx,const List<SV>&a);
SV UInt3_getYXZ(CTX ctx,const List<SV>&a);
SV UInt3_setYXZ(CTX ctx,const List<SV>&a);
SV UInt3_getYZX(CTX ctx,const List<SV>&a);
SV UInt3_setYZX(CTX ctx,const List<SV>&a);
SV UInt3_getZXY(CTX ctx,const List<SV>&a);
SV UInt3_setZXY(CTX ctx,const List<SV>&a);
SV UInt3_getZYX(CTX ctx,const List<SV>&a);
SV UInt3_setZYX(CTX ctx,const List<SV>&a);
void LightSpotData_destroy(CTX,NO);
SV LightSpotData_get_member(CTX,NO,SV);
void LightSpotData_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs LightSpotData_funcs={
.destroy = LightSpotData_destroy,
.getMember = LightSpotData_get_member,
.setMember = LightSpotData_set_member
};
template <>
struct create_val<LightSpotData>
{
static SV f(CTX ctx,const LightSpotData&obj)
{
#define ghfj LightSpotData
RET STG::createNativeObject(LightSpotData_funcs,NEW(ghfj, obj),EXT->LightSpotData_typeID);
}
};
template <>
struct val_to_c<LightSpotData>
{
static LightSpotData f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->LightSpotData_typeID)
RET*((LightSpotData*)obj->data);
else
 CATE(TE,"Value can not be converted to LightSpotData."));
} else
 CATE(TE,"Value can not be converted to LightSpotData."));
}
};

template <>
struct val_to_c<const LightSpotData>
{
static LightSpotData f(CTX ctx,const SV head) {return val_to_c<LightSpotData>::f(ctx, head);}
};

template <>
struct create_val<const LightSpotData>
{
static SV f(CTX ctx,const LightSpotData&obj) {return create_val<LightSpotData>::f(ctx,obj);}
};

template <>
struct type_same<LightSpotData>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->LightSpotData_typeID;
else
 RET false;
}
};

void PhysicsShape_destroy(CTX,NO);
SV PhysicsShape_get_member(CTX,NO,SV);
void PhysicsShape_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs PhysicsShape_funcs={
.destroy = PhysicsShape_destroy,
.getMember = PhysicsShape_get_member,
.setMember = PhysicsShape_set_member
};
template <>
struct type_same<PhysicsShape>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->PhysicsShape_typeID;
else
 RET false;
}
};

SV PhysicsShape_removeContent(CTX ctx,const List<SV>&a);
SV PhysicsShape_getImpl(CTX ctx,const List<SV>&a);
SV PhysicsShape_getShapeType(CTX ctx,const List<SV>&a);
SV PhysicsShape_getMargin(CTX ctx,const List<SV>&a);
SV PhysicsShape_setMargin(CTX ctx,const List<SV>&a);
SV PhysicsShape_getScale(CTX ctx,const List<SV>&a);
SV PhysicsShape_setScale(CTX ctx,const List<SV>&a);
SV PhysicsShape_getBulletShape(CTX ctx,const List<SV>&a);
SV PhysicsShape_setEmpty(CTX ctx,const List<SV>&a);
SV PhysicsShape_setSphere(CTX ctx,const List<SV>&a);
SV PhysicsShape_setBox(CTX ctx,const List<SV>&a);
SV PhysicsShape_setCylinder(CTX ctx,const List<SV>&a);
SV PhysicsShape_setCapsule(CTX ctx,const List<SV>&a);
SV PhysicsShape_setCone(CTX ctx,const List<SV>&a);
SV PhysicsShape_setConvexHull(CTX ctx,const List<SV>&a);
SV PhysicsShape_setStaticTriangleMesh(CTX ctx,const List<SV>&a);
SV PhysicsShape_setHeightfield(CTX ctx,const List<SV>&a);
SV PhysicsShape_setPlane(CTX ctx,const List<SV>&a);
SV PhysicsShape_setCompound(CTX ctx,const List<SV>&a);
SV PhysicsShape_save(CTX ctx,const List<SV>&a);
SV PhysicsShape_load(CTX ctx,const List<SV>&a);
SV PhysicsShape_copy(CTX ctx,const List<SV>&a);
SV PhysicsShape_getType(CTX ctx,const List<SV>&a);
SV PhysicsShape_release(CTX ctx,const List<SV>&a);
SV PhysicsShape_getRefCount(CTX ctx,const List<SV>&a);
SV PhysicsShape_getFilename(CTX ctx,const List<SV>&a);
SV PhysicsShape_setFilename(CTX ctx,const List<SV>&a);
void AudioDevice_destroy(CTX,NO);
SV AudioDevice_get_member(CTX,NO,SV);
void AudioDevice_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs AudioDevice_funcs={
.destroy = AudioDevice_destroy,
.getMember = AudioDevice_get_member,
.setMember = AudioDevice_set_member
};
template <>
struct create_val<AudioDevice>
{
static SV f(CTX ctx,const AudioDevice&obj)
{
#define ghfj AudioDevice
RET STG::createNativeObject(AudioDevice_funcs,NEW(ghfj, obj),EXT->AudioDevice_typeID);
}
};
template <>
struct val_to_c<AudioDevice>
{
static AudioDevice f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->AudioDevice_typeID)
RET*((AudioDevice*)obj->data);
else
 CATE(TE,"Value can not be converted to AudioDevice."));
} else
 CATE(TE,"Value can not be converted to AudioDevice."));
}
};

template <>
struct val_to_c<const AudioDevice>
{
static AudioDevice f(CTX ctx,const SV head) {return val_to_c<AudioDevice>::f(ctx, head);}
};

template <>
struct create_val<const AudioDevice>
{
static SV f(CTX ctx,const AudioDevice&obj) {return create_val<AudioDevice>::f(ctx,obj);}
};

template <>
struct type_same<AudioDevice>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->AudioDevice_typeID;
else
 RET false;
}
};

SV AudioDevice_getName(CTX ctx,const List<SV>&a);
SV AudioDevice_getDeviceCount(CTX ctx,const List<SV>&a);
SV AudioDevice_setIndex(CTX ctx,const List<SV>&a);
SV AudioDevice_setFrequency(CTX ctx,const List<SV>&a);
SV AudioDevice_setSamples(CTX ctx,const List<SV>&a);
SV AudioDevice_getIndex(CTX ctx,const List<SV>&a);
SV AudioDevice_getFrequency(CTX ctx,const List<SV>&a);
SV AudioDevice_getSamples(CTX ctx,const List<SV>&a);
SV AudioDevice_getNumQueuedSamples(CTX ctx,const List<SV>&a);
SV AudioDevice_pause(CTX ctx,const List<SV>&a);
SV AudioDevice_play(CTX ctx,const List<SV>&a);
SV AudioDevice_getPaused(CTX ctx,const List<SV>&a);
SV AudioDevice_runCallbacks(CTX ctx,const List<SV>&a);
void RigidBodyList_destroy(CTX,NO);
SV RigidBodyList_get_member(CTX,NO,SV);
void RigidBodyList_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs RigidBodyList_funcs={
.destroy = RigidBodyList_destroy,
.getMember = RigidBodyList_get_member,
.setMember = RigidBodyList_set_member
};
template <>
struct create_val<List<RigidBody*>>
{
static SV f(CTX ctx,const List<RigidBody*>&obj)
{
#define ghfj List<RigidBody*>
RET STG::createNativeObject(RigidBodyList_funcs,NEW(ghfj, obj),EXT->RigidBodyList_typeID);
}
};
template <>
struct val_to_c<List<RigidBody*>>
{
static List<RigidBody*> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->RigidBodyList_typeID)
RET*((List<RigidBody*>*)obj->data);
else
 CATE(TE,"Value can not be converted to RigidBodyList."));
} else
 CATE(TE,"Value can not be converted to RigidBodyList."));
}
};

template <>
struct val_to_c<const List<RigidBody*>>
{
static List<RigidBody*> f(CTX ctx,const SV head) {return val_to_c<List<RigidBody*>>::f(ctx, head);}
};

template <>
struct create_val<const List<RigidBody*>>
{
static SV f(CTX ctx,const List<RigidBody*>&obj) {return create_val<List<RigidBody*>>::f(ctx,obj);}
};

template <>
struct type_same<List<RigidBody*>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RigidBodyList_typeID;
else
 RET false;
}
};

SV RigidBodyList___eq__(CTX ctx,const List<SV>&a);
SV RigidBodyList___neq__(CTX ctx,const List<SV>&a);
SV RigidBodyList_get(CTX ctx,const List<SV>&a);
SV RigidBodyList_set(CTX ctx,const List<SV>&a);
SV RigidBodyList_getCount(CTX ctx,const List<SV>&a);
SV RigidBodyList_getData(CTX ctx,const List<SV>&a);
SV RigidBodyList_append(CTX ctx,const List<SV>&a);
SV RigidBodyList_insert(CTX ctx,const List<SV>&a);
SV RigidBodyList_remove(CTX ctx,const List<SV>&a);
SV RigidBodyList_clear(CTX ctx,const List<SV>&a);
SV RigidBodyList_find(CTX ctx,const List<SV>&a);
SV RigidBodyList_copy(CTX ctx,const List<SV>&a);
SV RigidBodyList_in(CTX ctx,const List<SV>&a);
SV RigidBodyList_begin(CTX ctx,const List<SV>&a);
SV RigidBodyList_end(CTX ctx,const List<SV>&a);
void UInt4_destroy(CTX,NO);
SV UInt4_get_member(CTX,NO,SV);
void UInt4_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs UInt4_funcs={
.destroy = UInt4_destroy,
.getMember = UInt4_get_member,
.setMember = UInt4_set_member
};
template <>
struct create_val<T4<uint32_t>>
{
static SV f(CTX ctx,const T4<uint32_t>&obj)
{
#define ghfj T4<uint32_t>
RET STG::createNativeObject(UInt4_funcs,NEW(ghfj, obj),EXT->UInt4_typeID);
}
};
template <>
struct val_to_c<T4<uint32_t>>
{
static T4<uint32_t> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->UInt4_typeID)
RET*((T4<uint32_t>*)obj->data);
else
 CATE(TE,"Value can not be converted to UInt4."));
} else
 CATE(TE,"Value can not be converted to UInt4."));
}
};

template <>
struct val_to_c<const T4<uint32_t>>
{
static T4<uint32_t> f(CTX ctx,const SV head) {return val_to_c<T4<uint32_t>>::f(ctx, head);}
};

template <>
struct create_val<const T4<uint32_t>>
{
static SV f(CTX ctx,const T4<uint32_t>&obj) {return create_val<T4<uint32_t>>::f(ctx,obj);}
};

template <>
struct type_same<T4<uint32_t>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->UInt4_typeID;
else
 RET false;
}
};

SV UInt4___add__(CTX ctx,const List<SV>&a);
SV UInt4___sub__(CTX ctx,const List<SV>&a);
SV UInt4___mul__(CTX ctx,const List<SV>&a);
SV UInt4___div__(CTX ctx,const List<SV>&a);
SV UInt4___eq__(CTX ctx,const List<SV>&a);
SV UInt4___neq__(CTX ctx,const List<SV>&a);
SV UInt4___less__(CTX ctx,const List<SV>&a);
SV UInt4___grtr__(CTX ctx,const List<SV>&a);
SV UInt4___leq__(CTX ctx,const List<SV>&a);
SV UInt4___geq__(CTX ctx,const List<SV>&a);
SV UInt4_sum(CTX ctx,const List<SV>&a);
SV UInt4_length(CTX ctx,const List<SV>&a);
SV UInt4_lengthSquared(CTX ctx,const List<SV>&a);
SV UInt4_dot(CTX ctx,const List<SV>&a);
SV UInt4_distance(CTX ctx,const List<SV>&a);
SV UInt4_distanceSquared(CTX ctx,const List<SV>&a);
SV UInt4_normalize(CTX ctx,const List<SV>&a);
SV UInt4_getXY(CTX ctx,const List<SV>&a);
SV UInt4_setXY(CTX ctx,const List<SV>&a);
SV UInt4_getXZ(CTX ctx,const List<SV>&a);
SV UInt4_setXZ(CTX ctx,const List<SV>&a);
SV UInt4_getXW(CTX ctx,const List<SV>&a);
SV UInt4_setXW(CTX ctx,const List<SV>&a);
SV UInt4_getYX(CTX ctx,const List<SV>&a);
SV UInt4_setYX(CTX ctx,const List<SV>&a);
SV UInt4_getYZ(CTX ctx,const List<SV>&a);
SV UInt4_setYZ(CTX ctx,const List<SV>&a);
SV UInt4_getYW(CTX ctx,const List<SV>&a);
SV UInt4_setYW(CTX ctx,const List<SV>&a);
SV UInt4_getZX(CTX ctx,const List<SV>&a);
SV UInt4_setZX(CTX ctx,const List<SV>&a);
SV UInt4_getZY(CTX ctx,const List<SV>&a);
SV UInt4_setZY(CTX ctx,const List<SV>&a);
SV UInt4_getZW(CTX ctx,const List<SV>&a);
SV UInt4_setZW(CTX ctx,const List<SV>&a);
SV UInt4_getWX(CTX ctx,const List<SV>&a);
SV UInt4_setWX(CTX ctx,const List<SV>&a);
SV UInt4_getWY(CTX ctx,const List<SV>&a);
SV UInt4_setWY(CTX ctx,const List<SV>&a);
SV UInt4_getWZ(CTX ctx,const List<SV>&a);
SV UInt4_setWZ(CTX ctx,const List<SV>&a);
SV UInt4_getXYZ(CTX ctx,const List<SV>&a);
SV UInt4_setXYZ(CTX ctx,const List<SV>&a);
SV UInt4_getXYW(CTX ctx,const List<SV>&a);
SV UInt4_setXYW(CTX ctx,const List<SV>&a);
SV UInt4_getXZY(CTX ctx,const List<SV>&a);
SV UInt4_setXZY(CTX ctx,const List<SV>&a);
SV UInt4_getXZW(CTX ctx,const List<SV>&a);
SV UInt4_setXZW(CTX ctx,const List<SV>&a);
SV UInt4_getXWZ(CTX ctx,const List<SV>&a);
SV UInt4_setXWZ(CTX ctx,const List<SV>&a);
SV UInt4_getXWY(CTX ctx,const List<SV>&a);
SV UInt4_setXWY(CTX ctx,const List<SV>&a);
SV UInt4_getYXZ(CTX ctx,const List<SV>&a);
SV UInt4_setYXZ(CTX ctx,const List<SV>&a);
SV UInt4_getYXW(CTX ctx,const List<SV>&a);
SV UInt4_setYXW(CTX ctx,const List<SV>&a);
SV UInt4_getYZX(CTX ctx,const List<SV>&a);
SV UInt4_setYZX(CTX ctx,const List<SV>&a);
SV UInt4_getYZW(CTX ctx,const List<SV>&a);
SV UInt4_setYZW(CTX ctx,const List<SV>&a);
SV UInt4_getYWZ(CTX ctx,const List<SV>&a);
SV UInt4_setYWZ(CTX ctx,const List<SV>&a);
SV UInt4_getYWX(CTX ctx,const List<SV>&a);
SV UInt4_setYWX(CTX ctx,const List<SV>&a);
SV UInt4_getZXY(CTX ctx,const List<SV>&a);
SV UInt4_setZXY(CTX ctx,const List<SV>&a);
SV UInt4_getZXW(CTX ctx,const List<SV>&a);
SV UInt4_setZXW(CTX ctx,const List<SV>&a);
SV UInt4_getZYX(CTX ctx,const List<SV>&a);
SV UInt4_setZYX(CTX ctx,const List<SV>&a);
SV UInt4_getZYW(CTX ctx,const List<SV>&a);
SV UInt4_setZYW(CTX ctx,const List<SV>&a);
SV UInt4_getZWY(CTX ctx,const List<SV>&a);
SV UInt4_setZWY(CTX ctx,const List<SV>&a);
SV UInt4_getZWX(CTX ctx,const List<SV>&a);
SV UInt4_setZWX(CTX ctx,const List<SV>&a);
SV UInt4_getWXY(CTX ctx,const List<SV>&a);
SV UInt4_setWXY(CTX ctx,const List<SV>&a);
SV UInt4_getWXZ(CTX ctx,const List<SV>&a);
SV UInt4_setWXZ(CTX ctx,const List<SV>&a);
SV UInt4_getWYX(CTX ctx,const List<SV>&a);
SV UInt4_setWYX(CTX ctx,const List<SV>&a);
SV UInt4_getWYZ(CTX ctx,const List<SV>&a);
SV UInt4_setWYZ(CTX ctx,const List<SV>&a);
SV UInt4_getWZY(CTX ctx,const List<SV>&a);
SV UInt4_setWZY(CTX ctx,const List<SV>&a);
SV UInt4_getWZX(CTX ctx,const List<SV>&a);
SV UInt4_setWZX(CTX ctx,const List<SV>&a);
SV UInt4_getXYZW(CTX ctx,const List<SV>&a);
SV UInt4_setXYZW(CTX ctx,const List<SV>&a);
SV UInt4_getXYWZ(CTX ctx,const List<SV>&a);
SV UInt4_setXYWZ(CTX ctx,const List<SV>&a);
SV UInt4_getXZYW(CTX ctx,const List<SV>&a);
SV UInt4_setXZYW(CTX ctx,const List<SV>&a);
SV UInt4_getXZWY(CTX ctx,const List<SV>&a);
SV UInt4_setXZWY(CTX ctx,const List<SV>&a);
SV UInt4_getXWZY(CTX ctx,const List<SV>&a);
SV UInt4_setXWZY(CTX ctx,const List<SV>&a);
SV UInt4_getXWYZ(CTX ctx,const List<SV>&a);
SV UInt4_setXWYZ(CTX ctx,const List<SV>&a);
SV UInt4_getYXZW(CTX ctx,const List<SV>&a);
SV UInt4_setYXZW(CTX ctx,const List<SV>&a);
SV UInt4_getYXWZ(CTX ctx,const List<SV>&a);
SV UInt4_setYXWZ(CTX ctx,const List<SV>&a);
SV UInt4_getYZXW(CTX ctx,const List<SV>&a);
SV UInt4_setYZXW(CTX ctx,const List<SV>&a);
SV UInt4_getYZWX(CTX ctx,const List<SV>&a);
SV UInt4_setYZWX(CTX ctx,const List<SV>&a);
SV UInt4_getYWZX(CTX ctx,const List<SV>&a);
SV UInt4_setYWZX(CTX ctx,const List<SV>&a);
SV UInt4_getYWXZ(CTX ctx,const List<SV>&a);
SV UInt4_setYWXZ(CTX ctx,const List<SV>&a);
SV UInt4_getZYXW(CTX ctx,const List<SV>&a);
SV UInt4_setZYXW(CTX ctx,const List<SV>&a);
SV UInt4_getZYWX(CTX ctx,const List<SV>&a);
SV UInt4_setZYWX(CTX ctx,const List<SV>&a);
SV UInt4_getZXYW(CTX ctx,const List<SV>&a);
SV UInt4_setZXYW(CTX ctx,const List<SV>&a);
SV UInt4_getZXWY(CTX ctx,const List<SV>&a);
SV UInt4_setZXWY(CTX ctx,const List<SV>&a);
SV UInt4_getZWXY(CTX ctx,const List<SV>&a);
SV UInt4_setZWXY(CTX ctx,const List<SV>&a);
SV UInt4_getZWYX(CTX ctx,const List<SV>&a);
SV UInt4_setZWYX(CTX ctx,const List<SV>&a);
SV UInt4_getWYZX(CTX ctx,const List<SV>&a);
SV UInt4_setWYZX(CTX ctx,const List<SV>&a);
SV UInt4_getWYXZ(CTX ctx,const List<SV>&a);
SV UInt4_setWYXZ(CTX ctx,const List<SV>&a);
SV UInt4_getWZYX(CTX ctx,const List<SV>&a);
SV UInt4_setWZYX(CTX ctx,const List<SV>&a);
SV UInt4_getWZXY(CTX ctx,const List<SV>&a);
SV UInt4_setWZXY(CTX ctx,const List<SV>&a);
SV UInt4_getWXZY(CTX ctx,const List<SV>&a);
SV UInt4_setWXZY(CTX ctx,const List<SV>&a);
SV UInt4_getWXYZ(CTX ctx,const List<SV>&a);
SV UInt4_setWXYZ(CTX ctx,const List<SV>&a);
void RayCastResult_destroy(CTX,NO);
SV RayCastResult_get_member(CTX,NO,SV);
void RayCastResult_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs RayCastResult_funcs={
.destroy = RayCastResult_destroy,
.getMember = RayCastResult_get_member,
.setMember = RayCastResult_set_member
};
template <>
struct create_val<RayCastResult>
{
static SV f(CTX ctx,const RayCastResult&obj)
{
#define ghfj RayCastResult
RET STG::createNativeObject(RayCastResult_funcs,NEW(ghfj, obj),EXT->RayCastResult_typeID);
}
};
template <>
struct val_to_c<RayCastResult>
{
static RayCastResult f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->RayCastResult_typeID)
RET*((RayCastResult*)obj->data);
else
 CATE(TE,"Value can not be converted to RayCastResult."));
} else
 CATE(TE,"Value can not be converted to RayCastResult."));
}
};

template <>
struct val_to_c<const RayCastResult>
{
static RayCastResult f(CTX ctx,const SV head) {return val_to_c<RayCastResult>::f(ctx, head);}
};

template <>
struct create_val<const RayCastResult>
{
static SV f(CTX ctx,const RayCastResult&obj) {return create_val<RayCastResult>::f(ctx,obj);}
};

template <>
struct type_same<RayCastResult>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RayCastResult_typeID;
else
 RET false;
}
};

SV RayCastResult_getRigidBody(CTX ctx,const List<SV>&a);
SV RayCastResult_getGhost(CTX ctx,const List<SV>&a);
SV RayCastResult___eq__(CTX ctx,const List<SV>&a);
void GfxLOD_destroy(CTX,NO);
SV GfxLOD_get_member(CTX,NO,SV);
void GfxLOD_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxLOD_funcs={
.destroy = GfxLOD_destroy,
.getMember = GfxLOD_get_member,
.setMember = GfxLOD_set_member
};
template <>
struct create_val<GfxLOD>
{
static SV f(CTX ctx,const GfxLOD&obj)
{
#define ghfj GfxLOD
RET STG::createNativeObject(GfxLOD_funcs,NEW(ghfj, obj),EXT->GfxLOD_typeID);
}
};
template <>
struct val_to_c<GfxLOD>
{
static GfxLOD f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxLOD_typeID)
RET*((GfxLOD*)obj->data);
else
 CATE(TE,"Value can not be converted to GfxLOD."));
} else
 CATE(TE,"Value can not be converted to GfxLOD."));
}
};

template <>
struct val_to_c<const GfxLOD>
{
static GfxLOD f(CTX ctx,const SV head) {return val_to_c<GfxLOD>::f(ctx, head);}
};

template <>
struct create_val<const GfxLOD>
{
static SV f(CTX ctx,const GfxLOD&obj) {return create_val<GfxLOD>::f(ctx,obj);}
};

template <>
struct type_same<GfxLOD>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxLOD_typeID;
else
 RET false;
}
};

SV GfxLOD___eq__(CTX ctx,const List<SV>&a);
void File_destroy(CTX,NO);
SV File_get_member(CTX,NO,SV);
void File_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs File_funcs={
.destroy = File_destroy,
.getMember = File_get_member,
.setMember = File_set_member
};
template <>
struct type_same<File>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->File_typeID;
else
 RET false;
}
};

SV File_read(CTX ctx,const List<SV>&a);
SV File_write(CTX ctx,const List<SV>&a);
SV File_seek(CTX ctx,const List<SV>&a);
SV File_tell(CTX ctx,const List<SV>&a);
SV File_flush(CTX ctx,const List<SV>&a);
SV File_isAtEndOfFile(CTX ctx,const List<SV>&a);
SV File_getSize(CTX ctx,const List<SV>&a);
SV File_readUInt8(CTX ctx,const List<SV>&a);
SV File_readInt8(CTX ctx,const List<SV>&a);
SV File_readUInt16LE(CTX ctx,const List<SV>&a);
SV File_readInt16LE(CTX ctx,const List<SV>&a);
SV File_readUInt32LE(CTX ctx,const List<SV>&a);
SV File_readInt32LE(CTX ctx,const List<SV>&a);
SV File_readUInt64LE(CTX ctx,const List<SV>&a);
SV File_readInt64LE(CTX ctx,const List<SV>&a);
SV File_readUInt16BE(CTX ctx,const List<SV>&a);
SV File_readInt16BE(CTX ctx,const List<SV>&a);
SV File_readUInt32BE(CTX ctx,const List<SV>&a);
SV File_readInt32BE(CTX ctx,const List<SV>&a);
SV File_readUInt64BE(CTX ctx,const List<SV>&a);
SV File_readInt64BE(CTX ctx,const List<SV>&a);
SV File_readFloat32(CTX ctx,const List<SV>&a);
SV File_readChar(CTX ctx,const List<SV>&a);
SV File_writeUInt8(CTX ctx,const List<SV>&a);
SV File_writeInt8(CTX ctx,const List<SV>&a);
SV File_writeUInt16LE(CTX ctx,const List<SV>&a);
SV File_writeInt16LE(CTX ctx,const List<SV>&a);
SV File_writeUInt32LE(CTX ctx,const List<SV>&a);
SV File_writeInt32LE(CTX ctx,const List<SV>&a);
SV File_writeUInt64LE(CTX ctx,const List<SV>&a);
SV File_writeInt64LE(CTX ctx,const List<SV>&a);
SV File_writeUInt16BE(CTX ctx,const List<SV>&a);
SV File_writeInt16BE(CTX ctx,const List<SV>&a);
SV File_writeUInt32BE(CTX ctx,const List<SV>&a);
SV File_writeInt32BE(CTX ctx,const List<SV>&a);
SV File_writeUInt64BE(CTX ctx,const List<SV>&a);
SV File_writeInt64BE(CTX ctx,const List<SV>&a);
SV File_writeFloat32(CTX ctx,const List<SV>&a);
SV File_printf(CTX ctx,const List<SV>&a);
SV File_vprintf(CTX ctx,const List<SV>&a);
SV File_writeChar(CTX ctx,const List<SV>&a);
void AABB_destroy(CTX,NO);
SV AABB_get_member(CTX,NO,SV);
void AABB_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs AABB_funcs={
.destroy = AABB_destroy,
.getMember = AABB_get_member,
.setMember = AABB_set_member
};
template <>
struct create_val<AABB>
{
static SV f(CTX ctx,const AABB&obj)
{
#define ghfj AABB
RET STG::createNativeObject(AABB_funcs,NEW(ghfj, obj),EXT->AABB_typeID);
}
};
template <>
struct val_to_c<AABB>
{
static AABB f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->AABB_typeID)
RET*((AABB*)obj->data);
else
 CATE(TE,"Value can not be converted to AABB."));
} else
 CATE(TE,"Value can not be converted to AABB."));
}
};

template <>
struct val_to_c<const AABB>
{
static AABB f(CTX ctx,const SV head) {return val_to_c<AABB>::f(ctx, head);}
};

template <>
struct create_val<const AABB>
{
static SV f(CTX ctx,const AABB&obj) {return create_val<AABB>::f(ctx,obj);}
};

template <>
struct type_same<AABB>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->AABB_typeID;
else
 RET false;
}
};

SV AABB_transform(CTX ctx,const List<SV>&a);
SV AABB_extend(CTX ctx,const List<SV>&a);
SV AABB_grow(CTX ctx,const List<SV>&a);
void RigidBodyConstructionInfo_destroy(CTX,NO);
SV RigidBodyConstructionInfo_get_member(CTX,NO,SV);
void RigidBodyConstructionInfo_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs RigidBodyConstructionInfo_funcs={
.destroy = RigidBodyConstructionInfo_destroy,
.getMember = RigidBodyConstructionInfo_get_member,
.setMember = RigidBodyConstructionInfo_set_member
};
template <>
struct create_val<RigidBodyConstructionInfo>
{
static SV f(CTX ctx,const RigidBodyConstructionInfo&obj)
{
#define ghfj RigidBodyConstructionInfo
RET STG::createNativeObject(RigidBodyConstructionInfo_funcs,NEW(ghfj, obj),EXT->RigidBodyConstructionInfo_typeID);
}
};
template <>
struct val_to_c<RigidBodyConstructionInfo>
{
static RigidBodyConstructionInfo f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->RigidBodyConstructionInfo_typeID)
RET*((RigidBodyConstructionInfo*)obj->data);
else
 CATE(TE,"Value can not be converted to RigidBodyConstructionInfo."));
} else
 CATE(TE,"Value can not be converted to RigidBodyConstructionInfo."));
}
};

template <>
struct val_to_c<const RigidBodyConstructionInfo>
{
static RigidBodyConstructionInfo f(CTX ctx,const SV head) {return val_to_c<RigidBodyConstructionInfo>::f(ctx, head);}
};

template <>
struct create_val<const RigidBodyConstructionInfo>
{
static SV f(CTX ctx,const RigidBodyConstructionInfo&obj) {return create_val<RigidBodyConstructionInfo>::f(ctx,obj);}
};

template <>
struct type_same<RigidBodyConstructionInfo>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RigidBodyConstructionInfo_typeID;
else
 RET false;
}
};

void List_destroy(CTX,NO);
SV List_get_member(CTX,NO,SV);
void List_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs List_funcs={
.destroy = List_destroy,
.getMember = List_get_member,
.setMember = List_set_member
};
template <>
struct create_val<List<scripting::Value*>>
{
static SV f(CTX ctx,const List<scripting::Value*>&obj)
{
#define ghfj List<scripting::Value*>
RET STG::createNativeObject(List_funcs,NEW(ghfj, obj),EXT->List_typeID);
}
};
template <>
struct val_to_c<List<scripting::Value*>>
{
static List<scripting::Value*> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->List_typeID)
RET*((List<scripting::Value*>*)obj->data);
else
 CATE(TE,"Value can not be converted to List."));
} else
 CATE(TE,"Value can not be converted to List."));
}
};

template <>
struct val_to_c<const List<scripting::Value*>>
{
static List<scripting::Value*> f(CTX ctx,const SV head) {return val_to_c<List<scripting::Value*>>::f(ctx, head);}
};

template <>
struct create_val<const List<scripting::Value*>>
{
static SV f(CTX ctx,const List<scripting::Value*>&obj) {return create_val<List<scripting::Value*>>::f(ctx,obj);}
};

template <>
struct type_same<List<scripting::Value*>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->List_typeID;
else
 RET false;
}
};

SV List___eq__(CTX ctx,const List<SV>&a);
SV List___neq__(CTX ctx,const List<SV>&a);
SV List_get(CTX ctx,const List<SV>&a);
SV List_set(CTX ctx,const List<SV>&a);
SV List_getCount(CTX ctx,const List<SV>&a);
SV List_getData(CTX ctx,const List<SV>&a);
SV List_append(CTX ctx,const List<SV>&a);
SV List_insert(CTX ctx,const List<SV>&a);
SV List_remove(CTX ctx,const List<SV>&a);
SV List_clear(CTX ctx,const List<SV>&a);
SV List_find(CTX ctx,const List<SV>&a);
SV List_copy(CTX ctx,const List<SV>&a);
SV List_in(CTX ctx,const List<SV>&a);
SV List_begin(CTX ctx,const List<SV>&a);
SV List_end(CTX ctx,const List<SV>&a);
void Audio_destroy(CTX,NO);
SV Audio_get_member(CTX,NO,SV);
void Audio_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Audio_funcs={
.destroy = Audio_destroy,
.getMember = Audio_get_member,
.setMember = Audio_set_member
};
template <>
struct type_same<Audio>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Audio_typeID;
else
 RET false;
}
};

SV Audio_removeContent(CTX ctx,const List<SV>&a);
SV Audio_changeSampleFrequency(CTX ctx,const List<SV>&a);
SV Audio_getNumSamples(CTX ctx,const List<SV>&a);
SV Audio_getSample(CTX ctx,const List<SV>&a);
SV Audio_getMonoSample(CTX ctx,const List<SV>&a);
SV Audio_setSample(CTX ctx,const List<SV>&a);
SV Audio_setMonoSample(CTX ctx,const List<SV>&a);
SV Audio_getDuration(CTX ctx,const List<SV>&a);
SV Audio_getSampleIndex(CTX ctx,const List<SV>&a);
SV Audio_load(CTX ctx,const List<SV>&a);
SV Audio_save(CTX ctx,const List<SV>&a);
SV Audio_copy(CTX ctx,const List<SV>&a);
SV Audio_getType(CTX ctx,const List<SV>&a);
SV Audio_release(CTX ctx,const List<SV>&a);
SV Audio_getRefCount(CTX ctx,const List<SV>&a);
SV Audio_getFilename(CTX ctx,const List<SV>&a);
SV Audio_setFilename(CTX ctx,const List<SV>&a);
void GfxTexture_destroy(CTX,NO);
SV GfxTexture_get_member(CTX,NO,SV);
void GfxTexture_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxTexture_funcs={
.destroy = GfxTexture_destroy,
.getMember = GfxTexture_get_member,
.setMember = GfxTexture_set_member
};
template <>
struct type_same<GfxTexture>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxTexture_typeID;
else
 RET false;
}
};

SV GfxTexture_removeContent(CTX ctx,const List<SV>&a);
SV GfxTexture_startCreation(CTX ctx,const List<SV>&a);
SV GfxTexture_allocMipmapFace(CTX ctx,const List<SV>&a);
SV GfxTexture_allocMipmap(CTX ctx,const List<SV>&a);
SV GfxTexture_getMipmapFace(CTX ctx,const List<SV>&a);
SV GfxTexture_getMipmap(CTX ctx,const List<SV>&a);
SV GfxTexture_generateMipmaps(CTX ctx,const List<SV>&a);
SV GfxTexture_getTextureType(CTX ctx,const List<SV>&a);
SV GfxTexture_shouldCompress(CTX ctx,const List<SV>&a);
SV GfxTexture_getMaximumAnisotropy(CTX ctx,const List<SV>&a);
SV GfxTexture_getMinFilter(CTX ctx,const List<SV>&a);
SV GfxTexture_getMagFilter(CTX ctx,const List<SV>&a);
SV GfxTexture_getMipmapMode(CTX ctx,const List<SV>&a);
SV GfxTexture_getWrapMode(CTX ctx,const List<SV>&a);
SV GfxTexture_getBaseWidth(CTX ctx,const List<SV>&a);
SV GfxTexture_getBaseHeight(CTX ctx,const List<SV>&a);
SV GfxTexture_getBaseDepth(CTX ctx,const List<SV>&a);
SV GfxTexture_getCompressionQuality(CTX ctx,const List<SV>&a);
SV GfxTexture_getPurpose(CTX ctx,const List<SV>&a);
SV GfxTexture_getFormat(CTX ctx,const List<SV>&a);
SV GfxTexture_getShadowmap(CTX ctx,const List<SV>&a);
SV GfxTexture_setMaximumAnisotropy(CTX ctx,const List<SV>&a);
SV GfxTexture_setMinFilter(CTX ctx,const List<SV>&a);
SV GfxTexture_setMagFilter(CTX ctx,const List<SV>&a);
SV GfxTexture_setMipmapMode(CTX ctx,const List<SV>&a);
SV GfxTexture_setWrapMode(CTX ctx,const List<SV>&a);
SV GfxTexture_setShadowmap(CTX ctx,const List<SV>&a);
SV GfxTexture_getImpl(CTX ctx,const List<SV>&a);
SV GfxTexture_save(CTX ctx,const List<SV>&a);
SV GfxTexture_load(CTX ctx,const List<SV>&a);
SV GfxTexture_copy(CTX ctx,const List<SV>&a);
SV GfxTexture_getType(CTX ctx,const List<SV>&a);
SV GfxTexture_release(CTX ctx,const List<SV>&a);
SV GfxTexture_getRefCount(CTX ctx,const List<SV>&a);
SV GfxTexture_getFilename(CTX ctx,const List<SV>&a);
SV GfxTexture_setFilename(CTX ctx,const List<SV>&a);
void GfxSubModelList_destroy(CTX,NO);
SV GfxSubModelList_get_member(CTX,NO,SV);
void GfxSubModelList_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxSubModelList_funcs={
.destroy = GfxSubModelList_destroy,
.getMember = GfxSubModelList_get_member,
.setMember = GfxSubModelList_set_member
};
template <>
struct create_val<List<GfxModel::SubModel>>
{
static SV f(CTX ctx,const List<GfxModel::SubModel>&obj)
{
#define ghfj List<GfxModel::SubModel>
RET STG::createNativeObject(GfxSubModelList_funcs,NEW(ghfj, obj),EXT->GfxSubModelList_typeID);
}
};
template <>
struct val_to_c<List<GfxModel::SubModel>>
{
static List<GfxModel::SubModel> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxSubModelList_typeID)
RET*((List<GfxModel::SubModel>*)obj->data);
else
 CATE(TE,"Value can not be converted to GfxSubModelList."));
} else
 CATE(TE,"Value can not be converted to GfxSubModelList."));
}
};

template <>
struct val_to_c<const List<GfxModel::SubModel>>
{
static List<GfxModel::SubModel> f(CTX ctx,const SV head) {return val_to_c<List<GfxModel::SubModel>>::f(ctx, head);}
};

template <>
struct create_val<const List<GfxModel::SubModel>>
{
static SV f(CTX ctx,const List<GfxModel::SubModel>&obj) {return create_val<List<GfxModel::SubModel>>::f(ctx,obj);}
};

template <>
struct type_same<List<GfxModel::SubModel>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxSubModelList_typeID;
else
 RET false;
}
};

SV GfxSubModelList___eq__(CTX ctx,const List<SV>&a);
SV GfxSubModelList___neq__(CTX ctx,const List<SV>&a);
SV GfxSubModelList_get(CTX ctx,const List<SV>&a);
SV GfxSubModelList_set(CTX ctx,const List<SV>&a);
SV GfxSubModelList_getCount(CTX ctx,const List<SV>&a);
SV GfxSubModelList_getData(CTX ctx,const List<SV>&a);
SV GfxSubModelList_append(CTX ctx,const List<SV>&a);
SV GfxSubModelList_insert(CTX ctx,const List<SV>&a);
SV GfxSubModelList_remove(CTX ctx,const List<SV>&a);
SV GfxSubModelList_clear(CTX ctx,const List<SV>&a);
SV GfxSubModelList_find(CTX ctx,const List<SV>&a);
SV GfxSubModelList_copy(CTX ctx,const List<SV>&a);
SV GfxSubModelList_in(CTX ctx,const List<SV>&a);
SV GfxSubModelList_begin(CTX ctx,const List<SV>&a);
SV GfxSubModelList_end(CTX ctx,const List<SV>&a);
void GfxModel_destroy(CTX,NO);
SV GfxModel_get_member(CTX,NO,SV);
void GfxModel_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxModel_funcs={
.destroy = GfxModel_destroy,
.getMember = GfxModel_get_member,
.setMember = GfxModel_set_member
};
template <>
struct type_same<GfxModel>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxModel_typeID;
else
 RET false;
}
};

SV GfxModel_removeContent(CTX ctx,const List<SV>&a);
SV GfxModel_save(CTX ctx,const List<SV>&a);
SV GfxModel_load(CTX ctx,const List<SV>&a);
SV GfxModel_copy(CTX ctx,const List<SV>&a);
SV GfxModel_getType(CTX ctx,const List<SV>&a);
SV GfxModel_release(CTX ctx,const List<SV>&a);
SV GfxModel_getRefCount(CTX ctx,const List<SV>&a);
SV GfxModel_getFilename(CTX ctx,const List<SV>&a);
SV GfxModel_setFilename(CTX ctx,const List<SV>&a);
void GfxLODList_destroy(CTX,NO);
SV GfxLODList_get_member(CTX,NO,SV);
void GfxLODList_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxLODList_funcs={
.destroy = GfxLODList_destroy,
.getMember = GfxLODList_get_member,
.setMember = GfxLODList_set_member
};
template <>
struct create_val<List<GfxLOD>>
{
static SV f(CTX ctx,const List<GfxLOD>&obj)
{
#define ghfj List<GfxLOD>
RET STG::createNativeObject(GfxLODList_funcs,NEW(ghfj, obj),EXT->GfxLODList_typeID);
}
};
template <>
struct val_to_c<List<GfxLOD>>
{
static List<GfxLOD> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxLODList_typeID)
RET*((List<GfxLOD>*)obj->data);
else
 CATE(TE,"Value can not be converted to GfxLODList."));
} else
 CATE(TE,"Value can not be converted to GfxLODList."));
}
};

template <>
struct val_to_c<const List<GfxLOD>>
{
static List<GfxLOD> f(CTX ctx,const SV head) {return val_to_c<List<GfxLOD>>::f(ctx, head);}
};

template <>
struct create_val<const List<GfxLOD>>
{
static SV f(CTX ctx,const List<GfxLOD>&obj) {return create_val<List<GfxLOD>>::f(ctx,obj);}
};

template <>
struct type_same<List<GfxLOD>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxLODList_typeID;
else
 RET false;
}
};

SV GfxLODList___eq__(CTX ctx,const List<SV>&a);
SV GfxLODList___neq__(CTX ctx,const List<SV>&a);
SV GfxLODList_get(CTX ctx,const List<SV>&a);
SV GfxLODList_set(CTX ctx,const List<SV>&a);
SV GfxLODList_getCount(CTX ctx,const List<SV>&a);
SV GfxLODList_getData(CTX ctx,const List<SV>&a);
SV GfxLODList_append(CTX ctx,const List<SV>&a);
SV GfxLODList_insert(CTX ctx,const List<SV>&a);
SV GfxLODList_remove(CTX ctx,const List<SV>&a);
SV GfxLODList_clear(CTX ctx,const List<SV>&a);
SV GfxLODList_find(CTX ctx,const List<SV>&a);
SV GfxLODList_copy(CTX ctx,const List<SV>&a);
SV GfxLODList_in(CTX ctx,const List<SV>&a);
SV GfxLODList_begin(CTX ctx,const List<SV>&a);
SV GfxLODList_end(CTX ctx,const List<SV>&a);
void EntityList_destroy(CTX,NO);
SV EntityList_get_member(CTX,NO,SV);
void EntityList_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs EntityList_funcs={
.destroy = EntityList_destroy,
.getMember = EntityList_get_member,
.setMember = EntityList_set_member
};
template <>
struct create_val<List<Entity*>>
{
static SV f(CTX ctx,const List<Entity*>&obj)
{
#define ghfj List<Entity*>
RET STG::createNativeObject(EntityList_funcs,NEW(ghfj, obj),EXT->EntityList_typeID);
}
};
template <>
struct val_to_c<List<Entity*>>
{
static List<Entity*> f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->EntityList_typeID)
RET*((List<Entity*>*)obj->data);
else
 CATE(TE,"Value can not be converted to EntityList."));
} else
 CATE(TE,"Value can not be converted to EntityList."));
}
};

template <>
struct val_to_c<const List<Entity*>>
{
static List<Entity*> f(CTX ctx,const SV head) {return val_to_c<List<Entity*>>::f(ctx, head);}
};

template <>
struct create_val<const List<Entity*>>
{
static SV f(CTX ctx,const List<Entity*>&obj) {return create_val<List<Entity*>>::f(ctx,obj);}
};

template <>
struct type_same<List<Entity*>>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->EntityList_typeID;
else
 RET false;
}
};

SV EntityList___eq__(CTX ctx,const List<SV>&a);
SV EntityList___neq__(CTX ctx,const List<SV>&a);
SV EntityList_get(CTX ctx,const List<SV>&a);
SV EntityList_set(CTX ctx,const List<SV>&a);
SV EntityList_getCount(CTX ctx,const List<SV>&a);
SV EntityList_getData(CTX ctx,const List<SV>&a);
SV EntityList_append(CTX ctx,const List<SV>&a);
SV EntityList_insert(CTX ctx,const List<SV>&a);
SV EntityList_remove(CTX ctx,const List<SV>&a);
SV EntityList_clear(CTX ctx,const List<SV>&a);
SV EntityList_find(CTX ctx,const List<SV>&a);
SV EntityList_copy(CTX ctx,const List<SV>&a);
SV EntityList_in(CTX ctx,const List<SV>&a);
SV EntityList_begin(CTX ctx,const List<SV>&a);
SV EntityList_end(CTX ctx,const List<SV>&a);
void GfxShaderCombination_destroy(CTX,NO);
SV GfxShaderCombination_get_member(CTX,NO,SV);
void GfxShaderCombination_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxShaderCombination_funcs={
.destroy = GfxShaderCombination_destroy,
.getMember = GfxShaderCombination_get_member,
.setMember = GfxShaderCombination_set_member
};
template <>
struct type_same<GfxShaderCombination>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxShaderCombination_typeID;
else
 RET false;
}
};

SV GfxShaderCombination_setDefine(CTX ctx,const List<SV>&a);
SV GfxShaderCombination_getDefine(CTX ctx,const List<SV>&a);
SV GfxShaderCombination_removeDefine(CTX ctx,const List<SV>&a);
SV GfxShaderCombination_getShader(CTX ctx,const List<SV>&a);
SV GfxShaderCombination_setShader(CTX ctx,const List<SV>&a);
SV GfxShaderCombination_getCompiled(CTX ctx,const List<SV>&a);
void Matrix3x3_destroy(CTX,NO);
SV Matrix3x3_get_member(CTX,NO,SV);
void Matrix3x3_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Matrix3x3_funcs={
.destroy = Matrix3x3_destroy,
.getMember = Matrix3x3_get_member,
.setMember = Matrix3x3_set_member
};
template <>
struct create_val<Matrix3x3>
{
static SV f(CTX ctx,const Matrix3x3&obj)
{
#define ghfj Matrix3x3
RET STG::createNativeObject(Matrix3x3_funcs,NEW(ghfj, obj),EXT->Matrix3x3_typeID);
}
};
template <>
struct val_to_c<Matrix3x3>
{
static Matrix3x3 f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Matrix3x3_typeID)
RET*((Matrix3x3*)obj->data);
else
 CATE(TE,"Value can not be converted to Matrix3x3."));
} else
 CATE(TE,"Value can not be converted to Matrix3x3."));
}
};

template <>
struct val_to_c<const Matrix3x3>
{
static Matrix3x3 f(CTX ctx,const SV head) {return val_to_c<Matrix3x3>::f(ctx, head);}
};

template <>
struct create_val<const Matrix3x3>
{
static SV f(CTX ctx,const Matrix3x3&obj) {return create_val<Matrix3x3>::f(ctx,obj);}
};

template <>
struct type_same<Matrix3x3>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Matrix3x3_typeID;
else
 RET false;
}
};

SV Matrix3x3___mul__(CTX ctx,const List<SV>&a);
SV Matrix3x3___div__(CTX ctx,const List<SV>&a);
SV Matrix3x3_get(CTX ctx,const List<SV>&a);
SV Matrix3x3_set(CTX ctx,const List<SV>&a);
SV Matrix3x3___eq__(CTX ctx,const List<SV>&a);
SV Matrix3x3_transpose(CTX ctx,const List<SV>&a);
SV Matrix3x3_inverse(CTX ctx,const List<SV>&a);
SV Matrix3x3_translate(CTX ctx,const List<SV>&a);
SV Matrix3x3_scale(CTX ctx,const List<SV>&a);
SV Matrix3x3_rotate(CTX ctx,const List<SV>&a);
SV Matrix3x3_rotatex(CTX ctx,const List<SV>&a);
SV Matrix3x3_rotatey(CTX ctx,const List<SV>&a);
SV Matrix3x3_rotatez(CTX ctx,const List<SV>&a);
void GfxDebugDrawer_destroy(CTX,NO);
SV GfxDebugDrawer_get_member(CTX,NO,SV);
void GfxDebugDrawer_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxDebugDrawer_funcs={
.destroy = GfxDebugDrawer_destroy,
.getMember = GfxDebugDrawer_get_member,
.setMember = GfxDebugDrawer_set_member
};
template <>
struct type_same<GfxDebugDrawer>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxDebugDrawer_typeID;
else
 RET false;
}
};

SV GfxDebugDrawer_addLine(CTX ctx,const List<SV>&a);
SV GfxDebugDrawer_render(CTX ctx,const List<SV>&a);
SV GhostObject_ptr_copy(CTX,NO);
void GhostObject_ptr_destroy(CTX,NO);
SV GhostObject_ptr_get_member(CTX,NO,SV);
void GhostObject_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GhostObject_ptr_funcs={
.destroy = GhostObject_ptr_destroy,
.getMember = GhostObject_ptr_get_member,
.setMember = GhostObject_ptr_set_member
};
template <>
struct create_val<GhostObject *>
{
static SV f(CTX ctx,GhostObject*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GhostObject_ptr_funcs,obj,EXT->GhostObject_ptr_typeID);
}
};
template <>
struct val_to_c<GhostObject *>
{
static GhostObject *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GhostObject_ptr_typeID)
RET(GhostObject*)obj->data;
else
 CATE(TE,"Value is not a GhostObjectRef."));
} else
 CATE(TE,"Value is not a GhostObjectRef."));
}
};
template <>
struct type_same<GhostObject *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GhostObject_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GhostObject *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GhostObject_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GhostObject *>
{
static const GhostObject *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GhostObject_ptr_typeID)
RET(GhostObject*)obj->data;
else
 CATE(TE,"Value is not a GhostObjectRef."));
} else
 CATE(TE,"Value is not a GhostObjectRef."));
}
};

SV Filesystem_ptr_copy(CTX,NO);
void Filesystem_ptr_destroy(CTX,NO);
SV Filesystem_ptr_get_member(CTX,NO,SV);
void Filesystem_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Filesystem_ptr_funcs={
.destroy = Filesystem_ptr_destroy,
.getMember = Filesystem_ptr_get_member,
.setMember = Filesystem_ptr_set_member
};
template <>
struct create_val<Filesystem *>
{
static SV f(CTX ctx,Filesystem*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Filesystem_ptr_funcs,obj,EXT->Filesystem_ptr_typeID);
}
};
template <>
struct val_to_c<Filesystem *>
{
static Filesystem *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Filesystem_ptr_typeID)
RET(Filesystem*)obj->data;
else
 CATE(TE,"Value is not a FilesystemRef."));
} else
 CATE(TE,"Value is not a FilesystemRef."));
}
};
template <>
struct type_same<Filesystem *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Filesystem_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Filesystem *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Filesystem_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Filesystem *>
{
static const Filesystem *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Filesystem_ptr_typeID)
RET(Filesystem*)obj->data;
else
 CATE(TE,"Value is not a FilesystemRef."));
} else
 CATE(TE,"Value is not a FilesystemRef."));
}
};

SV StrStrMap_ptr_copy(CTX,NO);
void StrStrMap_ptr_destroy(CTX,NO);
SV StrStrMap_ptr_get_member(CTX,NO,SV);
void StrStrMap_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs StrStrMap_ptr_funcs={
.destroy = StrStrMap_ptr_destroy,
.getMember = StrStrMap_ptr_get_member,
.setMember = StrStrMap_ptr_set_member
};
template <>
struct create_val<HashMap<String,String> *>
{
static SV f(CTX ctx,HashMap<String,String>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(StrStrMap_ptr_funcs,obj,EXT->StrStrMap_ptr_typeID);
}
};
template <>
struct val_to_c<HashMap<String,String> *>
{
static HashMap<String,String> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->StrStrMap_ptr_typeID)
RET(HashMap<String,String>*)obj->data;
else
 CATE(TE,"Value is not a StrStrMapRef."));
} else
 CATE(TE,"Value is not a StrStrMapRef."));
}
};
template <>
struct type_same<HashMap<String,String> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->StrStrMap_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const HashMap<String,String> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->StrStrMap_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const HashMap<String,String> *>
{
static const HashMap<String,String> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->StrStrMap_ptr_typeID)
RET(HashMap<String,String>*)obj->data;
else
 CATE(TE,"Value is not a StrStrMapRef."));
} else
 CATE(TE,"Value is not a StrStrMapRef."));
}
};

SV GfxApi_ptr_copy(CTX,NO);
void GfxApi_ptr_destroy(CTX,NO);
SV GfxApi_ptr_get_member(CTX,NO,SV);
void GfxApi_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxApi_ptr_funcs={
.destroy = GfxApi_ptr_destroy,
.getMember = GfxApi_ptr_get_member,
.setMember = GfxApi_ptr_set_member
};
template <>
struct create_val<GfxApi *>
{
static SV f(CTX ctx,GfxApi*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxApi_ptr_funcs,obj,EXT->GfxApi_ptr_typeID);
}
};
template <>
struct val_to_c<GfxApi *>
{
static GfxApi *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxApi_ptr_typeID)
RET(GfxApi*)obj->data;
else
 CATE(TE,"Value is not a GfxApiRef."));
} else
 CATE(TE,"Value is not a GfxApiRef."));
}
};
template <>
struct type_same<GfxApi *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxApi_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxApi *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxApi_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxApi *>
{
static const GfxApi *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxApi_ptr_typeID)
RET(GfxApi*)obj->data;
else
 CATE(TE,"Value is not a GfxApiRef."));
} else
 CATE(TE,"Value is not a GfxApiRef."));
}
};

SV GfxCompiledShader_ptr_copy(CTX,NO);
void GfxCompiledShader_ptr_destroy(CTX,NO);
SV GfxCompiledShader_ptr_get_member(CTX,NO,SV);
void GfxCompiledShader_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxCompiledShader_ptr_funcs={
.destroy = GfxCompiledShader_ptr_destroy,
.getMember = GfxCompiledShader_ptr_get_member,
.setMember = GfxCompiledShader_ptr_set_member
};
template <>
struct create_val<GfxCompiledShader *>
{
static SV f(CTX ctx,GfxCompiledShader*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxCompiledShader_ptr_funcs,obj,EXT->GfxCompiledShader_ptr_typeID);
}
};
template <>
struct val_to_c<GfxCompiledShader *>
{
static GfxCompiledShader *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxCompiledShader_ptr_typeID)
RET(GfxCompiledShader*)obj->data;
else
 CATE(TE,"Value is not a GfxCompiledShaderRef."));
} else
 CATE(TE,"Value is not a GfxCompiledShaderRef."));
}
};
template <>
struct type_same<GfxCompiledShader *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxCompiledShader_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxCompiledShader *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxCompiledShader_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxCompiledShader *>
{
static const GfxCompiledShader *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxCompiledShader_ptr_typeID)
RET(GfxCompiledShader*)obj->data;
else
 CATE(TE,"Value is not a GfxCompiledShaderRef."));
} else
 CATE(TE,"Value is not a GfxCompiledShaderRef."));
}
};

SV ScrollBar_ptr_copy(CTX,NO);
void ScrollBar_ptr_destroy(CTX,NO);
SV ScrollBar_ptr_get_member(CTX,NO,SV);
void ScrollBar_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs ScrollBar_ptr_funcs={
.destroy = ScrollBar_ptr_destroy,
.getMember = ScrollBar_ptr_get_member,
.setMember = ScrollBar_ptr_set_member
};
template <>
struct create_val<ScrollBar *>
{
static SV f(CTX ctx,ScrollBar*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(ScrollBar_ptr_funcs,obj,EXT->ScrollBar_ptr_typeID);
}
};
template <>
struct val_to_c<ScrollBar *>
{
static ScrollBar *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->ScrollBar_ptr_typeID)
RET(ScrollBar*)obj->data;
else
 CATE(TE,"Value is not a ScrollBarRef."));
} else
 CATE(TE,"Value is not a ScrollBarRef."));
}
};
template <>
struct type_same<ScrollBar *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->ScrollBar_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const ScrollBar *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->ScrollBar_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const ScrollBar *>
{
static const ScrollBar *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->ScrollBar_ptr_typeID)
RET(ScrollBar*)obj->data;
else
 CATE(TE,"Value is not a ScrollBarRef."));
} else
 CATE(TE,"Value is not a ScrollBarRef."));
}
};

SV GhostObjList_ptr_copy(CTX,NO);
void GhostObjList_ptr_destroy(CTX,NO);
SV GhostObjList_ptr_get_member(CTX,NO,SV);
void GhostObjList_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GhostObjList_ptr_funcs={
.destroy = GhostObjList_ptr_destroy,
.getMember = GhostObjList_ptr_get_member,
.setMember = GhostObjList_ptr_set_member
};
template <>
struct create_val<List<GhostObject*> *>
{
static SV f(CTX ctx,List<GhostObject*>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GhostObjList_ptr_funcs,obj,EXT->GhostObjList_ptr_typeID);
}
};
template <>
struct val_to_c<List<GhostObject*> *>
{
static List<GhostObject*> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GhostObjList_ptr_typeID)
RET(List<GhostObject*>*)obj->data;
else
 CATE(TE,"Value is not a GhostObjListRef."));
} else
 CATE(TE,"Value is not a GhostObjListRef."));
}
};
template <>
struct type_same<List<GhostObject*> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GhostObjList_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<GhostObject*> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GhostObjList_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<GhostObject*> *>
{
static const List<GhostObject*> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GhostObjList_ptr_typeID)
RET(List<GhostObject*>*)obj->data;
else
 CATE(TE,"Value is not a GhostObjListRef."));
} else
 CATE(TE,"Value is not a GhostObjListRef."));
}
};

SV GPUTimer_ptr_copy(CTX,NO);
void GPUTimer_ptr_destroy(CTX,NO);
SV GPUTimer_ptr_get_member(CTX,NO,SV);
void GPUTimer_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GPUTimer_ptr_funcs={
.destroy = GPUTimer_ptr_destroy,
.getMember = GPUTimer_ptr_get_member,
.setMember = GPUTimer_ptr_set_member
};
template <>
struct create_val<GPUTimer *>
{
static SV f(CTX ctx,GPUTimer*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GPUTimer_ptr_funcs,obj,EXT->GPUTimer_ptr_typeID);
}
};
template <>
struct val_to_c<GPUTimer *>
{
static GPUTimer *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GPUTimer_ptr_typeID)
RET(GPUTimer*)obj->data;
else
 CATE(TE,"Value is not a GPUTimerRef."));
} else
 CATE(TE,"Value is not a GPUTimerRef."));
}
};
template <>
struct type_same<GPUTimer *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GPUTimer_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GPUTimer *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GPUTimer_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GPUTimer *>
{
static const GPUTimer *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GPUTimer_ptr_typeID)
RET(GPUTimer*)obj->data;
else
 CATE(TE,"Value is not a GPUTimerRef."));
} else
 CATE(TE,"Value is not a GPUTimerRef."));
}
};

SV RigidBody_ptr_copy(CTX,NO);
void RigidBody_ptr_destroy(CTX,NO);
SV RigidBody_ptr_get_member(CTX,NO,SV);
void RigidBody_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs RigidBody_ptr_funcs={
.destroy = RigidBody_ptr_destroy,
.getMember = RigidBody_ptr_get_member,
.setMember = RigidBody_ptr_set_member
};
template <>
struct create_val<RigidBody *>
{
static SV f(CTX ctx,RigidBody*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(RigidBody_ptr_funcs,obj,EXT->RigidBody_ptr_typeID);
}
};
template <>
struct val_to_c<RigidBody *>
{
static RigidBody *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->RigidBody_ptr_typeID)
RET(RigidBody*)obj->data;
else
 CATE(TE,"Value is not a RigidBodyRef."));
} else
 CATE(TE,"Value is not a RigidBodyRef."));
}
};
template <>
struct type_same<RigidBody *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RigidBody_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const RigidBody *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RigidBody_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const RigidBody *>
{
static const RigidBody *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->RigidBody_ptr_typeID)
RET(RigidBody*)obj->data;
else
 CATE(TE,"Value is not a RigidBodyRef."));
} else
 CATE(TE,"Value is not a RigidBodyRef."));
}
};

SV UInt2_ptr_copy(CTX,NO);
void UInt2_ptr_destroy(CTX,NO);
SV UInt2_ptr_get_member(CTX,NO,SV);
void UInt2_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs UInt2_ptr_funcs={
.destroy = UInt2_ptr_destroy,
.getMember = UInt2_ptr_get_member,
.setMember = UInt2_ptr_set_member
};
template <>
struct create_val<T2<uint32_t> *>
{
static SV f(CTX ctx,T2<uint32_t>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(UInt2_ptr_funcs,obj,EXT->UInt2_ptr_typeID);
}
};
template <>
struct val_to_c<T2<uint32_t> *>
{
static T2<uint32_t> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->UInt2_ptr_typeID)
RET(T2<uint32_t>*)obj->data;
else
 CATE(TE,"Value is not a UInt2Ref."));
} else
 CATE(TE,"Value is not a UInt2Ref."));
}
};
template <>
struct type_same<T2<uint32_t> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->UInt2_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T2<uint32_t> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->UInt2_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T2<uint32_t> *>
{
static const T2<uint32_t> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->UInt2_ptr_typeID)
RET(T2<uint32_t>*)obj->data;
else
 CATE(TE,"Value is not a UInt2Ref."));
} else
 CATE(TE,"Value is not a UInt2Ref."));
}
};

SV LightList_ptr_copy(CTX,NO);
void LightList_ptr_destroy(CTX,NO);
SV LightList_ptr_get_member(CTX,NO,SV);
void LightList_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs LightList_ptr_funcs={
.destroy = LightList_ptr_destroy,
.getMember = LightList_ptr_get_member,
.setMember = LightList_ptr_set_member
};
template <>
struct create_val<List<Light*> *>
{
static SV f(CTX ctx,List<Light*>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(LightList_ptr_funcs,obj,EXT->LightList_ptr_typeID);
}
};
template <>
struct val_to_c<List<Light*> *>
{
static List<Light*> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->LightList_ptr_typeID)
RET(List<Light*>*)obj->data;
else
 CATE(TE,"Value is not a LightListRef."));
} else
 CATE(TE,"Value is not a LightListRef."));
}
};
template <>
struct type_same<List<Light*> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->LightList_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<Light*> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->LightList_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<Light*> *>
{
static const List<Light*> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->LightList_ptr_typeID)
RET(List<Light*>*)obj->data;
else
 CATE(TE,"Value is not a LightListRef."));
} else
 CATE(TE,"Value is not a LightListRef."));
}
};

SV ResourceManager_ptr_copy(CTX,NO);
void ResourceManager_ptr_destroy(CTX,NO);
SV ResourceManager_ptr_get_member(CTX,NO,SV);
void ResourceManager_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs ResourceManager_ptr_funcs={
.destroy = ResourceManager_ptr_destroy,
.getMember = ResourceManager_ptr_get_member,
.setMember = ResourceManager_ptr_set_member
};
template <>
struct create_val<ResourceManager *>
{
static SV f(CTX ctx,ResourceManager*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(ResourceManager_ptr_funcs,obj,EXT->ResourceManager_ptr_typeID);
}
};
template <>
struct val_to_c<ResourceManager *>
{
static ResourceManager *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->ResourceManager_ptr_typeID)
RET(ResourceManager*)obj->data;
else
 CATE(TE,"Value is not a ResourceManagerRef."));
} else
 CATE(TE,"Value is not a ResourceManagerRef."));
}
};
template <>
struct type_same<ResourceManager *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->ResourceManager_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const ResourceManager *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->ResourceManager_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const ResourceManager *>
{
static const ResourceManager *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->ResourceManager_ptr_typeID)
RET(ResourceManager*)obj->data;
else
 CATE(TE,"Value is not a ResourceManagerRef."));
} else
 CATE(TE,"Value is not a ResourceManagerRef."));
}
};

SV Entity_ptr_copy(CTX,NO);
void Entity_ptr_destroy(CTX,NO);
SV Entity_ptr_get_member(CTX,NO,SV);
void Entity_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Entity_ptr_funcs={
.destroy = Entity_ptr_destroy,
.getMember = Entity_ptr_get_member,
.setMember = Entity_ptr_set_member
};
template <>
struct create_val<Entity *>
{
static SV f(CTX ctx,Entity*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Entity_ptr_funcs,obj,EXT->Entity_ptr_typeID);
}
};
template <>
struct val_to_c<Entity *>
{
static Entity *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Entity_ptr_typeID)
RET(Entity*)obj->data;
else
 CATE(TE,"Value is not a EntityRef."));
} else
 CATE(TE,"Value is not a EntityRef."));
}
};
template <>
struct type_same<Entity *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Entity_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Entity *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Entity_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Entity *>
{
static const Entity *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Entity_ptr_typeID)
RET(Entity*)obj->data;
else
 CATE(TE,"Value is not a EntityRef."));
} else
 CATE(TE,"Value is not a EntityRef."));
}
};

SV GfxRenderer_ptr_copy(CTX,NO);
void GfxRenderer_ptr_destroy(CTX,NO);
SV GfxRenderer_ptr_get_member(CTX,NO,SV);
void GfxRenderer_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxRenderer_ptr_funcs={
.destroy = GfxRenderer_ptr_destroy,
.getMember = GfxRenderer_ptr_get_member,
.setMember = GfxRenderer_ptr_set_member
};
template <>
struct create_val<GfxRenderer *>
{
static SV f(CTX ctx,GfxRenderer*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxRenderer_ptr_funcs,obj,EXT->GfxRenderer_ptr_typeID);
}
};
template <>
struct val_to_c<GfxRenderer *>
{
static GfxRenderer *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxRenderer_ptr_typeID)
RET(GfxRenderer*)obj->data;
else
 CATE(TE,"Value is not a GfxRendererRef."));
} else
 CATE(TE,"Value is not a GfxRendererRef."));
}
};
template <>
struct type_same<GfxRenderer *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxRenderer_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxRenderer *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxRenderer_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxRenderer *>
{
static const GfxRenderer *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxRenderer_ptr_typeID)
RET(GfxRenderer*)obj->data;
else
 CATE(TE,"Value is not a GfxRendererRef."));
} else
 CATE(TE,"Value is not a GfxRendererRef."));
}
};

SV Float2_ptr_copy(CTX,NO);
void Float2_ptr_destroy(CTX,NO);
SV Float2_ptr_get_member(CTX,NO,SV);
void Float2_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Float2_ptr_funcs={
.destroy = Float2_ptr_destroy,
.getMember = Float2_ptr_get_member,
.setMember = Float2_ptr_set_member
};
template <>
struct create_val<T2<float> *>
{
static SV f(CTX ctx,T2<float>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Float2_ptr_funcs,obj,EXT->Float2_ptr_typeID);
}
};
template <>
struct val_to_c<T2<float> *>
{
static T2<float> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Float2_ptr_typeID)
RET(T2<float>*)obj->data;
else
 CATE(TE,"Value is not a Float2Ref."));
} else
 CATE(TE,"Value is not a Float2Ref."));
}
};
template <>
struct type_same<T2<float> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Float2_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T2<float> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Float2_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T2<float> *>
{
static const T2<float> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Float2_ptr_typeID)
RET(T2<float>*)obj->data;
else
 CATE(TE,"Value is not a Float2Ref."));
} else
 CATE(TE,"Value is not a Float2Ref."));
}
};

SV GfxFramebuffer_ptr_copy(CTX,NO);
void GfxFramebuffer_ptr_destroy(CTX,NO);
SV GfxFramebuffer_ptr_get_member(CTX,NO,SV);
void GfxFramebuffer_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxFramebuffer_ptr_funcs={
.destroy = GfxFramebuffer_ptr_destroy,
.getMember = GfxFramebuffer_ptr_get_member,
.setMember = GfxFramebuffer_ptr_set_member
};
template <>
struct create_val<GfxFramebuffer *>
{
static SV f(CTX ctx,GfxFramebuffer*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxFramebuffer_ptr_funcs,obj,EXT->GfxFramebuffer_ptr_typeID);
}
};
template <>
struct val_to_c<GfxFramebuffer *>
{
static GfxFramebuffer *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxFramebuffer_ptr_typeID)
RET(GfxFramebuffer*)obj->data;
else
 CATE(TE,"Value is not a GfxFramebufferRef."));
} else
 CATE(TE,"Value is not a GfxFramebufferRef."));
}
};
template <>
struct type_same<GfxFramebuffer *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxFramebuffer_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxFramebuffer *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxFramebuffer_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxFramebuffer *>
{
static const GfxFramebuffer *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxFramebuffer_ptr_typeID)
RET(GfxFramebuffer*)obj->data;
else
 CATE(TE,"Value is not a GfxFramebufferRef."));
} else
 CATE(TE,"Value is not a GfxFramebufferRef."));
}
};

SV Font_ptr_copy(CTX,NO);
void Font_ptr_destroy(CTX,NO);
SV Font_ptr_get_member(CTX,NO,SV);
void Font_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Font_ptr_funcs={
.destroy = Font_ptr_destroy,
.getMember = Font_ptr_get_member,
.setMember = Font_ptr_set_member
};
template <>
struct create_val<Font *>
{
static SV f(CTX ctx,Font*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Font_ptr_funcs,obj,EXT->Font_ptr_typeID);
}
};
template <>
struct val_to_c<Font *>
{
static Font *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Font_ptr_typeID)
RET(Font*)obj->data;
else
 CATE(TE,"Value is not a FontRef."));
} else
 CATE(TE,"Value is not a FontRef."));
}
};
template <>
struct type_same<Font *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Font_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Font *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Font_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Font *>
{
static const Font *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Font_ptr_typeID)
RET(Font*)obj->data;
else
 CATE(TE,"Value is not a FontRef."));
} else
 CATE(TE,"Value is not a FontRef."));
}
};

SV Event_ptr_copy(CTX,NO);
void Event_ptr_destroy(CTX,NO);
SV Event_ptr_get_member(CTX,NO,SV);
void Event_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Event_ptr_funcs={
.destroy = Event_ptr_destroy,
.getMember = Event_ptr_get_member,
.setMember = Event_ptr_set_member
};
template <>
struct create_val<Event *>
{
static SV f(CTX ctx,Event*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Event_ptr_funcs,obj,EXT->Event_ptr_typeID);
}
};
template <>
struct val_to_c<Event *>
{
static Event *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Event_ptr_typeID)
RET(Event*)obj->data;
else
 CATE(TE,"Value is not a EventRef."));
} else
 CATE(TE,"Value is not a EventRef."));
}
};
template <>
struct type_same<Event *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Event_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Event *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Event_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Event *>
{
static const Event *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Event_ptr_typeID)
RET(Event*)obj->data;
else
 CATE(TE,"Value is not a EventRef."));
} else
 CATE(TE,"Value is not a EventRef."));
}
};

SV PhysicsWorld_ptr_copy(CTX,NO);
void PhysicsWorld_ptr_destroy(CTX,NO);
SV PhysicsWorld_ptr_get_member(CTX,NO,SV);
void PhysicsWorld_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs PhysicsWorld_ptr_funcs={
.destroy = PhysicsWorld_ptr_destroy,
.getMember = PhysicsWorld_ptr_get_member,
.setMember = PhysicsWorld_ptr_set_member
};
template <>
struct create_val<PhysicsWorld *>
{
static SV f(CTX ctx,PhysicsWorld*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(PhysicsWorld_ptr_funcs,obj,EXT->PhysicsWorld_ptr_typeID);
}
};
template <>
struct val_to_c<PhysicsWorld *>
{
static PhysicsWorld *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->PhysicsWorld_ptr_typeID)
RET(PhysicsWorld*)obj->data;
else
 CATE(TE,"Value is not a PhysicsWorldRef."));
} else
 CATE(TE,"Value is not a PhysicsWorldRef."));
}
};
template <>
struct type_same<PhysicsWorld *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->PhysicsWorld_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const PhysicsWorld *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->PhysicsWorld_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const PhysicsWorld *>
{
static const PhysicsWorld *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->PhysicsWorld_ptr_typeID)
RET(PhysicsWorld*)obj->data;
else
 CATE(TE,"Value is not a PhysicsWorldRef."));
} else
 CATE(TE,"Value is not a PhysicsWorldRef."));
}
};

SV Stats_ptr_copy(CTX,NO);
void Stats_ptr_destroy(CTX,NO);
SV Stats_ptr_get_member(CTX,NO,SV);
void Stats_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Stats_ptr_funcs={
.destroy = Stats_ptr_destroy,
.getMember = Stats_ptr_get_member,
.setMember = Stats_ptr_set_member
};
template <>
struct create_val<Stats *>
{
static SV f(CTX ctx,Stats*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Stats_ptr_funcs,obj,EXT->Stats_ptr_typeID);
}
};
template <>
struct val_to_c<Stats *>
{
static Stats *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Stats_ptr_typeID)
RET(Stats*)obj->data;
else
 CATE(TE,"Value is not a StatsRef."));
} else
 CATE(TE,"Value is not a StatsRef."));
}
};
template <>
struct type_same<Stats *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Stats_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Stats *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Stats_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Stats *>
{
static const Stats *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Stats_ptr_typeID)
RET(Stats*)obj->data;
else
 CATE(TE,"Value is not a StatsRef."));
} else
 CATE(TE,"Value is not a StatsRef."));
}
};

SV AudioSource_ptr_copy(CTX,NO);
void AudioSource_ptr_destroy(CTX,NO);
SV AudioSource_ptr_get_member(CTX,NO,SV);
void AudioSource_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs AudioSource_ptr_funcs={
.destroy = AudioSource_ptr_destroy,
.getMember = AudioSource_ptr_get_member,
.setMember = AudioSource_ptr_set_member
};
template <>
struct create_val<AudioSource *>
{
static SV f(CTX ctx,AudioSource*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(AudioSource_ptr_funcs,obj,EXT->AudioSource_ptr_typeID);
}
};
template <>
struct val_to_c<AudioSource *>
{
static AudioSource *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->AudioSource_ptr_typeID)
RET(AudioSource*)obj->data;
else
 CATE(TE,"Value is not a AudioSourceRef."));
} else
 CATE(TE,"Value is not a AudioSourceRef."));
}
};
template <>
struct type_same<AudioSource *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->AudioSource_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const AudioSource *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->AudioSource_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const AudioSource *>
{
static const AudioSource *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->AudioSource_ptr_typeID)
RET(AudioSource*)obj->data;
else
 CATE(TE,"Value is not a AudioSourceRef."));
} else
 CATE(TE,"Value is not a AudioSourceRef."));
}
};

SV RayCastResultList_ptr_copy(CTX,NO);
void RayCastResultList_ptr_destroy(CTX,NO);
SV RayCastResultList_ptr_get_member(CTX,NO,SV);
void RayCastResultList_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs RayCastResultList_ptr_funcs={
.destroy = RayCastResultList_ptr_destroy,
.getMember = RayCastResultList_ptr_get_member,
.setMember = RayCastResultList_ptr_set_member
};
template <>
struct create_val<List<RayCastResult> *>
{
static SV f(CTX ctx,List<RayCastResult>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(RayCastResultList_ptr_funcs,obj,EXT->RayCastResultList_ptr_typeID);
}
};
template <>
struct val_to_c<List<RayCastResult> *>
{
static List<RayCastResult> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->RayCastResultList_ptr_typeID)
RET(List<RayCastResult>*)obj->data;
else
 CATE(TE,"Value is not a RayCastResultListRef."));
} else
 CATE(TE,"Value is not a RayCastResultListRef."));
}
};
template <>
struct type_same<List<RayCastResult> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RayCastResultList_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<RayCastResult> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RayCastResultList_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<RayCastResult> *>
{
static const List<RayCastResult> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->RayCastResultList_ptr_typeID)
RET(List<RayCastResult>*)obj->data;
else
 CATE(TE,"Value is not a RayCastResultListRef."));
} else
 CATE(TE,"Value is not a RayCastResultListRef."));
}
};

SV Platform_ptr_copy(CTX,NO);
void Platform_ptr_destroy(CTX,NO);
SV Platform_ptr_get_member(CTX,NO,SV);
void Platform_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Platform_ptr_funcs={
.destroy = Platform_ptr_destroy,
.getMember = Platform_ptr_get_member,
.setMember = Platform_ptr_set_member
};
template <>
struct create_val<Platform *>
{
static SV f(CTX ctx,Platform*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Platform_ptr_funcs,obj,EXT->Platform_ptr_typeID);
}
};
template <>
struct val_to_c<Platform *>
{
static Platform *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Platform_ptr_typeID)
RET(Platform*)obj->data;
else
 CATE(TE,"Value is not a PlatformRef."));
} else
 CATE(TE,"Value is not a PlatformRef."));
}
};
template <>
struct type_same<Platform *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Platform_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Platform *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Platform_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Platform *>
{
static const Platform *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Platform_ptr_typeID)
RET(Platform*)obj->data;
else
 CATE(TE,"Value is not a PlatformRef."));
} else
 CATE(TE,"Value is not a PlatformRef."));
}
};

SV Camera_ptr_copy(CTX,NO);
void Camera_ptr_destroy(CTX,NO);
SV Camera_ptr_get_member(CTX,NO,SV);
void Camera_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Camera_ptr_funcs={
.destroy = Camera_ptr_destroy,
.getMember = Camera_ptr_get_member,
.setMember = Camera_ptr_set_member
};
template <>
struct create_val<Camera *>
{
static SV f(CTX ctx,Camera*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Camera_ptr_funcs,obj,EXT->Camera_ptr_typeID);
}
};
template <>
struct val_to_c<Camera *>
{
static Camera *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Camera_ptr_typeID)
RET(Camera*)obj->data;
else
 CATE(TE,"Value is not a CameraRef."));
} else
 CATE(TE,"Value is not a CameraRef."));
}
};
template <>
struct type_same<Camera *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Camera_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Camera *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Camera_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Camera *>
{
static const Camera *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Camera_ptr_typeID)
RET(Camera*)obj->data;
else
 CATE(TE,"Value is not a CameraRef."));
} else
 CATE(TE,"Value is not a CameraRef."));
}
};

SV GfxMesh_ptr_copy(CTX,NO);
void GfxMesh_ptr_destroy(CTX,NO);
SV GfxMesh_ptr_get_member(CTX,NO,SV);
void GfxMesh_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxMesh_ptr_funcs={
.destroy = GfxMesh_ptr_destroy,
.getMember = GfxMesh_ptr_get_member,
.setMember = GfxMesh_ptr_set_member
};
template <>
struct create_val<GfxMesh *>
{
static SV f(CTX ctx,GfxMesh*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxMesh_ptr_funcs,obj,EXT->GfxMesh_ptr_typeID);
}
};
template <>
struct val_to_c<GfxMesh *>
{
static GfxMesh *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxMesh_ptr_typeID)
RET(GfxMesh*)obj->data;
else
 CATE(TE,"Value is not a GfxMeshRef."));
} else
 CATE(TE,"Value is not a GfxMeshRef."));
}
};
template <>
struct type_same<GfxMesh *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxMesh_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxMesh *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxMesh_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxMesh *>
{
static const GfxMesh *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxMesh_ptr_typeID)
RET(GfxMesh*)obj->data;
else
 CATE(TE,"Value is not a GfxMeshRef."));
} else
 CATE(TE,"Value is not a GfxMeshRef."));
}
};

SV Resource_ptr_copy(CTX,NO);
void Resource_ptr_destroy(CTX,NO);
SV Resource_ptr_get_member(CTX,NO,SV);
void Resource_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Resource_ptr_funcs={
.destroy = Resource_ptr_destroy,
.getMember = Resource_ptr_get_member,
.setMember = Resource_ptr_set_member
};
template <>
struct create_val<Resource *>
{
static SV f(CTX ctx,Resource*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Resource_ptr_funcs,obj,EXT->Resource_ptr_typeID);
}
};
template <>
struct val_to_c<Resource *>
{
static Resource *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Resource_ptr_typeID)
RET(Resource*)obj->data;
else
 CATE(TE,"Value is not a ResourceRef."));
} else
 CATE(TE,"Value is not a ResourceRef."));
}
};
template <>
struct type_same<Resource *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Resource_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Resource *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Resource_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Resource *>
{
static const Resource *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Resource_ptr_typeID)
RET(Resource*)obj->data;
else
 CATE(TE,"Value is not a ResourceRef."));
} else
 CATE(TE,"Value is not a ResourceRef."));
}
};

SV GfxShader_ptr_copy(CTX,NO);
void GfxShader_ptr_destroy(CTX,NO);
SV GfxShader_ptr_get_member(CTX,NO,SV);
void GfxShader_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxShader_ptr_funcs={
.destroy = GfxShader_ptr_destroy,
.getMember = GfxShader_ptr_get_member,
.setMember = GfxShader_ptr_set_member
};
template <>
struct create_val<GfxShader *>
{
static SV f(CTX ctx,GfxShader*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxShader_ptr_funcs,obj,EXT->GfxShader_ptr_typeID);
}
};
template <>
struct val_to_c<GfxShader *>
{
static GfxShader *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxShader_ptr_typeID)
RET(GfxShader*)obj->data;
else
 CATE(TE,"Value is not a GfxShaderRef."));
} else
 CATE(TE,"Value is not a GfxShaderRef."));
}
};
template <>
struct type_same<GfxShader *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxShader_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxShader *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxShader_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxShader *>
{
static const GfxShader *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxShader_ptr_typeID)
RET(GfxShader*)obj->data;
else
 CATE(TE,"Value is not a GfxShaderRef."));
} else
 CATE(TE,"Value is not a GfxShaderRef."));
}
};

SV Light_ptr_copy(CTX,NO);
void Light_ptr_destroy(CTX,NO);
SV Light_ptr_get_member(CTX,NO,SV);
void Light_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Light_ptr_funcs={
.destroy = Light_ptr_destroy,
.getMember = Light_ptr_get_member,
.setMember = Light_ptr_set_member
};
template <>
struct create_val<Light *>
{
static SV f(CTX ctx,Light*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Light_ptr_funcs,obj,EXT->Light_ptr_typeID);
}
};
template <>
struct val_to_c<Light *>
{
static Light *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Light_ptr_typeID)
RET(Light*)obj->data;
else
 CATE(TE,"Value is not a LightRef."));
} else
 CATE(TE,"Value is not a LightRef."));
}
};
template <>
struct type_same<Light *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Light_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Light *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Light_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Light *>
{
static const Light *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Light_ptr_typeID)
RET(Light*)obj->data;
else
 CATE(TE,"Value is not a LightRef."));
} else
 CATE(TE,"Value is not a LightRef."));
}
};

SV TextureSampler_ptr_copy(CTX,NO);
void TextureSampler_ptr_destroy(CTX,NO);
SV TextureSampler_ptr_get_member(CTX,NO,SV);
void TextureSampler_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs TextureSampler_ptr_funcs={
.destroy = TextureSampler_ptr_destroy,
.getMember = TextureSampler_ptr_get_member,
.setMember = TextureSampler_ptr_set_member
};
template <>
struct create_val<TextureSampler *>
{
static SV f(CTX ctx,TextureSampler*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(TextureSampler_ptr_funcs,obj,EXT->TextureSampler_ptr_typeID);
}
};
template <>
struct val_to_c<TextureSampler *>
{
static TextureSampler *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->TextureSampler_ptr_typeID)
RET(TextureSampler*)obj->data;
else
 CATE(TE,"Value is not a TextureSamplerRef."));
} else
 CATE(TE,"Value is not a TextureSamplerRef."));
}
};
template <>
struct type_same<TextureSampler *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->TextureSampler_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const TextureSampler *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->TextureSampler_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const TextureSampler *>
{
static const TextureSampler *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->TextureSampler_ptr_typeID)
RET(TextureSampler*)obj->data;
else
 CATE(TE,"Value is not a TextureSamplerRef."));
} else
 CATE(TE,"Value is not a TextureSamplerRef."));
}
};

SV Scene_ptr_copy(CTX,NO);
void Scene_ptr_destroy(CTX,NO);
SV Scene_ptr_get_member(CTX,NO,SV);
void Scene_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Scene_ptr_funcs={
.destroy = Scene_ptr_destroy,
.getMember = Scene_ptr_get_member,
.setMember = Scene_ptr_set_member
};
template <>
struct create_val<Scene *>
{
static SV f(CTX ctx,Scene*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Scene_ptr_funcs,obj,EXT->Scene_ptr_typeID);
}
};
template <>
struct val_to_c<Scene *>
{
static Scene *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Scene_ptr_typeID)
RET(Scene*)obj->data;
else
 CATE(TE,"Value is not a SceneRef."));
} else
 CATE(TE,"Value is not a SceneRef."));
}
};
template <>
struct type_same<Scene *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Scene_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Scene *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Scene_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Scene *>
{
static const Scene *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Scene_ptr_typeID)
RET(Scene*)obj->data;
else
 CATE(TE,"Value is not a SceneRef."));
} else
 CATE(TE,"Value is not a SceneRef."));
}
};

SV Int3_ptr_copy(CTX,NO);
void Int3_ptr_destroy(CTX,NO);
SV Int3_ptr_get_member(CTX,NO,SV);
void Int3_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Int3_ptr_funcs={
.destroy = Int3_ptr_destroy,
.getMember = Int3_ptr_get_member,
.setMember = Int3_ptr_set_member
};
template <>
struct create_val<T3<int32_t> *>
{
static SV f(CTX ctx,T3<int32_t>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Int3_ptr_funcs,obj,EXT->Int3_ptr_typeID);
}
};
template <>
struct val_to_c<T3<int32_t> *>
{
static T3<int32_t> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Int3_ptr_typeID)
RET(T3<int32_t>*)obj->data;
else
 CATE(TE,"Value is not a Int3Ref."));
} else
 CATE(TE,"Value is not a Int3Ref."));
}
};
template <>
struct type_same<T3<int32_t> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Int3_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T3<int32_t> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Int3_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T3<int32_t> *>
{
static const T3<int32_t> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Int3_ptr_typeID)
RET(T3<int32_t>*)obj->data;
else
 CATE(TE,"Value is not a Int3Ref."));
} else
 CATE(TE,"Value is not a Int3Ref."));
}
};

SV ResizableData_ptr_copy(CTX,NO);
void ResizableData_ptr_destroy(CTX,NO);
SV ResizableData_ptr_get_member(CTX,NO,SV);
void ResizableData_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs ResizableData_ptr_funcs={
.destroy = ResizableData_ptr_destroy,
.getMember = ResizableData_ptr_get_member,
.setMember = ResizableData_ptr_set_member
};
template <>
struct create_val<ResizableData *>
{
static SV f(CTX ctx,ResizableData*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(ResizableData_ptr_funcs,obj,EXT->ResizableData_ptr_typeID);
}
};
template <>
struct val_to_c<ResizableData *>
{
static ResizableData *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->ResizableData_ptr_typeID)
RET(ResizableData*)obj->data;
else
 CATE(TE,"Value is not a ResizableDataRef."));
} else
 CATE(TE,"Value is not a ResizableDataRef."));
}
};
template <>
struct type_same<ResizableData *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->ResizableData_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const ResizableData *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->ResizableData_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const ResizableData *>
{
static const ResizableData *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->ResizableData_ptr_typeID)
RET(ResizableData*)obj->data;
else
 CATE(TE,"Value is not a ResizableDataRef."));
} else
 CATE(TE,"Value is not a ResizableDataRef."));
}
};

SV Int4_ptr_copy(CTX,NO);
void Int4_ptr_destroy(CTX,NO);
SV Int4_ptr_get_member(CTX,NO,SV);
void Int4_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Int4_ptr_funcs={
.destroy = Int4_ptr_destroy,
.getMember = Int4_ptr_get_member,
.setMember = Int4_ptr_set_member
};
template <>
struct create_val<T4<int32_t> *>
{
static SV f(CTX ctx,T4<int32_t>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Int4_ptr_funcs,obj,EXT->Int4_ptr_typeID);
}
};
template <>
struct val_to_c<T4<int32_t> *>
{
static T4<int32_t> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Int4_ptr_typeID)
RET(T4<int32_t>*)obj->data;
else
 CATE(TE,"Value is not a Int4Ref."));
} else
 CATE(TE,"Value is not a Int4Ref."));
}
};
template <>
struct type_same<T4<int32_t> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Int4_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T4<int32_t> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Int4_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T4<int32_t> *>
{
static const T4<int32_t> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Int4_ptr_typeID)
RET(T4<int32_t>*)obj->data;
else
 CATE(TE,"Value is not a Int4Ref."));
} else
 CATE(TE,"Value is not a Int4Ref."));
}
};

SV Float3_ptr_copy(CTX,NO);
void Float3_ptr_destroy(CTX,NO);
SV Float3_ptr_get_member(CTX,NO,SV);
void Float3_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Float3_ptr_funcs={
.destroy = Float3_ptr_destroy,
.getMember = Float3_ptr_get_member,
.setMember = Float3_ptr_set_member
};
template <>
struct create_val<T3<float> *>
{
static SV f(CTX ctx,T3<float>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Float3_ptr_funcs,obj,EXT->Float3_ptr_typeID);
}
};
template <>
struct val_to_c<T3<float> *>
{
static T3<float> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Float3_ptr_typeID)
RET(T3<float>*)obj->data;
else
 CATE(TE,"Value is not a Float3Ref."));
} else
 CATE(TE,"Value is not a Float3Ref."));
}
};
template <>
struct type_same<T3<float> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Float3_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T3<float> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Float3_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T3<float> *>
{
static const T3<float> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Float3_ptr_typeID)
RET(T3<float>*)obj->data;
else
 CATE(TE,"Value is not a Float3Ref."));
} else
 CATE(TE,"Value is not a Float3Ref."));
}
};

SV GfxBuffer_ptr_copy(CTX,NO);
void GfxBuffer_ptr_destroy(CTX,NO);
SV GfxBuffer_ptr_get_member(CTX,NO,SV);
void GfxBuffer_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxBuffer_ptr_funcs={
.destroy = GfxBuffer_ptr_destroy,
.getMember = GfxBuffer_ptr_get_member,
.setMember = GfxBuffer_ptr_set_member
};
template <>
struct create_val<GfxBuffer *>
{
static SV f(CTX ctx,GfxBuffer*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxBuffer_ptr_funcs,obj,EXT->GfxBuffer_ptr_typeID);
}
};
template <>
struct val_to_c<GfxBuffer *>
{
static GfxBuffer *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxBuffer_ptr_typeID)
RET(GfxBuffer*)obj->data;
else
 CATE(TE,"Value is not a GfxBufferRef."));
} else
 CATE(TE,"Value is not a GfxBufferRef."));
}
};
template <>
struct type_same<GfxBuffer *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxBuffer_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxBuffer *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxBuffer_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxBuffer *>
{
static const GfxBuffer *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxBuffer_ptr_typeID)
RET(GfxBuffer*)obj->data;
else
 CATE(TE,"Value is not a GfxBufferRef."));
} else
 CATE(TE,"Value is not a GfxBufferRef."));
}
};

SV Transform_ptr_copy(CTX,NO);
void Transform_ptr_destroy(CTX,NO);
SV Transform_ptr_get_member(CTX,NO,SV);
void Transform_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Transform_ptr_funcs={
.destroy = Transform_ptr_destroy,
.getMember = Transform_ptr_get_member,
.setMember = Transform_ptr_set_member
};
template <>
struct create_val<Transform *>
{
static SV f(CTX ctx,Transform*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Transform_ptr_funcs,obj,EXT->Transform_ptr_typeID);
}
};
template <>
struct val_to_c<Transform *>
{
static Transform *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Transform_ptr_typeID)
RET(Transform*)obj->data;
else
 CATE(TE,"Value is not a TransformRef."));
} else
 CATE(TE,"Value is not a TransformRef."));
}
};
template <>
struct type_same<Transform *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Transform_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Transform *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Transform_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Transform *>
{
static const Transform *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Transform_ptr_typeID)
RET(Transform*)obj->data;
else
 CATE(TE,"Value is not a TransformRef."));
} else
 CATE(TE,"Value is not a TransformRef."));
}
};

SV AudioSourceList_ptr_copy(CTX,NO);
void AudioSourceList_ptr_destroy(CTX,NO);
SV AudioSourceList_ptr_get_member(CTX,NO,SV);
void AudioSourceList_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs AudioSourceList_ptr_funcs={
.destroy = AudioSourceList_ptr_destroy,
.getMember = AudioSourceList_ptr_get_member,
.setMember = AudioSourceList_ptr_set_member
};
template <>
struct create_val<List<AudioSource*> *>
{
static SV f(CTX ctx,List<AudioSource*>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(AudioSourceList_ptr_funcs,obj,EXT->AudioSourceList_ptr_typeID);
}
};
template <>
struct val_to_c<List<AudioSource*> *>
{
static List<AudioSource*> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->AudioSourceList_ptr_typeID)
RET(List<AudioSource*>*)obj->data;
else
 CATE(TE,"Value is not a AudioSourceListRef."));
} else
 CATE(TE,"Value is not a AudioSourceListRef."));
}
};
template <>
struct type_same<List<AudioSource*> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->AudioSourceList_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<AudioSource*> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->AudioSourceList_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<AudioSource*> *>
{
static const List<AudioSource*> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->AudioSourceList_ptr_typeID)
RET(List<AudioSource*>*)obj->data;
else
 CATE(TE,"Value is not a AudioSourceListRef."));
} else
 CATE(TE,"Value is not a AudioSourceListRef."));
}
};

SV GfxMaterial_ptr_copy(CTX,NO);
void GfxMaterial_ptr_destroy(CTX,NO);
SV GfxMaterial_ptr_get_member(CTX,NO,SV);
void GfxMaterial_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxMaterial_ptr_funcs={
.destroy = GfxMaterial_ptr_destroy,
.getMember = GfxMaterial_ptr_get_member,
.setMember = GfxMaterial_ptr_set_member
};
template <>
struct create_val<GfxMaterial *>
{
static SV f(CTX ctx,GfxMaterial*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxMaterial_ptr_funcs,obj,EXT->GfxMaterial_ptr_typeID);
}
};
template <>
struct val_to_c<GfxMaterial *>
{
static GfxMaterial *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxMaterial_ptr_typeID)
RET(GfxMaterial*)obj->data;
else
 CATE(TE,"Value is not a GfxMaterialRef."));
} else
 CATE(TE,"Value is not a GfxMaterialRef."));
}
};
template <>
struct type_same<GfxMaterial *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxMaterial_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxMaterial *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxMaterial_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxMaterial *>
{
static const GfxMaterial *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxMaterial_ptr_typeID)
RET(GfxMaterial*)obj->data;
else
 CATE(TE,"Value is not a GfxMaterialRef."));
} else
 CATE(TE,"Value is not a GfxMaterialRef."));
}
};

SV Quaternion_ptr_copy(CTX,NO);
void Quaternion_ptr_destroy(CTX,NO);
SV Quaternion_ptr_get_member(CTX,NO,SV);
void Quaternion_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Quaternion_ptr_funcs={
.destroy = Quaternion_ptr_destroy,
.getMember = Quaternion_ptr_get_member,
.setMember = Quaternion_ptr_set_member
};
template <>
struct create_val<Quaternion *>
{
static SV f(CTX ctx,Quaternion*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Quaternion_ptr_funcs,obj,EXT->Quaternion_ptr_typeID);
}
};
template <>
struct val_to_c<Quaternion *>
{
static Quaternion *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Quaternion_ptr_typeID)
RET(Quaternion*)obj->data;
else
 CATE(TE,"Value is not a QuaternionRef."));
} else
 CATE(TE,"Value is not a QuaternionRef."));
}
};
template <>
struct type_same<Quaternion *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Quaternion_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Quaternion *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Quaternion_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Quaternion *>
{
static const Quaternion *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Quaternion_ptr_typeID)
RET(Quaternion*)obj->data;
else
 CATE(TE,"Value is not a QuaternionRef."));
} else
 CATE(TE,"Value is not a QuaternionRef."));
}
};

SV GfxMeshAttrib_ptr_copy(CTX,NO);
void GfxMeshAttrib_ptr_destroy(CTX,NO);
SV GfxMeshAttrib_ptr_get_member(CTX,NO,SV);
void GfxMeshAttrib_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxMeshAttrib_ptr_funcs={
.destroy = GfxMeshAttrib_ptr_destroy,
.getMember = GfxMeshAttrib_ptr_get_member,
.setMember = GfxMeshAttrib_ptr_set_member
};
template <>
struct create_val<GfxMeshAttrib *>
{
static SV f(CTX ctx,GfxMeshAttrib*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxMeshAttrib_ptr_funcs,obj,EXT->GfxMeshAttrib_ptr_typeID);
}
};
template <>
struct val_to_c<GfxMeshAttrib *>
{
static GfxMeshAttrib *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxMeshAttrib_ptr_typeID)
RET(GfxMeshAttrib*)obj->data;
else
 CATE(TE,"Value is not a GfxMeshAttribRef."));
} else
 CATE(TE,"Value is not a GfxMeshAttribRef."));
}
};
template <>
struct type_same<GfxMeshAttrib *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxMeshAttrib_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxMeshAttrib *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxMeshAttrib_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxMeshAttrib *>
{
static const GfxMeshAttrib *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxMeshAttrib_ptr_typeID)
RET(GfxMeshAttrib*)obj->data;
else
 CATE(TE,"Value is not a GfxMeshAttribRef."));
} else
 CATE(TE,"Value is not a GfxMeshAttribRef."));
}
};

SV RenderComponent_ptr_copy(CTX,NO);
void RenderComponent_ptr_destroy(CTX,NO);
SV RenderComponent_ptr_get_member(CTX,NO,SV);
void RenderComponent_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs RenderComponent_ptr_funcs={
.destroy = RenderComponent_ptr_destroy,
.getMember = RenderComponent_ptr_get_member,
.setMember = RenderComponent_ptr_set_member
};
template <>
struct create_val<RenderComponent *>
{
static SV f(CTX ctx,RenderComponent*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(RenderComponent_ptr_funcs,obj,EXT->RenderComponent_ptr_typeID);
}
};
template <>
struct val_to_c<RenderComponent *>
{
static RenderComponent *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->RenderComponent_ptr_typeID)
RET(RenderComponent*)obj->data;
else
 CATE(TE,"Value is not a RenderComponentRef."));
} else
 CATE(TE,"Value is not a RenderComponentRef."));
}
};
template <>
struct type_same<RenderComponent *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RenderComponent_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const RenderComponent *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RenderComponent_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const RenderComponent *>
{
static const RenderComponent *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->RenderComponent_ptr_typeID)
RET(RenderComponent*)obj->data;
else
 CATE(TE,"Value is not a RenderComponentRef."));
} else
 CATE(TE,"Value is not a RenderComponentRef."));
}
};

SV Int2_ptr_copy(CTX,NO);
void Int2_ptr_destroy(CTX,NO);
SV Int2_ptr_get_member(CTX,NO,SV);
void Int2_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Int2_ptr_funcs={
.destroy = Int2_ptr_destroy,
.getMember = Int2_ptr_get_member,
.setMember = Int2_ptr_set_member
};
template <>
struct create_val<T2<int32_t> *>
{
static SV f(CTX ctx,T2<int32_t>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Int2_ptr_funcs,obj,EXT->Int2_ptr_typeID);
}
};
template <>
struct val_to_c<T2<int32_t> *>
{
static T2<int32_t> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Int2_ptr_typeID)
RET(T2<int32_t>*)obj->data;
else
 CATE(TE,"Value is not a Int2Ref."));
} else
 CATE(TE,"Value is not a Int2Ref."));
}
};
template <>
struct type_same<T2<int32_t> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Int2_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T2<int32_t> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Int2_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T2<int32_t> *>
{
static const T2<int32_t> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Int2_ptr_typeID)
RET(T2<int32_t>*)obj->data;
else
 CATE(TE,"Value is not a Int2Ref."));
} else
 CATE(TE,"Value is not a Int2Ref."));
}
};

SV AudioWorld_ptr_copy(CTX,NO);
void AudioWorld_ptr_destroy(CTX,NO);
SV AudioWorld_ptr_get_member(CTX,NO,SV);
void AudioWorld_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs AudioWorld_ptr_funcs={
.destroy = AudioWorld_ptr_destroy,
.getMember = AudioWorld_ptr_get_member,
.setMember = AudioWorld_ptr_set_member
};
template <>
struct create_val<AudioWorld *>
{
static SV f(CTX ctx,AudioWorld*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(AudioWorld_ptr_funcs,obj,EXT->AudioWorld_ptr_typeID);
}
};
template <>
struct val_to_c<AudioWorld *>
{
static AudioWorld *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->AudioWorld_ptr_typeID)
RET(AudioWorld*)obj->data;
else
 CATE(TE,"Value is not a AudioWorldRef."));
} else
 CATE(TE,"Value is not a AudioWorldRef."));
}
};
template <>
struct type_same<AudioWorld *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->AudioWorld_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const AudioWorld *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->AudioWorld_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const AudioWorld *>
{
static const AudioWorld *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->AudioWorld_ptr_typeID)
RET(AudioWorld*)obj->data;
else
 CATE(TE,"Value is not a AudioWorldRef."));
} else
 CATE(TE,"Value is not a AudioWorldRef."));
}
};

SV GuiPlacer_ptr_copy(CTX,NO);
void GuiPlacer_ptr_destroy(CTX,NO);
SV GuiPlacer_ptr_get_member(CTX,NO,SV);
void GuiPlacer_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GuiPlacer_ptr_funcs={
.destroy = GuiPlacer_ptr_destroy,
.getMember = GuiPlacer_ptr_get_member,
.setMember = GuiPlacer_ptr_set_member
};
template <>
struct create_val<GuiPlacer *>
{
static SV f(CTX ctx,GuiPlacer*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GuiPlacer_ptr_funcs,obj,EXT->GuiPlacer_ptr_typeID);
}
};
template <>
struct val_to_c<GuiPlacer *>
{
static GuiPlacer *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GuiPlacer_ptr_typeID)
RET(GuiPlacer*)obj->data;
else
 CATE(TE,"Value is not a GuiPlacerRef."));
} else
 CATE(TE,"Value is not a GuiPlacerRef."));
}
};
template <>
struct type_same<GuiPlacer *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GuiPlacer_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GuiPlacer *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GuiPlacer_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GuiPlacer *>
{
static const GuiPlacer *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GuiPlacer_ptr_typeID)
RET(GuiPlacer*)obj->data;
else
 CATE(TE,"Value is not a GuiPlacerRef."));
} else
 CATE(TE,"Value is not a GuiPlacerRef."));
}
};

SV ImGui_ptr_copy(CTX,NO);
void ImGui_ptr_destroy(CTX,NO);
SV ImGui_ptr_get_member(CTX,NO,SV);
void ImGui_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs ImGui_ptr_funcs={
.destroy = ImGui_ptr_destroy,
.getMember = ImGui_ptr_get_member,
.setMember = ImGui_ptr_set_member
};
template <>
struct create_val<ImGui *>
{
static SV f(CTX ctx,ImGui*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(ImGui_ptr_funcs,obj,EXT->ImGui_ptr_typeID);
}
};
template <>
struct val_to_c<ImGui *>
{
static ImGui *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->ImGui_ptr_typeID)
RET(ImGui*)obj->data;
else
 CATE(TE,"Value is not a ImGuiRef."));
} else
 CATE(TE,"Value is not a ImGuiRef."));
}
};
template <>
struct type_same<ImGui *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->ImGui_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const ImGui *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->ImGui_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const ImGui *>
{
static const ImGui *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->ImGui_ptr_typeID)
RET(ImGui*)obj->data;
else
 CATE(TE,"Value is not a ImGuiRef."));
} else
 CATE(TE,"Value is not a ImGuiRef."));
}
};

SV StringList_ptr_copy(CTX,NO);
void StringList_ptr_destroy(CTX,NO);
SV StringList_ptr_get_member(CTX,NO,SV);
void StringList_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs StringList_ptr_funcs={
.destroy = StringList_ptr_destroy,
.getMember = StringList_ptr_get_member,
.setMember = StringList_ptr_set_member
};
template <>
struct create_val<List<String> *>
{
static SV f(CTX ctx,List<String>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(StringList_ptr_funcs,obj,EXT->StringList_ptr_typeID);
}
};
template <>
struct val_to_c<List<String> *>
{
static List<String> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->StringList_ptr_typeID)
RET(List<String>*)obj->data;
else
 CATE(TE,"Value is not a StringListRef."));
} else
 CATE(TE,"Value is not a StringListRef."));
}
};
template <>
struct type_same<List<String> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->StringList_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<String> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->StringList_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<String> *>
{
static const List<String> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->StringList_ptr_typeID)
RET(List<String>*)obj->data;
else
 CATE(TE,"Value is not a StringListRef."));
} else
 CATE(TE,"Value is not a StringListRef."));
}
};

SV Application_ptr_copy(CTX,NO);
void Application_ptr_destroy(CTX,NO);
SV Application_ptr_get_member(CTX,NO,SV);
void Application_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Application_ptr_funcs={
.destroy = Application_ptr_destroy,
.getMember = Application_ptr_get_member,
.setMember = Application_ptr_set_member
};
template <>
struct create_val<Application *>
{
static SV f(CTX ctx,Application*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Application_ptr_funcs,obj,EXT->Application_ptr_typeID);
}
};
template <>
struct val_to_c<Application *>
{
static Application *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Application_ptr_typeID)
RET(Application*)obj->data;
else
 CATE(TE,"Value is not a ApplicationRef."));
} else
 CATE(TE,"Value is not a ApplicationRef."));
}
};
template <>
struct type_same<Application *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Application_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Application *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Application_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Application *>
{
static const Application *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Application_ptr_typeID)
RET(Application*)obj->data;
else
 CATE(TE,"Value is not a ApplicationRef."));
} else
 CATE(TE,"Value is not a ApplicationRef."));
}
};

SV LightPointData_ptr_copy(CTX,NO);
void LightPointData_ptr_destroy(CTX,NO);
SV LightPointData_ptr_get_member(CTX,NO,SV);
void LightPointData_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs LightPointData_ptr_funcs={
.destroy = LightPointData_ptr_destroy,
.getMember = LightPointData_ptr_get_member,
.setMember = LightPointData_ptr_set_member
};
template <>
struct create_val<LightPointData *>
{
static SV f(CTX ctx,LightPointData*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(LightPointData_ptr_funcs,obj,EXT->LightPointData_ptr_typeID);
}
};
template <>
struct val_to_c<LightPointData *>
{
static LightPointData *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->LightPointData_ptr_typeID)
RET(LightPointData*)obj->data;
else
 CATE(TE,"Value is not a LightPointDataRef."));
} else
 CATE(TE,"Value is not a LightPointDataRef."));
}
};
template <>
struct type_same<LightPointData *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->LightPointData_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const LightPointData *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->LightPointData_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const LightPointData *>
{
static const LightPointData *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->LightPointData_ptr_typeID)
RET(LightPointData*)obj->data;
else
 CATE(TE,"Value is not a LightPointDataRef."));
} else
 CATE(TE,"Value is not a LightPointDataRef."));
}
};

SV Float4_ptr_copy(CTX,NO);
void Float4_ptr_destroy(CTX,NO);
SV Float4_ptr_get_member(CTX,NO,SV);
void Float4_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Float4_ptr_funcs={
.destroy = Float4_ptr_destroy,
.getMember = Float4_ptr_get_member,
.setMember = Float4_ptr_set_member
};
template <>
struct create_val<T4<float> *>
{
static SV f(CTX ctx,T4<float>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Float4_ptr_funcs,obj,EXT->Float4_ptr_typeID);
}
};
template <>
struct val_to_c<T4<float> *>
{
static T4<float> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Float4_ptr_typeID)
RET(T4<float>*)obj->data;
else
 CATE(TE,"Value is not a Float4Ref."));
} else
 CATE(TE,"Value is not a Float4Ref."));
}
};
template <>
struct type_same<T4<float> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Float4_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T4<float> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Float4_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T4<float> *>
{
static const T4<float> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Float4_ptr_typeID)
RET(T4<float>*)obj->data;
else
 CATE(TE,"Value is not a Float4Ref."));
} else
 CATE(TE,"Value is not a Float4Ref."));
}
};

SV FloatList_ptr_copy(CTX,NO);
void FloatList_ptr_destroy(CTX,NO);
SV FloatList_ptr_get_member(CTX,NO,SV);
void FloatList_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs FloatList_ptr_funcs={
.destroy = FloatList_ptr_destroy,
.getMember = FloatList_ptr_get_member,
.setMember = FloatList_ptr_set_member
};
template <>
struct create_val<List<float> *>
{
static SV f(CTX ctx,List<float>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(FloatList_ptr_funcs,obj,EXT->FloatList_ptr_typeID);
}
};
template <>
struct val_to_c<List<float> *>
{
static List<float> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->FloatList_ptr_typeID)
RET(List<float>*)obj->data;
else
 CATE(TE,"Value is not a FloatListRef."));
} else
 CATE(TE,"Value is not a FloatListRef."));
}
};
template <>
struct type_same<List<float> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->FloatList_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<float> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->FloatList_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<float> *>
{
static const List<float> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->FloatList_ptr_typeID)
RET(List<float>*)obj->data;
else
 CATE(TE,"Value is not a FloatListRef."));
} else
 CATE(TE,"Value is not a FloatListRef."));
}
};

SV Container_ptr_copy(CTX,NO);
void Container_ptr_destroy(CTX,NO);
SV Container_ptr_get_member(CTX,NO,SV);
void Container_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Container_ptr_funcs={
.destroy = Container_ptr_destroy,
.getMember = Container_ptr_get_member,
.setMember = Container_ptr_set_member
};
template <>
struct create_val<Container *>
{
static SV f(CTX ctx,Container*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Container_ptr_funcs,obj,EXT->Container_ptr_typeID);
}
};
template <>
struct val_to_c<Container *>
{
static Container *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Container_ptr_typeID)
RET(Container*)obj->data;
else
 CATE(TE,"Value is not a ContainerRef."));
} else
 CATE(TE,"Value is not a ContainerRef."));
}
};
template <>
struct type_same<Container *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Container_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Container *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Container_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Container *>
{
static const Container *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Container_ptr_typeID)
RET(Container*)obj->data;
else
 CATE(TE,"Value is not a ContainerRef."));
} else
 CATE(TE,"Value is not a ContainerRef."));
}
};

SV LightDirectionalData_ptr_copy(CTX,NO);
void LightDirectionalData_ptr_destroy(CTX,NO);
SV LightDirectionalData_ptr_get_member(CTX,NO,SV);
void LightDirectionalData_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs LightDirectionalData_ptr_funcs={
.destroy = LightDirectionalData_ptr_destroy,
.getMember = LightDirectionalData_ptr_get_member,
.setMember = LightDirectionalData_ptr_set_member
};
template <>
struct create_val<LightDirectionalData *>
{
static SV f(CTX ctx,LightDirectionalData*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(LightDirectionalData_ptr_funcs,obj,EXT->LightDirectionalData_ptr_typeID);
}
};
template <>
struct val_to_c<LightDirectionalData *>
{
static LightDirectionalData *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->LightDirectionalData_ptr_typeID)
RET(LightDirectionalData*)obj->data;
else
 CATE(TE,"Value is not a LightDirectionalDataRef."));
} else
 CATE(TE,"Value is not a LightDirectionalDataRef."));
}
};
template <>
struct type_same<LightDirectionalData *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->LightDirectionalData_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const LightDirectionalData *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->LightDirectionalData_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const LightDirectionalData *>
{
static const LightDirectionalData *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->LightDirectionalData_ptr_typeID)
RET(LightDirectionalData*)obj->data;
else
 CATE(TE,"Value is not a LightDirectionalDataRef."));
} else
 CATE(TE,"Value is not a LightDirectionalDataRef."));
}
};

SV Matrix4x4_ptr_copy(CTX,NO);
void Matrix4x4_ptr_destroy(CTX,NO);
SV Matrix4x4_ptr_get_member(CTX,NO,SV);
void Matrix4x4_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Matrix4x4_ptr_funcs={
.destroy = Matrix4x4_ptr_destroy,
.getMember = Matrix4x4_ptr_get_member,
.setMember = Matrix4x4_ptr_set_member
};
template <>
struct create_val<Matrix4x4 *>
{
static SV f(CTX ctx,Matrix4x4*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Matrix4x4_ptr_funcs,obj,EXT->Matrix4x4_ptr_typeID);
}
};
template <>
struct val_to_c<Matrix4x4 *>
{
static Matrix4x4 *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Matrix4x4_ptr_typeID)
RET(Matrix4x4*)obj->data;
else
 CATE(TE,"Value is not a Matrix4x4Ref."));
} else
 CATE(TE,"Value is not a Matrix4x4Ref."));
}
};
template <>
struct type_same<Matrix4x4 *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Matrix4x4_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Matrix4x4 *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Matrix4x4_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Matrix4x4 *>
{
static const Matrix4x4 *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Matrix4x4_ptr_typeID)
RET(Matrix4x4*)obj->data;
else
 CATE(TE,"Value is not a Matrix4x4Ref."));
} else
 CATE(TE,"Value is not a Matrix4x4Ref."));
}
};

SV Map_ptr_copy(CTX,NO);
void Map_ptr_destroy(CTX,NO);
SV Map_ptr_get_member(CTX,NO,SV);
void Map_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Map_ptr_funcs={
.destroy = Map_ptr_destroy,
.getMember = Map_ptr_get_member,
.setMember = Map_ptr_set_member
};
template <>
struct create_val<HashMap<scripting::Value*,scripting::Value*> *>
{
static SV f(CTX ctx,HashMap<scripting::Value*,scripting::Value*>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Map_ptr_funcs,obj,EXT->Map_ptr_typeID);
}
};
template <>
struct val_to_c<HashMap<scripting::Value*,scripting::Value*> *>
{
static HashMap<scripting::Value*,scripting::Value*> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Map_ptr_typeID)
RET(HashMap<scripting::Value*,scripting::Value*>*)obj->data;
else
 CATE(TE,"Value is not a MapRef."));
} else
 CATE(TE,"Value is not a MapRef."));
}
};
template <>
struct type_same<HashMap<scripting::Value*,scripting::Value*> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Map_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const HashMap<scripting::Value*,scripting::Value*> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Map_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const HashMap<scripting::Value*,scripting::Value*> *>
{
static const HashMap<scripting::Value*,scripting::Value*> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Map_ptr_typeID)
RET(HashMap<scripting::Value*,scripting::Value*>*)obj->data;
else
 CATE(TE,"Value is not a MapRef."));
} else
 CATE(TE,"Value is not a MapRef."));
}
};

SV UInt3_ptr_copy(CTX,NO);
void UInt3_ptr_destroy(CTX,NO);
SV UInt3_ptr_get_member(CTX,NO,SV);
void UInt3_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs UInt3_ptr_funcs={
.destroy = UInt3_ptr_destroy,
.getMember = UInt3_ptr_get_member,
.setMember = UInt3_ptr_set_member
};
template <>
struct create_val<T3<uint32_t> *>
{
static SV f(CTX ctx,T3<uint32_t>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(UInt3_ptr_funcs,obj,EXT->UInt3_ptr_typeID);
}
};
template <>
struct val_to_c<T3<uint32_t> *>
{
static T3<uint32_t> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->UInt3_ptr_typeID)
RET(T3<uint32_t>*)obj->data;
else
 CATE(TE,"Value is not a UInt3Ref."));
} else
 CATE(TE,"Value is not a UInt3Ref."));
}
};
template <>
struct type_same<T3<uint32_t> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->UInt3_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T3<uint32_t> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->UInt3_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T3<uint32_t> *>
{
static const T3<uint32_t> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->UInt3_ptr_typeID)
RET(T3<uint32_t>*)obj->data;
else
 CATE(TE,"Value is not a UInt3Ref."));
} else
 CATE(TE,"Value is not a UInt3Ref."));
}
};

SV LightSpotData_ptr_copy(CTX,NO);
void LightSpotData_ptr_destroy(CTX,NO);
SV LightSpotData_ptr_get_member(CTX,NO,SV);
void LightSpotData_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs LightSpotData_ptr_funcs={
.destroy = LightSpotData_ptr_destroy,
.getMember = LightSpotData_ptr_get_member,
.setMember = LightSpotData_ptr_set_member
};
template <>
struct create_val<LightSpotData *>
{
static SV f(CTX ctx,LightSpotData*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(LightSpotData_ptr_funcs,obj,EXT->LightSpotData_ptr_typeID);
}
};
template <>
struct val_to_c<LightSpotData *>
{
static LightSpotData *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->LightSpotData_ptr_typeID)
RET(LightSpotData*)obj->data;
else
 CATE(TE,"Value is not a LightSpotDataRef."));
} else
 CATE(TE,"Value is not a LightSpotDataRef."));
}
};
template <>
struct type_same<LightSpotData *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->LightSpotData_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const LightSpotData *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->LightSpotData_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const LightSpotData *>
{
static const LightSpotData *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->LightSpotData_ptr_typeID)
RET(LightSpotData*)obj->data;
else
 CATE(TE,"Value is not a LightSpotDataRef."));
} else
 CATE(TE,"Value is not a LightSpotDataRef."));
}
};

SV PhysicsShape_ptr_copy(CTX,NO);
void PhysicsShape_ptr_destroy(CTX,NO);
SV PhysicsShape_ptr_get_member(CTX,NO,SV);
void PhysicsShape_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs PhysicsShape_ptr_funcs={
.destroy = PhysicsShape_ptr_destroy,
.getMember = PhysicsShape_ptr_get_member,
.setMember = PhysicsShape_ptr_set_member
};
template <>
struct create_val<PhysicsShape *>
{
static SV f(CTX ctx,PhysicsShape*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(PhysicsShape_ptr_funcs,obj,EXT->PhysicsShape_ptr_typeID);
}
};
template <>
struct val_to_c<PhysicsShape *>
{
static PhysicsShape *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->PhysicsShape_ptr_typeID)
RET(PhysicsShape*)obj->data;
else
 CATE(TE,"Value is not a PhysicsShapeRef."));
} else
 CATE(TE,"Value is not a PhysicsShapeRef."));
}
};
template <>
struct type_same<PhysicsShape *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->PhysicsShape_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const PhysicsShape *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->PhysicsShape_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const PhysicsShape *>
{
static const PhysicsShape *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->PhysicsShape_ptr_typeID)
RET(PhysicsShape*)obj->data;
else
 CATE(TE,"Value is not a PhysicsShapeRef."));
} else
 CATE(TE,"Value is not a PhysicsShapeRef."));
}
};

SV AudioDevice_ptr_copy(CTX,NO);
void AudioDevice_ptr_destroy(CTX,NO);
SV AudioDevice_ptr_get_member(CTX,NO,SV);
void AudioDevice_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs AudioDevice_ptr_funcs={
.destroy = AudioDevice_ptr_destroy,
.getMember = AudioDevice_ptr_get_member,
.setMember = AudioDevice_ptr_set_member
};
template <>
struct create_val<AudioDevice *>
{
static SV f(CTX ctx,AudioDevice*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(AudioDevice_ptr_funcs,obj,EXT->AudioDevice_ptr_typeID);
}
};
template <>
struct val_to_c<AudioDevice *>
{
static AudioDevice *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->AudioDevice_ptr_typeID)
RET(AudioDevice*)obj->data;
else
 CATE(TE,"Value is not a AudioDeviceRef."));
} else
 CATE(TE,"Value is not a AudioDeviceRef."));
}
};
template <>
struct type_same<AudioDevice *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->AudioDevice_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const AudioDevice *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->AudioDevice_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const AudioDevice *>
{
static const AudioDevice *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->AudioDevice_ptr_typeID)
RET(AudioDevice*)obj->data;
else
 CATE(TE,"Value is not a AudioDeviceRef."));
} else
 CATE(TE,"Value is not a AudioDeviceRef."));
}
};

SV RigidBodyList_ptr_copy(CTX,NO);
void RigidBodyList_ptr_destroy(CTX,NO);
SV RigidBodyList_ptr_get_member(CTX,NO,SV);
void RigidBodyList_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs RigidBodyList_ptr_funcs={
.destroy = RigidBodyList_ptr_destroy,
.getMember = RigidBodyList_ptr_get_member,
.setMember = RigidBodyList_ptr_set_member
};
template <>
struct create_val<List<RigidBody*> *>
{
static SV f(CTX ctx,List<RigidBody*>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(RigidBodyList_ptr_funcs,obj,EXT->RigidBodyList_ptr_typeID);
}
};
template <>
struct val_to_c<List<RigidBody*> *>
{
static List<RigidBody*> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->RigidBodyList_ptr_typeID)
RET(List<RigidBody*>*)obj->data;
else
 CATE(TE,"Value is not a RigidBodyListRef."));
} else
 CATE(TE,"Value is not a RigidBodyListRef."));
}
};
template <>
struct type_same<List<RigidBody*> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RigidBodyList_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<RigidBody*> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RigidBodyList_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<RigidBody*> *>
{
static const List<RigidBody*> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->RigidBodyList_ptr_typeID)
RET(List<RigidBody*>*)obj->data;
else
 CATE(TE,"Value is not a RigidBodyListRef."));
} else
 CATE(TE,"Value is not a RigidBodyListRef."));
}
};

SV UInt4_ptr_copy(CTX,NO);
void UInt4_ptr_destroy(CTX,NO);
SV UInt4_ptr_get_member(CTX,NO,SV);
void UInt4_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs UInt4_ptr_funcs={
.destroy = UInt4_ptr_destroy,
.getMember = UInt4_ptr_get_member,
.setMember = UInt4_ptr_set_member
};
template <>
struct create_val<T4<uint32_t> *>
{
static SV f(CTX ctx,T4<uint32_t>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(UInt4_ptr_funcs,obj,EXT->UInt4_ptr_typeID);
}
};
template <>
struct val_to_c<T4<uint32_t> *>
{
static T4<uint32_t> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->UInt4_ptr_typeID)
RET(T4<uint32_t>*)obj->data;
else
 CATE(TE,"Value is not a UInt4Ref."));
} else
 CATE(TE,"Value is not a UInt4Ref."));
}
};
template <>
struct type_same<T4<uint32_t> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->UInt4_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const T4<uint32_t> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->UInt4_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const T4<uint32_t> *>
{
static const T4<uint32_t> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->UInt4_ptr_typeID)
RET(T4<uint32_t>*)obj->data;
else
 CATE(TE,"Value is not a UInt4Ref."));
} else
 CATE(TE,"Value is not a UInt4Ref."));
}
};

SV RayCastResult_ptr_copy(CTX,NO);
void RayCastResult_ptr_destroy(CTX,NO);
SV RayCastResult_ptr_get_member(CTX,NO,SV);
void RayCastResult_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs RayCastResult_ptr_funcs={
.destroy = RayCastResult_ptr_destroy,
.getMember = RayCastResult_ptr_get_member,
.setMember = RayCastResult_ptr_set_member
};
template <>
struct create_val<RayCastResult *>
{
static SV f(CTX ctx,RayCastResult*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(RayCastResult_ptr_funcs,obj,EXT->RayCastResult_ptr_typeID);
}
};
template <>
struct val_to_c<RayCastResult *>
{
static RayCastResult *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->RayCastResult_ptr_typeID)
RET(RayCastResult*)obj->data;
else
 CATE(TE,"Value is not a RayCastResultRef."));
} else
 CATE(TE,"Value is not a RayCastResultRef."));
}
};
template <>
struct type_same<RayCastResult *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RayCastResult_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const RayCastResult *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RayCastResult_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const RayCastResult *>
{
static const RayCastResult *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->RayCastResult_ptr_typeID)
RET(RayCastResult*)obj->data;
else
 CATE(TE,"Value is not a RayCastResultRef."));
} else
 CATE(TE,"Value is not a RayCastResultRef."));
}
};

SV GfxLOD_ptr_copy(CTX,NO);
void GfxLOD_ptr_destroy(CTX,NO);
SV GfxLOD_ptr_get_member(CTX,NO,SV);
void GfxLOD_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxLOD_ptr_funcs={
.destroy = GfxLOD_ptr_destroy,
.getMember = GfxLOD_ptr_get_member,
.setMember = GfxLOD_ptr_set_member
};
template <>
struct create_val<GfxLOD *>
{
static SV f(CTX ctx,GfxLOD*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxLOD_ptr_funcs,obj,EXT->GfxLOD_ptr_typeID);
}
};
template <>
struct val_to_c<GfxLOD *>
{
static GfxLOD *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxLOD_ptr_typeID)
RET(GfxLOD*)obj->data;
else
 CATE(TE,"Value is not a GfxLODRef."));
} else
 CATE(TE,"Value is not a GfxLODRef."));
}
};
template <>
struct type_same<GfxLOD *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxLOD_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxLOD *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxLOD_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxLOD *>
{
static const GfxLOD *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxLOD_ptr_typeID)
RET(GfxLOD*)obj->data;
else
 CATE(TE,"Value is not a GfxLODRef."));
} else
 CATE(TE,"Value is not a GfxLODRef."));
}
};

SV File_ptr_copy(CTX,NO);
void File_ptr_destroy(CTX,NO);
SV File_ptr_get_member(CTX,NO,SV);
void File_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs File_ptr_funcs={
.destroy = File_ptr_destroy,
.getMember = File_ptr_get_member,
.setMember = File_ptr_set_member
};
template <>
struct create_val<File *>
{
static SV f(CTX ctx,File*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(File_ptr_funcs,obj,EXT->File_ptr_typeID);
}
};
template <>
struct val_to_c<File *>
{
static File *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->File_ptr_typeID)
RET(File*)obj->data;
else
 CATE(TE,"Value is not a FileRef."));
} else
 CATE(TE,"Value is not a FileRef."));
}
};
template <>
struct type_same<File *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->File_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const File *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->File_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const File *>
{
static const File *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->File_ptr_typeID)
RET(File*)obj->data;
else
 CATE(TE,"Value is not a FileRef."));
} else
 CATE(TE,"Value is not a FileRef."));
}
};

SV AABB_ptr_copy(CTX,NO);
void AABB_ptr_destroy(CTX,NO);
SV AABB_ptr_get_member(CTX,NO,SV);
void AABB_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs AABB_ptr_funcs={
.destroy = AABB_ptr_destroy,
.getMember = AABB_ptr_get_member,
.setMember = AABB_ptr_set_member
};
template <>
struct create_val<AABB *>
{
static SV f(CTX ctx,AABB*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(AABB_ptr_funcs,obj,EXT->AABB_ptr_typeID);
}
};
template <>
struct val_to_c<AABB *>
{
static AABB *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->AABB_ptr_typeID)
RET(AABB*)obj->data;
else
 CATE(TE,"Value is not a AABBRef."));
} else
 CATE(TE,"Value is not a AABBRef."));
}
};
template <>
struct type_same<AABB *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->AABB_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const AABB *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->AABB_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const AABB *>
{
static const AABB *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->AABB_ptr_typeID)
RET(AABB*)obj->data;
else
 CATE(TE,"Value is not a AABBRef."));
} else
 CATE(TE,"Value is not a AABBRef."));
}
};

SV RigidBodyConstructionInfo_ptr_copy(CTX,NO);
void RigidBodyConstructionInfo_ptr_destroy(CTX,NO);
SV RigidBodyConstructionInfo_ptr_get_member(CTX,NO,SV);
void RigidBodyConstructionInfo_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs RigidBodyConstructionInfo_ptr_funcs={
.destroy = RigidBodyConstructionInfo_ptr_destroy,
.getMember = RigidBodyConstructionInfo_ptr_get_member,
.setMember = RigidBodyConstructionInfo_ptr_set_member
};
template <>
struct create_val<RigidBodyConstructionInfo *>
{
static SV f(CTX ctx,RigidBodyConstructionInfo*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(RigidBodyConstructionInfo_ptr_funcs,obj,EXT->RigidBodyConstructionInfo_ptr_typeID);
}
};
template <>
struct val_to_c<RigidBodyConstructionInfo *>
{
static RigidBodyConstructionInfo *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->RigidBodyConstructionInfo_ptr_typeID)
RET(RigidBodyConstructionInfo*)obj->data;
else
 CATE(TE,"Value is not a RigidBodyConstructionInfoRef."));
} else
 CATE(TE,"Value is not a RigidBodyConstructionInfoRef."));
}
};
template <>
struct type_same<RigidBodyConstructionInfo *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RigidBodyConstructionInfo_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const RigidBodyConstructionInfo *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->RigidBodyConstructionInfo_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const RigidBodyConstructionInfo *>
{
static const RigidBodyConstructionInfo *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->RigidBodyConstructionInfo_ptr_typeID)
RET(RigidBodyConstructionInfo*)obj->data;
else
 CATE(TE,"Value is not a RigidBodyConstructionInfoRef."));
} else
 CATE(TE,"Value is not a RigidBodyConstructionInfoRef."));
}
};

SV List_ptr_copy(CTX,NO);
void List_ptr_destroy(CTX,NO);
SV List_ptr_get_member(CTX,NO,SV);
void List_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs List_ptr_funcs={
.destroy = List_ptr_destroy,
.getMember = List_ptr_get_member,
.setMember = List_ptr_set_member
};
template <>
struct create_val<List<scripting::Value*> *>
{
static SV f(CTX ctx,List<scripting::Value*>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(List_ptr_funcs,obj,EXT->List_ptr_typeID);
}
};
template <>
struct val_to_c<List<scripting::Value*> *>
{
static List<scripting::Value*> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->List_ptr_typeID)
RET(List<scripting::Value*>*)obj->data;
else
 CATE(TE,"Value is not a ListRef."));
} else
 CATE(TE,"Value is not a ListRef."));
}
};
template <>
struct type_same<List<scripting::Value*> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->List_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<scripting::Value*> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->List_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<scripting::Value*> *>
{
static const List<scripting::Value*> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->List_ptr_typeID)
RET(List<scripting::Value*>*)obj->data;
else
 CATE(TE,"Value is not a ListRef."));
} else
 CATE(TE,"Value is not a ListRef."));
}
};

SV Audio_ptr_copy(CTX,NO);
void Audio_ptr_destroy(CTX,NO);
SV Audio_ptr_get_member(CTX,NO,SV);
void Audio_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Audio_ptr_funcs={
.destroy = Audio_ptr_destroy,
.getMember = Audio_ptr_get_member,
.setMember = Audio_ptr_set_member
};
template <>
struct create_val<Audio *>
{
static SV f(CTX ctx,Audio*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Audio_ptr_funcs,obj,EXT->Audio_ptr_typeID);
}
};
template <>
struct val_to_c<Audio *>
{
static Audio *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Audio_ptr_typeID)
RET(Audio*)obj->data;
else
 CATE(TE,"Value is not a AudioRef."));
} else
 CATE(TE,"Value is not a AudioRef."));
}
};
template <>
struct type_same<Audio *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Audio_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Audio *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Audio_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Audio *>
{
static const Audio *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Audio_ptr_typeID)
RET(Audio*)obj->data;
else
 CATE(TE,"Value is not a AudioRef."));
} else
 CATE(TE,"Value is not a AudioRef."));
}
};

SV GfxTexture_ptr_copy(CTX,NO);
void GfxTexture_ptr_destroy(CTX,NO);
SV GfxTexture_ptr_get_member(CTX,NO,SV);
void GfxTexture_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxTexture_ptr_funcs={
.destroy = GfxTexture_ptr_destroy,
.getMember = GfxTexture_ptr_get_member,
.setMember = GfxTexture_ptr_set_member
};
template <>
struct create_val<GfxTexture *>
{
static SV f(CTX ctx,GfxTexture*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxTexture_ptr_funcs,obj,EXT->GfxTexture_ptr_typeID);
}
};
template <>
struct val_to_c<GfxTexture *>
{
static GfxTexture *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxTexture_ptr_typeID)
RET(GfxTexture*)obj->data;
else
 CATE(TE,"Value is not a GfxTextureRef."));
} else
 CATE(TE,"Value is not a GfxTextureRef."));
}
};
template <>
struct type_same<GfxTexture *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxTexture_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxTexture *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxTexture_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxTexture *>
{
static const GfxTexture *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxTexture_ptr_typeID)
RET(GfxTexture*)obj->data;
else
 CATE(TE,"Value is not a GfxTextureRef."));
} else
 CATE(TE,"Value is not a GfxTextureRef."));
}
};

SV GfxSubModelList_ptr_copy(CTX,NO);
void GfxSubModelList_ptr_destroy(CTX,NO);
SV GfxSubModelList_ptr_get_member(CTX,NO,SV);
void GfxSubModelList_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxSubModelList_ptr_funcs={
.destroy = GfxSubModelList_ptr_destroy,
.getMember = GfxSubModelList_ptr_get_member,
.setMember = GfxSubModelList_ptr_set_member
};
template <>
struct create_val<List<GfxModel::SubModel> *>
{
static SV f(CTX ctx,List<GfxModel::SubModel>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxSubModelList_ptr_funcs,obj,EXT->GfxSubModelList_ptr_typeID);
}
};
template <>
struct val_to_c<List<GfxModel::SubModel> *>
{
static List<GfxModel::SubModel> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxSubModelList_ptr_typeID)
RET(List<GfxModel::SubModel>*)obj->data;
else
 CATE(TE,"Value is not a GfxSubModelListRef."));
} else
 CATE(TE,"Value is not a GfxSubModelListRef."));
}
};
template <>
struct type_same<List<GfxModel::SubModel> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxSubModelList_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<GfxModel::SubModel> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxSubModelList_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<GfxModel::SubModel> *>
{
static const List<GfxModel::SubModel> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxSubModelList_ptr_typeID)
RET(List<GfxModel::SubModel>*)obj->data;
else
 CATE(TE,"Value is not a GfxSubModelListRef."));
} else
 CATE(TE,"Value is not a GfxSubModelListRef."));
}
};

SV GfxModel_ptr_copy(CTX,NO);
void GfxModel_ptr_destroy(CTX,NO);
SV GfxModel_ptr_get_member(CTX,NO,SV);
void GfxModel_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxModel_ptr_funcs={
.destroy = GfxModel_ptr_destroy,
.getMember = GfxModel_ptr_get_member,
.setMember = GfxModel_ptr_set_member
};
template <>
struct create_val<GfxModel *>
{
static SV f(CTX ctx,GfxModel*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxModel_ptr_funcs,obj,EXT->GfxModel_ptr_typeID);
}
};
template <>
struct val_to_c<GfxModel *>
{
static GfxModel *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxModel_ptr_typeID)
RET(GfxModel*)obj->data;
else
 CATE(TE,"Value is not a GfxModelRef."));
} else
 CATE(TE,"Value is not a GfxModelRef."));
}
};
template <>
struct type_same<GfxModel *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxModel_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxModel *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxModel_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxModel *>
{
static const GfxModel *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxModel_ptr_typeID)
RET(GfxModel*)obj->data;
else
 CATE(TE,"Value is not a GfxModelRef."));
} else
 CATE(TE,"Value is not a GfxModelRef."));
}
};

SV GfxLODList_ptr_copy(CTX,NO);
void GfxLODList_ptr_destroy(CTX,NO);
SV GfxLODList_ptr_get_member(CTX,NO,SV);
void GfxLODList_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxLODList_ptr_funcs={
.destroy = GfxLODList_ptr_destroy,
.getMember = GfxLODList_ptr_get_member,
.setMember = GfxLODList_ptr_set_member
};
template <>
struct create_val<List<GfxLOD> *>
{
static SV f(CTX ctx,List<GfxLOD>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxLODList_ptr_funcs,obj,EXT->GfxLODList_ptr_typeID);
}
};
template <>
struct val_to_c<List<GfxLOD> *>
{
static List<GfxLOD> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxLODList_ptr_typeID)
RET(List<GfxLOD>*)obj->data;
else
 CATE(TE,"Value is not a GfxLODListRef."));
} else
 CATE(TE,"Value is not a GfxLODListRef."));
}
};
template <>
struct type_same<List<GfxLOD> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxLODList_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<GfxLOD> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxLODList_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<GfxLOD> *>
{
static const List<GfxLOD> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxLODList_ptr_typeID)
RET(List<GfxLOD>*)obj->data;
else
 CATE(TE,"Value is not a GfxLODListRef."));
} else
 CATE(TE,"Value is not a GfxLODListRef."));
}
};

SV EntityList_ptr_copy(CTX,NO);
void EntityList_ptr_destroy(CTX,NO);
SV EntityList_ptr_get_member(CTX,NO,SV);
void EntityList_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs EntityList_ptr_funcs={
.destroy = EntityList_ptr_destroy,
.getMember = EntityList_ptr_get_member,
.setMember = EntityList_ptr_set_member
};
template <>
struct create_val<List<Entity*> *>
{
static SV f(CTX ctx,List<Entity*>*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(EntityList_ptr_funcs,obj,EXT->EntityList_ptr_typeID);
}
};
template <>
struct val_to_c<List<Entity*> *>
{
static List<Entity*> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->EntityList_ptr_typeID)
RET(List<Entity*>*)obj->data;
else
 CATE(TE,"Value is not a EntityListRef."));
} else
 CATE(TE,"Value is not a EntityListRef."));
}
};
template <>
struct type_same<List<Entity*> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->EntityList_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const List<Entity*> *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->EntityList_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const List<Entity*> *>
{
static const List<Entity*> *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->EntityList_ptr_typeID)
RET(List<Entity*>*)obj->data;
else
 CATE(TE,"Value is not a EntityListRef."));
} else
 CATE(TE,"Value is not a EntityListRef."));
}
};

SV GfxShaderCombination_ptr_copy(CTX,NO);
void GfxShaderCombination_ptr_destroy(CTX,NO);
SV GfxShaderCombination_ptr_get_member(CTX,NO,SV);
void GfxShaderCombination_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxShaderCombination_ptr_funcs={
.destroy = GfxShaderCombination_ptr_destroy,
.getMember = GfxShaderCombination_ptr_get_member,
.setMember = GfxShaderCombination_ptr_set_member
};
template <>
struct create_val<GfxShaderCombination *>
{
static SV f(CTX ctx,GfxShaderCombination*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxShaderCombination_ptr_funcs,obj,EXT->GfxShaderCombination_ptr_typeID);
}
};
template <>
struct val_to_c<GfxShaderCombination *>
{
static GfxShaderCombination *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxShaderCombination_ptr_typeID)
RET(GfxShaderCombination*)obj->data;
else
 CATE(TE,"Value is not a GfxShaderCombinationRef."));
} else
 CATE(TE,"Value is not a GfxShaderCombinationRef."));
}
};
template <>
struct type_same<GfxShaderCombination *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxShaderCombination_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxShaderCombination *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxShaderCombination_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxShaderCombination *>
{
static const GfxShaderCombination *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxShaderCombination_ptr_typeID)
RET(GfxShaderCombination*)obj->data;
else
 CATE(TE,"Value is not a GfxShaderCombinationRef."));
} else
 CATE(TE,"Value is not a GfxShaderCombinationRef."));
}
};

SV Matrix3x3_ptr_copy(CTX,NO);
void Matrix3x3_ptr_destroy(CTX,NO);
SV Matrix3x3_ptr_get_member(CTX,NO,SV);
void Matrix3x3_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs Matrix3x3_ptr_funcs={
.destroy = Matrix3x3_ptr_destroy,
.getMember = Matrix3x3_ptr_get_member,
.setMember = Matrix3x3_ptr_set_member
};
template <>
struct create_val<Matrix3x3 *>
{
static SV f(CTX ctx,Matrix3x3*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(Matrix3x3_ptr_funcs,obj,EXT->Matrix3x3_ptr_typeID);
}
};
template <>
struct val_to_c<Matrix3x3 *>
{
static Matrix3x3 *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Matrix3x3_ptr_typeID)
RET(Matrix3x3*)obj->data;
else
 CATE(TE,"Value is not a Matrix3x3Ref."));
} else
 CATE(TE,"Value is not a Matrix3x3Ref."));
}
};
template <>
struct type_same<Matrix3x3 *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Matrix3x3_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const Matrix3x3 *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->Matrix3x3_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const Matrix3x3 *>
{
static const Matrix3x3 *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->Matrix3x3_ptr_typeID)
RET(Matrix3x3*)obj->data;
else
 CATE(TE,"Value is not a Matrix3x3Ref."));
} else
 CATE(TE,"Value is not a Matrix3x3Ref."));
}
};

SV GfxDebugDrawer_ptr_copy(CTX,NO);
void GfxDebugDrawer_ptr_destroy(CTX,NO);
SV GfxDebugDrawer_ptr_get_member(CTX,NO,SV);
void GfxDebugDrawer_ptr_set_member(CTX,NO,SV,SV);
static const STG::NativeObjectFuncs GfxDebugDrawer_ptr_funcs={
.destroy = GfxDebugDrawer_ptr_destroy,
.getMember = GfxDebugDrawer_ptr_get_member,
.setMember = GfxDebugDrawer_ptr_set_member
};
template <>
struct create_val<GfxDebugDrawer *>
{
static SV f(CTX ctx,GfxDebugDrawer*obj)
{
AllocInfo i=getAllocInfo((void*)obj);
i.scriptRef = true;
setAllocInfo((void *)obj, i);
RET STG::createNativeObject(GfxDebugDrawer_ptr_funcs,obj,EXT->GfxDebugDrawer_ptr_typeID);
}
};
template <>
struct val_to_c<GfxDebugDrawer *>
{
static GfxDebugDrawer *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxDebugDrawer_ptr_typeID)
RET(GfxDebugDrawer*)obj->data;
else
 CATE(TE,"Value is not a GfxDebugDrawerRef."));
} else
 CATE(TE,"Value is not a GfxDebugDrawerRef."));
}
};
template <>
struct type_same<GfxDebugDrawer *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxDebugDrawer_ptr_typeID;
else
 RET false;
}
};
template <>
struct type_same<const GfxDebugDrawer *>
{
static bool f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
RET((NO)head)->typeID==EXT->GfxDebugDrawer_ptr_typeID;
else
 RET false;
}
};
template <>
struct val_to_c<const GfxDebugDrawer *>
{
static const GfxDebugDrawer *f(CTX ctx,const SV head)
{
if(head->type==STG::ValueType::NativeObject)
{
NO obj=(NO)head;
if(obj->typeID==EXT->GfxDebugDrawer_ptr_typeID)
RET(GfxDebugDrawer*)obj->data;
else
 CATE(TE,"Value is not a GfxDebugDrawerRef."));
} else
 CATE(TE,"Value is not a GfxDebugDrawerRef."));
}
};

SV Key___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("Key::__eq__")));
size_t f;
if(!TS(a[0],Key))
CATE(TE,FAE("Key::Key","Key")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],Key))
CATE(VE,UFOF("Key::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV Key_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Key");
EI(keyStr=="__eq__")
RET CNF(Key___eq__);
EI(keyStr=="ScrollLock")RET STG::createNativeObject(Key_funcs,(void *)271,EXT->Key_typeID);
EI(keyStr=="RightBracket")RET STG::createNativeObject(Key_funcs,(void *)93,EXT->Key_typeID);
EI(keyStr=="Pause")RET STG::createNativeObject(Key_funcs,(void *)274,EXT->Key_typeID);
EI(keyStr=="Backslash")RET STG::createNativeObject(Key_funcs,(void *)92,EXT->Key_typeID);
EI(keyStr=="LeftBracket")RET STG::createNativeObject(Key_funcs,(void *)91,EXT->Key_typeID);
EI(keyStr=="Space")RET STG::createNativeObject(Key_funcs,(void *)32,EXT->Key_typeID);
EI(keyStr=="Menu")RET STG::createNativeObject(Key_funcs,(void *)292,EXT->Key_typeID);
EI(keyStr=="Enter")RET STG::createNativeObject(Key_funcs,(void *)257,EXT->Key_typeID);
EI(keyStr=="F3")RET STG::createNativeObject(Key_funcs,(void *)277,EXT->Key_typeID);
EI(keyStr=="_2")RET STG::createNativeObject(Key_funcs,(void *)50,EXT->Key_typeID);
EI(keyStr=="RightControl")RET STG::createNativeObject(Key_funcs,(void *)289,EXT->Key_typeID);
EI(keyStr=="Backspace")RET STG::createNativeObject(Key_funcs,(void *)259,EXT->Key_typeID);
EI(keyStr=="Slash")RET STG::createNativeObject(Key_funcs,(void *)47,EXT->Key_typeID);
EI(keyStr=="X")RET STG::createNativeObject(Key_funcs,(void *)120,EXT->Key_typeID);
EI(keyStr=="End")RET STG::createNativeObject(Key_funcs,(void *)269,EXT->Key_typeID);
EI(keyStr=="Up")RET STG::createNativeObject(Key_funcs,(void *)265,EXT->Key_typeID);
EI(keyStr=="RightSuper")RET STG::createNativeObject(Key_funcs,(void *)291,EXT->Key_typeID);
EI(keyStr=="F9")RET STG::createNativeObject(Key_funcs,(void *)283,EXT->Key_typeID);
EI(keyStr=="LeftSuper")RET STG::createNativeObject(Key_funcs,(void *)287,EXT->Key_typeID);
EI(keyStr=="PrintScreen")RET STG::createNativeObject(Key_funcs,(void *)273,EXT->Key_typeID);
EI(keyStr=="Z")RET STG::createNativeObject(Key_funcs,(void *)122,EXT->Key_typeID);
EI(keyStr=="RightAlt")RET STG::createNativeObject(Key_funcs,(void *)290,EXT->Key_typeID);
EI(keyStr=="F5")RET STG::createNativeObject(Key_funcs,(void *)279,EXT->Key_typeID);
EI(keyStr=="PageUp")RET STG::createNativeObject(Key_funcs,(void *)266,EXT->Key_typeID);
EI(keyStr=="LeftShift")RET STG::createNativeObject(Key_funcs,(void *)284,EXT->Key_typeID);
EI(keyStr=="F7")RET STG::createNativeObject(Key_funcs,(void *)281,EXT->Key_typeID);
EI(keyStr=="LeftAlt")RET STG::createNativeObject(Key_funcs,(void *)286,EXT->Key_typeID);
EI(keyStr=="LeftControl")RET STG::createNativeObject(Key_funcs,(void *)285,EXT->Key_typeID);
EI(keyStr=="Unknown")RET STG::createNativeObject(Key_funcs,(void *)293,EXT->Key_typeID);
EI(keyStr=="Left")RET STG::createNativeObject(Key_funcs,(void *)263,EXT->Key_typeID);
EI(keyStr=="A")RET STG::createNativeObject(Key_funcs,(void *)97,EXT->Key_typeID);
EI(keyStr=="Insert")RET STG::createNativeObject(Key_funcs,(void *)260,EXT->Key_typeID);
EI(keyStr=="C")RET STG::createNativeObject(Key_funcs,(void *)99,EXT->Key_typeID);
EI(keyStr=="B")RET STG::createNativeObject(Key_funcs,(void *)98,EXT->Key_typeID);
EI(keyStr=="E")RET STG::createNativeObject(Key_funcs,(void *)101,EXT->Key_typeID);
EI(keyStr=="D")RET STG::createNativeObject(Key_funcs,(void *)100,EXT->Key_typeID);
EI(keyStr=="G")RET STG::createNativeObject(Key_funcs,(void *)103,EXT->Key_typeID);
EI(keyStr=="F")RET STG::createNativeObject(Key_funcs,(void *)102,EXT->Key_typeID);
EI(keyStr=="I")RET STG::createNativeObject(Key_funcs,(void *)105,EXT->Key_typeID);
EI(keyStr=="H")RET STG::createNativeObject(Key_funcs,(void *)104,EXT->Key_typeID);
EI(keyStr=="K")RET STG::createNativeObject(Key_funcs,(void *)107,EXT->Key_typeID);
EI(keyStr=="J")RET STG::createNativeObject(Key_funcs,(void *)106,EXT->Key_typeID);
EI(keyStr=="M")RET STG::createNativeObject(Key_funcs,(void *)109,EXT->Key_typeID);
EI(keyStr=="Equal")RET STG::createNativeObject(Key_funcs,(void *)61,EXT->Key_typeID);
EI(keyStr=="O")RET STG::createNativeObject(Key_funcs,(void *)111,EXT->Key_typeID);
EI(keyStr=="L")RET STG::createNativeObject(Key_funcs,(void *)108,EXT->Key_typeID);
EI(keyStr=="Q")RET STG::createNativeObject(Key_funcs,(void *)113,EXT->Key_typeID);
EI(keyStr=="P")RET STG::createNativeObject(Key_funcs,(void *)112,EXT->Key_typeID);
EI(keyStr=="S")RET STG::createNativeObject(Key_funcs,(void *)115,EXT->Key_typeID);
EI(keyStr=="R")RET STG::createNativeObject(Key_funcs,(void *)114,EXT->Key_typeID);
EI(keyStr=="U")RET STG::createNativeObject(Key_funcs,(void *)117,EXT->Key_typeID);
EI(keyStr=="T")RET STG::createNativeObject(Key_funcs,(void *)116,EXT->Key_typeID);
EI(keyStr=="W")RET STG::createNativeObject(Key_funcs,(void *)119,EXT->Key_typeID);
EI(keyStr=="V")RET STG::createNativeObject(Key_funcs,(void *)118,EXT->Key_typeID);
EI(keyStr=="Y")RET STG::createNativeObject(Key_funcs,(void *)121,EXT->Key_typeID);
EI(keyStr=="Apostrophe")RET STG::createNativeObject(Key_funcs,(void *)39,EXT->Key_typeID);
EI(keyStr=="NumLock")RET STG::createNativeObject(Key_funcs,(void *)272,EXT->Key_typeID);
EI(keyStr=="N")RET STG::createNativeObject(Key_funcs,(void *)110,EXT->Key_typeID);
EI(keyStr=="CapsLock")RET STG::createNativeObject(Key_funcs,(void *)270,EXT->Key_typeID);
EI(keyStr=="Minus")RET STG::createNativeObject(Key_funcs,(void *)45,EXT->Key_typeID);
EI(keyStr=="Delete")RET STG::createNativeObject(Key_funcs,(void *)261,EXT->Key_typeID);
EI(keyStr=="F1")RET STG::createNativeObject(Key_funcs,(void *)275,EXT->Key_typeID);
EI(keyStr=="F2")RET STG::createNativeObject(Key_funcs,(void *)276,EXT->Key_typeID);
EI(keyStr=="Right")RET STG::createNativeObject(Key_funcs,(void *)262,EXT->Key_typeID);
EI(keyStr=="F4")RET STG::createNativeObject(Key_funcs,(void *)278,EXT->Key_typeID);
EI(keyStr=="_9")RET STG::createNativeObject(Key_funcs,(void *)57,EXT->Key_typeID);
EI(keyStr=="Semicolon")RET STG::createNativeObject(Key_funcs,(void *)59,EXT->Key_typeID);
EI(keyStr=="_8")RET STG::createNativeObject(Key_funcs,(void *)56,EXT->Key_typeID);
EI(keyStr=="_7")RET STG::createNativeObject(Key_funcs,(void *)55,EXT->Key_typeID);
EI(keyStr=="_6")RET STG::createNativeObject(Key_funcs,(void *)54,EXT->Key_typeID);
EI(keyStr=="_5")RET STG::createNativeObject(Key_funcs,(void *)53,EXT->Key_typeID);
EI(keyStr=="_4")RET STG::createNativeObject(Key_funcs,(void *)52,EXT->Key_typeID);
EI(keyStr=="_3")RET STG::createNativeObject(Key_funcs,(void *)51,EXT->Key_typeID);
EI(keyStr=="Period")RET STG::createNativeObject(Key_funcs,(void *)46,EXT->Key_typeID);
EI(keyStr=="_1")RET STG::createNativeObject(Key_funcs,(void *)49,EXT->Key_typeID);
EI(keyStr=="_0")RET STG::createNativeObject(Key_funcs,(void *)48,EXT->Key_typeID);
EI(keyStr=="Down")RET STG::createNativeObject(Key_funcs,(void *)264,EXT->Key_typeID);
EI(keyStr=="F8")RET STG::createNativeObject(Key_funcs,(void *)282,EXT->Key_typeID);
EI(keyStr=="Comma")RET STG::createNativeObject(Key_funcs,(void *)44,EXT->Key_typeID);
EI(keyStr=="PageDown")RET STG::createNativeObject(Key_funcs,(void *)267,EXT->Key_typeID);
EI(keyStr=="Tab")RET STG::createNativeObject(Key_funcs,(void *)258,EXT->Key_typeID);
EI(keyStr=="Escape")RET STG::createNativeObject(Key_funcs,(void *)256,EXT->Key_typeID);
EI(keyStr=="Home")RET STG::createNativeObject(Key_funcs,(void *)268,EXT->Key_typeID);
EI(keyStr=="F6")RET STG::createNativeObject(Key_funcs,(void *)280,EXT->Key_typeID);
EI(keyStr=="RightShift")RET STG::createNativeObject(Key_funcs,(void *)288,EXT->Key_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Key");
EI(keyStr=="__eq__")
RET CNF(Key___eq__);
EI(keyStr=="ScrollLock")RET STG::createNativeObject(Key_funcs,(void *)271,EXT->Key_typeID);
EI(keyStr=="RightBracket")RET STG::createNativeObject(Key_funcs,(void *)93,EXT->Key_typeID);
EI(keyStr=="Pause")RET STG::createNativeObject(Key_funcs,(void *)274,EXT->Key_typeID);
EI(keyStr=="Backslash")RET STG::createNativeObject(Key_funcs,(void *)92,EXT->Key_typeID);
EI(keyStr=="LeftBracket")RET STG::createNativeObject(Key_funcs,(void *)91,EXT->Key_typeID);
EI(keyStr=="Space")RET STG::createNativeObject(Key_funcs,(void *)32,EXT->Key_typeID);
EI(keyStr=="Menu")RET STG::createNativeObject(Key_funcs,(void *)292,EXT->Key_typeID);
EI(keyStr=="Enter")RET STG::createNativeObject(Key_funcs,(void *)257,EXT->Key_typeID);
EI(keyStr=="F3")RET STG::createNativeObject(Key_funcs,(void *)277,EXT->Key_typeID);
EI(keyStr=="_2")RET STG::createNativeObject(Key_funcs,(void *)50,EXT->Key_typeID);
EI(keyStr=="RightControl")RET STG::createNativeObject(Key_funcs,(void *)289,EXT->Key_typeID);
EI(keyStr=="Backspace")RET STG::createNativeObject(Key_funcs,(void *)259,EXT->Key_typeID);
EI(keyStr=="Slash")RET STG::createNativeObject(Key_funcs,(void *)47,EXT->Key_typeID);
EI(keyStr=="X")RET STG::createNativeObject(Key_funcs,(void *)120,EXT->Key_typeID);
EI(keyStr=="End")RET STG::createNativeObject(Key_funcs,(void *)269,EXT->Key_typeID);
EI(keyStr=="Up")RET STG::createNativeObject(Key_funcs,(void *)265,EXT->Key_typeID);
EI(keyStr=="RightSuper")RET STG::createNativeObject(Key_funcs,(void *)291,EXT->Key_typeID);
EI(keyStr=="F9")RET STG::createNativeObject(Key_funcs,(void *)283,EXT->Key_typeID);
EI(keyStr=="LeftSuper")RET STG::createNativeObject(Key_funcs,(void *)287,EXT->Key_typeID);
EI(keyStr=="PrintScreen")RET STG::createNativeObject(Key_funcs,(void *)273,EXT->Key_typeID);
EI(keyStr=="Z")RET STG::createNativeObject(Key_funcs,(void *)122,EXT->Key_typeID);
EI(keyStr=="RightAlt")RET STG::createNativeObject(Key_funcs,(void *)290,EXT->Key_typeID);
EI(keyStr=="F5")RET STG::createNativeObject(Key_funcs,(void *)279,EXT->Key_typeID);
EI(keyStr=="PageUp")RET STG::createNativeObject(Key_funcs,(void *)266,EXT->Key_typeID);
EI(keyStr=="LeftShift")RET STG::createNativeObject(Key_funcs,(void *)284,EXT->Key_typeID);
EI(keyStr=="F7")RET STG::createNativeObject(Key_funcs,(void *)281,EXT->Key_typeID);
EI(keyStr=="LeftAlt")RET STG::createNativeObject(Key_funcs,(void *)286,EXT->Key_typeID);
EI(keyStr=="LeftControl")RET STG::createNativeObject(Key_funcs,(void *)285,EXT->Key_typeID);
EI(keyStr=="Unknown")RET STG::createNativeObject(Key_funcs,(void *)293,EXT->Key_typeID);
EI(keyStr=="Left")RET STG::createNativeObject(Key_funcs,(void *)263,EXT->Key_typeID);
EI(keyStr=="A")RET STG::createNativeObject(Key_funcs,(void *)97,EXT->Key_typeID);
EI(keyStr=="Insert")RET STG::createNativeObject(Key_funcs,(void *)260,EXT->Key_typeID);
EI(keyStr=="C")RET STG::createNativeObject(Key_funcs,(void *)99,EXT->Key_typeID);
EI(keyStr=="B")RET STG::createNativeObject(Key_funcs,(void *)98,EXT->Key_typeID);
EI(keyStr=="E")RET STG::createNativeObject(Key_funcs,(void *)101,EXT->Key_typeID);
EI(keyStr=="D")RET STG::createNativeObject(Key_funcs,(void *)100,EXT->Key_typeID);
EI(keyStr=="G")RET STG::createNativeObject(Key_funcs,(void *)103,EXT->Key_typeID);
EI(keyStr=="F")RET STG::createNativeObject(Key_funcs,(void *)102,EXT->Key_typeID);
EI(keyStr=="I")RET STG::createNativeObject(Key_funcs,(void *)105,EXT->Key_typeID);
EI(keyStr=="H")RET STG::createNativeObject(Key_funcs,(void *)104,EXT->Key_typeID);
EI(keyStr=="K")RET STG::createNativeObject(Key_funcs,(void *)107,EXT->Key_typeID);
EI(keyStr=="J")RET STG::createNativeObject(Key_funcs,(void *)106,EXT->Key_typeID);
EI(keyStr=="M")RET STG::createNativeObject(Key_funcs,(void *)109,EXT->Key_typeID);
EI(keyStr=="Equal")RET STG::createNativeObject(Key_funcs,(void *)61,EXT->Key_typeID);
EI(keyStr=="O")RET STG::createNativeObject(Key_funcs,(void *)111,EXT->Key_typeID);
EI(keyStr=="L")RET STG::createNativeObject(Key_funcs,(void *)108,EXT->Key_typeID);
EI(keyStr=="Q")RET STG::createNativeObject(Key_funcs,(void *)113,EXT->Key_typeID);
EI(keyStr=="P")RET STG::createNativeObject(Key_funcs,(void *)112,EXT->Key_typeID);
EI(keyStr=="S")RET STG::createNativeObject(Key_funcs,(void *)115,EXT->Key_typeID);
EI(keyStr=="R")RET STG::createNativeObject(Key_funcs,(void *)114,EXT->Key_typeID);
EI(keyStr=="U")RET STG::createNativeObject(Key_funcs,(void *)117,EXT->Key_typeID);
EI(keyStr=="T")RET STG::createNativeObject(Key_funcs,(void *)116,EXT->Key_typeID);
EI(keyStr=="W")RET STG::createNativeObject(Key_funcs,(void *)119,EXT->Key_typeID);
EI(keyStr=="V")RET STG::createNativeObject(Key_funcs,(void *)118,EXT->Key_typeID);
EI(keyStr=="Y")RET STG::createNativeObject(Key_funcs,(void *)121,EXT->Key_typeID);
EI(keyStr=="Apostrophe")RET STG::createNativeObject(Key_funcs,(void *)39,EXT->Key_typeID);
EI(keyStr=="NumLock")RET STG::createNativeObject(Key_funcs,(void *)272,EXT->Key_typeID);
EI(keyStr=="N")RET STG::createNativeObject(Key_funcs,(void *)110,EXT->Key_typeID);
EI(keyStr=="CapsLock")RET STG::createNativeObject(Key_funcs,(void *)270,EXT->Key_typeID);
EI(keyStr=="Minus")RET STG::createNativeObject(Key_funcs,(void *)45,EXT->Key_typeID);
EI(keyStr=="Delete")RET STG::createNativeObject(Key_funcs,(void *)261,EXT->Key_typeID);
EI(keyStr=="F1")RET STG::createNativeObject(Key_funcs,(void *)275,EXT->Key_typeID);
EI(keyStr=="F2")RET STG::createNativeObject(Key_funcs,(void *)276,EXT->Key_typeID);
EI(keyStr=="Right")RET STG::createNativeObject(Key_funcs,(void *)262,EXT->Key_typeID);
EI(keyStr=="F4")RET STG::createNativeObject(Key_funcs,(void *)278,EXT->Key_typeID);
EI(keyStr=="_9")RET STG::createNativeObject(Key_funcs,(void *)57,EXT->Key_typeID);
EI(keyStr=="Semicolon")RET STG::createNativeObject(Key_funcs,(void *)59,EXT->Key_typeID);
EI(keyStr=="_8")RET STG::createNativeObject(Key_funcs,(void *)56,EXT->Key_typeID);
EI(keyStr=="_7")RET STG::createNativeObject(Key_funcs,(void *)55,EXT->Key_typeID);
EI(keyStr=="_6")RET STG::createNativeObject(Key_funcs,(void *)54,EXT->Key_typeID);
EI(keyStr=="_5")RET STG::createNativeObject(Key_funcs,(void *)53,EXT->Key_typeID);
EI(keyStr=="_4")RET STG::createNativeObject(Key_funcs,(void *)52,EXT->Key_typeID);
EI(keyStr=="_3")RET STG::createNativeObject(Key_funcs,(void *)51,EXT->Key_typeID);
EI(keyStr=="Period")RET STG::createNativeObject(Key_funcs,(void *)46,EXT->Key_typeID);
EI(keyStr=="_1")RET STG::createNativeObject(Key_funcs,(void *)49,EXT->Key_typeID);
EI(keyStr=="_0")RET STG::createNativeObject(Key_funcs,(void *)48,EXT->Key_typeID);
EI(keyStr=="Down")RET STG::createNativeObject(Key_funcs,(void *)264,EXT->Key_typeID);
EI(keyStr=="F8")RET STG::createNativeObject(Key_funcs,(void *)282,EXT->Key_typeID);
EI(keyStr=="Comma")RET STG::createNativeObject(Key_funcs,(void *)44,EXT->Key_typeID);
EI(keyStr=="PageDown")RET STG::createNativeObject(Key_funcs,(void *)267,EXT->Key_typeID);
EI(keyStr=="Tab")RET STG::createNativeObject(Key_funcs,(void *)258,EXT->Key_typeID);
EI(keyStr=="Escape")RET STG::createNativeObject(Key_funcs,(void *)256,EXT->Key_typeID);
EI(keyStr=="Home")RET STG::createNativeObject(Key_funcs,(void *)268,EXT->Key_typeID);
EI(keyStr=="F6")RET STG::createNativeObject(Key_funcs,(void *)280,EXT->Key_typeID);
EI(keyStr=="RightShift")RET STG::createNativeObject(Key_funcs,(void *)288,EXT->Key_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void Key_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV MouseButton___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("MouseButton::__eq__")));
size_t f;
if(!TS(a[0],MouseButton))
CATE(TE,FAE("MouseButton::MouseButton","MouseButton")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],MouseButton))
CATE(VE,UFOF("MouseButton::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV MouseButton_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("MouseButton");
EI(keyStr=="__eq__")
RET CNF(MouseButton___eq__);
EI(keyStr=="Middle")RET STG::createNativeObject(MouseButton_funcs,(void *)1,EXT->MouseButton_typeID);
EI(keyStr=="Right")RET STG::createNativeObject(MouseButton_funcs,(void *)2,EXT->MouseButton_typeID);
EI(keyStr=="Unknown")RET STG::createNativeObject(MouseButton_funcs,(void *)3,EXT->MouseButton_typeID);
EI(keyStr=="Left")RET STG::createNativeObject(MouseButton_funcs,(void *)0,EXT->MouseButton_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("MouseButton");
EI(keyStr=="__eq__")
RET CNF(MouseButton___eq__);
EI(keyStr=="Middle")RET STG::createNativeObject(MouseButton_funcs,(void *)1,EXT->MouseButton_typeID);
EI(keyStr=="Right")RET STG::createNativeObject(MouseButton_funcs,(void *)2,EXT->MouseButton_typeID);
EI(keyStr=="Unknown")RET STG::createNativeObject(MouseButton_funcs,(void *)3,EXT->MouseButton_typeID);
EI(keyStr=="Left")RET STG::createNativeObject(MouseButton_funcs,(void *)0,EXT->MouseButton_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void MouseButton_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV EventType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("EventType::__eq__")));
size_t f;
if(!TS(a[0],EventType))
CATE(TE,FAE("EventType::EventType","EventType")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],EventType))
CATE(VE,UFOF("EventType::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV EventType_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("EventType");
EI(keyStr=="__eq__")
RET CNF(EventType___eq__);
EI(keyStr=="WindowResize")RET STG::createNativeObject(EventType_funcs,(void *)1,EXT->EventType_typeID);
EI(keyStr=="Quit")RET STG::createNativeObject(EventType_funcs,(void *)0,EXT->EventType_typeID);
EI(keyStr=="MouseWheel")RET STG::createNativeObject(EventType_funcs,(void *)7,EXT->EventType_typeID);
EI(keyStr=="MouseMotion")RET STG::createNativeObject(EventType_funcs,(void *)4,EXT->EventType_typeID);
EI(keyStr=="Unknown")RET STG::createNativeObject(EventType_funcs,(void *)8,EXT->EventType_typeID);
EI(keyStr=="MouseButtonDown")RET STG::createNativeObject(EventType_funcs,(void *)5,EXT->EventType_typeID);
EI(keyStr=="KeyUp")RET STG::createNativeObject(EventType_funcs,(void *)3,EXT->EventType_typeID);
EI(keyStr=="KeyDown")RET STG::createNativeObject(EventType_funcs,(void *)2,EXT->EventType_typeID);
EI(keyStr=="MouseButtonUp")RET STG::createNativeObject(EventType_funcs,(void *)6,EXT->EventType_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("EventType");
EI(keyStr=="__eq__")
RET CNF(EventType___eq__);
EI(keyStr=="WindowResize")RET STG::createNativeObject(EventType_funcs,(void *)1,EXT->EventType_typeID);
EI(keyStr=="Quit")RET STG::createNativeObject(EventType_funcs,(void *)0,EXT->EventType_typeID);
EI(keyStr=="MouseWheel")RET STG::createNativeObject(EventType_funcs,(void *)7,EXT->EventType_typeID);
EI(keyStr=="MouseMotion")RET STG::createNativeObject(EventType_funcs,(void *)4,EXT->EventType_typeID);
EI(keyStr=="Unknown")RET STG::createNativeObject(EventType_funcs,(void *)8,EXT->EventType_typeID);
EI(keyStr=="MouseButtonDown")RET STG::createNativeObject(EventType_funcs,(void *)5,EXT->EventType_typeID);
EI(keyStr=="KeyUp")RET STG::createNativeObject(EventType_funcs,(void *)3,EXT->EventType_typeID);
EI(keyStr=="KeyDown")RET STG::createNativeObject(EventType_funcs,(void *)2,EXT->EventType_typeID);
EI(keyStr=="MouseButtonUp")RET STG::createNativeObject(EventType_funcs,(void *)6,EXT->EventType_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void EventType_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV FileOrigin___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("FileOrigin::__eq__")));
size_t f;
if(!TS(a[0],FileOrigin))
CATE(TE,FAE("FileOrigin::FileOrigin","FileOrigin")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],FileOrigin))
CATE(VE,UFOF("FileOrigin::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV FileOrigin_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("FileOrigin");
EI(keyStr=="__eq__")
RET CNF(FileOrigin___eq__);
EI(keyStr=="Current")RET STG::createNativeObject(FileOrigin_funcs,(void *)1,EXT->FileOrigin_typeID);
EI(keyStr=="Set")RET STG::createNativeObject(FileOrigin_funcs,(void *)0,EXT->FileOrigin_typeID);
EI(keyStr=="End")RET STG::createNativeObject(FileOrigin_funcs,(void *)2,EXT->FileOrigin_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("FileOrigin");
EI(keyStr=="__eq__")
RET CNF(FileOrigin___eq__);
EI(keyStr=="Current")RET STG::createNativeObject(FileOrigin_funcs,(void *)1,EXT->FileOrigin_typeID);
EI(keyStr=="Set")RET STG::createNativeObject(FileOrigin_funcs,(void *)0,EXT->FileOrigin_typeID);
EI(keyStr=="End")RET STG::createNativeObject(FileOrigin_funcs,(void *)2,EXT->FileOrigin_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void FileOrigin_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV XOrigin___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("XOrigin::__eq__")));
size_t f;
if(!TS(a[0],XOrigin))
CATE(TE,FAE("XOrigin::XOrigin","XOrigin")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],XOrigin))
CATE(VE,UFOF("XOrigin::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV XOrigin_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("XOrigin");
EI(keyStr=="__eq__")
RET CNF(XOrigin___eq__);
EI(keyStr=="Right")RET STG::createNativeObject(XOrigin_funcs,(void *)1,EXT->XOrigin_typeID);
EI(keyStr=="Left")RET STG::createNativeObject(XOrigin_funcs,(void *)0,EXT->XOrigin_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("XOrigin");
EI(keyStr=="__eq__")
RET CNF(XOrigin___eq__);
EI(keyStr=="Right")RET STG::createNativeObject(XOrigin_funcs,(void *)1,EXT->XOrigin_typeID);
EI(keyStr=="Left")RET STG::createNativeObject(XOrigin_funcs,(void *)0,EXT->XOrigin_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void XOrigin_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV ResType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("ResType::__eq__")));
size_t f;
if(!TS(a[0],ResType))
CATE(TE,FAE("ResType::ResType","ResType")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],ResType))
CATE(VE,UFOF("ResType::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV ResType_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("ResType");
EI(keyStr=="__eq__")
RET CNF(ResType___eq__);
EI(keyStr=="GfxMaterialType")RET STG::createNativeObject(ResType_funcs,(void *)3,EXT->ResType_typeID);
EI(keyStr=="ScriptType")RET STG::createNativeObject(ResType_funcs,(void *)6,EXT->ResType_typeID);
EI(keyStr=="GfxTextureType")RET STG::createNativeObject(ResType_funcs,(void *)1,EXT->ResType_typeID);
EI(keyStr=="GfxMeshType")RET STG::createNativeObject(ResType_funcs,(void *)2,EXT->ResType_typeID);
EI(keyStr=="AudioType")RET STG::createNativeObject(ResType_funcs,(void *)8,EXT->ResType_typeID);
EI(keyStr=="FontType")RET STG::createNativeObject(ResType_funcs,(void *)9,EXT->ResType_typeID);
EI(keyStr=="GfxModelType")RET STG::createNativeObject(ResType_funcs,(void *)4,EXT->ResType_typeID);
EI(keyStr=="PhysicsShapeType")RET STG::createNativeObject(ResType_funcs,(void *)7,EXT->ResType_typeID);
EI(keyStr=="GfxShaderType")RET STG::createNativeObject(ResType_funcs,(void *)0,EXT->ResType_typeID);
EI(keyStr=="SceneType")RET STG::createNativeObject(ResType_funcs,(void *)5,EXT->ResType_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("ResType");
EI(keyStr=="__eq__")
RET CNF(ResType___eq__);
EI(keyStr=="GfxMaterialType")RET STG::createNativeObject(ResType_funcs,(void *)3,EXT->ResType_typeID);
EI(keyStr=="ScriptType")RET STG::createNativeObject(ResType_funcs,(void *)6,EXT->ResType_typeID);
EI(keyStr=="GfxTextureType")RET STG::createNativeObject(ResType_funcs,(void *)1,EXT->ResType_typeID);
EI(keyStr=="GfxMeshType")RET STG::createNativeObject(ResType_funcs,(void *)2,EXT->ResType_typeID);
EI(keyStr=="AudioType")RET STG::createNativeObject(ResType_funcs,(void *)8,EXT->ResType_typeID);
EI(keyStr=="FontType")RET STG::createNativeObject(ResType_funcs,(void *)9,EXT->ResType_typeID);
EI(keyStr=="GfxModelType")RET STG::createNativeObject(ResType_funcs,(void *)4,EXT->ResType_typeID);
EI(keyStr=="PhysicsShapeType")RET STG::createNativeObject(ResType_funcs,(void *)7,EXT->ResType_typeID);
EI(keyStr=="GfxShaderType")RET STG::createNativeObject(ResType_funcs,(void *)0,EXT->ResType_typeID);
EI(keyStr=="SceneType")RET STG::createNativeObject(ResType_funcs,(void *)5,EXT->ResType_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void ResType_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxPrimitive___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxPrimitive::__eq__")));
size_t f;
if(!TS(a[0],GfxPrimitive))
CATE(TE,FAE("GfxPrimitive::GfxPrimitive","GfxPrimitive")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxPrimitive))
CATE(VE,UFOF("GfxPrimitive::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxPrimitive_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxPrimitive");
EI(keyStr=="__eq__")
RET CNF(GfxPrimitive___eq__);
EI(keyStr=="GfxLineStrip")RET STG::createNativeObject(GfxPrimitive_funcs,(void *)1,EXT->GfxPrimitive_typeID);
EI(keyStr=="GfxTriangleFan")RET STG::createNativeObject(GfxPrimitive_funcs,(void *)5,EXT->GfxPrimitive_typeID);
EI(keyStr=="GfxTriangles")RET STG::createNativeObject(GfxPrimitive_funcs,(void *)6,EXT->GfxPrimitive_typeID);
EI(keyStr=="GfxPoints")RET STG::createNativeObject(GfxPrimitive_funcs,(void *)0,EXT->GfxPrimitive_typeID);
EI(keyStr=="GfxLines")RET STG::createNativeObject(GfxPrimitive_funcs,(void *)3,EXT->GfxPrimitive_typeID);
EI(keyStr=="GfxLineLoop")RET STG::createNativeObject(GfxPrimitive_funcs,(void *)2,EXT->GfxPrimitive_typeID);
EI(keyStr=="GfxTriangleStrip")RET STG::createNativeObject(GfxPrimitive_funcs,(void *)4,EXT->GfxPrimitive_typeID);
EI(keyStr=="GfxPatches")RET STG::createNativeObject(GfxPrimitive_funcs,(void *)7,EXT->GfxPrimitive_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxPrimitive");
EI(keyStr=="__eq__")
RET CNF(GfxPrimitive___eq__);
EI(keyStr=="GfxLineStrip")RET STG::createNativeObject(GfxPrimitive_funcs,(void *)1,EXT->GfxPrimitive_typeID);
EI(keyStr=="GfxTriangleFan")RET STG::createNativeObject(GfxPrimitive_funcs,(void *)5,EXT->GfxPrimitive_typeID);
EI(keyStr=="GfxTriangles")RET STG::createNativeObject(GfxPrimitive_funcs,(void *)6,EXT->GfxPrimitive_typeID);
EI(keyStr=="GfxPoints")RET STG::createNativeObject(GfxPrimitive_funcs,(void *)0,EXT->GfxPrimitive_typeID);
EI(keyStr=="GfxLines")RET STG::createNativeObject(GfxPrimitive_funcs,(void *)3,EXT->GfxPrimitive_typeID);
EI(keyStr=="GfxLineLoop")RET STG::createNativeObject(GfxPrimitive_funcs,(void *)2,EXT->GfxPrimitive_typeID);
EI(keyStr=="GfxTriangleStrip")RET STG::createNativeObject(GfxPrimitive_funcs,(void *)4,EXT->GfxPrimitive_typeID);
EI(keyStr=="GfxPatches")RET STG::createNativeObject(GfxPrimitive_funcs,(void *)7,EXT->GfxPrimitive_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxPrimitive_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxDepthFunction___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxDepthFunction::__eq__")));
size_t f;
if(!TS(a[0],GfxDepthFunction))
CATE(TE,FAE("GfxDepthFunction::GfxDepthFunction","GfxDepthFunction")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxDepthFunction))
CATE(VE,UFOF("GfxDepthFunction::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxDepthFunction_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxDepthFunction");
EI(keyStr=="__eq__")
RET CNF(GfxDepthFunction___eq__);
EI(keyStr=="GfxGreaterEqual")RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)6,EXT->GfxDepthFunction_typeID);
EI(keyStr=="GfxNever")RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)0,EXT->GfxDepthFunction_typeID);
EI(keyStr=="GfxLessEqual")RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)3,EXT->GfxDepthFunction_typeID);
EI(keyStr=="GfxAlways")RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)7,EXT->GfxDepthFunction_typeID);
EI(keyStr=="GfxLess")RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)1,EXT->GfxDepthFunction_typeID);
EI(keyStr=="GfxGreater")RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)4,EXT->GfxDepthFunction_typeID);
EI(keyStr=="GfxEqual")RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)2,EXT->GfxDepthFunction_typeID);
EI(keyStr=="GfxNotEqual")RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)5,EXT->GfxDepthFunction_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxDepthFunction");
EI(keyStr=="__eq__")
RET CNF(GfxDepthFunction___eq__);
EI(keyStr=="GfxGreaterEqual")RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)6,EXT->GfxDepthFunction_typeID);
EI(keyStr=="GfxNever")RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)0,EXT->GfxDepthFunction_typeID);
EI(keyStr=="GfxLessEqual")RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)3,EXT->GfxDepthFunction_typeID);
EI(keyStr=="GfxAlways")RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)7,EXT->GfxDepthFunction_typeID);
EI(keyStr=="GfxLess")RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)1,EXT->GfxDepthFunction_typeID);
EI(keyStr=="GfxGreater")RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)4,EXT->GfxDepthFunction_typeID);
EI(keyStr=="GfxEqual")RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)2,EXT->GfxDepthFunction_typeID);
EI(keyStr=="GfxNotEqual")RET STG::createNativeObject(GfxDepthFunction_funcs,(void *)5,EXT->GfxDepthFunction_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxDepthFunction_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxBlendMode___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxBlendMode::__eq__")));
size_t f;
if(!TS(a[0],GfxBlendMode))
CATE(TE,FAE("GfxBlendMode::GfxBlendMode","GfxBlendMode")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxBlendMode))
CATE(VE,UFOF("GfxBlendMode::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxBlendMode_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxBlendMode");
EI(keyStr=="__eq__")
RET CNF(GfxBlendMode___eq__);
EI(keyStr=="GfxReverseSubtract")RET STG::createNativeObject(GfxBlendMode_funcs,(void *)2,EXT->GfxBlendMode_typeID);
EI(keyStr=="GfxAdd")RET STG::createNativeObject(GfxBlendMode_funcs,(void *)0,EXT->GfxBlendMode_typeID);
EI(keyStr=="GfxSubtract")RET STG::createNativeObject(GfxBlendMode_funcs,(void *)1,EXT->GfxBlendMode_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxBlendMode");
EI(keyStr=="__eq__")
RET CNF(GfxBlendMode___eq__);
EI(keyStr=="GfxReverseSubtract")RET STG::createNativeObject(GfxBlendMode_funcs,(void *)2,EXT->GfxBlendMode_typeID);
EI(keyStr=="GfxAdd")RET STG::createNativeObject(GfxBlendMode_funcs,(void *)0,EXT->GfxBlendMode_typeID);
EI(keyStr=="GfxSubtract")RET STG::createNativeObject(GfxBlendMode_funcs,(void *)1,EXT->GfxBlendMode_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxBlendMode_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxBlendFactor___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxBlendFactor::__eq__")));
size_t f;
if(!TS(a[0],GfxBlendFactor))
CATE(TE,FAE("GfxBlendFactor::GfxBlendFactor","GfxBlendFactor")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxBlendFactor))
CATE(VE,UFOF("GfxBlendFactor::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxBlendFactor_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxBlendFactor");
EI(keyStr=="__eq__")
RET CNF(GfxBlendFactor___eq__);
EI(keyStr=="GfxZero")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)0,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxSrcColor")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)2,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxOneMinusSrcAlpha")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)7,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxConstantAlpha")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)12,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxDstAlpha")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)8,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxSrcAlpha")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)6,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxOneMinusDstColor")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)5,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxDstColor")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)4,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxOneMinusConstantColor")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)11,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxOneMinusSrcColor")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)3,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxConstantColor")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)10,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxOneMinusConstantAlpha")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)13,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxOne")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)1,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxOneMinusDstAlpha")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)9,EXT->GfxBlendFactor_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxBlendFactor");
EI(keyStr=="__eq__")
RET CNF(GfxBlendFactor___eq__);
EI(keyStr=="GfxZero")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)0,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxSrcColor")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)2,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxOneMinusSrcAlpha")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)7,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxConstantAlpha")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)12,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxDstAlpha")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)8,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxSrcAlpha")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)6,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxOneMinusDstColor")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)5,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxDstColor")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)4,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxOneMinusConstantColor")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)11,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxOneMinusSrcColor")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)3,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxConstantColor")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)10,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxOneMinusConstantAlpha")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)13,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxOne")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)1,EXT->GfxBlendFactor_typeID);
EI(keyStr=="GfxOneMinusDstAlpha")RET STG::createNativeObject(GfxBlendFactor_funcs,(void *)9,EXT->GfxBlendFactor_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxBlendFactor_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxCullMode___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxCullMode::__eq__")));
size_t f;
if(!TS(a[0],GfxCullMode))
CATE(TE,FAE("GfxCullMode::GfxCullMode","GfxCullMode")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxCullMode))
CATE(VE,UFOF("GfxCullMode::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxCullMode_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxCullMode");
EI(keyStr=="__eq__")
RET CNF(GfxCullMode___eq__);
EI(keyStr=="GfxCullNone")RET STG::createNativeObject(GfxCullMode_funcs,(void *)0,EXT->GfxCullMode_typeID);
EI(keyStr=="GfxCullBack")RET STG::createNativeObject(GfxCullMode_funcs,(void *)2,EXT->GfxCullMode_typeID);
EI(keyStr=="GfxCullFront")RET STG::createNativeObject(GfxCullMode_funcs,(void *)1,EXT->GfxCullMode_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxCullMode");
EI(keyStr=="__eq__")
RET CNF(GfxCullMode___eq__);
EI(keyStr=="GfxCullNone")RET STG::createNativeObject(GfxCullMode_funcs,(void *)0,EXT->GfxCullMode_typeID);
EI(keyStr=="GfxCullBack")RET STG::createNativeObject(GfxCullMode_funcs,(void *)2,EXT->GfxCullMode_typeID);
EI(keyStr=="GfxCullFront")RET STG::createNativeObject(GfxCullMode_funcs,(void *)1,EXT->GfxCullMode_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxCullMode_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxWinding___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxWinding::__eq__")));
size_t f;
if(!TS(a[0],GfxWinding))
CATE(TE,FAE("GfxWinding::GfxWinding","GfxWinding")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxWinding))
CATE(VE,UFOF("GfxWinding::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxWinding_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxWinding");
EI(keyStr=="__eq__")
RET CNF(GfxWinding___eq__);
EI(keyStr=="GfxCCW")RET STG::createNativeObject(GfxWinding_funcs,(void *)1,EXT->GfxWinding_typeID);
EI(keyStr=="GfxCW")RET STG::createNativeObject(GfxWinding_funcs,(void *)0,EXT->GfxWinding_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxWinding");
EI(keyStr=="__eq__")
RET CNF(GfxWinding___eq__);
EI(keyStr=="GfxCCW")RET STG::createNativeObject(GfxWinding_funcs,(void *)1,EXT->GfxWinding_typeID);
EI(keyStr=="GfxCW")RET STG::createNativeObject(GfxWinding_funcs,(void *)0,EXT->GfxWinding_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxWinding_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxVertexAttribPurpose___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxVertexAttribPurpose::__eq__")));
size_t f;
if(!TS(a[0],GfxVertexAttribPurpose))
CATE(TE,FAE("GfxVertexAttribPurpose::GfxVertexAttribPurpose","GfxVertexAttribPurpose")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxVertexAttribPurpose))
CATE(VE,UFOF("GfxVertexAttribPurpose::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxVertexAttribPurpose_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxVertexAttribPurpose");
EI(keyStr=="__eq__")
RET CNF(GfxVertexAttribPurpose___eq__);
EI(keyStr=="GfxTexCoord")RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)4,EXT->GfxVertexAttribPurpose_typeID);
EI(keyStr=="GfxTangent")RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)2,EXT->GfxVertexAttribPurpose_typeID);
EI(keyStr=="GfxPosition")RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)0,EXT->GfxVertexAttribPurpose_typeID);
EI(keyStr=="GfxNormal")RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)1,EXT->GfxVertexAttribPurpose_typeID);
EI(keyStr=="GfxColor")RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)3,EXT->GfxVertexAttribPurpose_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxVertexAttribPurpose");
EI(keyStr=="__eq__")
RET CNF(GfxVertexAttribPurpose___eq__);
EI(keyStr=="GfxTexCoord")RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)4,EXT->GfxVertexAttribPurpose_typeID);
EI(keyStr=="GfxTangent")RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)2,EXT->GfxVertexAttribPurpose_typeID);
EI(keyStr=="GfxPosition")RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)0,EXT->GfxVertexAttribPurpose_typeID);
EI(keyStr=="GfxNormal")RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)1,EXT->GfxVertexAttribPurpose_typeID);
EI(keyStr=="GfxColor")RET STG::createNativeObject(GfxVertexAttribPurpose_funcs,(void *)3,EXT->GfxVertexAttribPurpose_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxVertexAttribPurpose_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxVertexAttribType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxVertexAttribType::__eq__")));
size_t f;
if(!TS(a[0],GfxVertexAttribType))
CATE(TE,FAE("GfxVertexAttribType::GfxVertexAttribType","GfxVertexAttribType")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxVertexAttribType))
CATE(VE,UFOF("GfxVertexAttribType::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxVertexAttribType_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxVertexAttribType");
EI(keyStr=="__eq__")
RET CNF(GfxVertexAttribType___eq__);
EI(keyStr=="GfxUnsignedInteger")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)8,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxNormalizedUnsignedByte")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)10,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxFloat")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)1,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxNormalizedUnsignedInteger")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)14,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxShort")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)5,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxInteger")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)7,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxByte")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)3,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxNormalizedByte")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)9,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxUnsignedShort")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)6,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxDouble")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)2,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxHalfFloat")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)0,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxNormalizedShort")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)11,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxNormalizedInteger")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)13,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxUnsignedByte")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)4,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxNormalizedUnsignedShort")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)12,EXT->GfxVertexAttribType_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxVertexAttribType");
EI(keyStr=="__eq__")
RET CNF(GfxVertexAttribType___eq__);
EI(keyStr=="GfxUnsignedInteger")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)8,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxNormalizedUnsignedByte")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)10,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxFloat")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)1,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxNormalizedUnsignedInteger")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)14,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxShort")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)5,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxInteger")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)7,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxByte")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)3,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxNormalizedByte")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)9,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxUnsignedShort")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)6,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxDouble")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)2,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxHalfFloat")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)0,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxNormalizedShort")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)11,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxNormalizedInteger")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)13,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxUnsignedByte")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)4,EXT->GfxVertexAttribType_typeID);
EI(keyStr=="GfxNormalizedUnsignedShort")RET STG::createNativeObject(GfxVertexAttribType_funcs,(void *)12,EXT->GfxVertexAttribType_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxVertexAttribType_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxTextureType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxTextureType::__eq__")));
size_t f;
if(!TS(a[0],GfxTextureType))
CATE(TE,FAE("GfxTextureType::GfxTextureType","GfxTextureType")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxTextureType))
CATE(VE,UFOF("GfxTextureType::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxTextureType_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxTextureType");
EI(keyStr=="__eq__")
RET CNF(GfxTextureType___eq__);
EI(keyStr=="CubeMap")RET STG::createNativeObject(GfxTextureType_funcs,(void *)1,EXT->GfxTextureType_typeID);
EI(keyStr=="Texture3D")RET STG::createNativeObject(GfxTextureType_funcs,(void *)2,EXT->GfxTextureType_typeID);
EI(keyStr=="Texture2D")RET STG::createNativeObject(GfxTextureType_funcs,(void *)0,EXT->GfxTextureType_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxTextureType");
EI(keyStr=="__eq__")
RET CNF(GfxTextureType___eq__);
EI(keyStr=="CubeMap")RET STG::createNativeObject(GfxTextureType_funcs,(void *)1,EXT->GfxTextureType_typeID);
EI(keyStr=="Texture3D")RET STG::createNativeObject(GfxTextureType_funcs,(void *)2,EXT->GfxTextureType_typeID);
EI(keyStr=="Texture2D")RET STG::createNativeObject(GfxTextureType_funcs,(void *)0,EXT->GfxTextureType_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxTextureType_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxFilter___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxFilter::__eq__")));
size_t f;
if(!TS(a[0],GfxFilter))
CATE(TE,FAE("GfxFilter::GfxFilter","GfxFilter")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxFilter))
CATE(VE,UFOF("GfxFilter::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxFilter_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxFilter");
EI(keyStr=="__eq__")
RET CNF(GfxFilter___eq__);
EI(keyStr=="Bilinear")RET STG::createNativeObject(GfxFilter_funcs,(void *)1,EXT->GfxFilter_typeID);
EI(keyStr=="Nearest")RET STG::createNativeObject(GfxFilter_funcs,(void *)0,EXT->GfxFilter_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxFilter");
EI(keyStr=="__eq__")
RET CNF(GfxFilter___eq__);
EI(keyStr=="Bilinear")RET STG::createNativeObject(GfxFilter_funcs,(void *)1,EXT->GfxFilter_typeID);
EI(keyStr=="Nearest")RET STG::createNativeObject(GfxFilter_funcs,(void *)0,EXT->GfxFilter_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxFilter_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxMipmapMode___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxMipmapMode::__eq__")));
size_t f;
if(!TS(a[0],GfxMipmapMode))
CATE(TE,FAE("GfxMipmapMode::GfxMipmapMode","GfxMipmapMode")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxMipmapMode))
CATE(VE,UFOF("GfxMipmapMode::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxMipmapMode_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxMipmapMode");
EI(keyStr=="__eq__")
RET CNF(GfxMipmapMode___eq__);
EI(keyStr=="Nearest")RET STG::createNativeObject(GfxMipmapMode_funcs,(void *)1,EXT->GfxMipmapMode_typeID);
EI(keyStr=="None")RET STG::createNativeObject(GfxMipmapMode_funcs,(void *)0,EXT->GfxMipmapMode_typeID);
EI(keyStr=="Linear")RET STG::createNativeObject(GfxMipmapMode_funcs,(void *)2,EXT->GfxMipmapMode_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxMipmapMode");
EI(keyStr=="__eq__")
RET CNF(GfxMipmapMode___eq__);
EI(keyStr=="Nearest")RET STG::createNativeObject(GfxMipmapMode_funcs,(void *)1,EXT->GfxMipmapMode_typeID);
EI(keyStr=="None")RET STG::createNativeObject(GfxMipmapMode_funcs,(void *)0,EXT->GfxMipmapMode_typeID);
EI(keyStr=="Linear")RET STG::createNativeObject(GfxMipmapMode_funcs,(void *)2,EXT->GfxMipmapMode_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxMipmapMode_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxWrapMode___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxWrapMode::__eq__")));
size_t f;
if(!TS(a[0],GfxWrapMode))
CATE(TE,FAE("GfxWrapMode::GfxWrapMode","GfxWrapMode")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxWrapMode))
CATE(VE,UFOF("GfxWrapMode::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxWrapMode_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxWrapMode");
EI(keyStr=="__eq__")
RET CNF(GfxWrapMode___eq__);
EI(keyStr=="Stretch")RET STG::createNativeObject(GfxWrapMode_funcs,(void *)0,EXT->GfxWrapMode_typeID);
EI(keyStr=="Repeat")RET STG::createNativeObject(GfxWrapMode_funcs,(void *)1,EXT->GfxWrapMode_typeID);
EI(keyStr=="Mirror")RET STG::createNativeObject(GfxWrapMode_funcs,(void *)2,EXT->GfxWrapMode_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxWrapMode");
EI(keyStr=="__eq__")
RET CNF(GfxWrapMode___eq__);
EI(keyStr=="Stretch")RET STG::createNativeObject(GfxWrapMode_funcs,(void *)0,EXT->GfxWrapMode_typeID);
EI(keyStr=="Repeat")RET STG::createNativeObject(GfxWrapMode_funcs,(void *)1,EXT->GfxWrapMode_typeID);
EI(keyStr=="Mirror")RET STG::createNativeObject(GfxWrapMode_funcs,(void *)2,EXT->GfxWrapMode_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxWrapMode_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxTexFormat___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxTexFormat::__eq__")));
size_t f;
if(!TS(a[0],GfxTexFormat))
CATE(TE,FAE("GfxTexFormat::GfxTexFormat","GfxTexFormat")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxTexFormat))
CATE(VE,UFOF("GfxTexFormat::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxTexFormat_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxTexFormat");
EI(keyStr=="__eq__")
RET CNF(GfxTexFormat___eq__);
EI(keyStr=="RGBAF32_F16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)29,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceAlphaI8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)13,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceI16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)9,EXT->GfxTexFormat_typeID);
EI(keyStr=="AlphaI8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)1,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int2_8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)36,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedF32_F16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)70,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int_32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)34,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt2_16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)39,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceAlphaU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)12,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt2_32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)41,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBI8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)19,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedI16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)68,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedU16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)67,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceI8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)7,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int2_16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)38,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBAU16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)26,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBF32_F16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)23,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedGreenI16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)62,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)65,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int3_8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)42,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int_8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)30,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceU16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)8,EXT->GfxTexFormat_typeID);
EI(keyStr=="AlphaI16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)3,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBI16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)21,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceF32_F16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)11,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)6,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt_8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)31,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt2_8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)37,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int3_16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)44,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBAU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)24,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBU16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)20,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceAlphaF32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)16,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBAF32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)28,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt3_8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)43,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int4_8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)48,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceAlphaU16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)14,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int2_32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)40,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt_16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)33,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt4_8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)49,EXT->GfxTexFormat_typeID);
EI(keyStr=="AlphaU16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)2,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedGreenI8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)60,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceAlphaF32_F16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)17,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int3_32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)46,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedGreenF32_F16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)64,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)18,EXT->GfxTexFormat_typeID);
EI(keyStr=="SRGBU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)54,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedGreenU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)59,EXT->GfxTexFormat_typeID);
EI(keyStr=="DepthF32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)58,EXT->GfxTexFormat_typeID);
EI(keyStr=="AlphaF32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)4,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt_32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)35,EXT->GfxTexFormat_typeID);
EI(keyStr=="AlphaU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)0,EXT->GfxTexFormat_typeID);
EI(keyStr=="DepthF32_F24")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)57,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedF32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)69,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedGreenF32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)63,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int4_16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)50,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBAI8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)25,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt4_32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)53,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt4_16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)51,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt3_16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)45,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt3_32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)47,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedI8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)66,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int4_32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)52,EXT->GfxTexFormat_typeID);
EI(keyStr=="SRGBAU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)55,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceF32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)10,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBF32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)22,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int_16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)32,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedGreenU16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)61,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceAlphaI16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)15,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBAI16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)27,EXT->GfxTexFormat_typeID);
EI(keyStr=="DepthF32_F16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)56,EXT->GfxTexFormat_typeID);
EI(keyStr=="AlphaF32_F16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)5,EXT->GfxTexFormat_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxTexFormat");
EI(keyStr=="__eq__")
RET CNF(GfxTexFormat___eq__);
EI(keyStr=="RGBAF32_F16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)29,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceAlphaI8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)13,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceI16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)9,EXT->GfxTexFormat_typeID);
EI(keyStr=="AlphaI8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)1,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int2_8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)36,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedF32_F16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)70,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int_32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)34,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt2_16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)39,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceAlphaU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)12,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt2_32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)41,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBI8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)19,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedI16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)68,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedU16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)67,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceI8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)7,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int2_16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)38,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBAU16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)26,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBF32_F16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)23,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedGreenI16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)62,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)65,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int3_8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)42,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int_8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)30,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceU16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)8,EXT->GfxTexFormat_typeID);
EI(keyStr=="AlphaI16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)3,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBI16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)21,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceF32_F16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)11,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)6,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt_8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)31,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt2_8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)37,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int3_16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)44,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBAU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)24,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBU16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)20,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceAlphaF32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)16,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBAF32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)28,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt3_8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)43,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int4_8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)48,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceAlphaU16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)14,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int2_32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)40,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt_16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)33,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt4_8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)49,EXT->GfxTexFormat_typeID);
EI(keyStr=="AlphaU16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)2,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedGreenI8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)60,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceAlphaF32_F16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)17,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int3_32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)46,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedGreenF32_F16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)64,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)18,EXT->GfxTexFormat_typeID);
EI(keyStr=="SRGBU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)54,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedGreenU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)59,EXT->GfxTexFormat_typeID);
EI(keyStr=="DepthF32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)58,EXT->GfxTexFormat_typeID);
EI(keyStr=="AlphaF32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)4,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt_32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)35,EXT->GfxTexFormat_typeID);
EI(keyStr=="AlphaU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)0,EXT->GfxTexFormat_typeID);
EI(keyStr=="DepthF32_F24")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)57,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedF32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)69,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedGreenF32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)63,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int4_16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)50,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBAI8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)25,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt4_32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)53,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt4_16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)51,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt3_16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)45,EXT->GfxTexFormat_typeID);
EI(keyStr=="UInt3_32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)47,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedI8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)66,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int4_32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)52,EXT->GfxTexFormat_typeID);
EI(keyStr=="SRGBAU8")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)55,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceF32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)10,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBF32")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)22,EXT->GfxTexFormat_typeID);
EI(keyStr=="Int_16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)32,EXT->GfxTexFormat_typeID);
EI(keyStr=="RedGreenU16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)61,EXT->GfxTexFormat_typeID);
EI(keyStr=="LuminanceAlphaI16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)15,EXT->GfxTexFormat_typeID);
EI(keyStr=="RGBAI16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)27,EXT->GfxTexFormat_typeID);
EI(keyStr=="DepthF32_F16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)56,EXT->GfxTexFormat_typeID);
EI(keyStr=="AlphaF32_F16")RET STG::createNativeObject(GfxTexFormat_funcs,(void *)5,EXT->GfxTexFormat_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxTexFormat_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxTexPurpose___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxTexPurpose::__eq__")));
size_t f;
if(!TS(a[0],GfxTexPurpose))
CATE(TE,FAE("GfxTexPurpose::GfxTexPurpose","GfxTexPurpose")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxTexPurpose))
CATE(VE,UFOF("GfxTexPurpose::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxTexPurpose_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxTexPurpose");
EI(keyStr=="__eq__")
RET CNF(GfxTexPurpose___eq__);
EI(keyStr=="Color")RET STG::createNativeObject(GfxTexPurpose_funcs,(void *)0,EXT->GfxTexPurpose_typeID);
EI(keyStr=="Other")RET STG::createNativeObject(GfxTexPurpose_funcs,(void *)2,EXT->GfxTexPurpose_typeID);
EI(keyStr=="Normal")RET STG::createNativeObject(GfxTexPurpose_funcs,(void *)1,EXT->GfxTexPurpose_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxTexPurpose");
EI(keyStr=="__eq__")
RET CNF(GfxTexPurpose___eq__);
EI(keyStr=="Color")RET STG::createNativeObject(GfxTexPurpose_funcs,(void *)0,EXT->GfxTexPurpose_typeID);
EI(keyStr=="Other")RET STG::createNativeObject(GfxTexPurpose_funcs,(void *)2,EXT->GfxTexPurpose_typeID);
EI(keyStr=="Normal")RET STG::createNativeObject(GfxTexPurpose_funcs,(void *)1,EXT->GfxTexPurpose_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxTexPurpose_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxFace___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxFace::__eq__")));
size_t f;
if(!TS(a[0],GfxFace))
CATE(TE,FAE("GfxFace::GfxFace","GfxFace")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxFace))
CATE(VE,UFOF("GfxFace::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxFace_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxFace");
EI(keyStr=="__eq__")
RET CNF(GfxFace___eq__);
EI(keyStr=="PositiveZ")RET STG::createNativeObject(GfxFace_funcs,(void *)4,EXT->GfxFace_typeID);
EI(keyStr=="PositiveX")RET STG::createNativeObject(GfxFace_funcs,(void *)0,EXT->GfxFace_typeID);
EI(keyStr=="PositiveY")RET STG::createNativeObject(GfxFace_funcs,(void *)2,EXT->GfxFace_typeID);
EI(keyStr=="NegativeZ")RET STG::createNativeObject(GfxFace_funcs,(void *)5,EXT->GfxFace_typeID);
EI(keyStr=="NegativeX")RET STG::createNativeObject(GfxFace_funcs,(void *)1,EXT->GfxFace_typeID);
EI(keyStr=="NegativeY")RET STG::createNativeObject(GfxFace_funcs,(void *)3,EXT->GfxFace_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxFace");
EI(keyStr=="__eq__")
RET CNF(GfxFace___eq__);
EI(keyStr=="PositiveZ")RET STG::createNativeObject(GfxFace_funcs,(void *)4,EXT->GfxFace_typeID);
EI(keyStr=="PositiveX")RET STG::createNativeObject(GfxFace_funcs,(void *)0,EXT->GfxFace_typeID);
EI(keyStr=="PositiveY")RET STG::createNativeObject(GfxFace_funcs,(void *)2,EXT->GfxFace_typeID);
EI(keyStr=="NegativeZ")RET STG::createNativeObject(GfxFace_funcs,(void *)5,EXT->GfxFace_typeID);
EI(keyStr=="NegativeX")RET STG::createNativeObject(GfxFace_funcs,(void *)1,EXT->GfxFace_typeID);
EI(keyStr=="NegativeY")RET STG::createNativeObject(GfxFace_funcs,(void *)3,EXT->GfxFace_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxFace_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxShaderType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxShaderType::__eq__")));
size_t f;
if(!TS(a[0],GfxShaderType))
CATE(TE,FAE("GfxShaderType::GfxShaderType","GfxShaderType")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxShaderType))
CATE(VE,UFOF("GfxShaderType::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxShaderType_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxShaderType");
EI(keyStr=="__eq__")
RET CNF(GfxShaderType___eq__);
EI(keyStr=="Compute")RET STG::createNativeObject(GfxShaderType_funcs,(void *)5,EXT->GfxShaderType_typeID);
EI(keyStr=="Geometry")RET STG::createNativeObject(GfxShaderType_funcs,(void *)3,EXT->GfxShaderType_typeID);
EI(keyStr=="Vertex")RET STG::createNativeObject(GfxShaderType_funcs,(void *)0,EXT->GfxShaderType_typeID);
EI(keyStr=="Fragment")RET STG::createNativeObject(GfxShaderType_funcs,(void *)4,EXT->GfxShaderType_typeID);
EI(keyStr=="TessControl")RET STG::createNativeObject(GfxShaderType_funcs,(void *)1,EXT->GfxShaderType_typeID);
EI(keyStr=="TessEval")RET STG::createNativeObject(GfxShaderType_funcs,(void *)2,EXT->GfxShaderType_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxShaderType");
EI(keyStr=="__eq__")
RET CNF(GfxShaderType___eq__);
EI(keyStr=="Compute")RET STG::createNativeObject(GfxShaderType_funcs,(void *)5,EXT->GfxShaderType_typeID);
EI(keyStr=="Geometry")RET STG::createNativeObject(GfxShaderType_funcs,(void *)3,EXT->GfxShaderType_typeID);
EI(keyStr=="Vertex")RET STG::createNativeObject(GfxShaderType_funcs,(void *)0,EXT->GfxShaderType_typeID);
EI(keyStr=="Fragment")RET STG::createNativeObject(GfxShaderType_funcs,(void *)4,EXT->GfxShaderType_typeID);
EI(keyStr=="TessControl")RET STG::createNativeObject(GfxShaderType_funcs,(void *)1,EXT->GfxShaderType_typeID);
EI(keyStr=="TessEval")RET STG::createNativeObject(GfxShaderType_funcs,(void *)2,EXT->GfxShaderType_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxShaderType_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxBufferUsage___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxBufferUsage::__eq__")));
size_t f;
if(!TS(a[0],GfxBufferUsage))
CATE(TE,FAE("GfxBufferUsage::GfxBufferUsage","GfxBufferUsage")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxBufferUsage))
CATE(VE,UFOF("GfxBufferUsage::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxBufferUsage_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxBufferUsage");
EI(keyStr=="__eq__")
RET CNF(GfxBufferUsage___eq__);
EI(keyStr=="Dynamic")RET STG::createNativeObject(GfxBufferUsage_funcs,(void *)2,EXT->GfxBufferUsage_typeID);
EI(keyStr=="Static")RET STG::createNativeObject(GfxBufferUsage_funcs,(void *)1,EXT->GfxBufferUsage_typeID);
EI(keyStr=="Stream")RET STG::createNativeObject(GfxBufferUsage_funcs,(void *)0,EXT->GfxBufferUsage_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxBufferUsage");
EI(keyStr=="__eq__")
RET CNF(GfxBufferUsage___eq__);
EI(keyStr=="Dynamic")RET STG::createNativeObject(GfxBufferUsage_funcs,(void *)2,EXT->GfxBufferUsage_typeID);
EI(keyStr=="Static")RET STG::createNativeObject(GfxBufferUsage_funcs,(void *)1,EXT->GfxBufferUsage_typeID);
EI(keyStr=="Stream")RET STG::createNativeObject(GfxBufferUsage_funcs,(void *)0,EXT->GfxBufferUsage_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxBufferUsage_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxMeshIndexDataType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxMeshIndexDataType::__eq__")));
size_t f;
if(!TS(a[0],GfxMeshIndexDataType))
CATE(TE,FAE("GfxMeshIndexDataType::GfxMeshIndexDataType","GfxMeshIndexDataType")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxMeshIndexDataType))
CATE(VE,UFOF("GfxMeshIndexDataType::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxMeshIndexDataType_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxMeshIndexDataType");
EI(keyStr=="__eq__")
RET CNF(GfxMeshIndexDataType___eq__);
EI(keyStr=="U32")RET STG::createNativeObject(GfxMeshIndexDataType_funcs,(void *)2,EXT->GfxMeshIndexDataType_typeID);
EI(keyStr=="U8")RET STG::createNativeObject(GfxMeshIndexDataType_funcs,(void *)0,EXT->GfxMeshIndexDataType_typeID);
EI(keyStr=="U16")RET STG::createNativeObject(GfxMeshIndexDataType_funcs,(void *)1,EXT->GfxMeshIndexDataType_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxMeshIndexDataType");
EI(keyStr=="__eq__")
RET CNF(GfxMeshIndexDataType___eq__);
EI(keyStr=="U32")RET STG::createNativeObject(GfxMeshIndexDataType_funcs,(void *)2,EXT->GfxMeshIndexDataType_typeID);
EI(keyStr=="U8")RET STG::createNativeObject(GfxMeshIndexDataType_funcs,(void *)0,EXT->GfxMeshIndexDataType_typeID);
EI(keyStr=="U16")RET STG::createNativeObject(GfxMeshIndexDataType_funcs,(void *)1,EXT->GfxMeshIndexDataType_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxMeshIndexDataType_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxMeshAttribType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxMeshAttribType::__eq__")));
size_t f;
if(!TS(a[0],GfxMeshAttribType))
CATE(TE,FAE("GfxMeshAttribType::GfxMeshAttribType","GfxMeshAttribType")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxMeshAttribType))
CATE(VE,UFOF("GfxMeshAttribType::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxMeshAttribType_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxMeshAttribType");
EI(keyStr=="__eq__")
RET CNF(GfxMeshAttribType___eq__);
EI(keyStr=="Normal")RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)1,EXT->GfxMeshAttribType_typeID);
EI(keyStr=="Color")RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)3,EXT->GfxMeshAttribType_typeID);
EI(keyStr=="TexCoord")RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)4,EXT->GfxMeshAttribType_typeID);
EI(keyStr=="Tangent")RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)2,EXT->GfxMeshAttribType_typeID);
EI(keyStr=="BoneWeight")RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)6,EXT->GfxMeshAttribType_typeID);
EI(keyStr=="Position")RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)0,EXT->GfxMeshAttribType_typeID);
EI(keyStr=="BoneIndex")RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)5,EXT->GfxMeshAttribType_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxMeshAttribType");
EI(keyStr=="__eq__")
RET CNF(GfxMeshAttribType___eq__);
EI(keyStr=="Normal")RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)1,EXT->GfxMeshAttribType_typeID);
EI(keyStr=="Color")RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)3,EXT->GfxMeshAttribType_typeID);
EI(keyStr=="TexCoord")RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)4,EXT->GfxMeshAttribType_typeID);
EI(keyStr=="Tangent")RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)2,EXT->GfxMeshAttribType_typeID);
EI(keyStr=="BoneWeight")RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)6,EXT->GfxMeshAttribType_typeID);
EI(keyStr=="Position")RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)0,EXT->GfxMeshAttribType_typeID);
EI(keyStr=="BoneIndex")RET STG::createNativeObject(GfxMeshAttribType_funcs,(void *)5,EXT->GfxMeshAttribType_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxMeshAttribType_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxMeshAttribDataType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxMeshAttribDataType::__eq__")));
size_t f;
if(!TS(a[0],GfxMeshAttribDataType))
CATE(TE,FAE("GfxMeshAttribDataType::GfxMeshAttribDataType","GfxMeshAttribDataType")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxMeshAttribDataType))
CATE(VE,UFOF("GfxMeshAttribDataType::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxMeshAttribDataType_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxMeshAttribDataType");
EI(keyStr=="__eq__")
RET CNF(GfxMeshAttribDataType___eq__);
EI(keyStr=="S32_3Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)54,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S16_2")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)21,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S16_3")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)22,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S16_1")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)20,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S8_2Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)37,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S16_4")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)23,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S32_2Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)53,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U16_3Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)42,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S32_4Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)55,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S8_3Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)38,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U32_2")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)25,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U32_3")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)26,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U32_1")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)24,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U32_4")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)27,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S8_1Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)36,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U8_2")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)9,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U8_3")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)10,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U8_1")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)8,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S8_4Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)39,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U8_4")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)11,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U8_3Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)34,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="F16_3")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)2,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="F16_2")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)1,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="F16_1")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)0,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S32_1Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)52,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="F16_4")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)3,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U32_3Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)50,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U16_2Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)41,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U16_1Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)40,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U8_2Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)33,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U8_4Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)35,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U32_4Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)51,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U32_1Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)48,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S16_2Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)45,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U16_4")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)19,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U16_1")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)16,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U16_2")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)17,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U16_3")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)18,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S16_4Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)47,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U8_1Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)32,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S32_4")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)31,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S8_1")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)12,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S8_2")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)13,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S8_3")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)14,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S8_4")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)15,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S32_1")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)28,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S32_2")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)29,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S32_3")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)30,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U32_2Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)49,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S16_3Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)46,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="F32_1")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)4,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="F32_3")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)6,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="F32_2")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)5,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="F32_4")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)7,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U16_4Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)43,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S16_1Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)44,EXT->GfxMeshAttribDataType_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxMeshAttribDataType");
EI(keyStr=="__eq__")
RET CNF(GfxMeshAttribDataType___eq__);
EI(keyStr=="S32_3Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)54,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S16_2")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)21,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S16_3")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)22,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S16_1")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)20,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S8_2Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)37,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S16_4")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)23,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S32_2Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)53,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U16_3Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)42,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S32_4Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)55,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S8_3Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)38,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U32_2")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)25,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U32_3")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)26,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U32_1")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)24,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U32_4")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)27,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S8_1Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)36,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U8_2")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)9,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U8_3")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)10,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U8_1")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)8,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S8_4Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)39,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U8_4")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)11,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U8_3Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)34,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="F16_3")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)2,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="F16_2")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)1,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="F16_1")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)0,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S32_1Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)52,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="F16_4")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)3,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U32_3Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)50,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U16_2Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)41,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U16_1Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)40,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U8_2Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)33,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U8_4Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)35,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U32_4Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)51,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U32_1Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)48,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S16_2Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)45,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U16_4")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)19,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U16_1")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)16,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U16_2")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)17,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U16_3")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)18,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S16_4Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)47,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U8_1Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)32,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S32_4")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)31,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S8_1")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)12,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S8_2")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)13,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S8_3")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)14,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S8_4")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)15,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S32_1")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)28,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S32_2")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)29,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S32_3")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)30,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U32_2Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)49,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S16_3Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)46,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="F32_1")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)4,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="F32_3")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)6,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="F32_2")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)5,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="F32_4")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)7,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="U16_4Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)43,EXT->GfxMeshAttribDataType_typeID);
EI(keyStr=="S16_1Norm")RET STG::createNativeObject(GfxMeshAttribDataType_funcs,(void *)44,EXT->GfxMeshAttribDataType_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxMeshAttribDataType_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxShadowmapPrecision___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxShadowmapPrecision::__eq__")));
size_t f;
if(!TS(a[0],GfxShadowmapPrecision))
CATE(TE,FAE("GfxShadowmapPrecision::GfxShadowmapPrecision","GfxShadowmapPrecision")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxShadowmapPrecision))
CATE(VE,UFOF("GfxShadowmapPrecision::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxShadowmapPrecision_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxShadowmapPrecision");
EI(keyStr=="__eq__")
RET CNF(GfxShadowmapPrecision___eq__);
EI(keyStr=="High")RET STG::createNativeObject(GfxShadowmapPrecision_funcs,(void *)2,EXT->GfxShadowmapPrecision_typeID);
EI(keyStr=="Medium")RET STG::createNativeObject(GfxShadowmapPrecision_funcs,(void *)1,EXT->GfxShadowmapPrecision_typeID);
EI(keyStr=="Low")RET STG::createNativeObject(GfxShadowmapPrecision_funcs,(void *)0,EXT->GfxShadowmapPrecision_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxShadowmapPrecision");
EI(keyStr=="__eq__")
RET CNF(GfxShadowmapPrecision___eq__);
EI(keyStr=="High")RET STG::createNativeObject(GfxShadowmapPrecision_funcs,(void *)2,EXT->GfxShadowmapPrecision_typeID);
EI(keyStr=="Medium")RET STG::createNativeObject(GfxShadowmapPrecision_funcs,(void *)1,EXT->GfxShadowmapPrecision_typeID);
EI(keyStr=="Low")RET STG::createNativeObject(GfxShadowmapPrecision_funcs,(void *)0,EXT->GfxShadowmapPrecision_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxShadowmapPrecision_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxLightType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxLightType::__eq__")));
size_t f;
if(!TS(a[0],GfxLightType))
CATE(TE,FAE("GfxLightType::GfxLightType","GfxLightType")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxLightType))
CATE(VE,UFOF("GfxLightType::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxLightType_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxLightType");
EI(keyStr=="__eq__")
RET CNF(GfxLightType___eq__);
EI(keyStr=="Point")RET STG::createNativeObject(GfxLightType_funcs,(void *)2,EXT->GfxLightType_typeID);
EI(keyStr=="Spot")RET STG::createNativeObject(GfxLightType_funcs,(void *)1,EXT->GfxLightType_typeID);
EI(keyStr=="Directional")RET STG::createNativeObject(GfxLightType_funcs,(void *)0,EXT->GfxLightType_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxLightType");
EI(keyStr=="__eq__")
RET CNF(GfxLightType___eq__);
EI(keyStr=="Point")RET STG::createNativeObject(GfxLightType_funcs,(void *)2,EXT->GfxLightType_typeID);
EI(keyStr=="Spot")RET STG::createNativeObject(GfxLightType_funcs,(void *)1,EXT->GfxLightType_typeID);
EI(keyStr=="Directional")RET STG::createNativeObject(GfxLightType_funcs,(void *)0,EXT->GfxLightType_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxLightType_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV GfxDriver___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("GfxDriver::__eq__")));
size_t f;
if(!TS(a[0],GfxDriver))
CATE(TE,FAE("GfxDriver::GfxDriver","GfxDriver")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],GfxDriver))
CATE(VE,UFOF("GfxDriver::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV GfxDriver_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxDriver");
EI(keyStr=="__eq__")
RET CNF(GfxDriver___eq__);
EI(keyStr=="Unknown")RET STG::createNativeObject(GfxDriver_funcs,(void *)2,EXT->GfxDriver_typeID);
EI(keyStr=="Mesa")RET STG::createNativeObject(GfxDriver_funcs,(void *)1,EXT->GfxDriver_typeID);
EI(keyStr=="Nvidia")RET STG::createNativeObject(GfxDriver_funcs,(void *)0,EXT->GfxDriver_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxDriver");
EI(keyStr=="__eq__")
RET CNF(GfxDriver___eq__);
EI(keyStr=="Unknown")RET STG::createNativeObject(GfxDriver_funcs,(void *)2,EXT->GfxDriver_typeID);
EI(keyStr=="Mesa")RET STG::createNativeObject(GfxDriver_funcs,(void *)1,EXT->GfxDriver_typeID);
EI(keyStr=="Nvidia")RET STG::createNativeObject(GfxDriver_funcs,(void *)0,EXT->GfxDriver_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void GfxDriver_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV CameraType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("CameraType::__eq__")));
size_t f;
if(!TS(a[0],CameraType))
CATE(TE,FAE("CameraType::CameraType","CameraType")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],CameraType))
CATE(VE,UFOF("CameraType::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV CameraType_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("CameraType");
EI(keyStr=="__eq__")
RET CNF(CameraType___eq__);
EI(keyStr=="Perspective")RET STG::createNativeObject(CameraType_funcs,(void *)0,EXT->CameraType_typeID);
EI(keyStr=="Orthographic")RET STG::createNativeObject(CameraType_funcs,(void *)1,EXT->CameraType_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("CameraType");
EI(keyStr=="__eq__")
RET CNF(CameraType___eq__);
EI(keyStr=="Perspective")RET STG::createNativeObject(CameraType_funcs,(void *)0,EXT->CameraType_typeID);
EI(keyStr=="Orthographic")RET STG::createNativeObject(CameraType_funcs,(void *)1,EXT->CameraType_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void CameraType_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV RigidBodyType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("RigidBodyType::__eq__")));
size_t f;
if(!TS(a[0],RigidBodyType))
CATE(TE,FAE("RigidBodyType::RigidBodyType","RigidBodyType")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],RigidBodyType))
CATE(VE,UFOF("RigidBodyType::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV RigidBodyType_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("RigidBodyType");
EI(keyStr=="__eq__")
RET CNF(RigidBodyType___eq__);
EI(keyStr=="Dynamic")RET STG::createNativeObject(RigidBodyType_funcs,(void *)1,EXT->RigidBodyType_typeID);
EI(keyStr=="Static")RET STG::createNativeObject(RigidBodyType_funcs,(void *)0,EXT->RigidBodyType_typeID);
EI(keyStr=="Kinematic")RET STG::createNativeObject(RigidBodyType_funcs,(void *)2,EXT->RigidBodyType_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("RigidBodyType");
EI(keyStr=="__eq__")
RET CNF(RigidBodyType___eq__);
EI(keyStr=="Dynamic")RET STG::createNativeObject(RigidBodyType_funcs,(void *)1,EXT->RigidBodyType_typeID);
EI(keyStr=="Static")RET STG::createNativeObject(RigidBodyType_funcs,(void *)0,EXT->RigidBodyType_typeID);
EI(keyStr=="Kinematic")RET STG::createNativeObject(RigidBodyType_funcs,(void *)2,EXT->RigidBodyType_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void RigidBodyType_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV PhysicsObjectType___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("PhysicsObjectType::__eq__")));
size_t f;
if(!TS(a[0],PhysicsObjectType))
CATE(TE,FAE("PhysicsObjectType::PhysicsObjectType","PhysicsObjectType")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],PhysicsObjectType))
CATE(VE,UFOF("PhysicsObjectType::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV PhysicsObjectType_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("PhysicsObjectType");
EI(keyStr=="__eq__")
RET CNF(PhysicsObjectType___eq__);
EI(keyStr=="Body")RET STG::createNativeObject(PhysicsObjectType_funcs,(void *)0,EXT->PhysicsObjectType_typeID);
EI(keyStr=="Ghost")RET STG::createNativeObject(PhysicsObjectType_funcs,(void *)1,EXT->PhysicsObjectType_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("PhysicsObjectType");
EI(keyStr=="__eq__")
RET CNF(PhysicsObjectType___eq__);
EI(keyStr=="Body")RET STG::createNativeObject(PhysicsObjectType_funcs,(void *)0,EXT->PhysicsObjectType_typeID);
EI(keyStr=="Ghost")RET STG::createNativeObject(PhysicsObjectType_funcs,(void *)1,EXT->PhysicsObjectType_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void PhysicsObjectType_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
SV RenderMode___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,UFOF("RenderMode::__eq__")));
size_t f;
if(!TS(a[0],RenderMode))
CATE(TE,FAE("RenderMode::RenderMode","RenderMode")));
else
 f=(size_t)((NO)a[0])->data;
size_t other;
if(!TS(a[1],RenderMode))
CATE(VE,UFOF("RenderMode::__eq__")));
else
 other=(size_t)((NO)a[1])->data;
return STG::createBoolean(f == other);
}SV RenderMode_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("RenderMode");
EI(keyStr=="__eq__")
RET CNF(RenderMode___eq__);
EI(keyStr=="Nothing")RET STG::createNativeObject(RenderMode_funcs,(void *)0,EXT->RenderMode_typeID);
EI(keyStr=="Model")RET STG::createNativeObject(RenderMode_funcs,(void *)1,EXT->RenderMode_typeID);
EI(keyStr=="Overlay")RET STG::createNativeObject(RenderMode_funcs,(void *)2,EXT->RenderMode_typeID);

else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("RenderMode");
EI(keyStr=="__eq__")
RET CNF(RenderMode___eq__);
EI(keyStr=="Nothing")RET STG::createNativeObject(RenderMode_funcs,(void *)0,EXT->RenderMode_typeID);
EI(keyStr=="Model")RET STG::createNativeObject(RenderMode_funcs,(void *)1,EXT->RenderMode_typeID);
EI(keyStr=="Overlay")RET STG::createNativeObject(RenderMode_funcs,(void *)2,EXT->RenderMode_typeID);

else
 CATE(KE,"Unknown member."));
}
}
}
void RenderMode_set_member(CTX ctx,NO,SV,SV){CATE(KE,"Enums are read-only."));}
void GhostObject_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GhostObject))
CATE(TE,"GhostObject::__del__ expects GhostObject as first argument."));

}SV GhostObject_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GhostObject's constructor" EAOE));
if(!TS(a[0],GhostObject))
CATE(TE,"GhostObject's constructor expects GhostObject as first argument."));
CATE(TE,UFOF("GhostObject's constructor.")));
}

SV GhostObject_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GhostObject");
EI(keyStr=="__new__")
RET CNF(GhostObject_new);
EI(keyStr=="__call__")
RET CNF(GhostObject_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GhostObject_new);
 EI(keyStr == "getBulletGhostObject")
RET CNF(GhostObject_getBulletGhostObject);
 EI(keyStr == "getTransform")
RET CNF(GhostObject_getTransform);
 EI(keyStr == "setTransform")
RET CNF(GhostObject_setTransform);
 EI(keyStr == "getWorld")
RET CNF(GhostObject_getWorld);
 EI(keyStr == "getCollisionMask")
RET CNF(GhostObject_getCollisionMask);
 EI(keyStr == "setShape")
RET CNF(GhostObject_setShape);
 EI(keyStr == "getCollisions")
RET CNF(GhostObject_getCollisions);
 EI(keyStr == "getRigidBodyCollisions")
RET CNF(GhostObject_getRigidBodyCollisions);
 EI(keyStr == "getGhostCollisions")
RET CNF(GhostObject_getGhostCollisions);
 EI(keyStr == "getShape")
RET CNF(GhostObject_getShape);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GhostObject_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GhostObject_getTransform(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::getTransform" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getTransform());
;
}
CATE(TE,UFOF("GhostObject::getTransform.")));
RET CN;
}

SV GhostObject_setTransform(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::setTransform" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Transform &))
{
( f->setTransform(val_to_c<std::remove_reference<const Transform &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GhostObject::setTransform.")));
RET CN;
}

SV GhostObject_getGhostCollisions(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::getGhostCollisions" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGhostCollisions());
;
}
CATE(TE,UFOF("GhostObject::getGhostCollisions.")));
RET CN;
}

SV GhostObject_getCollisions(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::getCollisions" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0])->data;

CATE(TE,UFOF("GhostObject::getCollisions.")));
RET CN;
}

SV GhostObject_getBulletGhostObject(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::getBulletGhostObject" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0])->data;

CATE(TE,UFOF("GhostObject::getBulletGhostObject.")));
RET CN;
}

SV GhostObject_getWorld(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::getWorld" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWorld());
;
}
CATE(TE,UFOF("GhostObject::getWorld.")));
RET CN;
}

SV GhostObject_getShape(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::getShape" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShape());
;
}
CATE(TE,UFOF("GhostObject::getShape.")));
RET CN;
}

SV GhostObject_getRigidBodyCollisions(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::getRigidBodyCollisions" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRigidBodyCollisions());
;
}
CATE(TE,UFOF("GhostObject::getRigidBodyCollisions.")));
RET CN;
}

SV GhostObject_getCollisionMask(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::getCollisionMask" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCollisionMask());
;
}
CATE(TE,UFOF("GhostObject::getCollisionMask.")));
RET CN;
}

SV GhostObject_setShape(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObject::setShape" EAOE));
GhostObject*f;
f=(GhostObject*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],PhysicsShape *))
{
( f->setShape(val_to_c<std::remove_reference<PhysicsShape *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GhostObject::setShape.")));
RET CN;
}

void Filesystem_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Filesystem))
CATE(TE,"Filesystem::__del__ expects Filesystem as first argument."));

DELETE((Filesystem*)f->data);
}SV Filesystem_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Filesystem's constructor" EAOE));
if(!TS(a[0],Filesystem))
CATE(TE,"Filesystem's constructor expects Filesystem as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(Filesystem_funcs,NEW(Filesystem),EXT->Filesystem_typeID);
CATE(TE,UFOF("Filesystem's constructor.")));
RET CN;
}

SV Filesystem_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Filesystem");
EI(keyStr=="__new__")
RET CNF(Filesystem_new);
EI(keyStr=="__call__")
RET CNF(Filesystem_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Filesystem_new);
 EI(keyStr == "pushSearchPaths")
RET CNF(Filesystem_pushSearchPaths);
 EI(keyStr == "popSearchPaths")
RET CNF(Filesystem_popSearchPaths);
 EI(keyStr == "addSearchPath")
RET CNF(Filesystem_addSearchPath);
 EI(keyStr == "getAbsolutePath")
RET CNF(Filesystem_getAbsolutePath);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Filesystem_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Filesystem_addSearchPath(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Filesystem::addSearchPath" EAOE));
Filesystem*f;
f=(Filesystem*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
( f->addSearchPath(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Filesystem::addSearchPath.")));
RET CN;
}

SV Filesystem_pushSearchPaths(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Filesystem::pushSearchPaths" EAOE));
Filesystem*f;
f=(Filesystem*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->pushSearchPaths());
RET CN;
}
CATE(TE,UFOF("Filesystem::pushSearchPaths.")));
RET CN;
}

SV Filesystem_popSearchPaths(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Filesystem::popSearchPaths" EAOE));
Filesystem*f;
f=(Filesystem*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->popSearchPaths());
RET CN;
}
CATE(TE,UFOF("Filesystem::popSearchPaths.")));
RET CN;
}

SV Filesystem_getAbsolutePath(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Filesystem::getAbsolutePath" EAOE));
Filesystem*f;
f=(Filesystem*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const char *))
{
RET CV( f->getAbsolutePath(val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Filesystem::getAbsolutePath.")));
RET CN;
}

void StrStrMap_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,HashMap<String,String>))
CATE(TE,"StrStrMap::__del__ expects StrStrMap as first argument."));

DELETE((HashMap<String,String>*)f->data);
}SV StrStrMap_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"StrStrMap's constructor" EAOE));
if(!TS(a[0],HashMap<String,String>))
CATE(TE,"StrStrMap's constructor expects StrStrMap as first argument."));
#define fjis HashMap<String,String>
RET STG::createNativeObject(StrStrMap_funcs,NEW(fjis),EXT->StrStrMap_typeID);
}

SV StrStrMap_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("StrStrMap");
EI(keyStr=="__new__")
RET CNF(StrStrMap_new);
EI(keyStr=="__call__")
RET CNF(StrStrMap_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(StrStrMap_new);
 EI(keyStr == "__eq__")
RET CNF(StrStrMap___eq__);
 EI(keyStr == "__neq__")
RET CNF(StrStrMap___neq__);
 EI(keyStr == "getEntryCount")
RET CNF(StrStrMap_getEntryCount);
 EI(keyStr == "findEntry")
RET CNF(StrStrMap_findEntry);
 EI(keyStr == "getKey")
RET CNF(StrStrMap_getKey);
 EI(keyStr == "getValue")
RET CNF(StrStrMap_getValue);
 EI(keyStr == "getKeyHash")
RET CNF(StrStrMap_getKeyHash);
 EI(keyStr == "get")
RET CNF(StrStrMap_get);
 EI(keyStr == "set")
RET CNF(StrStrMap_set);
 EI(keyStr == "removeEntry")
RET CNF(StrStrMap_removeEntry);
 EI(keyStr == "remove")
RET CNF(StrStrMap_remove);
 EI(keyStr == "clear")
RET CNF(StrStrMap_clear);
 EI(keyStr == "append")
RET CNF(StrStrMap_append);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void StrStrMap_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV StrStrMap_removeEntry(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::removeEntry" EAOE));
HashMap<String,String>*f;
f=(HashMap<String,String>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],int))
{
( f->removeEntry(val_to_c<std::remove_reference<int>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("StrStrMap::removeEntry.")));
RET CN;
}

SV StrStrMap_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::set" EAOE));
HashMap<String,String>*f;
f=(HashMap<String,String>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],String)&&TS(a[2],String))
{
RET CV( f->set(val_to_c<std::remove_reference<String>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<String>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("StrStrMap::set.")));
RET CN;
}

SV StrStrMap_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::get" EAOE));
HashMap<String,String>*f;
f=(HashMap<String,String>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],String))
{
RET CV( f->get(val_to_c<std::remove_reference<String>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==2)
if(1&&TS(a[1],String))
{
RET CV( f->get(val_to_c<std::remove_reference<String>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("StrStrMap::get.")));
RET CN;
}

SV StrStrMap_getEntryCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::getEntryCount" EAOE));
HashMap<String,String>*f;
f=(HashMap<String,String>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getEntryCount());
;
}
CATE(TE,UFOF("StrStrMap::getEntryCount.")));
RET CN;
}

SV StrStrMap_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::clear" EAOE));
HashMap<String,String>*f;
f=(HashMap<String,String>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("StrStrMap::clear.")));
RET CN;
}

SV StrStrMap_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::remove" EAOE));
HashMap<String,String>*f;
f=(HashMap<String,String>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],String))
{
( f->remove(val_to_c<std::remove_reference<String>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("StrStrMap::remove.")));
RET CN;
}

SV StrStrMap_getValue(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::getValue" EAOE));
HashMap<String,String>*f;
f=(HashMap<String,String>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getValue(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getValue(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("StrStrMap::getValue.")));
RET CN;
}

SV StrStrMap_getKeyHash(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::getKeyHash" EAOE));
HashMap<String,String>*f;
f=(HashMap<String,String>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getKeyHash(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("StrStrMap::getKeyHash.")));
RET CN;
}

SV StrStrMap_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::append" EAOE));
HashMap<String,String>*f;
f=(HashMap<String,String>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const HashMap<String, String> &))
{
( f->append(val_to_c<std::remove_reference<const HashMap<String, String> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("StrStrMap::append.")));
RET CN;
}

SV StrStrMap_getKey(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::getKey" EAOE));
HashMap<String,String>*f;
f=(HashMap<String,String>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getKey(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getKey(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("StrStrMap::getKey.")));
RET CN;
}

SV StrStrMap___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::__eq__" EAOE));
HashMap<String,String>*f;
f=(HashMap<String,String>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const HashMap<String, String> &))
{
auto v=val_to_c<std::remove_reference<const HashMap<String, String> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("StrStrMap::__eq__.")));
RET CN;
}

SV StrStrMap_findEntry(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::findEntry" EAOE));
HashMap<String,String>*f;
f=(HashMap<String,String>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],String))
{
RET CV( f->findEntry(val_to_c<std::remove_reference<String>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("StrStrMap::findEntry.")));
RET CN;
}

SV StrStrMap___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StrStrMap::__neq__" EAOE));
HashMap<String,String>*f;
f=(HashMap<String,String>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const HashMap<String, String> &))
{
auto v=val_to_c<std::remove_reference<const HashMap<String, String> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("StrStrMap::__neq__.")));
RET CN;
}

void GfxApi_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxApi))
CATE(TE,"GfxApi::__del__ expects GfxApi as first argument."));

DELETE((GfxApi*)f->data);
}SV GfxApi_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxApi's constructor" EAOE));
if(!TS(a[0],GfxApi))
CATE(TE,"GfxApi's constructor expects GfxApi as first argument."));
CATE(TE,UFOF("GfxApi's constructor.")));
}

SV GfxApi_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxApi");
EI(keyStr=="__new__")
RET CNF(GfxApi_new);
EI(keyStr=="__call__")
RET CNF(GfxApi_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GfxApi_new);
 EI(keyStr == "getDriver")
RET CNF(GfxApi_getDriver);
 EI(keyStr == "tesselationSupported")
RET CNF(GfxApi_tesselationSupported);
 EI(keyStr == "createBuffer")
RET CNF(GfxApi_createBuffer);
 EI(keyStr == "createTextureImpl")
RET CNF(GfxApi_createTextureImpl);
 EI(keyStr == "createFramebuffer")
RET CNF(GfxApi_createFramebuffer);
 EI(keyStr == "createTimer")
RET CNF(GfxApi_createTimer);
 EI(keyStr == "setCurrentFramebuffer")
RET CNF(GfxApi_setCurrentFramebuffer);
 EI(keyStr == "clearDepth")
RET CNF(GfxApi_clearDepth);
 EI(keyStr == "clearColor")
RET CNF(GfxApi_clearColor);
 EI(keyStr == "begin")
RET CNF(GfxApi_begin);
 EI(keyStr == "draw")
RET CNF(GfxApi_draw);
 EI(keyStr == "end")
RET CNF(GfxApi_end);
 EI(keyStr == "uniform")
RET CNF(GfxApi_uniform);
 EI(keyStr == "addUBOBinding")
RET CNF(GfxApi_addUBOBinding);
 EI(keyStr == "addTextureBinding")
RET CNF(GfxApi_addTextureBinding);
 EI(keyStr == "pushState")
RET CNF(GfxApi_pushState);
 EI(keyStr == "popState")
RET CNF(GfxApi_popState);
 EI(keyStr == "resetState")
RET CNF(GfxApi_resetState);
 EI(keyStr == "setBlendingEnabled")
RET CNF(GfxApi_setBlendingEnabled);
 EI(keyStr == "isBlendingEnabled")
RET CNF(GfxApi_isBlendingEnabled);
 EI(keyStr == "setBlendConstantColor")
RET CNF(GfxApi_setBlendConstantColor);
 EI(keyStr == "getBlendConstantColor")
RET CNF(GfxApi_getBlendConstantColor);
 EI(keyStr == "getBlendConstantColorR")
RET CNF(GfxApi_getBlendConstantColorR);
 EI(keyStr == "getBlendConstantColorG")
RET CNF(GfxApi_getBlendConstantColorG);
 EI(keyStr == "getBlendConstantColorB")
RET CNF(GfxApi_getBlendConstantColorB);
 EI(keyStr == "getBlendConstantColorA")
RET CNF(GfxApi_getBlendConstantColorA);
 EI(keyStr == "setBlendFactors")
RET CNF(GfxApi_setBlendFactors);
 EI(keyStr == "getBlendSrcFactorRGB")
RET CNF(GfxApi_getBlendSrcFactorRGB);
 EI(keyStr == "getBlendSrcFactorAlpha")
RET CNF(GfxApi_getBlendSrcFactorAlpha);
 EI(keyStr == "getBlendDstFactorRGB")
RET CNF(GfxApi_getBlendDstFactorRGB);
 EI(keyStr == "getBlendDstFactorAlpha")
RET CNF(GfxApi_getBlendDstFactorAlpha);
 EI(keyStr == "setBlendMode")
RET CNF(GfxApi_setBlendMode);
 EI(keyStr == "getBlendModeRGB")
RET CNF(GfxApi_getBlendModeRGB);
 EI(keyStr == "getBlendModeAlpha")
RET CNF(GfxApi_getBlendModeAlpha);
 EI(keyStr == "setWriteDepth")
RET CNF(GfxApi_setWriteDepth);
 EI(keyStr == "getWriteDepth")
RET CNF(GfxApi_getWriteDepth);
 EI(keyStr == "setDepthFunction")
RET CNF(GfxApi_setDepthFunction);
 EI(keyStr == "getDepthFunction")
RET CNF(GfxApi_getDepthFunction);
 EI(keyStr == "setCullMode")
RET CNF(GfxApi_setCullMode);
 EI(keyStr == "getCullMode")
RET CNF(GfxApi_getCullMode);
 EI(keyStr == "setViewport")
RET CNF(GfxApi_setViewport);
 EI(keyStr == "getViewportLeft")
RET CNF(GfxApi_getViewportLeft);
 EI(keyStr == "getViewportBottom")
RET CNF(GfxApi_getViewportBottom);
 EI(keyStr == "getViewportWidth")
RET CNF(GfxApi_getViewportWidth);
 EI(keyStr == "getViewportHeight")
RET CNF(GfxApi_getViewportHeight);
 EI(keyStr == "setScissor")
RET CNF(GfxApi_setScissor);
 EI(keyStr == "getScissorLeft")
RET CNF(GfxApi_getScissorLeft);
 EI(keyStr == "getScissorBottom")
RET CNF(GfxApi_getScissorBottom);
 EI(keyStr == "getScissorWidth")
RET CNF(GfxApi_getScissorWidth);
 EI(keyStr == "getScissorHeight")
RET CNF(GfxApi_getScissorHeight);
 EI(keyStr == "setScissorEnabled")
RET CNF(GfxApi_setScissorEnabled);
 EI(keyStr == "getScissorEnabled")
RET CNF(GfxApi_getScissorEnabled);
 EI(keyStr == "setTessPatchSize")
RET CNF(GfxApi_setTessPatchSize);
 EI(keyStr == "getTessPatchSize")
RET CNF(GfxApi_getTessPatchSize);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GfxApi_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GfxApi_getScissorWidth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getScissorWidth" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScissorWidth());
;
}
CATE(TE,UFOF("GfxApi::getScissorWidth.")));
RET CN;
}

SV GfxApi_setDepthFunction(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setDepthFunction" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxDepthFunction))
{
( f->setDepthFunction(val_to_c<std::remove_reference<GfxDepthFunction>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setDepthFunction.")));
RET CN;
}

SV GfxApi_setCurrentFramebuffer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setCurrentFramebuffer" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxFramebuffer *))
{
( f->setCurrentFramebuffer(val_to_c<std::remove_reference<GfxFramebuffer *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setCurrentFramebuffer.")));
RET CN;
}

SV GfxApi_createTextureImpl(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::createTextureImpl" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

CATE(TE,UFOF("GfxApi::createTextureImpl.")));
RET CN;
}

SV GfxApi_draw(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::draw" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->draw(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::draw.")));
RET CN;
}

SV GfxApi_tesselationSupported(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::tesselationSupported" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->tesselationSupported());
;
}
CATE(TE,UFOF("GfxApi::tesselationSupported.")));
RET CN;
}

SV GfxApi_popState(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::popState" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->popState());
RET CN;
}
CATE(TE,UFOF("GfxApi::popState.")));
RET CN;
}

SV GfxApi_getBlendModeAlpha(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendModeAlpha" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendModeAlpha());
;
}
CATE(TE,UFOF("GfxApi::getBlendModeAlpha.")));
RET CN;
}

SV GfxApi_getDepthFunction(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getDepthFunction" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDepthFunction());
;
}
CATE(TE,UFOF("GfxApi::getDepthFunction.")));
RET CN;
}

SV GfxApi_pushState(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::pushState" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->pushState());
RET CN;
}
CATE(TE,UFOF("GfxApi::pushState.")));
RET CN;
}

SV GfxApi_getViewportLeft(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getViewportLeft" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getViewportLeft());
;
}
CATE(TE,UFOF("GfxApi::getViewportLeft.")));
RET CN;
}

SV GfxApi_getWriteDepth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getWriteDepth" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWriteDepth());
;
}
CATE(TE,UFOF("GfxApi::getWriteDepth.")));
RET CN;
}

SV GfxApi_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::end" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->end(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::end.")));
RET CN;
}

SV GfxApi_getScissorLeft(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getScissorLeft" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScissorLeft());
;
}
CATE(TE,UFOF("GfxApi::getScissorLeft.")));
RET CN;
}

SV GfxApi_setScissor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setScissor" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==5)
if(1&&TS(a[1],uint16_t)&&TS(a[2],uint16_t)&&TS(a[3],uint16_t)&&TS(a[4],uint16_t))
{
( f->setScissor(val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[4])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setScissor.")));
RET CN;
}

SV GfxApi_resetState(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::resetState" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->resetState());
RET CN;
}
CATE(TE,UFOF("GfxApi::resetState.")));
RET CN;
}

SV GfxApi_getBlendDstFactorAlpha(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendDstFactorAlpha" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendDstFactorAlpha());
;
}
CATE(TE,UFOF("GfxApi::getBlendDstFactorAlpha.")));
RET CN;
}

SV GfxApi_getBlendConstantColorR(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendConstantColorR" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendConstantColorR());
;
}
CATE(TE,UFOF("GfxApi::getBlendConstantColorR.")));
RET CN;
}

SV GfxApi_uniform(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::uniform" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],float))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const Float2 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Float2 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const Float3 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const Float4 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Float4 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],int32_t))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const Int2 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Int2 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const Int3 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Int3 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const Int4 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Int4 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],uint32_t))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const UInt2 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const UInt2 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const UInt3 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const UInt3 &>::type>::f(ctx,a[3])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const UInt4 &))
{
( f->uniform(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const UInt4 &>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("GfxApi::uniform.")));
RET CN;
}

SV GfxApi_getTessPatchSize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getTessPatchSize" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getTessPatchSize());
;
}
CATE(TE,UFOF("GfxApi::getTessPatchSize.")));
RET CN;
}

SV GfxApi_addUBOBinding(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::addUBOBinding" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],const GfxBuffer *))
{
( f->addUBOBinding(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const GfxBuffer *>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("GfxApi::addUBOBinding.")));
RET CN;
}

SV GfxApi_getBlendModeRGB(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendModeRGB" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendModeRGB());
;
}
CATE(TE,UFOF("GfxApi::getBlendModeRGB.")));
RET CN;
}

SV GfxApi_setScissorEnabled(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setScissorEnabled" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],bool))
{
( f->setScissorEnabled(val_to_c<std::remove_reference<bool>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setScissorEnabled.")));
RET CN;
}

SV GfxApi_getBlendConstantColorG(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendConstantColorG" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendConstantColorG());
;
}
CATE(TE,UFOF("GfxApi::getBlendConstantColorG.")));
RET CN;
}

SV GfxApi_createFramebuffer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::createFramebuffer" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->createFramebuffer());
;
}
CATE(TE,UFOF("GfxApi::createFramebuffer.")));
RET CN;
}

SV GfxApi_getBlendConstantColorA(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendConstantColorA" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendConstantColorA());
;
}
CATE(TE,UFOF("GfxApi::getBlendConstantColorA.")));
RET CN;
}

SV GfxApi_getBlendConstantColorB(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendConstantColorB" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendConstantColorB());
;
}
CATE(TE,UFOF("GfxApi::getBlendConstantColorB.")));
RET CN;
}

SV GfxApi_getBlendSrcFactorRGB(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendSrcFactorRGB" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendSrcFactorRGB());
;
}
CATE(TE,UFOF("GfxApi::getBlendSrcFactorRGB.")));
RET CN;
}

SV GfxApi_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::begin" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==7)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],GfxCompiledShader *)&&TS(a[3],GfxCompiledShader *)&&TS(a[4],GfxCompiledShader *)&&TS(a[5],GfxCompiledShader *)&&TS(a[6],GfxMesh *))
{
( f->begin(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[5]), val_to_c<std::remove_reference<GfxMesh *>::type>::f(ctx,a[6])));
RET CN;
}
CATE(TE,UFOF("GfxApi::begin.")));
RET CN;
}

SV GfxApi_setTessPatchSize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setTessPatchSize" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->setTessPatchSize(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setTessPatchSize.")));
RET CN;
}

SV GfxApi_getViewportWidth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getViewportWidth" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getViewportWidth());
;
}
CATE(TE,UFOF("GfxApi::getViewportWidth.")));
RET CN;
}

SV GfxApi_setBlendFactors(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setBlendFactors" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==5)
if(1&&TS(a[1],GfxBlendFactor)&&TS(a[2],GfxBlendFactor)&&TS(a[3],GfxBlendFactor)&&TS(a[4],GfxBlendFactor))
{
( f->setBlendFactors(val_to_c<std::remove_reference<GfxBlendFactor>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxBlendFactor>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<GfxBlendFactor>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<GfxBlendFactor>::type>::f(ctx,a[4])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setBlendFactors.")));
RET CN;
}

SV GfxApi_getViewportBottom(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getViewportBottom" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getViewportBottom());
;
}
CATE(TE,UFOF("GfxApi::getViewportBottom.")));
RET CN;
}

SV GfxApi_getDriver(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getDriver" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDriver());
;
}
CATE(TE,UFOF("GfxApi::getDriver.")));
RET CN;
}

SV GfxApi_setBlendMode(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setBlendMode" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],GfxBlendMode)&&TS(a[2],GfxBlendMode))
{
( f->setBlendMode(val_to_c<std::remove_reference<GfxBlendMode>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxBlendMode>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setBlendMode.")));
RET CN;
}

SV GfxApi_setWriteDepth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setWriteDepth" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],bool))
{
( f->setWriteDepth(val_to_c<std::remove_reference<bool>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setWriteDepth.")));
RET CN;
}

SV GfxApi_createBuffer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::createBuffer" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->createBuffer());
;
}
CATE(TE,UFOF("GfxApi::createBuffer.")));
RET CN;
}

SV GfxApi_getScissorEnabled(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getScissorEnabled" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScissorEnabled());
;
}
CATE(TE,UFOF("GfxApi::getScissorEnabled.")));
RET CN;
}

SV GfxApi_getCullMode(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getCullMode" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCullMode());
;
}
CATE(TE,UFOF("GfxApi::getCullMode.")));
RET CN;
}

SV GfxApi_getBlendConstantColor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendConstantColor" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

CATE(TE,UFOF("GfxApi::getBlendConstantColor.")));
RET CN;
}

SV GfxApi_clearDepth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::clearDepth" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->clearDepth(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::clearDepth.")));
RET CN;
}

SV GfxApi_setBlendConstantColor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setBlendConstantColor" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==5)
if(1&&TS(a[1],uint8_t)&&TS(a[2],uint8_t)&&TS(a[3],uint8_t)&&TS(a[4],uint8_t))
{
( f->setBlendConstantColor(val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[4])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setBlendConstantColor.")));
RET CN;
}

SV GfxApi_setBlendingEnabled(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setBlendingEnabled" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],bool))
{
( f->setBlendingEnabled(val_to_c<std::remove_reference<bool>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setBlendingEnabled.")));
RET CN;
}

SV GfxApi_getBlendSrcFactorAlpha(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendSrcFactorAlpha" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendSrcFactorAlpha());
;
}
CATE(TE,UFOF("GfxApi::getBlendSrcFactorAlpha.")));
RET CN;
}

SV GfxApi_createTimer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::createTimer" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->createTimer());
;
}
CATE(TE,UFOF("GfxApi::createTimer.")));
RET CN;
}

SV GfxApi_getScissorBottom(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getScissorBottom" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScissorBottom());
;
}
CATE(TE,UFOF("GfxApi::getScissorBottom.")));
RET CN;
}

SV GfxApi_getBlendDstFactorRGB(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getBlendDstFactorRGB" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBlendDstFactorRGB());
;
}
CATE(TE,UFOF("GfxApi::getBlendDstFactorRGB.")));
RET CN;
}

SV GfxApi_setCullMode(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setCullMode" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxCullMode))
{
( f->setCullMode(val_to_c<std::remove_reference<GfxCullMode>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setCullMode.")));
RET CN;
}

SV GfxApi_setViewport(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::setViewport" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==5)
if(1&&TS(a[1],uint16_t)&&TS(a[2],uint16_t)&&TS(a[3],uint16_t)&&TS(a[4],uint16_t))
{
( f->setViewport(val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[4])));
RET CN;
}
CATE(TE,UFOF("GfxApi::setViewport.")));
RET CN;
}

SV GfxApi_addTextureBinding(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::addTextureBinding" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==5)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],GfxTexture *)&&TS(a[4],TextureSampler))
{
( f->addTextureBinding(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<TextureSampler>::type>::f(ctx,a[4])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],GfxCompiledShader *)&&TS(a[2],const char *)&&TS(a[3],GfxTexture *))
{
( f->addTextureBinding(val_to_c<std::remove_reference<GfxCompiledShader *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("GfxApi::addTextureBinding.")));
RET CN;
}

SV GfxApi_getViewportHeight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getViewportHeight" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getViewportHeight());
;
}
CATE(TE,UFOF("GfxApi::getViewportHeight.")));
RET CN;
}

SV GfxApi_getScissorHeight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::getScissorHeight" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScissorHeight());
;
}
CATE(TE,UFOF("GfxApi::getScissorHeight.")));
RET CN;
}

SV GfxApi_isBlendingEnabled(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::isBlendingEnabled" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->isBlendingEnabled());
;
}
CATE(TE,UFOF("GfxApi::isBlendingEnabled.")));
RET CN;
}

SV GfxApi_clearColor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxApi::clearColor" EAOE));
GfxApi*f;
f=(GfxApi*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],Float4))
{
( f->clearColor(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<Float4>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],Int4))
{
( f->clearColor(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<Int4>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],UInt4))
{
( f->clearColor(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<UInt4>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxApi::clearColor.")));
RET CN;
}

void GfxCompiledShader_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxCompiledShader))
CATE(TE,"GfxCompiledShader::__del__ expects GfxCompiledShader as first argument."));

DELETE((GfxCompiledShader*)f->data);
}SV GfxCompiledShader_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxCompiledShader's constructor" EAOE));
if(!TS(a[0],GfxCompiledShader))
CATE(TE,"GfxCompiledShader's constructor expects GfxCompiledShader as first argument."));
CATE(TE,UFOF("GfxCompiledShader's constructor.")));
}

SV GfxCompiledShader_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxCompiledShader");
EI(keyStr=="__new__")
RET CNF(GfxCompiledShader_new);
EI(keyStr=="__call__")
RET CNF(GfxCompiledShader_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GfxCompiledShader_new);
 EI(keyStr == "getShader")
RET CNF(GfxCompiledShader_getShader);
 EI(keyStr == "getGLProgram")
RET CNF(GfxCompiledShader_getGLProgram);
 EI(keyStr == "getGLShader")
RET CNF(GfxCompiledShader_getGLShader);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GfxCompiledShader_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GfxCompiledShader_getGLShader(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxCompiledShader::getGLShader" EAOE));
GfxCompiledShader*f;
f=(GfxCompiledShader*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGLShader());
;
}
CATE(TE,UFOF("GfxCompiledShader::getGLShader.")));
RET CN;
}

SV GfxCompiledShader_getShader(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxCompiledShader::getShader" EAOE));
GfxCompiledShader*f;
f=(GfxCompiledShader*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShader());
;
}
CATE(TE,UFOF("GfxCompiledShader::getShader.")));
RET CN;
}

SV GfxCompiledShader_getGLProgram(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxCompiledShader::getGLProgram" EAOE));
GfxCompiledShader*f;
f=(GfxCompiledShader*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGLProgram());
;
}
CATE(TE,UFOF("GfxCompiledShader::getGLProgram.")));
RET CN;
}

void ScrollBar_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,ScrollBar))
CATE(TE,"ScrollBar::__del__ expects ScrollBar as first argument."));

DELETE((ScrollBar*)f->data);
}SV ScrollBar_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScrollBar's constructor" EAOE));
if(!TS(a[0],ScrollBar))
CATE(TE,"ScrollBar's constructor expects ScrollBar as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(ScrollBar_funcs,NEW(ScrollBar),EXT->ScrollBar_typeID);
CATE(TE,UFOF("ScrollBar's constructor.")));
RET CN;
}

SV ScrollBar_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("ScrollBar");
EI(keyStr=="__new__")
RET CNF(ScrollBar_new);
EI(keyStr=="__call__")
RET CNF(ScrollBar_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(ScrollBar_new);
 EI(keyStr == "getValue")
RET CNF(ScrollBar_getValue);
 EI(keyStr == "setValue")
RET CNF(ScrollBar_setValue);
 EI(keyStr=="center")
{
ScrollBar*obj=(ScrollBar*)f->data;
RET CV(obj->center);
} EI(keyStr=="barSize")
{
ScrollBar*obj=(ScrollBar*)f->data;
RET CV(obj->barSize);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void ScrollBar_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="center")
{
ScrollBar*obj=(ScrollBar*)f->data;
obj->center=val_to_c<decltype(obj->center)>::f(ctx,value);
} EI(keyStr=="barSize")
{
ScrollBar*obj=(ScrollBar*)f->data;
obj->barSize=val_to_c<decltype(obj->barSize)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV ScrollBar_setValue(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScrollBar::setValue" EAOE));
ScrollBar*f;
f=(ScrollBar*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setValue(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("ScrollBar::setValue.")));
RET CN;
}

SV ScrollBar_getValue(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ScrollBar::getValue" EAOE));
ScrollBar*f;
f=(ScrollBar*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getValue());
;
}
CATE(TE,UFOF("ScrollBar::getValue.")));
RET CN;
}

void GhostObjList_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<GhostObject*>))
CATE(TE,"GhostObjList::__del__ expects GhostObjList as first argument."));

DELETE((List<GhostObject*>*)f->data);
}SV GhostObjList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList's constructor" EAOE));
if(!TS(a[0],List<GhostObject*>))
CATE(TE,"GhostObjList's constructor expects GhostObjList as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(GhostObjList_funcs,NEW(List<GhostObject*>),EXT->GhostObjList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],std::size_t))
RET STG::createNativeObject(GhostObjList_funcs,NEW(List<GhostObject*>,val_to_c<std::size_t>::f(ctx,a[1])),EXT->GhostObjList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const List<GhostObject*> &))
RET STG::createNativeObject(GhostObjList_funcs,NEW(List<GhostObject*>,val_to_c<const List<GhostObject*> &>::f(ctx,a[1])),EXT->GhostObjList_typeID);
CATE(TE,UFOF("GhostObjList's constructor.")));
RET CN;
}

SV GhostObjList_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GhostObjList");
EI(keyStr=="__new__")
RET CNF(GhostObjList_new);
EI(keyStr=="__call__")
RET CNF(GhostObjList_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GhostObjList_new);
 EI(keyStr == "__eq__")
RET CNF(GhostObjList___eq__);
 EI(keyStr == "__neq__")
RET CNF(GhostObjList___neq__);
 EI(keyStr == "get")
RET CNF(GhostObjList_get);
 EI(keyStr == "set")
RET CNF(GhostObjList_set);
 EI(keyStr == "getCount")
RET CNF(GhostObjList_getCount);
 EI(keyStr == "getData")
RET CNF(GhostObjList_getData);
 EI(keyStr == "append")
RET CNF(GhostObjList_append);
 EI(keyStr == "insert")
RET CNF(GhostObjList_insert);
 EI(keyStr == "remove")
RET CNF(GhostObjList_remove);
 EI(keyStr == "clear")
RET CNF(GhostObjList_clear);
 EI(keyStr == "find")
RET CNF(GhostObjList_find);
 EI(keyStr == "copy")
RET CNF(GhostObjList_copy);
 EI(keyStr == "in")
RET CNF(GhostObjList_in);
 EI(keyStr == "begin")
RET CNF(GhostObjList_begin);
 EI(keyStr == "end")
RET CNF(GhostObjList_end);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GhostObjList_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GhostObjList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::insert" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],GhostObject*))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GhostObject*>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<GhostObject*> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<GhostObject*> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GhostObjList::insert.")));
RET CN;
}

SV GhostObjList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::begin" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0])->data;

CATE(TE,UFOF("GhostObjList::begin.")));
RET CN;
}

SV GhostObjList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::set" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],GhostObject*))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GhostObject*>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GhostObjList::set.")));
RET CN;
}

SV GhostObjList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::end" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0])->data;

CATE(TE,UFOF("GhostObjList::end.")));
RET CN;
}

SV GhostObjList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::get" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GhostObjList::get.")));
RET CN;
}

SV GhostObjList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::clear" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("GhostObjList::clear.")));
RET CN;
}

SV GhostObjList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::copy" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("GhostObjList::copy.")));
RET CN;
}

SV GhostObjList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::remove" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GhostObjList::remove.")));
RET CN;
}

SV GhostObjList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::in" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GhostObject*))
{
RET CV( f->in(val_to_c<std::remove_reference<GhostObject*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GhostObjList::in.")));
RET CN;
}

SV GhostObjList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::getCount" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("GhostObjList::getCount.")));
RET CN;
}

SV GhostObjList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::getData" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0])->data;

CATE(TE,UFOF("GhostObjList::getData.")));
RET CN;
}

SV GhostObjList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::__eq__" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<GhostObject*> &))
{
auto v=val_to_c<std::remove_reference<const List<GhostObject*> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("GhostObjList::__eq__.")));
RET CN;
}

SV GhostObjList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::find" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GhostObject*))
{
RET CV( f->find(val_to_c<std::remove_reference<GhostObject*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GhostObjList::find.")));
RET CN;
}

SV GhostObjList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::append" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GhostObject*))
{
( f->append(val_to_c<std::remove_reference<GhostObject*>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<GhostObject*> &))
{
( f->append(val_to_c<std::remove_reference<const List<GhostObject*> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GhostObjList::append.")));
RET CN;
}

SV GhostObjList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GhostObjList::__neq__" EAOE));
List<GhostObject*>*f;
f=(List<GhostObject*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<GhostObject*> &))
{
auto v=val_to_c<std::remove_reference<const List<GhostObject*> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("GhostObjList::__neq__.")));
RET CN;
}

void GPUTimer_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GPUTimer))
CATE(TE,"GPUTimer::__del__ expects GPUTimer as first argument."));

DELETE((GPUTimer*)f->data);
}SV GPUTimer_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GPUTimer's constructor" EAOE));
if(!TS(a[0],GPUTimer))
CATE(TE,"GPUTimer's constructor expects GPUTimer as first argument."));
CATE(TE,UFOF("GPUTimer's constructor.")));
}

SV GPUTimer_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GPUTimer");
EI(keyStr=="__new__")
RET CNF(GPUTimer_new);
EI(keyStr=="__call__")
RET CNF(GPUTimer_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GPUTimer_new);
 EI(keyStr == "resultAvailable")
RET CNF(GPUTimer_resultAvailable);
 EI(keyStr == "getResult")
RET CNF(GPUTimer_getResult);
 EI(keyStr == "getResultResolution")
RET CNF(GPUTimer_getResultResolution);
 EI(keyStr == "begin")
RET CNF(GPUTimer_begin);
 EI(keyStr == "end")
RET CNF(GPUTimer_end);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GPUTimer_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GPUTimer_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GPUTimer::begin" EAOE));
GPUTimer*f;
f=(GPUTimer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->begin());
RET CN;
}
CATE(TE,UFOF("GPUTimer::begin.")));
RET CN;
}

SV GPUTimer_resultAvailable(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GPUTimer::resultAvailable" EAOE));
GPUTimer*f;
f=(GPUTimer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->resultAvailable());
;
}
CATE(TE,UFOF("GPUTimer::resultAvailable.")));
RET CN;
}

SV GPUTimer_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GPUTimer::end" EAOE));
GPUTimer*f;
f=(GPUTimer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->end());
RET CN;
}
CATE(TE,UFOF("GPUTimer::end.")));
RET CN;
}

SV GPUTimer_getResultResolution(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GPUTimer::getResultResolution" EAOE));
GPUTimer*f;
f=(GPUTimer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getResultResolution());
;
}
CATE(TE,UFOF("GPUTimer::getResultResolution.")));
RET CN;
}

SV GPUTimer_getResult(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GPUTimer::getResult" EAOE));
GPUTimer*f;
f=(GPUTimer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getResult());
;
}
CATE(TE,UFOF("GPUTimer::getResult.")));
RET CN;
}

void RigidBody_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,RigidBody))
CATE(TE,"RigidBody::__del__ expects RigidBody as first argument."));

}SV RigidBody_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"RigidBody's constructor" EAOE));
if(!TS(a[0],RigidBody))
CATE(TE,"RigidBody's constructor expects RigidBody as first argument."));
CATE(TE,UFOF("RigidBody's constructor.")));
}

SV RigidBody_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("RigidBody");
EI(keyStr=="__new__")
RET CNF(RigidBody_new);
EI(keyStr=="__call__")
RET CNF(RigidBody_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(RigidBody_new);
 EI(keyStr == "getBulletRigidBody")
RET CNF(RigidBody_getBulletRigidBody);
 EI(keyStr == "getType")
RET CNF(RigidBody_getType);
 EI(keyStr == "getGravity")
RET CNF(RigidBody_getGravity);
 EI(keyStr == "setGravity")
RET CNF(RigidBody_setGravity);
 EI(keyStr == "setLinearDamping")
RET CNF(RigidBody_setLinearDamping);
 EI(keyStr == "getLinearDamping")
RET CNF(RigidBody_getLinearDamping);
 EI(keyStr == "setAngularDamping")
RET CNF(RigidBody_setAngularDamping);
 EI(keyStr == "getAngularDamping")
RET CNF(RigidBody_getAngularDamping);
 EI(keyStr == "setMass")
RET CNF(RigidBody_setMass);
 EI(keyStr == "getMass")
RET CNF(RigidBody_getMass);
 EI(keyStr == "getLinearSleepingThreshold")
RET CNF(RigidBody_getLinearSleepingThreshold);
 EI(keyStr == "setLinearSleepingThreshold")
RET CNF(RigidBody_setLinearSleepingThreshold);
 EI(keyStr == "getAngularSleepingThreshold")
RET CNF(RigidBody_getAngularSleepingThreshold);
 EI(keyStr == "setAngularSleepingThreshold")
RET CNF(RigidBody_setAngularSleepingThreshold);
 EI(keyStr == "applyTorque")
RET CNF(RigidBody_applyTorque);
 EI(keyStr == "applyForce")
RET CNF(RigidBody_applyForce);
 EI(keyStr == "applyCentralImpulse")
RET CNF(RigidBody_applyCentralImpulse);
 EI(keyStr == "applyTorqueImpulse")
RET CNF(RigidBody_applyTorqueImpulse);
 EI(keyStr == "applyImpulse")
RET CNF(RigidBody_applyImpulse);
 EI(keyStr == "clearForces")
RET CNF(RigidBody_clearForces);
 EI(keyStr == "getLinearVelocity")
RET CNF(RigidBody_getLinearVelocity);
 EI(keyStr == "setLinearVelocity")
RET CNF(RigidBody_setLinearVelocity);
 EI(keyStr == "getAngularVelocity")
RET CNF(RigidBody_getAngularVelocity);
 EI(keyStr == "setAngularVelocity")
RET CNF(RigidBody_setAngularVelocity);
 EI(keyStr == "getVelocityOfPoint")
RET CNF(RigidBody_getVelocityOfPoint);
 EI(keyStr == "getRestitution")
RET CNF(RigidBody_getRestitution);
 EI(keyStr == "setRestitution")
RET CNF(RigidBody_setRestitution);
 EI(keyStr == "getFriction")
RET CNF(RigidBody_getFriction);
 EI(keyStr == "setFriction")
RET CNF(RigidBody_setFriction);
 EI(keyStr == "getRollingFriction")
RET CNF(RigidBody_getRollingFriction);
 EI(keyStr == "setRollingFriction")
RET CNF(RigidBody_setRollingFriction);
 EI(keyStr == "getLinearFactor")
RET CNF(RigidBody_getLinearFactor);
 EI(keyStr == "setLinearFactor")
RET CNF(RigidBody_setLinearFactor);
 EI(keyStr == "getAngularFactor")
RET CNF(RigidBody_getAngularFactor);
 EI(keyStr == "setAngularFactor")
RET CNF(RigidBody_setAngularFactor);
 EI(keyStr == "setTransform")
RET CNF(RigidBody_setTransform);
 EI(keyStr == "getWorld")
RET CNF(RigidBody_getWorld);
 EI(keyStr == "getCollisionMask")
RET CNF(RigidBody_getCollisionMask);
 EI(keyStr == "setShape")
RET CNF(RigidBody_setShape);
 EI(keyStr == "getShape")
RET CNF(RigidBody_getShape);
 EI(keyStr == "getEntity")
RET CNF(RigidBody_getEntity);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void RigidBody_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV RigidBody_setGravity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setGravity" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->setGravity(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setGravity.")));
RET CN;
}

SV RigidBody_getFriction(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getFriction" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFriction());
;
}
CATE(TE,UFOF("RigidBody::getFriction.")));
RET CN;
}

SV RigidBody_getRollingFriction(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getRollingFriction" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRollingFriction());
;
}
CATE(TE,UFOF("RigidBody::getRollingFriction.")));
RET CN;
}

SV RigidBody_setAngularFactor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setAngularFactor" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
( f->setAngularFactor(val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setAngularFactor.")));
RET CN;
}

SV RigidBody_getVelocityOfPoint(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getVelocityOfPoint" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Position3D &))
{
RET CV( f->getVelocityOfPoint(val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("RigidBody::getVelocityOfPoint.")));
RET CN;
}

SV RigidBody_setTransform(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setTransform" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Matrix4x4 &))
{
( f->setTransform(val_to_c<std::remove_reference<const Matrix4x4 &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setTransform.")));
RET CN;
}

SV RigidBody_getMass(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getMass" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getMass());
;
}
CATE(TE,UFOF("RigidBody::getMass.")));
RET CN;
}

SV RigidBody_setFriction(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setFriction" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setFriction(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setFriction.")));
RET CN;
}

SV RigidBody_clearForces(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::clearForces" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->clearForces());
RET CN;
}
CATE(TE,UFOF("RigidBody::clearForces.")));
RET CN;
}

SV RigidBody_applyImpulse(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::applyImpulse" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],const Vector3D &)&&TS(a[2],const Position3D &))
{
( f->applyImpulse(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("RigidBody::applyImpulse.")));
RET CN;
}

SV RigidBody_applyTorque(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::applyTorque" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->applyTorque(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::applyTorque.")));
RET CN;
}

SV RigidBody_setLinearFactor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setLinearFactor" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
( f->setLinearFactor(val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setLinearFactor.")));
RET CN;
}

SV RigidBody_setLinearDamping(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setLinearDamping" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setLinearDamping(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setLinearDamping.")));
RET CN;
}

SV RigidBody_getLinearFactor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getLinearFactor" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getLinearFactor());
;
}
CATE(TE,UFOF("RigidBody::getLinearFactor.")));
RET CN;
}

SV RigidBody_setAngularDamping(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setAngularDamping" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setAngularDamping(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setAngularDamping.")));
RET CN;
}

SV RigidBody_getWorld(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getWorld" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWorld());
;
}
CATE(TE,UFOF("RigidBody::getWorld.")));
RET CN;
}

SV RigidBody_getAngularVelocity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getAngularVelocity" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAngularVelocity());
;
}
CATE(TE,UFOF("RigidBody::getAngularVelocity.")));
RET CN;
}

SV RigidBody_getShape(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getShape" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShape());
;
}
CATE(TE,UFOF("RigidBody::getShape.")));
RET CN;
}

SV RigidBody_setAngularSleepingThreshold(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setAngularSleepingThreshold" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setAngularSleepingThreshold(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setAngularSleepingThreshold.")));
RET CN;
}

SV RigidBody_applyTorqueImpulse(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::applyTorqueImpulse" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->applyTorqueImpulse(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::applyTorqueImpulse.")));
RET CN;
}

SV RigidBody_setLinearVelocity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setLinearVelocity" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->setLinearVelocity(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setLinearVelocity.")));
RET CN;
}

SV RigidBody_getCollisionMask(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getCollisionMask" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCollisionMask());
;
}
CATE(TE,UFOF("RigidBody::getCollisionMask.")));
RET CN;
}

SV RigidBody_getLinearVelocity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getLinearVelocity" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getLinearVelocity());
;
}
CATE(TE,UFOF("RigidBody::getLinearVelocity.")));
RET CN;
}

SV RigidBody_setAngularVelocity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setAngularVelocity" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->setAngularVelocity(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setAngularVelocity.")));
RET CN;
}

SV RigidBody_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getType" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("RigidBody::getType.")));
RET CN;
}

SV RigidBody_getAngularSleepingThreshold(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getAngularSleepingThreshold" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAngularSleepingThreshold());
;
}
CATE(TE,UFOF("RigidBody::getAngularSleepingThreshold.")));
RET CN;
}

SV RigidBody_setLinearSleepingThreshold(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setLinearSleepingThreshold" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setLinearSleepingThreshold(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setLinearSleepingThreshold.")));
RET CN;
}

SV RigidBody_setRollingFriction(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setRollingFriction" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setRollingFriction(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setRollingFriction.")));
RET CN;
}

SV RigidBody_getGravity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getGravity" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGravity());
;
}
CATE(TE,UFOF("RigidBody::getGravity.")));
RET CN;
}

SV RigidBody_setMass(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setMass" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setMass(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setMass.")));
RET CN;
}

SV RigidBody_applyCentralImpulse(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::applyCentralImpulse" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->applyCentralImpulse(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::applyCentralImpulse.")));
RET CN;
}

SV RigidBody_getBulletRigidBody(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getBulletRigidBody" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

CATE(TE,UFOF("RigidBody::getBulletRigidBody.")));
RET CN;
}

SV RigidBody_getRestitution(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getRestitution" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRestitution());
;
}
CATE(TE,UFOF("RigidBody::getRestitution.")));
RET CN;
}

SV RigidBody_getAngularFactor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getAngularFactor" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAngularFactor());
;
}
CATE(TE,UFOF("RigidBody::getAngularFactor.")));
RET CN;
}

SV RigidBody_getAngularDamping(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getAngularDamping" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAngularDamping());
;
}
CATE(TE,UFOF("RigidBody::getAngularDamping.")));
RET CN;
}

SV RigidBody_getLinearSleepingThreshold(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getLinearSleepingThreshold" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getLinearSleepingThreshold());
;
}
CATE(TE,UFOF("RigidBody::getLinearSleepingThreshold.")));
RET CN;
}

SV RigidBody_applyForce(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::applyForce" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],const Vector3D &)&&TS(a[2],const Position3D &))
{
( f->applyForce(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("RigidBody::applyForce.")));
RET CN;
}

SV RigidBody_getEntity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getEntity" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getEntity());
;
}
CATE(TE,UFOF("RigidBody::getEntity.")));
RET CN;
}

SV RigidBody_setRestitution(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setRestitution" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setRestitution(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setRestitution.")));
RET CN;
}

SV RigidBody_setShape(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::setShape" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],PhysicsShape *))
{
( f->setShape(val_to_c<std::remove_reference<PhysicsShape *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBody::setShape.")));
RET CN;
}

SV RigidBody_getLinearDamping(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBody::getLinearDamping" EAOE));
RigidBody*f;
f=(RigidBody*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getLinearDamping());
;
}
CATE(TE,UFOF("RigidBody::getLinearDamping.")));
RET CN;
}

void UInt2_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T2<uint32_t>))
CATE(TE,"UInt2::__del__ expects UInt2 as first argument."));

DELETE((T2<uint32_t>*)f->data);
}SV UInt2_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2's constructor" EAOE));
if(!TS(a[0],T2<uint32_t>))
CATE(TE,"UInt2's constructor expects UInt2 as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(UInt2_funcs,NEW(T2<uint32_t>),EXT->UInt2_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],uint32_t))
RET STG::createNativeObject(UInt2_funcs,NEW(T2<uint32_t>,val_to_c<uint32_t>::f(ctx,a[1])),EXT->UInt2_typeID);
if(a.getCount()==3)
if(true&&TS(a[1],uint32_t)&&TS(a[2],uint32_t))
RET STG::createNativeObject(UInt2_funcs,NEW(T2<uint32_t>,val_to_c<uint32_t>::f(ctx,a[1]),val_to_c<uint32_t>::f(ctx,a[2])),EXT->UInt2_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T2<float> &))
RET STG::createNativeObject(UInt2_funcs,NEW(T2<uint32_t>,val_to_c<const T2<float> &>::f(ctx,a[1])),EXT->UInt2_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T2<int32_t> &))
RET STG::createNativeObject(UInt2_funcs,NEW(T2<uint32_t>,val_to_c<const T2<int32_t> &>::f(ctx,a[1])),EXT->UInt2_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T2<uint32_t> &))
RET STG::createNativeObject(UInt2_funcs,NEW(T2<uint32_t>,val_to_c<const T2<uint32_t> &>::f(ctx,a[1])),EXT->UInt2_typeID);
CATE(TE,UFOF("UInt2's constructor.")));
RET CN;
}

SV UInt2_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("UInt2");
EI(keyStr=="__new__")
RET CNF(UInt2_new);
EI(keyStr=="__call__")
RET CNF(UInt2_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(UInt2_new);
 EI(keyStr == "__add__")
RET CNF(UInt2___add__);
 EI(keyStr == "__sub__")
RET CNF(UInt2___sub__);
 EI(keyStr == "__mul__")
RET CNF(UInt2___mul__);
 EI(keyStr == "__div__")
RET CNF(UInt2___div__);
 EI(keyStr == "__eq__")
RET CNF(UInt2___eq__);
 EI(keyStr == "__neq__")
RET CNF(UInt2___neq__);
 EI(keyStr == "__less__")
RET CNF(UInt2___less__);
 EI(keyStr == "__grtr__")
RET CNF(UInt2___grtr__);
 EI(keyStr == "__leq__")
RET CNF(UInt2___leq__);
 EI(keyStr == "__geq__")
RET CNF(UInt2___geq__);
 EI(keyStr == "sum")
RET CNF(UInt2_sum);
 EI(keyStr == "length")
RET CNF(UInt2_length);
 EI(keyStr == "lengthSquared")
RET CNF(UInt2_lengthSquared);
 EI(keyStr == "dot")
RET CNF(UInt2_dot);
 EI(keyStr == "distance")
RET CNF(UInt2_distance);
 EI(keyStr == "distanceSquared")
RET CNF(UInt2_distanceSquared);
 EI(keyStr == "normalize")
RET CNF(UInt2_normalize);
 EI(keyStr == "getXY")
RET CNF(UInt2_getXY);
 EI(keyStr == "setXY")
RET CNF(UInt2_setXY);
 EI(keyStr == "getYX")
RET CNF(UInt2_getYX);
 EI(keyStr == "setYX")
RET CNF(UInt2_setYX);
 EI(keyStr=="x")
{
T2<uint32_t>*obj=(T2<uint32_t>*)f->data;
RET CV(obj->x);
} EI(keyStr=="y")
{
T2<uint32_t>*obj=(T2<uint32_t>*)f->data;
RET CV(obj->y);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void UInt2_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="x")
{
T2<uint32_t>*obj=(T2<uint32_t>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr=="y")
{
T2<uint32_t>*obj=(T2<uint32_t>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV UInt2_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::normalize" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("UInt2::normalize.")));
RET CN;
}

SV UInt2_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::distance" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("UInt2::distance.")));
RET CN;
}

SV UInt2_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::lengthSquared" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("UInt2::lengthSquared.")));
RET CN;
}

SV UInt2___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__leq__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("UInt2::__leq__.")));
RET CN;
}

SV UInt2_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::setYX" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt2::setYX.")));
RET CN;
}

SV UInt2___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__grtr__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("UInt2::__grtr__.")));
RET CN;
}

SV UInt2_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::sum" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("UInt2::sum.")));
RET CN;
}

SV UInt2_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::getXY" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("UInt2::getXY.")));
RET CN;
}

SV UInt2_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::length" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("UInt2::length.")));
RET CN;
}

SV UInt2_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::getYX" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("UInt2::getYX.")));
RET CN;
}

SV UInt2___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__div__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("UInt2::__div__.")));
RET CN;
}

SV UInt2_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::setXY" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt2::setXY.")));
RET CN;
}

SV UInt2___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__mul__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("UInt2::__mul__.")));
RET CN;
}

SV UInt2___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__add__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("UInt2::__add__.")));
RET CN;
}

SV UInt2___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__less__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("UInt2::__less__.")));
RET CN;
}

SV UInt2___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__sub__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("UInt2::__sub__.")));
RET CN;
}

SV UInt2___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__geq__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("UInt2::__geq__.")));
RET CN;
}

SV UInt2_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::distanceSquared" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("UInt2::distanceSquared.")));
RET CN;
}

SV UInt2___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__eq__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("UInt2::__eq__.")));
RET CN;
}

SV UInt2_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::dot" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("UInt2::dot.")));
RET CN;
}

SV UInt2___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt2::__neq__" EAOE));
T2<uint32_t>*f;
f=(T2<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("UInt2::__neq__.")));
RET CN;
}

void LightList_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<Light*>))
CATE(TE,"LightList::__del__ expects LightList as first argument."));

DELETE((List<Light*>*)f->data);
}SV LightList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList's constructor" EAOE));
if(!TS(a[0],List<Light*>))
CATE(TE,"LightList's constructor expects LightList as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(LightList_funcs,NEW(List<Light*>),EXT->LightList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],std::size_t))
RET STG::createNativeObject(LightList_funcs,NEW(List<Light*>,val_to_c<std::size_t>::f(ctx,a[1])),EXT->LightList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const List<Light*> &))
RET STG::createNativeObject(LightList_funcs,NEW(List<Light*>,val_to_c<const List<Light*> &>::f(ctx,a[1])),EXT->LightList_typeID);
CATE(TE,UFOF("LightList's constructor.")));
RET CN;
}

SV LightList_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("LightList");
EI(keyStr=="__new__")
RET CNF(LightList_new);
EI(keyStr=="__call__")
RET CNF(LightList_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(LightList_new);
 EI(keyStr == "__eq__")
RET CNF(LightList___eq__);
 EI(keyStr == "__neq__")
RET CNF(LightList___neq__);
 EI(keyStr == "get")
RET CNF(LightList_get);
 EI(keyStr == "set")
RET CNF(LightList_set);
 EI(keyStr == "getCount")
RET CNF(LightList_getCount);
 EI(keyStr == "getData")
RET CNF(LightList_getData);
 EI(keyStr == "append")
RET CNF(LightList_append);
 EI(keyStr == "insert")
RET CNF(LightList_insert);
 EI(keyStr == "remove")
RET CNF(LightList_remove);
 EI(keyStr == "clear")
RET CNF(LightList_clear);
 EI(keyStr == "find")
RET CNF(LightList_find);
 EI(keyStr == "copy")
RET CNF(LightList_copy);
 EI(keyStr == "in")
RET CNF(LightList_in);
 EI(keyStr == "begin")
RET CNF(LightList_begin);
 EI(keyStr == "end")
RET CNF(LightList_end);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void LightList_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV LightList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::insert" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],Light*))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<Light*>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<Light*> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<Light*> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("LightList::insert.")));
RET CN;
}

SV LightList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::begin" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0])->data;

CATE(TE,UFOF("LightList::begin.")));
RET CN;
}

SV LightList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::set" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],Light*))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<Light*>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("LightList::set.")));
RET CN;
}

SV LightList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::end" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0])->data;

CATE(TE,UFOF("LightList::end.")));
RET CN;
}

SV LightList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::get" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("LightList::get.")));
RET CN;
}

SV LightList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::clear" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("LightList::clear.")));
RET CN;
}

SV LightList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::copy" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("LightList::copy.")));
RET CN;
}

SV LightList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::remove" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("LightList::remove.")));
RET CN;
}

SV LightList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::in" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],Light*))
{
RET CV( f->in(val_to_c<std::remove_reference<Light*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("LightList::in.")));
RET CN;
}

SV LightList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::getCount" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("LightList::getCount.")));
RET CN;
}

SV LightList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::getData" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0])->data;

CATE(TE,UFOF("LightList::getData.")));
RET CN;
}

SV LightList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::__eq__" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<Light*> &))
{
auto v=val_to_c<std::remove_reference<const List<Light*> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("LightList::__eq__.")));
RET CN;
}

SV LightList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::find" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],Light*))
{
RET CV( f->find(val_to_c<std::remove_reference<Light*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("LightList::find.")));
RET CN;
}

SV LightList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::append" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],Light*))
{
( f->append(val_to_c<std::remove_reference<Light*>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<Light*> &))
{
( f->append(val_to_c<std::remove_reference<const List<Light*> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("LightList::append.")));
RET CN;
}

SV LightList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"LightList::__neq__" EAOE));
List<Light*>*f;
f=(List<Light*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<Light*> &))
{
auto v=val_to_c<std::remove_reference<const List<Light*> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("LightList::__neq__.")));
RET CN;
}

void ResourceManager_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,ResourceManager))
CATE(TE,"ResourceManager::__del__ expects ResourceManager as first argument."));

DELETE((ResourceManager*)f->data);
}SV ResourceManager_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager's constructor" EAOE));
if(!TS(a[0],ResourceManager))
CATE(TE,"ResourceManager's constructor expects ResourceManager as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(ResourceManager_funcs,NEW(ResourceManager),EXT->ResourceManager_typeID);
CATE(TE,UFOF("ResourceManager's constructor.")));
RET CN;
}

SV ResourceManager_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("ResourceManager");
EI(keyStr=="__new__")
RET CNF(ResourceManager_new);
EI(keyStr=="__call__")
RET CNF(ResourceManager_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(ResourceManager_new);
 EI(keyStr == "loadShader")
RET CNF(ResourceManager_loadShader);
 EI(keyStr == "loadTexture")
RET CNF(ResourceManager_loadTexture);
 EI(keyStr == "loadMesh")
RET CNF(ResourceManager_loadMesh);
 EI(keyStr == "loadMaterial")
RET CNF(ResourceManager_loadMaterial);
 EI(keyStr == "loadModel")
RET CNF(ResourceManager_loadModel);
 EI(keyStr == "loadScene")
RET CNF(ResourceManager_loadScene);
 EI(keyStr == "loadScript")
RET CNF(ResourceManager_loadScript);
 EI(keyStr == "loadPhysicsShape")
RET CNF(ResourceManager_loadPhysicsShape);
 EI(keyStr == "loadAudio")
RET CNF(ResourceManager_loadAudio);
 EI(keyStr == "loadFont")
RET CNF(ResourceManager_loadFont);
 EI(keyStr == "load")
RET CNF(ResourceManager_load);
 EI(keyStr == "loadShaderAndCopy")
RET CNF(ResourceManager_loadShaderAndCopy);
 EI(keyStr == "loadTextureAndCopy")
RET CNF(ResourceManager_loadTextureAndCopy);
 EI(keyStr == "loadMeshAndCopy")
RET CNF(ResourceManager_loadMeshAndCopy);
 EI(keyStr == "loadMaterialAndCopy")
RET CNF(ResourceManager_loadMaterialAndCopy);
 EI(keyStr == "loadModelAndCopy")
RET CNF(ResourceManager_loadModelAndCopy);
 EI(keyStr == "loadSceneAndCopy")
RET CNF(ResourceManager_loadSceneAndCopy);
 EI(keyStr == "loadScriptAndCopy")
RET CNF(ResourceManager_loadScriptAndCopy);
 EI(keyStr == "loadPhysicsShapeAndCopy")
RET CNF(ResourceManager_loadPhysicsShapeAndCopy);
 EI(keyStr == "loadAudioAndCopy")
RET CNF(ResourceManager_loadAudioAndCopy);
 EI(keyStr == "loadFontAndCopy")
RET CNF(ResourceManager_loadFontAndCopy);
 EI(keyStr == "loadAndCopy")
RET CNF(ResourceManager_loadAndCopy);
 EI(keyStr == "isResource")
RET CNF(ResourceManager_isResource);
 EI(keyStr == "cleanupResources")
RET CNF(ResourceManager_cleanupResources);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void ResourceManager_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV ResourceManager_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::load" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],ResType)&&TS(a[2],const String &))
{
RET CV( f->load(val_to_c<std::remove_reference<ResType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("ResourceManager::load.")));
RET CN;
}

SV ResourceManager_loadPhysicsShape(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadPhysicsShape" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadPhysicsShape(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadPhysicsShape.")));
RET CN;
}

SV ResourceManager_loadFont(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadFont" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadFont(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadFont.")));
RET CN;
}

SV ResourceManager_loadPhysicsShapeAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadPhysicsShapeAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadPhysicsShapeAndCopy(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadPhysicsShapeAndCopy.")));
RET CN;
}

SV ResourceManager_loadAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],ResType)&&TS(a[2],const String &))
{
RET CV( f->loadAndCopy(val_to_c<std::remove_reference<ResType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("ResourceManager::loadAndCopy.")));
RET CN;
}

SV ResourceManager_loadModel(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadModel" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadModel(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadModel.")));
RET CN;
}

SV ResourceManager_loadMeshAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadMeshAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadMeshAndCopy(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadMeshAndCopy.")));
RET CN;
}

SV ResourceManager_cleanupResources(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::cleanupResources" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->cleanupResources());
RET CN;
}
CATE(TE,UFOF("ResourceManager::cleanupResources.")));
RET CN;
}

SV ResourceManager_loadScene(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadScene" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadScene(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadScene.")));
RET CN;
}

SV ResourceManager_loadAudioAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadAudioAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadAudioAndCopy(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadAudioAndCopy.")));
RET CN;
}

SV ResourceManager_loadAudio(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadAudio" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadAudio(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadAudio.")));
RET CN;
}

SV ResourceManager_loadShader(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadShader" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadShader(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadShader.")));
RET CN;
}

SV ResourceManager_loadTexture(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadTexture" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadTexture(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadTexture.")));
RET CN;
}

SV ResourceManager_loadMaterialAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadMaterialAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadMaterialAndCopy(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadMaterialAndCopy.")));
RET CN;
}

SV ResourceManager_loadMaterial(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadMaterial" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadMaterial(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadMaterial.")));
RET CN;
}

SV ResourceManager_loadScriptAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadScriptAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

CATE(TE,UFOF("ResourceManager::loadScriptAndCopy.")));
RET CN;
}

SV ResourceManager_loadShaderAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadShaderAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadShaderAndCopy(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadShaderAndCopy.")));
RET CN;
}

SV ResourceManager_loadScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadScript" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

CATE(TE,UFOF("ResourceManager::loadScript.")));
RET CN;
}

SV ResourceManager_loadFontAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadFontAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadFontAndCopy(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadFontAndCopy.")));
RET CN;
}

SV ResourceManager_loadSceneAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadSceneAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadSceneAndCopy(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadSceneAndCopy.")));
RET CN;
}

SV ResourceManager_loadMesh(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadMesh" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadMesh(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadMesh.")));
RET CN;
}

SV ResourceManager_loadModelAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadModelAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadModelAndCopy(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadModelAndCopy.")));
RET CN;
}

SV ResourceManager_isResource(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::isResource" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],ResType)&&TS(a[2],const String &))
{
RET CV( f->isResource(val_to_c<std::remove_reference<ResType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("ResourceManager::isResource.")));
RET CN;
}

SV ResourceManager_loadTextureAndCopy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResourceManager::loadTextureAndCopy" EAOE));
ResourceManager*f;
f=(ResourceManager*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->loadTextureAndCopy(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResourceManager::loadTextureAndCopy.")));
RET CN;
}

void Entity_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Entity))
CATE(TE,"Entity::__del__ expects Entity as first argument."));

}SV Entity_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Entity's constructor" EAOE));
if(!TS(a[0],Entity))
CATE(TE,"Entity's constructor expects Entity as first argument."));
CATE(TE,UFOF("Entity's constructor.")));
}

SV Entity_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Entity");
EI(keyStr=="__new__")
RET CNF(Entity_new);
EI(keyStr=="__call__")
RET CNF(Entity_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Entity_new);
 EI(keyStr == "addScript")
RET CNF(Entity_addScript);
 EI(keyStr == "removeScript")
RET CNF(Entity_removeScript);
 EI(keyStr == "getScripts")
RET CNF(Entity_getScripts);
 EI(keyStr == "findScriptInstanceByName")
RET CNF(Entity_findScriptInstanceByName);
 EI(keyStr == "addRigidBody")
RET CNF(Entity_addRigidBody);
 EI(keyStr == "getRigidBody")
RET CNF(Entity_getRigidBody);
 EI(keyStr == "removeRigidBody")
RET CNF(Entity_removeRigidBody);
 EI(keyStr == "hasRigidBody")
RET CNF(Entity_hasRigidBody);
 EI(keyStr == "addModel")
RET CNF(Entity_addModel);
 EI(keyStr == "addOverlay")
RET CNF(Entity_addOverlay);
 EI(keyStr == "removeRenderComponent")
RET CNF(Entity_removeRenderComponent);
 EI(keyStr == "getRenderComponent")
RET CNF(Entity_getRenderComponent);
 EI(keyStr == "hasRenderComponent")
RET CNF(Entity_hasRenderComponent);
 EI(keyStr == "getScene")
RET CNF(Entity_getScene);
 EI(keyStr == "createEntity")
RET CNF(Entity_createEntity);
 EI(keyStr == "removeEntity")
RET CNF(Entity_removeEntity);
 EI(keyStr == "getEntities")
RET CNF(Entity_getEntities);
 EI(keyStr == "getParent")
RET CNF(Entity_getParent);
 EI(keyStr == "updateFinalTransform")
RET CNF(Entity_updateFinalTransform);
 EI(keyStr == "getFinalTransform")
RET CNF(Entity_getFinalTransform);
 EI(keyStr == "getAudioSources")
RET CNF(Entity_getAudioSources);
 EI(keyStr == "addAudioSource")
RET CNF(Entity_addAudioSource);
 EI(keyStr == "removeAudioSource")
RET CNF(Entity_removeAudioSource);
 EI(keyStr=="name")
{
Entity*obj=(Entity*)f->data;
RET CV(obj->name);
} EI(keyStr=="transform")
{
Entity*obj=(Entity*)f->data;
RET CV(obj->transform);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Entity_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="name")
{
Entity*obj=(Entity*)f->data;
obj->name=val_to_c<decltype(obj->name)>::f(ctx,value);
} EI(keyStr=="transform")
{
Entity*obj=(Entity*)f->data;
obj->transform=val_to_c<decltype(obj->transform)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Entity_getFinalTransform(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::getFinalTransform" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFinalTransform());
;
}
CATE(TE,UFOF("Entity::getFinalTransform.")));
RET CN;
}

SV Entity_removeAudioSource(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::removeAudioSource" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->removeAudioSource(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Entity::removeAudioSource.")));
RET CN;
}

SV Entity_getAudioSources(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::getAudioSources" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAudioSources());
;
}
CATE(TE,UFOF("Entity::getAudioSources.")));
RET CN;
}

SV Entity_getRigidBody(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::getRigidBody" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRigidBody());
;
}
CATE(TE,UFOF("Entity::getRigidBody.")));
RET CN;
}

SV Entity_findScriptInstanceByName(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::findScriptInstanceByName" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

CATE(TE,UFOF("Entity::findScriptInstanceByName.")));
RET CN;
}

SV Entity_addOverlay(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::addOverlay" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxTexture *))
{
( f->addOverlay(val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Entity::addOverlay.")));
RET CN;
}

SV Entity_addRigidBody(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::addRigidBody" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],const RigidBodyConstructionInfo &)&&TS(a[2],PhysicsShape *))
{
RET CV( f->addRigidBody(val_to_c<std::remove_reference<const RigidBodyConstructionInfo &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<PhysicsShape *>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("Entity::addRigidBody.")));
RET CN;
}

SV Entity_removeScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::removeScript" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

CATE(TE,UFOF("Entity::removeScript.")));
RET CN;
}

SV Entity_createEntity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::createEntity" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->createEntity(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Entity::createEntity.")));
RET CN;
}

SV Entity_hasRigidBody(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::hasRigidBody" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->hasRigidBody());
;
}
CATE(TE,UFOF("Entity::hasRigidBody.")));
RET CN;
}

SV Entity_updateFinalTransform(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::updateFinalTransform" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->updateFinalTransform());
RET CN;
}
CATE(TE,UFOF("Entity::updateFinalTransform.")));
RET CN;
}

SV Entity_removeRenderComponent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::removeRenderComponent" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->removeRenderComponent());
RET CN;
}
CATE(TE,UFOF("Entity::removeRenderComponent.")));
RET CN;
}

SV Entity_removeEntity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::removeEntity" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->removeEntity(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Entity::removeEntity.")));
RET CN;
}

SV Entity_removeRigidBody(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::removeRigidBody" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->removeRigidBody());
RET CN;
}
CATE(TE,UFOF("Entity::removeRigidBody.")));
RET CN;
}

SV Entity_addScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::addScript" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

CATE(TE,UFOF("Entity::addScript.")));
RET CN;
}

SV Entity_getEntities(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::getEntities" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getEntities());
;
}
CATE(TE,UFOF("Entity::getEntities.")));
RET CN;
}

SV Entity_hasRenderComponent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::hasRenderComponent" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->hasRenderComponent());
;
}
CATE(TE,UFOF("Entity::hasRenderComponent.")));
RET CN;
}

SV Entity_addAudioSource(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::addAudioSource" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],Audio *))
{
RET CV( f->addAudioSource(val_to_c<std::remove_reference<Audio *>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Entity::addAudioSource.")));
RET CN;
}

SV Entity_getRenderComponent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::getRenderComponent" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRenderComponent());
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->getRenderComponent());
;
}
CATE(TE,UFOF("Entity::getRenderComponent.")));
RET CN;
}

SV Entity_addModel(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::addModel" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],GfxModel *)&&TS(a[2],bool))
{
( f->addModel(val_to_c<std::remove_reference<GfxModel *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<bool>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("Entity::addModel.")));
RET CN;
}

SV Entity_getParent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::getParent" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getParent());
;
}
CATE(TE,UFOF("Entity::getParent.")));
RET CN;
}

SV Entity_getScripts(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::getScripts" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

CATE(TE,UFOF("Entity::getScripts.")));
RET CN;
}

SV Entity_getScene(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Entity::getScene" EAOE));
Entity*f;
f=(Entity*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScene());
;
}
CATE(TE,UFOF("Entity::getScene.")));
RET CN;
}

void GfxRenderer_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxRenderer))
CATE(TE,"GfxRenderer::__del__ expects GfxRenderer as first argument."));

DELETE((GfxRenderer*)f->data);
}SV GfxRenderer_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxRenderer's constructor" EAOE));
if(!TS(a[0],GfxRenderer))
CATE(TE,"GfxRenderer's constructor expects GfxRenderer as first argument."));
CATE(TE,UFOF("GfxRenderer's constructor.")));
}

SV GfxRenderer_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxRenderer");
EI(keyStr=="__new__")
RET CNF(GfxRenderer_new);
EI(keyStr=="__call__")
RET CNF(GfxRenderer_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GfxRenderer_new);
 EI(keyStr == "resize")
RET CNF(GfxRenderer_resize);
 EI(keyStr == "render")
RET CNF(GfxRenderer_render);
 EI(keyStr == "getNumLights")
RET CNF(GfxRenderer_getNumLights);
 EI(keyStr == "getLightBuffer")
RET CNF(GfxRenderer_getLightBuffer);
 EI(keyStr == "getStats")
RET CNF(GfxRenderer_getStats);
 EI(keyStr == "addLight")
RET CNF(GfxRenderer_addLight);
 EI(keyStr == "removeLight")
RET CNF(GfxRenderer_removeLight);
 EI(keyStr == "getLights")
RET CNF(GfxRenderer_getLights);
 EI(keyStr == "computeSceneAABB")
RET CNF(GfxRenderer_computeSceneAABB);
 EI(keyStr == "computeShadowCasterAABB")
RET CNF(GfxRenderer_computeShadowCasterAABB);
 EI(keyStr == "updateStats")
RET CNF(GfxRenderer_updateStats);
 EI(keyStr == "updateColorModifierShader")
RET CNF(GfxRenderer_updateColorModifierShader);
 EI(keyStr == "setSkybox")
RET CNF(GfxRenderer_setSkybox);
 EI(keyStr == "getSkybox")
RET CNF(GfxRenderer_getSkybox);
 EI(keyStr == "addTerrain")
RET CNF(GfxRenderer_addTerrain);
 EI(keyStr == "removeTerrain")
RET CNF(GfxRenderer_removeTerrain);
 EI(keyStr == "getTerrain")
RET CNF(GfxRenderer_getTerrain);
 EI(keyStr=="camera")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->camera);
} EI(keyStr=="debugDraw")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->debugDraw);
} EI(keyStr=="bloomThreshold")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloomThreshold);
} EI(keyStr=="bloom1Radius")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloom1Radius);
} EI(keyStr=="bloom2Radius")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloom2Radius);
} EI(keyStr=="bloom3Radius")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloom3Radius);
} EI(keyStr=="bloom4Radius")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloom4Radius);
} EI(keyStr=="bloom1Strength")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloom1Strength);
} EI(keyStr=="bloom2Strength")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloom2Strength);
} EI(keyStr=="bloom3Strength")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloom3Strength);
} EI(keyStr=="bloom4Strength")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloom4Strength);
} EI(keyStr=="bloomEnabled")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->bloomEnabled);
} EI(keyStr=="ssaoRadius")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
RET CV(obj->ssaoRadius);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GfxRenderer_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="camera")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->camera=val_to_c<decltype(obj->camera)>::f(ctx,value);
} EI(keyStr=="debugDraw")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->debugDraw=val_to_c<decltype(obj->debugDraw)>::f(ctx,value);
} EI(keyStr=="bloomThreshold")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloomThreshold=val_to_c<decltype(obj->bloomThreshold)>::f(ctx,value);
} EI(keyStr=="bloom1Radius")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloom1Radius=val_to_c<decltype(obj->bloom1Radius)>::f(ctx,value);
} EI(keyStr=="bloom2Radius")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloom2Radius=val_to_c<decltype(obj->bloom2Radius)>::f(ctx,value);
} EI(keyStr=="bloom3Radius")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloom3Radius=val_to_c<decltype(obj->bloom3Radius)>::f(ctx,value);
} EI(keyStr=="bloom4Radius")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloom4Radius=val_to_c<decltype(obj->bloom4Radius)>::f(ctx,value);
} EI(keyStr=="bloom1Strength")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloom1Strength=val_to_c<decltype(obj->bloom1Strength)>::f(ctx,value);
} EI(keyStr=="bloom2Strength")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloom2Strength=val_to_c<decltype(obj->bloom2Strength)>::f(ctx,value);
} EI(keyStr=="bloom3Strength")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloom3Strength=val_to_c<decltype(obj->bloom3Strength)>::f(ctx,value);
} EI(keyStr=="bloom4Strength")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloom4Strength=val_to_c<decltype(obj->bloom4Strength)>::f(ctx,value);
} EI(keyStr=="bloomEnabled")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->bloomEnabled=val_to_c<decltype(obj->bloomEnabled)>::f(ctx,value);
} EI(keyStr=="ssaoRadius")
{
GfxRenderer*obj=(GfxRenderer*)f->data;
obj->ssaoRadius=val_to_c<decltype(obj->ssaoRadius)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GfxRenderer_getLightBuffer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::getLightBuffer" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0])->data;

CATE(TE,UFOF("GfxRenderer::getLightBuffer.")));
RET CN;
}

SV GfxRenderer_updateColorModifierShader(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::updateColorModifierShader" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->updateColorModifierShader());
RET CN;
}
CATE(TE,UFOF("GfxRenderer::updateColorModifierShader.")));
RET CN;
}

SV GfxRenderer_render(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::render" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->render());
RET CN;
}
CATE(TE,UFOF("GfxRenderer::render.")));
RET CN;
}

SV GfxRenderer_addTerrain(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::addTerrain" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0])->data;

CATE(TE,UFOF("GfxRenderer::addTerrain.")));
RET CN;
}

SV GfxRenderer_getTerrain(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::getTerrain" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0])->data;

CATE(TE,UFOF("GfxRenderer::getTerrain.")));
RET CN;
}

SV GfxRenderer_setSkybox(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::setSkybox" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxTexture *))
{
( f->setSkybox(val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxRenderer::setSkybox.")));
RET CN;
}

SV GfxRenderer_getSkybox(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::getSkybox" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getSkybox());
;
}
CATE(TE,UFOF("GfxRenderer::getSkybox.")));
RET CN;
}

SV GfxRenderer_removeTerrain(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::removeTerrain" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->removeTerrain());
RET CN;
}
CATE(TE,UFOF("GfxRenderer::removeTerrain.")));
RET CN;
}

SV GfxRenderer_getNumLights(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::getNumLights" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getNumLights());
;
}
CATE(TE,UFOF("GfxRenderer::getNumLights.")));
RET CN;
}

SV GfxRenderer_computeSceneAABB(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::computeSceneAABB" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->computeSceneAABB());
;
}
CATE(TE,UFOF("GfxRenderer::computeSceneAABB.")));
RET CN;
}

SV GfxRenderer_getStats(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::getStats" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0])->data;

CATE(TE,UFOF("GfxRenderer::getStats.")));
RET CN;
}

SV GfxRenderer_computeShadowCasterAABB(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::computeShadowCasterAABB" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->computeShadowCasterAABB());
;
}
CATE(TE,UFOF("GfxRenderer::computeShadowCasterAABB.")));
RET CN;
}

SV GfxRenderer_addLight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::addLight" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->addLight());
;
}
CATE(TE,UFOF("GfxRenderer::addLight.")));
RET CN;
}

SV GfxRenderer_getLights(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::getLights" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getLights());
;
}
CATE(TE,UFOF("GfxRenderer::getLights.")));
RET CN;
}

SV GfxRenderer_updateStats(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::updateStats" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->updateStats());
RET CN;
}
CATE(TE,UFOF("GfxRenderer::updateStats.")));
RET CN;
}

SV GfxRenderer_resize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::resize" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const UInt2 &))
{
( f->resize(val_to_c<std::remove_reference<const UInt2 &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxRenderer::resize.")));
RET CN;
}

SV GfxRenderer_removeLight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxRenderer::removeLight" EAOE));
GfxRenderer*f;
f=(GfxRenderer*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->removeLight(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxRenderer::removeLight.")));
RET CN;
}

void Float2_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T2<float>))
CATE(TE,"Float2::__del__ expects Float2 as first argument."));

DELETE((T2<float>*)f->data);
}SV Float2_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2's constructor" EAOE));
if(!TS(a[0],T2<float>))
CATE(TE,"Float2's constructor expects Float2 as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(Float2_funcs,NEW(T2<float>),EXT->Float2_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],float))
RET STG::createNativeObject(Float2_funcs,NEW(T2<float>,val_to_c<float>::f(ctx,a[1])),EXT->Float2_typeID);
if(a.getCount()==3)
if(true&&TS(a[1],float)&&TS(a[2],float))
RET STG::createNativeObject(Float2_funcs,NEW(T2<float>,val_to_c<float>::f(ctx,a[1]),val_to_c<float>::f(ctx,a[2])),EXT->Float2_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T2<float> &))
RET STG::createNativeObject(Float2_funcs,NEW(T2<float>,val_to_c<const T2<float> &>::f(ctx,a[1])),EXT->Float2_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T2<int32_t> &))
RET STG::createNativeObject(Float2_funcs,NEW(T2<float>,val_to_c<const T2<int32_t> &>::f(ctx,a[1])),EXT->Float2_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T2<uint32_t> &))
RET STG::createNativeObject(Float2_funcs,NEW(T2<float>,val_to_c<const T2<uint32_t> &>::f(ctx,a[1])),EXT->Float2_typeID);
CATE(TE,UFOF("Float2's constructor.")));
RET CN;
}

SV Float2_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Float2");
EI(keyStr=="__new__")
RET CNF(Float2_new);
EI(keyStr=="__call__")
RET CNF(Float2_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Float2_new);
 EI(keyStr == "__add__")
RET CNF(Float2___add__);
 EI(keyStr == "__sub__")
RET CNF(Float2___sub__);
 EI(keyStr == "__mul__")
RET CNF(Float2___mul__);
 EI(keyStr == "__div__")
RET CNF(Float2___div__);
 EI(keyStr == "__eq__")
RET CNF(Float2___eq__);
 EI(keyStr == "__neq__")
RET CNF(Float2___neq__);
 EI(keyStr == "__less__")
RET CNF(Float2___less__);
 EI(keyStr == "__grtr__")
RET CNF(Float2___grtr__);
 EI(keyStr == "__leq__")
RET CNF(Float2___leq__);
 EI(keyStr == "__geq__")
RET CNF(Float2___geq__);
 EI(keyStr == "sum")
RET CNF(Float2_sum);
 EI(keyStr == "length")
RET CNF(Float2_length);
 EI(keyStr == "lengthSquared")
RET CNF(Float2_lengthSquared);
 EI(keyStr == "dot")
RET CNF(Float2_dot);
 EI(keyStr == "distance")
RET CNF(Float2_distance);
 EI(keyStr == "distanceSquared")
RET CNF(Float2_distanceSquared);
 EI(keyStr == "normalize")
RET CNF(Float2_normalize);
 EI(keyStr == "getXY")
RET CNF(Float2_getXY);
 EI(keyStr == "setXY")
RET CNF(Float2_setXY);
 EI(keyStr == "getYX")
RET CNF(Float2_getYX);
 EI(keyStr == "setYX")
RET CNF(Float2_setYX);
 EI(keyStr=="x")
{
T2<float>*obj=(T2<float>*)f->data;
RET CV(obj->x);
} EI(keyStr=="y")
{
T2<float>*obj=(T2<float>*)f->data;
RET CV(obj->y);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Float2_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="x")
{
T2<float>*obj=(T2<float>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr=="y")
{
T2<float>*obj=(T2<float>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Float2_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::normalize" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("Float2::normalize.")));
RET CN;
}

SV Float2_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::distance" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Float2::distance.")));
RET CN;
}

SV Float2_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::lengthSquared" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("Float2::lengthSquared.")));
RET CN;
}

SV Float2___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__leq__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("Float2::__leq__.")));
RET CN;
}

SV Float2_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::setYX" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float2::setYX.")));
RET CN;
}

SV Float2___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__grtr__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("Float2::__grtr__.")));
RET CN;
}

SV Float2_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::sum" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("Float2::sum.")));
RET CN;
}

SV Float2_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::getXY" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("Float2::getXY.")));
RET CN;
}

SV Float2_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::length" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("Float2::length.")));
RET CN;
}

SV Float2_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::getYX" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("Float2::getYX.")));
RET CN;
}

SV Float2___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__div__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("Float2::__div__.")));
RET CN;
}

SV Float2_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::setXY" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float2::setXY.")));
RET CN;
}

SV Float2___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__mul__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Float2::__mul__.")));
RET CN;
}

SV Float2___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__add__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("Float2::__add__.")));
RET CN;
}

SV Float2___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__less__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("Float2::__less__.")));
RET CN;
}

SV Float2___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__sub__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("Float2::__sub__.")));
RET CN;
}

SV Float2___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__geq__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("Float2::__geq__.")));
RET CN;
}

SV Float2_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::distanceSquared" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Float2::distanceSquared.")));
RET CN;
}

SV Float2___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__eq__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Float2::__eq__.")));
RET CN;
}

SV Float2_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::dot" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("Float2::dot.")));
RET CN;
}

SV Float2___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float2::__neq__" EAOE));
T2<float>*f;
f=(T2<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
auto v=val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("Float2::__neq__.")));
RET CN;
}

void GfxFramebuffer_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxFramebuffer))
CATE(TE,"GfxFramebuffer::__del__ expects GfxFramebuffer as first argument."));

DELETE((GfxFramebuffer*)f->data);
}SV GfxFramebuffer_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxFramebuffer's constructor" EAOE));
if(!TS(a[0],GfxFramebuffer))
CATE(TE,"GfxFramebuffer's constructor expects GfxFramebuffer as first argument."));
CATE(TE,UFOF("GfxFramebuffer's constructor.")));
}

SV GfxFramebuffer_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxFramebuffer");
EI(keyStr=="__new__")
RET CNF(GfxFramebuffer_new);
EI(keyStr=="__call__")
RET CNF(GfxFramebuffer_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GfxFramebuffer_new);
 EI(keyStr == "addColorAttachment")
RET CNF(GfxFramebuffer_addColorAttachment);
 EI(keyStr == "removeColorAttachment")
RET CNF(GfxFramebuffer_removeColorAttachment);
 EI(keyStr == "getNumColorAttachments")
RET CNF(GfxFramebuffer_getNumColorAttachments);
 EI(keyStr == "getColorRT")
RET CNF(GfxFramebuffer_getColorRT);
 EI(keyStr == "getColorAttachment")
RET CNF(GfxFramebuffer_getColorAttachment);
 EI(keyStr == "getColorAttachmentMipmapLevel")
RET CNF(GfxFramebuffer_getColorAttachmentMipmapLevel);
 EI(keyStr == "getColorAttachmentLayer")
RET CNF(GfxFramebuffer_getColorAttachmentLayer);
 EI(keyStr == "setDepthAttachment")
RET CNF(GfxFramebuffer_setDepthAttachment);
 EI(keyStr == "removeDepthAttachment")
RET CNF(GfxFramebuffer_removeDepthAttachment);
 EI(keyStr == "hasDepthAttachment")
RET CNF(GfxFramebuffer_hasDepthAttachment);
 EI(keyStr == "getDepthTexture")
RET CNF(GfxFramebuffer_getDepthTexture);
 EI(keyStr == "getDepthTextureMipmapLevel")
RET CNF(GfxFramebuffer_getDepthTextureMipmapLevel);
 EI(keyStr == "getDepthAttachmentLayer")
RET CNF(GfxFramebuffer_getDepthAttachmentLayer);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GfxFramebuffer_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GfxFramebuffer_getDepthTextureMipmapLevel(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::getDepthTextureMipmapLevel" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDepthTextureMipmapLevel());
;
}
CATE(TE,UFOF("GfxFramebuffer::getDepthTextureMipmapLevel.")));
RET CN;
}

SV GfxFramebuffer_removeDepthAttachment(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::removeDepthAttachment" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->removeDepthAttachment());
RET CN;
}
CATE(TE,UFOF("GfxFramebuffer::removeDepthAttachment.")));
RET CN;
}

SV GfxFramebuffer_getColorAttachmentLayer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::getColorAttachmentLayer" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getColorAttachmentLayer(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxFramebuffer::getColorAttachmentLayer.")));
RET CN;
}

SV GfxFramebuffer_getColorAttachment(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::getColorAttachment" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getColorAttachment(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxFramebuffer::getColorAttachment.")));
RET CN;
}

SV GfxFramebuffer_setDepthAttachment(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::setDepthAttachment" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0])->data;

if(a.getCount()==4)
if(1&&TS(a[1],GfxTexture *)&&TS(a[2],size_t)&&TS(a[3],int))
{
( f->setDepthAttachment(val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("GfxFramebuffer::setDepthAttachment.")));
RET CN;
}

SV GfxFramebuffer_removeColorAttachment(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::removeColorAttachment" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->removeColorAttachment(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxFramebuffer::removeColorAttachment.")));
RET CN;
}

SV GfxFramebuffer_getDepthAttachmentLayer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::getDepthAttachmentLayer" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDepthAttachmentLayer());
;
}
CATE(TE,UFOF("GfxFramebuffer::getDepthAttachmentLayer.")));
RET CN;
}

SV GfxFramebuffer_getColorRT(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::getColorRT" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getColorRT(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxFramebuffer::getColorRT.")));
RET CN;
}

SV GfxFramebuffer_getDepthTexture(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::getDepthTexture" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDepthTexture());
;
}
CATE(TE,UFOF("GfxFramebuffer::getDepthTexture.")));
RET CN;
}

SV GfxFramebuffer_getColorAttachmentMipmapLevel(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::getColorAttachmentMipmapLevel" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getColorAttachmentMipmapLevel(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxFramebuffer::getColorAttachmentMipmapLevel.")));
RET CN;
}

SV GfxFramebuffer_hasDepthAttachment(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::hasDepthAttachment" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->hasDepthAttachment());
;
}
CATE(TE,UFOF("GfxFramebuffer::hasDepthAttachment.")));
RET CN;
}

SV GfxFramebuffer_addColorAttachment(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::addColorAttachment" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0])->data;

if(a.getCount()==5)
if(1&&TS(a[1],size_t)&&TS(a[2],GfxTexture *)&&TS(a[3],size_t)&&TS(a[4],int))
{
( f->addColorAttachment(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[4])));
RET CN;
}
CATE(TE,UFOF("GfxFramebuffer::addColorAttachment.")));
RET CN;
}

SV GfxFramebuffer_getNumColorAttachments(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxFramebuffer::getNumColorAttachments" EAOE));
GfxFramebuffer*f;
f=(GfxFramebuffer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getNumColorAttachments());
;
}
CATE(TE,UFOF("GfxFramebuffer::getNumColorAttachments.")));
RET CN;
}

void Font_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Font))
CATE(TE,"Font::__del__ expects Font as first argument."));

Font*obj=(Font*)f->data;
if(obj!=nullptr){obj->release();}
}SV Font_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Font's constructor" EAOE));
if(!TS(a[0],Font))
CATE(TE,"Font's constructor expects Font as first argument."));
CATE(TE,UFOF("Font's constructor.")));
}

SV Font_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Font");
EI(keyStr=="__new__")
RET CNF(Font_new);
EI(keyStr=="__call__")
RET CNF(Font_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Font_new);
 EI(keyStr == "removeContent")
RET CNF(Font_removeContent);
 EI(keyStr == "predictWidth")
RET CNF(Font_predictWidth);
 EI(keyStr == "render")
RET CNF(Font_render);
 EI(keyStr == "load")
RET CNF(Font_load);
 EI(keyStr == "save")
RET CNF(Font_save);
 EI(keyStr == "copy")
RET CNF(Font_copy);
 EI(keyStr == "getType")
RET CNF(Font_getType);
 EI(keyStr == "release")
RET CNF(Font_release);
 EI(keyStr == "getRefCount")
RET CNF(Font_getRefCount);
 EI(keyStr == "getFilename")
RET CNF(Font_getFilename);
 EI(keyStr == "setFilename")
RET CNF(Font_setFilename);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Font_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Font_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::load" EAOE));
Font*f;
f=(Font*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("Font::load.")));
RET CN;
}

SV Font_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::getFilename" EAOE));
Font*f;
f=(Font*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("Font::getFilename.")));
RET CN;
}

SV Font_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::copy" EAOE));
Font*f;
f=(Font*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("Font::copy.")));
RET CN;
}

SV Font_render(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::render" EAOE));
Font*f;
f=(Font*)((NO)a[0])->data;

if(a.getCount()==6)
if(1&&TS(a[1],size_t)&&TS(a[2],const Float2 &)&&TS(a[3],const char *)&&TS(a[4],GfxFramebuffer *)&&TS(a[5],const Float3 &))
{
( f->render(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Float2 &>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<GfxFramebuffer *>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[5])));
RET CN;
}
CATE(TE,UFOF("Font::render.")));
RET CN;
}

SV Font_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::getType" EAOE));
Font*f;
f=(Font*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("Font::getType.")));
RET CN;
}

SV Font_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::setFilename" EAOE));
Font*f;
f=(Font*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
( f->setFilename(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Font::setFilename.")));
RET CN;
}

SV Font_predictWidth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::predictWidth" EAOE));
Font*f;
f=(Font*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],const char *))
{
RET CV( f->predictWidth(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("Font::predictWidth.")));
RET CN;
}

SV Font_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::removeContent" EAOE));
Font*f;
f=(Font*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("Font::removeContent.")));
RET CN;
}

SV Font_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::getRefCount" EAOE));
Font*f;
f=(Font*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("Font::getRefCount.")));
RET CN;
}

SV Font_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::release" EAOE));
Font*f;
f=(Font*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("Font::release.")));
RET CN;
}

SV Font_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Font::save" EAOE));
Font*f;
f=(Font*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("Font::save.")));
RET CN;
}

void Event_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Event))
CATE(TE,"Event::__del__ expects Event as first argument."));

DELETE((Event*)f->data);
}SV Event_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Event's constructor" EAOE));
if(!TS(a[0],Event))
CATE(TE,"Event's constructor expects Event as first argument."));
#define fjis Event
RET STG::createNativeObject(Event_funcs,NEW(fjis),EXT->Event_typeID);
}

SV Event_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Event");
EI(keyStr=="__new__")
RET CNF(Event_new);
EI(keyStr=="__call__")
RET CNF(Event_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Event_new);
 EI(keyStr == "getWidth")
RET CNF(Event_getWidth);
 EI(keyStr == "getHeight")
RET CNF(Event_getHeight);
 EI(keyStr == "getKey")
RET CNF(Event_getKey);
 EI(keyStr == "getX")
RET CNF(Event_getX);
 EI(keyStr == "getY")
RET CNF(Event_getY);
 EI(keyStr == "getRelX")
RET CNF(Event_getRelX);
 EI(keyStr == "getRelY")
RET CNF(Event_getRelY);
 EI(keyStr == "getButton")
RET CNF(Event_getButton);
 EI(keyStr == "getDoubleClicked")
RET CNF(Event_getDoubleClicked);
 EI(keyStr=="type")
{
Event*obj=(Event*)f->data;
RET CV(obj->type);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Event_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="type")
{
Event*obj=(Event*)f->data;
obj->type=val_to_c<decltype(obj->type)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Event_getX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getX" EAOE));
Event*f;
f=(Event*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getX());
;
}
CATE(TE,UFOF("Event::getX.")));
RET CN;
}

SV Event_getButton(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getButton" EAOE));
Event*f;
f=(Event*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getButton());
;
}
CATE(TE,UFOF("Event::getButton.")));
RET CN;
}

SV Event_getRelX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getRelX" EAOE));
Event*f;
f=(Event*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRelX());
;
}
CATE(TE,UFOF("Event::getRelX.")));
RET CN;
}

SV Event_getHeight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getHeight" EAOE));
Event*f;
f=(Event*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getHeight());
;
}
CATE(TE,UFOF("Event::getHeight.")));
RET CN;
}

SV Event_getRelY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getRelY" EAOE));
Event*f;
f=(Event*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRelY());
;
}
CATE(TE,UFOF("Event::getRelY.")));
RET CN;
}

SV Event_getKey(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getKey" EAOE));
Event*f;
f=(Event*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getKey());
;
}
CATE(TE,UFOF("Event::getKey.")));
RET CN;
}

SV Event_getWidth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getWidth" EAOE));
Event*f;
f=(Event*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWidth());
;
}
CATE(TE,UFOF("Event::getWidth.")));
RET CN;
}

SV Event_getY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getY" EAOE));
Event*f;
f=(Event*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getY());
;
}
CATE(TE,UFOF("Event::getY.")));
RET CN;
}

SV Event_getDoubleClicked(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Event::getDoubleClicked" EAOE));
Event*f;
f=(Event*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDoubleClicked());
;
}
CATE(TE,UFOF("Event::getDoubleClicked.")));
RET CN;
}

void PhysicsWorld_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,PhysicsWorld))
CATE(TE,"PhysicsWorld::__del__ expects PhysicsWorld as first argument."));

DELETE((PhysicsWorld*)f->data);
}SV PhysicsWorld_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld's constructor" EAOE));
if(!TS(a[0],PhysicsWorld))
CATE(TE,"PhysicsWorld's constructor expects PhysicsWorld as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(PhysicsWorld_funcs,NEW(PhysicsWorld),EXT->PhysicsWorld_typeID);
CATE(TE,UFOF("PhysicsWorld's constructor.")));
RET CN;
}

SV PhysicsWorld_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("PhysicsWorld");
EI(keyStr=="__new__")
RET CNF(PhysicsWorld_new);
EI(keyStr=="__call__")
RET CNF(PhysicsWorld_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(PhysicsWorld_new);
 EI(keyStr == "addDebugDrawer")
RET CNF(PhysicsWorld_addDebugDrawer);
 EI(keyStr == "setGravity")
RET CNF(PhysicsWorld_setGravity);
 EI(keyStr == "getGravity")
RET CNF(PhysicsWorld_getGravity);
 EI(keyStr == "getRigidBodies")
RET CNF(PhysicsWorld_getRigidBodies);
 EI(keyStr == "getGhostObjects")
RET CNF(PhysicsWorld_getGhostObjects);
 EI(keyStr == "createRigidBody")
RET CNF(PhysicsWorld_createRigidBody);
 EI(keyStr == "destroyRigidBody")
RET CNF(PhysicsWorld_destroyRigidBody);
 EI(keyStr == "createGhostObject")
RET CNF(PhysicsWorld_createGhostObject);
 EI(keyStr == "destroyGhostObject")
RET CNF(PhysicsWorld_destroyGhostObject);
 EI(keyStr == "stepSimulation")
RET CNF(PhysicsWorld_stepSimulation);
 EI(keyStr == "debugDraw")
RET CNF(PhysicsWorld_debugDraw);
 EI(keyStr == "castRay")
RET CNF(PhysicsWorld_castRay);
 EI(keyStr == "getBulletWorld")
RET CNF(PhysicsWorld_getBulletWorld);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void PhysicsWorld_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV PhysicsWorld_setGravity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::setGravity" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->setGravity(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("PhysicsWorld::setGravity.")));
RET CN;
}

SV PhysicsWorld_stepSimulation(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::stepSimulation" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0])->data;

if(a.getCount()==4)
if(1&&TS(a[1],float)&&TS(a[2],size_t)&&TS(a[3],float))
{
( f->stepSimulation(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("PhysicsWorld::stepSimulation.")));
RET CN;
}

SV PhysicsWorld_castRay(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::castRay" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0])->data;

if(a.getCount()==4)
if(1&&TS(a[1],const Position3D &)&&TS(a[2],const Direction3D &)&&TS(a[3],float))
{
RET CV( f->castRay(val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Direction3D &>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
;
}
CATE(TE,UFOF("PhysicsWorld::castRay.")));
RET CN;
}

SV PhysicsWorld_getGhostObjects(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::getGhostObjects" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGhostObjects());
;
}
CATE(TE,UFOF("PhysicsWorld::getGhostObjects.")));
RET CN;
}

SV PhysicsWorld_getBulletWorld(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::getBulletWorld" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0])->data;

CATE(TE,UFOF("PhysicsWorld::getBulletWorld.")));
RET CN;
}

SV PhysicsWorld_addDebugDrawer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::addDebugDrawer" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->addDebugDrawer());
RET CN;
}
CATE(TE,UFOF("PhysicsWorld::addDebugDrawer.")));
RET CN;
}

SV PhysicsWorld_createRigidBody(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::createRigidBody" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],const RigidBodyConstructionInfo &)&&TS(a[2],PhysicsShape *))
{
RET CV( f->createRigidBody(val_to_c<std::remove_reference<const RigidBodyConstructionInfo &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<PhysicsShape *>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("PhysicsWorld::createRigidBody.")));
RET CN;
}

SV PhysicsWorld_getRigidBodies(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::getRigidBodies" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRigidBodies());
;
}
CATE(TE,UFOF("PhysicsWorld::getRigidBodies.")));
RET CN;
}

SV PhysicsWorld_getGravity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::getGravity" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGravity());
;
}
CATE(TE,UFOF("PhysicsWorld::getGravity.")));
RET CN;
}

SV PhysicsWorld_destroyGhostObject(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::destroyGhostObject" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GhostObject *))
{
( f->destroyGhostObject(val_to_c<std::remove_reference<GhostObject *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("PhysicsWorld::destroyGhostObject.")));
RET CN;
}

SV PhysicsWorld_createGhostObject(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::createGhostObject" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],PhysicsShape *)&&TS(a[2],unsigned short))
{
RET CV( f->createGhostObject(val_to_c<std::remove_reference<PhysicsShape *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<unsigned short>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("PhysicsWorld::createGhostObject.")));
RET CN;
}

SV PhysicsWorld_destroyRigidBody(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::destroyRigidBody" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],RigidBody *))
{
( f->destroyRigidBody(val_to_c<std::remove_reference<RigidBody *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("PhysicsWorld::destroyRigidBody.")));
RET CN;
}

SV PhysicsWorld_debugDraw(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsWorld::debugDraw" EAOE));
PhysicsWorld*f;
f=(PhysicsWorld*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->debugDraw());
RET CN;
}
CATE(TE,UFOF("PhysicsWorld::debugDraw.")));
RET CN;
}

void Stats_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Stats))
CATE(TE,"Stats::__del__ expects Stats as first argument."));

DELETE((Stats*)f->data);
}SV Stats_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Stats's constructor" EAOE));
if(!TS(a[0],Stats))
CATE(TE,"Stats's constructor expects Stats as first argument."));
#define fjis Stats
RET STG::createNativeObject(Stats_funcs,NEW(fjis),EXT->Stats_typeID);
}

SV Stats_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Stats");
EI(keyStr=="__new__")
RET CNF(Stats_new);
EI(keyStr=="__call__")
RET CNF(Stats_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Stats_new);
 EI(keyStr=="handleInput")
{
Stats*obj=(Stats*)f->data;
RET CV(obj->handleInput);
} EI(keyStr=="update")
{
Stats*obj=(Stats*)f->data;
RET CV(obj->update);
} EI(keyStr=="fixedUpdate")
{
Stats*obj=(Stats*)f->data;
RET CV(obj->fixedUpdate);
} EI(keyStr=="preRender")
{
Stats*obj=(Stats*)f->data;
RET CV(obj->preRender);
} EI(keyStr=="postRender")
{
Stats*obj=(Stats*)f->data;
RET CV(obj->postRender);
} EI(keyStr=="audio")
{
Stats*obj=(Stats*)f->data;
RET CV(obj->audio);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Stats_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="handleInput")
{
Stats*obj=(Stats*)f->data;
obj->handleInput=val_to_c<decltype(obj->handleInput)>::f(ctx,value);
} EI(keyStr=="update")
{
Stats*obj=(Stats*)f->data;
obj->update=val_to_c<decltype(obj->update)>::f(ctx,value);
} EI(keyStr=="fixedUpdate")
{
Stats*obj=(Stats*)f->data;
obj->fixedUpdate=val_to_c<decltype(obj->fixedUpdate)>::f(ctx,value);
} EI(keyStr=="preRender")
{
Stats*obj=(Stats*)f->data;
obj->preRender=val_to_c<decltype(obj->preRender)>::f(ctx,value);
} EI(keyStr=="postRender")
{
Stats*obj=(Stats*)f->data;
obj->postRender=val_to_c<decltype(obj->postRender)>::f(ctx,value);
} EI(keyStr=="audio")
{
Stats*obj=(Stats*)f->data;
obj->audio=val_to_c<decltype(obj->audio)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

void AudioSource_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,AudioSource))
CATE(TE,"AudioSource::__del__ expects AudioSource as first argument."));

DELETE((AudioSource*)f->data);
}SV AudioSource_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSource's constructor" EAOE));
if(!TS(a[0],AudioSource))
CATE(TE,"AudioSource's constructor expects AudioSource as first argument."));
if(a.getCount()==2)
if(true&&TS(a[1],Audio *))
RET STG::createNativeObject(AudioSource_funcs,NEW(AudioSource,val_to_c<Audio *>::f(ctx,a[1])),EXT->AudioSource_typeID);
CATE(TE,UFOF("AudioSource's constructor.")));
RET CN;
}

SV AudioSource_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("AudioSource");
EI(keyStr=="__new__")
RET CNF(AudioSource_new);
EI(keyStr=="__call__")
RET CNF(AudioSource_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(AudioSource_new);
 EI(keyStr == "getAudio")
RET CNF(AudioSource_getAudio);
 EI(keyStr == "setAudio")
RET CNF(AudioSource_setAudio);
 EI(keyStr=="is3d")
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->is3d);
} EI(keyStr=="position")
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->position);
} EI(keyStr=="referenceDistance")
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->referenceDistance);
} EI(keyStr=="rolloffFactor")
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->rolloffFactor);
} EI(keyStr=="maxDistance")
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->maxDistance);
} EI(keyStr=="volume")
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->volume);
} EI(keyStr=="velocity")
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->velocity);
} EI(keyStr=="dopplerFactor")
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->dopplerFactor);
} EI(keyStr=="offset")
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->offset);
} EI(keyStr=="loop")
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->loop);
} EI(keyStr=="playing")
{
AudioSource*obj=(AudioSource*)f->data;
RET CV(obj->playing);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void AudioSource_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="is3d")
{
AudioSource*obj=(AudioSource*)f->data;
obj->is3d=val_to_c<decltype(obj->is3d)>::f(ctx,value);
} EI(keyStr=="position")
{
AudioSource*obj=(AudioSource*)f->data;
obj->position=val_to_c<decltype(obj->position)>::f(ctx,value);
} EI(keyStr=="referenceDistance")
{
AudioSource*obj=(AudioSource*)f->data;
obj->referenceDistance=val_to_c<decltype(obj->referenceDistance)>::f(ctx,value);
} EI(keyStr=="rolloffFactor")
{
AudioSource*obj=(AudioSource*)f->data;
obj->rolloffFactor=val_to_c<decltype(obj->rolloffFactor)>::f(ctx,value);
} EI(keyStr=="maxDistance")
{
AudioSource*obj=(AudioSource*)f->data;
obj->maxDistance=val_to_c<decltype(obj->maxDistance)>::f(ctx,value);
} EI(keyStr=="volume")
{
AudioSource*obj=(AudioSource*)f->data;
obj->volume=val_to_c<decltype(obj->volume)>::f(ctx,value);
} EI(keyStr=="velocity")
{
AudioSource*obj=(AudioSource*)f->data;
obj->velocity=val_to_c<decltype(obj->velocity)>::f(ctx,value);
} EI(keyStr=="dopplerFactor")
{
AudioSource*obj=(AudioSource*)f->data;
obj->dopplerFactor=val_to_c<decltype(obj->dopplerFactor)>::f(ctx,value);
} EI(keyStr=="offset")
{
AudioSource*obj=(AudioSource*)f->data;
obj->offset=val_to_c<decltype(obj->offset)>::f(ctx,value);
} EI(keyStr=="loop")
{
AudioSource*obj=(AudioSource*)f->data;
obj->loop=val_to_c<decltype(obj->loop)>::f(ctx,value);
} EI(keyStr=="playing")
{
AudioSource*obj=(AudioSource*)f->data;
obj->playing=val_to_c<decltype(obj->playing)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV AudioSource_getAudio(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSource::getAudio" EAOE));
AudioSource*f;
f=(AudioSource*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAudio());
;
}
CATE(TE,UFOF("AudioSource::getAudio.")));
RET CN;
}

SV AudioSource_setAudio(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSource::setAudio" EAOE));
AudioSource*f;
f=(AudioSource*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],Audio *))
{
( f->setAudio(val_to_c<std::remove_reference<Audio *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioSource::setAudio.")));
RET CN;
}

void RayCastResultList_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<RayCastResult>))
CATE(TE,"RayCastResultList::__del__ expects RayCastResultList as first argument."));

DELETE((List<RayCastResult>*)f->data);
}SV RayCastResultList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList's constructor" EAOE));
if(!TS(a[0],List<RayCastResult>))
CATE(TE,"RayCastResultList's constructor expects RayCastResultList as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(RayCastResultList_funcs,NEW(List<RayCastResult>),EXT->RayCastResultList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],std::size_t))
RET STG::createNativeObject(RayCastResultList_funcs,NEW(List<RayCastResult>,val_to_c<std::size_t>::f(ctx,a[1])),EXT->RayCastResultList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const List<RayCastResult> &))
RET STG::createNativeObject(RayCastResultList_funcs,NEW(List<RayCastResult>,val_to_c<const List<RayCastResult> &>::f(ctx,a[1])),EXT->RayCastResultList_typeID);
CATE(TE,UFOF("RayCastResultList's constructor.")));
RET CN;
}

SV RayCastResultList_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("RayCastResultList");
EI(keyStr=="__new__")
RET CNF(RayCastResultList_new);
EI(keyStr=="__call__")
RET CNF(RayCastResultList_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(RayCastResultList_new);
 EI(keyStr == "__eq__")
RET CNF(RayCastResultList___eq__);
 EI(keyStr == "__neq__")
RET CNF(RayCastResultList___neq__);
 EI(keyStr == "get")
RET CNF(RayCastResultList_get);
 EI(keyStr == "set")
RET CNF(RayCastResultList_set);
 EI(keyStr == "getCount")
RET CNF(RayCastResultList_getCount);
 EI(keyStr == "getData")
RET CNF(RayCastResultList_getData);
 EI(keyStr == "append")
RET CNF(RayCastResultList_append);
 EI(keyStr == "insert")
RET CNF(RayCastResultList_insert);
 EI(keyStr == "remove")
RET CNF(RayCastResultList_remove);
 EI(keyStr == "clear")
RET CNF(RayCastResultList_clear);
 EI(keyStr == "find")
RET CNF(RayCastResultList_find);
 EI(keyStr == "copy")
RET CNF(RayCastResultList_copy);
 EI(keyStr == "in")
RET CNF(RayCastResultList_in);
 EI(keyStr == "begin")
RET CNF(RayCastResultList_begin);
 EI(keyStr == "end")
RET CNF(RayCastResultList_end);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void RayCastResultList_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV RayCastResultList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::insert" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],RayCastResult))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<RayCastResult>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<RayCastResult> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<RayCastResult> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("RayCastResultList::insert.")));
RET CN;
}

SV RayCastResultList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::begin" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0])->data;

CATE(TE,UFOF("RayCastResultList::begin.")));
RET CN;
}

SV RayCastResultList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::set" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],RayCastResult))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<RayCastResult>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("RayCastResultList::set.")));
RET CN;
}

SV RayCastResultList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::end" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0])->data;

CATE(TE,UFOF("RayCastResultList::end.")));
RET CN;
}

SV RayCastResultList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::get" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("RayCastResultList::get.")));
RET CN;
}

SV RayCastResultList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::clear" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("RayCastResultList::clear.")));
RET CN;
}

SV RayCastResultList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::copy" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("RayCastResultList::copy.")));
RET CN;
}

SV RayCastResultList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::remove" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("RayCastResultList::remove.")));
RET CN;
}

SV RayCastResultList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::in" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],RayCastResult))
{
RET CV( f->in(val_to_c<std::remove_reference<RayCastResult>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("RayCastResultList::in.")));
RET CN;
}

SV RayCastResultList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::getCount" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("RayCastResultList::getCount.")));
RET CN;
}

SV RayCastResultList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::getData" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0])->data;

CATE(TE,UFOF("RayCastResultList::getData.")));
RET CN;
}

SV RayCastResultList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::__eq__" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<RayCastResult> &))
{
auto v=val_to_c<std::remove_reference<const List<RayCastResult> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("RayCastResultList::__eq__.")));
RET CN;
}

SV RayCastResultList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::find" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],RayCastResult))
{
RET CV( f->find(val_to_c<std::remove_reference<RayCastResult>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("RayCastResultList::find.")));
RET CN;
}

SV RayCastResultList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::append" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],RayCastResult))
{
( f->append(val_to_c<std::remove_reference<RayCastResult>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<RayCastResult> &))
{
( f->append(val_to_c<std::remove_reference<const List<RayCastResult> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RayCastResultList::append.")));
RET CN;
}

SV RayCastResultList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResultList::__neq__" EAOE));
List<RayCastResult>*f;
f=(List<RayCastResult>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<RayCastResult> &))
{
auto v=val_to_c<std::remove_reference<const List<RayCastResult> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("RayCastResultList::__neq__.")));
RET CN;
}

void Platform_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Platform))
CATE(TE,"Platform::__del__ expects Platform as first argument."));

DELETE((Platform*)f->data);
}SV Platform_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform's constructor" EAOE));
if(!TS(a[0],Platform))
CATE(TE,"Platform's constructor expects Platform as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(Platform_funcs,NEW(Platform),EXT->Platform_typeID);
CATE(TE,UFOF("Platform's constructor.")));
RET CN;
}

SV Platform_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Platform");
EI(keyStr=="__new__")
RET CNF(Platform_new);
EI(keyStr=="__call__")
RET CNF(Platform_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Platform_new);
 EI(keyStr == "initWindow")
RET CNF(Platform_initWindow);
 EI(keyStr == "destroyWindow")
RET CNF(Platform_destroyWindow);
 EI(keyStr == "run")
RET CNF(Platform_run);
 EI(keyStr == "pollEvent")
RET CNF(Platform_pollEvent);
 EI(keyStr == "eventsLeft")
RET CNF(Platform_eventsLeft);
 EI(keyStr == "popEvent")
RET CNF(Platform_popEvent);
 EI(keyStr == "getTime")
RET CNF(Platform_getTime);
 EI(keyStr == "getTimerFrequency")
RET CNF(Platform_getTimerFrequency);
 EI(keyStr == "getWindowWidth")
RET CNF(Platform_getWindowWidth);
 EI(keyStr == "getWindowHeight")
RET CNF(Platform_getWindowHeight);
 EI(keyStr == "getMousePosition")
RET CNF(Platform_getMousePosition);
 EI(keyStr == "setMousePosition")
RET CNF(Platform_setMousePosition);
 EI(keyStr == "isLeftMouseButtonPressed")
RET CNF(Platform_isLeftMouseButtonPressed);
 EI(keyStr == "isRightMouseButtonPressed")
RET CNF(Platform_isRightMouseButtonPressed);
 EI(keyStr == "isMiddleMouseButtonPressed")
RET CNF(Platform_isMiddleMouseButtonPressed);
 EI(keyStr == "getMouseWheel")
RET CNF(Platform_getMouseWheel);
 EI(keyStr == "isCursorVisible")
RET CNF(Platform_isCursorVisible);
 EI(keyStr == "setCursorVisible")
RET CNF(Platform_setCursorVisible);
 EI(keyStr == "isKeyPressed")
RET CNF(Platform_isKeyPressed);
 EI(keyStr == "getFullscreen")
RET CNF(Platform_getFullscreen);
 EI(keyStr == "setFullscreen")
RET CNF(Platform_setFullscreen);
 EI(keyStr == "getFrametime")
RET CNF(Platform_getFrametime);
 EI(keyStr == "getGPUFrametime")
RET CNF(Platform_getGPUFrametime);
 EI(keyStr == "getCPUFrametime")
RET CNF(Platform_getCPUFrametime);
 EI(keyStr=="running")
{
Platform*obj=(Platform*)f->data;
RET CV(obj->running);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Platform_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="running")
{
Platform*obj=(Platform*)f->data;
obj->running=val_to_c<decltype(obj->running)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Platform_setFullscreen(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::setFullscreen" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],bool))
{
( f->setFullscreen(val_to_c<std::remove_reference<bool>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Platform::setFullscreen.")));
RET CN;
}

SV Platform_getTime(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getTime" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getTime());
;
}
CATE(TE,UFOF("Platform::getTime.")));
RET CN;
}

SV Platform_eventsLeft(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::eventsLeft" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->eventsLeft());
;
}
CATE(TE,UFOF("Platform::eventsLeft.")));
RET CN;
}

SV Platform_setMousePosition(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::setMousePosition" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],Int2))
{
( f->setMousePosition(val_to_c<std::remove_reference<Int2>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Platform::setMousePosition.")));
RET CN;
}

SV Platform_getMousePosition(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getMousePosition" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getMousePosition());
;
}
CATE(TE,UFOF("Platform::getMousePosition.")));
RET CN;
}

SV Platform_setCursorVisible(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::setCursorVisible" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],bool))
{
( f->setCursorVisible(val_to_c<std::remove_reference<bool>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Platform::setCursorVisible.")));
RET CN;
}

SV Platform_isRightMouseButtonPressed(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::isRightMouseButtonPressed" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->isRightMouseButtonPressed());
;
}
CATE(TE,UFOF("Platform::isRightMouseButtonPressed.")));
RET CN;
}

SV Platform_getFullscreen(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getFullscreen" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFullscreen());
;
}
CATE(TE,UFOF("Platform::getFullscreen.")));
RET CN;
}

SV Platform_getFrametime(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getFrametime" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFrametime());
;
}
CATE(TE,UFOF("Platform::getFrametime.")));
RET CN;
}

SV Platform_initWindow(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::initWindow" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],uint32_t)&&TS(a[2],uint32_t))
{
( f->initWindow(val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("Platform::initWindow.")));
RET CN;
}

SV Platform_isKeyPressed(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::isKeyPressed" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],Key))
{
RET CV( f->isKeyPressed(val_to_c<std::remove_reference<Key>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Platform::isKeyPressed.")));
RET CN;
}

SV Platform_destroyWindow(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::destroyWindow" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->destroyWindow());
RET CN;
}
CATE(TE,UFOF("Platform::destroyWindow.")));
RET CN;
}

SV Platform_run(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::run" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

CATE(TE,UFOF("Platform::run.")));
RET CN;
}

SV Platform_getWindowWidth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getWindowWidth" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWindowWidth());
;
}
CATE(TE,UFOF("Platform::getWindowWidth.")));
RET CN;
}

SV Platform_popEvent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::popEvent" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->popEvent());
;
}
CATE(TE,UFOF("Platform::popEvent.")));
RET CN;
}

SV Platform_getTimerFrequency(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getTimerFrequency" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getTimerFrequency());
;
}
CATE(TE,UFOF("Platform::getTimerFrequency.")));
RET CN;
}

SV Platform_getWindowHeight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getWindowHeight" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWindowHeight());
;
}
CATE(TE,UFOF("Platform::getWindowHeight.")));
RET CN;
}

SV Platform_getMouseWheel(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getMouseWheel" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getMouseWheel());
;
}
CATE(TE,UFOF("Platform::getMouseWheel.")));
RET CN;
}

SV Platform_isMiddleMouseButtonPressed(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::isMiddleMouseButtonPressed" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->isMiddleMouseButtonPressed());
;
}
CATE(TE,UFOF("Platform::isMiddleMouseButtonPressed.")));
RET CN;
}

SV Platform_pollEvent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::pollEvent" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

CATE(TE,UFOF("Platform::pollEvent.")));
RET CN;
}

SV Platform_isLeftMouseButtonPressed(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::isLeftMouseButtonPressed" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->isLeftMouseButtonPressed());
;
}
CATE(TE,UFOF("Platform::isLeftMouseButtonPressed.")));
RET CN;
}

SV Platform_isCursorVisible(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::isCursorVisible" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->isCursorVisible());
;
}
CATE(TE,UFOF("Platform::isCursorVisible.")));
RET CN;
}

SV Platform_getCPUFrametime(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getCPUFrametime" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCPUFrametime());
;
}
CATE(TE,UFOF("Platform::getCPUFrametime.")));
RET CN;
}

SV Platform_getGPUFrametime(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Platform::getGPUFrametime" EAOE));
Platform*f;
f=(Platform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGPUFrametime());
;
}
CATE(TE,UFOF("Platform::getGPUFrametime.")));
RET CN;
}

void Camera_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Camera))
CATE(TE,"Camera::__del__ expects Camera as first argument."));

DELETE((Camera*)f->data);
}SV Camera_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera's constructor" EAOE));
if(!TS(a[0],Camera))
CATE(TE,"Camera's constructor expects Camera as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(Camera_funcs,NEW(Camera),EXT->Camera_typeID);
CATE(TE,UFOF("Camera's constructor.")));
RET CN;
}

SV Camera_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Camera");
EI(keyStr=="__new__")
RET CNF(Camera_new);
EI(keyStr=="__call__")
RET CNF(Camera_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Camera_new);
 EI(keyStr == "setType")
RET CNF(Camera_setType);
 EI(keyStr == "setPosition")
RET CNF(Camera_setPosition);
 EI(keyStr == "setDirection")
RET CNF(Camera_setDirection);
 EI(keyStr == "setUp")
RET CNF(Camera_setUp);
 EI(keyStr == "setWidth")
RET CNF(Camera_setWidth);
 EI(keyStr == "setHeight")
RET CNF(Camera_setHeight);
 EI(keyStr == "setFieldOfView")
RET CNF(Camera_setFieldOfView);
 EI(keyStr == "setLeft")
RET CNF(Camera_setLeft);
 EI(keyStr == "setRight")
RET CNF(Camera_setRight);
 EI(keyStr == "setBottom")
RET CNF(Camera_setBottom);
 EI(keyStr == "setTop")
RET CNF(Camera_setTop);
 EI(keyStr == "setNear")
RET CNF(Camera_setNear);
 EI(keyStr == "setFar")
RET CNF(Camera_setFar);
 EI(keyStr == "getType")
RET CNF(Camera_getType);
 EI(keyStr == "getPosition")
RET CNF(Camera_getPosition);
 EI(keyStr == "getDirection")
RET CNF(Camera_getDirection);
 EI(keyStr == "getUp")
RET CNF(Camera_getUp);
 EI(keyStr == "getWidth")
RET CNF(Camera_getWidth);
 EI(keyStr == "getHeight")
RET CNF(Camera_getHeight);
 EI(keyStr == "getFieldOfView")
RET CNF(Camera_getFieldOfView);
 EI(keyStr == "getLeft")
RET CNF(Camera_getLeft);
 EI(keyStr == "getRight")
RET CNF(Camera_getRight);
 EI(keyStr == "getBottom")
RET CNF(Camera_getBottom);
 EI(keyStr == "getTop")
RET CNF(Camera_getTop);
 EI(keyStr == "getNear")
RET CNF(Camera_getNear);
 EI(keyStr == "getFar")
RET CNF(Camera_getFar);
 EI(keyStr == "getViewMatrix")
RET CNF(Camera_getViewMatrix);
 EI(keyStr == "getProjectionMatrix")
RET CNF(Camera_getProjectionMatrix);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Camera_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Camera_setBottom(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setBottom" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setBottom(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setBottom.")));
RET CN;
}

SV Camera_getRight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getRight" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRight());
;
}
CATE(TE,UFOF("Camera::getRight.")));
RET CN;
}

SV Camera_setTop(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setTop" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setTop(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setTop.")));
RET CN;
}

SV Camera_getWidth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getWidth" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWidth());
;
}
CATE(TE,UFOF("Camera::getWidth.")));
RET CN;
}

SV Camera_getDirection(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getDirection" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDirection());
;
}
CATE(TE,UFOF("Camera::getDirection.")));
RET CN;
}

SV Camera_getFieldOfView(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getFieldOfView" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFieldOfView());
;
}
CATE(TE,UFOF("Camera::getFieldOfView.")));
RET CN;
}

SV Camera_setWidth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setWidth" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setWidth(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setWidth.")));
RET CN;
}

SV Camera_setType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setType" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],CameraType))
{
( f->setType(val_to_c<std::remove_reference<CameraType>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setType.")));
RET CN;
}

SV Camera_setDirection(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setDirection" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Direction3D &))
{
( f->setDirection(val_to_c<std::remove_reference<const Direction3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setDirection.")));
RET CN;
}

SV Camera_getLeft(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getLeft" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getLeft());
;
}
CATE(TE,UFOF("Camera::getLeft.")));
RET CN;
}

SV Camera_getProjectionMatrix(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getProjectionMatrix" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getProjectionMatrix());
;
}
CATE(TE,UFOF("Camera::getProjectionMatrix.")));
RET CN;
}

SV Camera_getHeight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getHeight" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getHeight());
;
}
CATE(TE,UFOF("Camera::getHeight.")));
RET CN;
}

SV Camera_setFar(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setFar" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setFar(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setFar.")));
RET CN;
}

SV Camera_setFieldOfView(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setFieldOfView" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setFieldOfView(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setFieldOfView.")));
RET CN;
}

SV Camera_getTop(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getTop" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getTop());
;
}
CATE(TE,UFOF("Camera::getTop.")));
RET CN;
}

SV Camera_getBottom(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getBottom" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBottom());
;
}
CATE(TE,UFOF("Camera::getBottom.")));
RET CN;
}

SV Camera_getFar(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getFar" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFar());
;
}
CATE(TE,UFOF("Camera::getFar.")));
RET CN;
}

SV Camera_setUp(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setUp" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Direction3D &))
{
( f->setUp(val_to_c<std::remove_reference<const Direction3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setUp.")));
RET CN;
}

SV Camera_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getType" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("Camera::getType.")));
RET CN;
}

SV Camera_setNear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setNear" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setNear(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setNear.")));
RET CN;
}

SV Camera_setPosition(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setPosition" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Position3D &))
{
( f->setPosition(val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setPosition.")));
RET CN;
}

SV Camera_setLeft(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setLeft" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setLeft(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setLeft.")));
RET CN;
}

SV Camera_getPosition(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getPosition" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getPosition());
;
}
CATE(TE,UFOF("Camera::getPosition.")));
RET CN;
}

SV Camera_setHeight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setHeight" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setHeight(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setHeight.")));
RET CN;
}

SV Camera_getViewMatrix(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getViewMatrix" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getViewMatrix());
;
}
CATE(TE,UFOF("Camera::getViewMatrix.")));
RET CN;
}

SV Camera_getNear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getNear" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getNear());
;
}
CATE(TE,UFOF("Camera::getNear.")));
RET CN;
}

SV Camera_setRight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::setRight" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setRight(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Camera::setRight.")));
RET CN;
}

SV Camera_getUp(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Camera::getUp" EAOE));
Camera*f;
f=(Camera*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getUp());
;
}
CATE(TE,UFOF("Camera::getUp.")));
RET CN;
}

void GfxMesh_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxMesh))
CATE(TE,"GfxMesh::__del__ expects GfxMesh as first argument."));

GfxMesh*obj=(GfxMesh*)f->data;
if(obj!=nullptr){obj->release();}
}SV GfxMesh_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxMesh's constructor" EAOE));
if(!TS(a[0],GfxMesh))
CATE(TE,"GfxMesh's constructor expects GfxMesh as first argument."));
CATE(TE,UFOF("GfxMesh's constructor.")));
}

SV GfxMesh_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxMesh");
EI(keyStr=="__new__")
RET CNF(GfxMesh_new);
EI(keyStr=="__call__")
RET CNF(GfxMesh_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GfxMesh_new);
 EI(keyStr == "addIndices")
RET CNF(GfxMesh_addIndices);
 EI(keyStr == "removeIndices")
RET CNF(GfxMesh_removeIndices);
 EI(keyStr == "setAttribute")
RET CNF(GfxMesh_setAttribute);
 EI(keyStr == "removeAttribute")
RET CNF(GfxMesh_removeAttribute);
 EI(keyStr == "getIndexed")
RET CNF(GfxMesh_getIndexed);
 EI(keyStr == "getIndexType")
RET CNF(GfxMesh_getIndexType);
 EI(keyStr == "getIndices")
RET CNF(GfxMesh_getIndices);
 EI(keyStr == "getAttribs")
RET CNF(GfxMesh_getAttribs);
 EI(keyStr == "getAttribCount")
RET CNF(GfxMesh_getAttribCount);
 EI(keyStr == "getAttrib")
RET CNF(GfxMesh_getAttrib);
 EI(keyStr == "getGLVAO")
RET CNF(GfxMesh_getGLVAO);
 EI(keyStr == "getGLIndexBuffer")
RET CNF(GfxMesh_getGLIndexBuffer);
 EI(keyStr == "removeContent")
RET CNF(GfxMesh_removeContent);
 EI(keyStr == "save")
RET CNF(GfxMesh_save);
 EI(keyStr == "load")
RET CNF(GfxMesh_load);
 EI(keyStr == "copy")
RET CNF(GfxMesh_copy);
 EI(keyStr == "getType")
RET CNF(GfxMesh_getType);
 EI(keyStr == "release")
RET CNF(GfxMesh_release);
 EI(keyStr == "getRefCount")
RET CNF(GfxMesh_getRefCount);
 EI(keyStr == "getFilename")
RET CNF(GfxMesh_getFilename);
 EI(keyStr == "setFilename")
RET CNF(GfxMesh_setFilename);
 EI(keyStr=="aabb")
{
GfxMesh*obj=(GfxMesh*)f->data;
RET CV(obj->aabb);
} EI(keyStr=="numVertices")
{
GfxMesh*obj=(GfxMesh*)f->data;
RET CV(obj->numVertices);
} EI(keyStr=="numIndices")
{
GfxMesh*obj=(GfxMesh*)f->data;
RET CV(obj->numIndices);
} EI(keyStr=="primitive")
{
GfxMesh*obj=(GfxMesh*)f->data;
RET CV(obj->primitive);
} EI(keyStr=="cullMode")
{
GfxMesh*obj=(GfxMesh*)f->data;
RET CV(obj->cullMode);
} EI(keyStr=="winding")
{
GfxMesh*obj=(GfxMesh*)f->data;
RET CV(obj->winding);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GfxMesh_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="aabb")
{
GfxMesh*obj=(GfxMesh*)f->data;
obj->aabb=val_to_c<decltype(obj->aabb)>::f(ctx,value);
} EI(keyStr=="numVertices")
{
GfxMesh*obj=(GfxMesh*)f->data;
obj->numVertices=val_to_c<decltype(obj->numVertices)>::f(ctx,value);
} EI(keyStr=="numIndices")
{
GfxMesh*obj=(GfxMesh*)f->data;
obj->numIndices=val_to_c<decltype(obj->numIndices)>::f(ctx,value);
} EI(keyStr=="primitive")
{
GfxMesh*obj=(GfxMesh*)f->data;
obj->primitive=val_to_c<decltype(obj->primitive)>::f(ctx,value);
} EI(keyStr=="cullMode")
{
GfxMesh*obj=(GfxMesh*)f->data;
obj->cullMode=val_to_c<decltype(obj->cullMode)>::f(ctx,value);
} EI(keyStr=="winding")
{
GfxMesh*obj=(GfxMesh*)f->data;
obj->winding=val_to_c<decltype(obj->winding)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GfxMesh_getAttribs(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getAttribs" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

CATE(TE,UFOF("GfxMesh::getAttribs.")));
RET CN;
}

SV GfxMesh_getGLIndexBuffer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getGLIndexBuffer" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGLIndexBuffer());
;
}
CATE(TE,UFOF("GfxMesh::getGLIndexBuffer.")));
RET CN;
}

SV GfxMesh_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getType" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("GfxMesh::getType.")));
RET CN;
}

SV GfxMesh_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::copy" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("GfxMesh::copy.")));
RET CN;
}

SV GfxMesh_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::setFilename" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
( f->setFilename(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxMesh::setFilename.")));
RET CN;
}

SV GfxMesh_removeAttribute(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::removeAttribute" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxMeshAttribType))
{
( f->removeAttribute(val_to_c<std::remove_reference<GfxMeshAttribType>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxMesh::removeAttribute.")));
RET CN;
}

SV GfxMesh_getAttrib(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getAttrib" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getAttrib(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxMesh::getAttrib.")));
RET CN;
}

SV GfxMesh_removeIndices(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::removeIndices" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->removeIndices());
RET CN;
}
CATE(TE,UFOF("GfxMesh::removeIndices.")));
RET CN;
}

SV GfxMesh_getAttribCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getAttribCount" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAttribCount());
;
}
CATE(TE,UFOF("GfxMesh::getAttribCount.")));
RET CN;
}

SV GfxMesh_setAttribute(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::setAttribute" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const GfxMeshAttrib &))
{
( f->setAttribute(val_to_c<std::remove_reference<const GfxMeshAttrib &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxMesh::setAttribute.")));
RET CN;
}

SV GfxMesh_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::load" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("GfxMesh::load.")));
RET CN;
}

SV GfxMesh_getGLVAO(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getGLVAO" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGLVAO());
;
}
CATE(TE,UFOF("GfxMesh::getGLVAO.")));
RET CN;
}

SV GfxMesh_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::removeContent" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("GfxMesh::removeContent.")));
RET CN;
}

SV GfxMesh_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getRefCount" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("GfxMesh::getRefCount.")));
RET CN;
}

SV GfxMesh_getIndices(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getIndices" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

CATE(TE,UFOF("GfxMesh::getIndices.")));
RET CN;
}

SV GfxMesh_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::release" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("GfxMesh::release.")));
RET CN;
}

SV GfxMesh_getIndexed(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getIndexed" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getIndexed());
;
}
CATE(TE,UFOF("GfxMesh::getIndexed.")));
RET CN;
}

SV GfxMesh_addIndices(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::addIndices" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==4)
if(1&&TS(a[1],size_t)&&TS(a[2],GfxMeshIndexDataType)&&TS(a[3],const ResizableData &))
{
( f->addIndices(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxMeshIndexDataType>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("GfxMesh::addIndices.")));
RET CN;
}

SV GfxMesh_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::save" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("GfxMesh::save.")));
RET CN;
}

SV GfxMesh_getIndexType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getIndexType" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getIndexType());
;
}
CATE(TE,UFOF("GfxMesh::getIndexType.")));
RET CN;
}

SV GfxMesh_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMesh::getFilename" EAOE));
GfxMesh*f;
f=(GfxMesh*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("GfxMesh::getFilename.")));
RET CN;
}

void Resource_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Resource))
CATE(TE,"Resource::__del__ expects Resource as first argument."));

Resource*obj=(Resource*)f->data;
if(obj!=nullptr){obj->release();}
}SV Resource_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Resource's constructor" EAOE));
if(!TS(a[0],Resource))
CATE(TE,"Resource's constructor expects Resource as first argument."));
CATE(TE,UFOF("Resource's constructor.")));
}

SV Resource_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Resource");
EI(keyStr=="__new__")
RET CNF(Resource_new);
EI(keyStr=="__call__")
RET CNF(Resource_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Resource_new);
 EI(keyStr == "removeContent")
RET CNF(Resource_removeContent);
 EI(keyStr == "load")
RET CNF(Resource_load);
 EI(keyStr == "save")
RET CNF(Resource_save);
 EI(keyStr == "copy")
RET CNF(Resource_copy);
 EI(keyStr == "getType")
RET CNF(Resource_getType);
 EI(keyStr == "release")
RET CNF(Resource_release);
 EI(keyStr == "getRefCount")
RET CNF(Resource_getRefCount);
 EI(keyStr == "getFilename")
RET CNF(Resource_getFilename);
 EI(keyStr == "setFilename")
RET CNF(Resource_setFilename);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Resource_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Resource_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::load" EAOE));
Resource*f;
f=(Resource*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("Resource::load.")));
RET CN;
}

SV Resource_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::getFilename" EAOE));
Resource*f;
f=(Resource*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("Resource::getFilename.")));
RET CN;
}

SV Resource_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::copy" EAOE));
Resource*f;
f=(Resource*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("Resource::copy.")));
RET CN;
}

SV Resource_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::getType" EAOE));
Resource*f;
f=(Resource*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("Resource::getType.")));
RET CN;
}

SV Resource_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::setFilename" EAOE));
Resource*f;
f=(Resource*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
( f->setFilename(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Resource::setFilename.")));
RET CN;
}

SV Resource_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::removeContent" EAOE));
Resource*f;
f=(Resource*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("Resource::removeContent.")));
RET CN;
}

SV Resource_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::getRefCount" EAOE));
Resource*f;
f=(Resource*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("Resource::getRefCount.")));
RET CN;
}

SV Resource_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::release" EAOE));
Resource*f;
f=(Resource*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("Resource::release.")));
RET CN;
}

SV Resource_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Resource::save" EAOE));
Resource*f;
f=(Resource*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("Resource::save.")));
RET CN;
}

void GfxShader_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxShader))
CATE(TE,"GfxShader::__del__ expects GfxShader as first argument."));

GfxShader*obj=(GfxShader*)f->data;
if(obj!=nullptr){obj->release();}
}SV GfxShader_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxShader's constructor" EAOE));
if(!TS(a[0],GfxShader))
CATE(TE,"GfxShader's constructor expects GfxShader as first argument."));
CATE(TE,UFOF("GfxShader's constructor.")));
}

SV GfxShader_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxShader");
EI(keyStr=="__new__")
RET CNF(GfxShader_new);
EI(keyStr=="__call__")
RET CNF(GfxShader_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GfxShader_new);
 EI(keyStr == "removeContent")
RET CNF(GfxShader_removeContent);
 EI(keyStr == "save")
RET CNF(GfxShader_save);
 EI(keyStr == "compile")
RET CNF(GfxShader_compile);
 EI(keyStr == "getSource")
RET CNF(GfxShader_getSource);
 EI(keyStr == "getShaderType")
RET CNF(GfxShader_getShaderType);
 EI(keyStr == "getCompiled")
RET CNF(GfxShader_getCompiled);
 EI(keyStr == "load")
RET CNF(GfxShader_load);
 EI(keyStr == "copy")
RET CNF(GfxShader_copy);
 EI(keyStr == "getType")
RET CNF(GfxShader_getType);
 EI(keyStr == "release")
RET CNF(GfxShader_release);
 EI(keyStr == "getRefCount")
RET CNF(GfxShader_getRefCount);
 EI(keyStr == "getFilename")
RET CNF(GfxShader_getFilename);
 EI(keyStr == "setFilename")
RET CNF(GfxShader_setFilename);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GfxShader_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GfxShader_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::load" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("GfxShader::load.")));
RET CN;
}

SV GfxShader_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::getFilename" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("GfxShader::getFilename.")));
RET CN;
}

SV GfxShader_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::copy" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("GfxShader::copy.")));
RET CN;
}

SV GfxShader_getCompiled(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::getCompiled" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const HashMap<String, String> &))
{
RET CV( f->getCompiled(val_to_c<std::remove_reference<const HashMap<String, String> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxShader::getCompiled.")));
RET CN;
}

SV GfxShader_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::getType" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("GfxShader::getType.")));
RET CN;
}

SV GfxShader_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::setFilename" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
( f->setFilename(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxShader::setFilename.")));
RET CN;
}

SV GfxShader_compile(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::compile" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],GfxShaderType)&&TS(a[2],const String &))
{
( f->compile(val_to_c<std::remove_reference<GfxShaderType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxShader::compile.")));
RET CN;
}

SV GfxShader_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::removeContent" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("GfxShader::removeContent.")));
RET CN;
}

SV GfxShader_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::getRefCount" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("GfxShader::getRefCount.")));
RET CN;
}

SV GfxShader_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::release" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("GfxShader::release.")));
RET CN;
}

SV GfxShader_getSource(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::getSource" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getSource());
;
}
CATE(TE,UFOF("GfxShader::getSource.")));
RET CN;
}

SV GfxShader_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::save" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("GfxShader::save.")));
RET CN;
}

SV GfxShader_getShaderType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShader::getShaderType" EAOE));
GfxShader*f;
f=(GfxShader*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShaderType());
;
}
CATE(TE,UFOF("GfxShader::getShaderType.")));
RET CN;
}

void Light_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Light))
CATE(TE,"Light::__del__ expects Light as first argument."));

DELETE((Light*)f->data);
}SV Light_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light's constructor" EAOE));
if(!TS(a[0],Light))
CATE(TE,"Light's constructor expects Light as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(Light_funcs,NEW(Light),EXT->Light_typeID);
CATE(TE,UFOF("Light's constructor.")));
RET CN;
}

SV Light_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Light");
EI(keyStr=="__new__")
RET CNF(Light_new);
EI(keyStr=="__call__")
RET CNF(Light_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Light_new);
 EI(keyStr == "addShadowmap")
RET CNF(Light_addShadowmap);
 EI(keyStr == "removeShadowmap")
RET CNF(Light_removeShadowmap);
 EI(keyStr == "getShadowmap")
RET CNF(Light_getShadowmap);
 EI(keyStr == "getShadowmapFramebuffer")
RET CNF(Light_getShadowmapFramebuffer);
 EI(keyStr == "getPointLightFramebuffers")
RET CNF(Light_getPointLightFramebuffers);
 EI(keyStr == "getPointLightFramebuffer")
RET CNF(Light_getPointLightFramebuffer);
 EI(keyStr == "getShadowmapResolution")
RET CNF(Light_getShadowmapResolution);
 EI(keyStr == "getShadowmapPrecision")
RET CNF(Light_getShadowmapPrecision);
 EI(keyStr == "updateMatrices")
RET CNF(Light_updateMatrices);
 EI(keyStr == "getViewMatrix")
RET CNF(Light_getViewMatrix);
 EI(keyStr == "getProjectionMatrix")
RET CNF(Light_getProjectionMatrix);
 EI(keyStr=="type")
{
Light*obj=(Light*)f->data;
RET CV(obj->type);
} EI(keyStr=="power")
{
Light*obj=(Light*)f->data;
RET CV(obj->power);
} EI(keyStr=="color")
{
Light*obj=(Light*)f->data;
RET CV(obj->color);
} EI(keyStr=="ambientStrength")
{
Light*obj=(Light*)f->data;
RET CV(obj->ambientStrength);
} EI(keyStr=="shadowmapNear")
{
Light*obj=(Light*)f->data;
RET CV(obj->shadowmapNear);
} EI(keyStr=="shadowmapFar")
{
Light*obj=(Light*)f->data;
RET CV(obj->shadowmapFar);
} EI(keyStr=="shadowMinBias")
{
Light*obj=(Light*)f->data;
RET CV(obj->shadowMinBias);
} EI(keyStr=="shadowBiasScale")
{
Light*obj=(Light*)f->data;
RET CV(obj->shadowBiasScale);
} EI(keyStr=="shadowAutoBiasScale")
{
Light*obj=(Light*)f->data;
RET CV(obj->shadowAutoBiasScale);
} EI(keyStr=="shadowFixedBias")
{
Light*obj=(Light*)f->data;
RET CV(obj->shadowFixedBias);
} EI(keyStr=="shadowRadius")
{
Light*obj=(Light*)f->data;
RET CV(obj->shadowRadius);
} EI(keyStr=="scriptOwned")
{
Light*obj=(Light*)f->data;
RET CV(obj->scriptOwned);
} EI(keyStr=="direction")
{
Light*obj=(Light*)f->data;
RET CV(obj->direction);
} EI(keyStr=="spot")
{
Light*obj=(Light*)f->data;
RET CV(obj->spot);
} EI(keyStr=="point")
{
Light*obj=(Light*)f->data;
RET CV(obj->point);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Light_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="type")
{
Light*obj=(Light*)f->data;
obj->type=val_to_c<decltype(obj->type)>::f(ctx,value);
} EI(keyStr=="power")
{
Light*obj=(Light*)f->data;
obj->power=val_to_c<decltype(obj->power)>::f(ctx,value);
} EI(keyStr=="color")
{
Light*obj=(Light*)f->data;
obj->color=val_to_c<decltype(obj->color)>::f(ctx,value);
} EI(keyStr=="ambientStrength")
{
Light*obj=(Light*)f->data;
obj->ambientStrength=val_to_c<decltype(obj->ambientStrength)>::f(ctx,value);
} EI(keyStr=="shadowmapNear")
{
Light*obj=(Light*)f->data;
obj->shadowmapNear=val_to_c<decltype(obj->shadowmapNear)>::f(ctx,value);
} EI(keyStr=="shadowmapFar")
{
Light*obj=(Light*)f->data;
obj->shadowmapFar=val_to_c<decltype(obj->shadowmapFar)>::f(ctx,value);
} EI(keyStr=="shadowMinBias")
{
Light*obj=(Light*)f->data;
obj->shadowMinBias=val_to_c<decltype(obj->shadowMinBias)>::f(ctx,value);
} EI(keyStr=="shadowBiasScale")
{
Light*obj=(Light*)f->data;
obj->shadowBiasScale=val_to_c<decltype(obj->shadowBiasScale)>::f(ctx,value);
} EI(keyStr=="shadowAutoBiasScale")
{
Light*obj=(Light*)f->data;
obj->shadowAutoBiasScale=val_to_c<decltype(obj->shadowAutoBiasScale)>::f(ctx,value);
} EI(keyStr=="shadowFixedBias")
{
Light*obj=(Light*)f->data;
obj->shadowFixedBias=val_to_c<decltype(obj->shadowFixedBias)>::f(ctx,value);
} EI(keyStr=="shadowRadius")
{
Light*obj=(Light*)f->data;
obj->shadowRadius=val_to_c<decltype(obj->shadowRadius)>::f(ctx,value);
} EI(keyStr=="scriptOwned")
{
Light*obj=(Light*)f->data;
obj->scriptOwned=val_to_c<decltype(obj->scriptOwned)>::f(ctx,value);
} EI(keyStr=="direction")
{
Light*obj=(Light*)f->data;
obj->direction=val_to_c<decltype(obj->direction)>::f(ctx,value);
} EI(keyStr=="spot")
{
Light*obj=(Light*)f->data;
obj->spot=val_to_c<decltype(obj->spot)>::f(ctx,value);
} EI(keyStr=="point")
{
Light*obj=(Light*)f->data;
obj->point=val_to_c<decltype(obj->point)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Light_getShadowmapResolution(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getShadowmapResolution" EAOE));
Light*f;
f=(Light*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShadowmapResolution());
;
}
CATE(TE,UFOF("Light::getShadowmapResolution.")));
RET CN;
}

SV Light_updateMatrices(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::updateMatrices" EAOE));
Light*f;
f=(Light*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxRenderer *))
{
( f->updateMatrices(val_to_c<std::remove_reference<GfxRenderer *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Light::updateMatrices.")));
RET CN;
}

SV Light_getShadowmap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getShadowmap" EAOE));
Light*f;
f=(Light*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShadowmap());
;
}
CATE(TE,UFOF("Light::getShadowmap.")));
RET CN;
}

SV Light_getPointLightFramebuffer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getPointLightFramebuffer" EAOE));
Light*f;
f=(Light*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxFace))
{
RET CV( f->getPointLightFramebuffer(val_to_c<std::remove_reference<GfxFace>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Light::getPointLightFramebuffer.")));
RET CN;
}

SV Light_getViewMatrix(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getViewMatrix" EAOE));
Light*f;
f=(Light*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getViewMatrix());
;
}
CATE(TE,UFOF("Light::getViewMatrix.")));
RET CN;
}

SV Light_getProjectionMatrix(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getProjectionMatrix" EAOE));
Light*f;
f=(Light*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getProjectionMatrix());
;
}
CATE(TE,UFOF("Light::getProjectionMatrix.")));
RET CN;
}

SV Light_addShadowmap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::addShadowmap" EAOE));
Light*f;
f=(Light*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],GfxShadowmapPrecision))
{
( f->addShadowmap(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxShadowmapPrecision>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("Light::addShadowmap.")));
RET CN;
}

SV Light_getShadowmapFramebuffer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getShadowmapFramebuffer" EAOE));
Light*f;
f=(Light*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShadowmapFramebuffer());
;
}
CATE(TE,UFOF("Light::getShadowmapFramebuffer.")));
RET CN;
}

SV Light_getShadowmapPrecision(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getShadowmapPrecision" EAOE));
Light*f;
f=(Light*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShadowmapPrecision());
;
}
CATE(TE,UFOF("Light::getShadowmapPrecision.")));
RET CN;
}

SV Light_getPointLightFramebuffers(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::getPointLightFramebuffers" EAOE));
Light*f;
f=(Light*)((NO)a[0])->data;

CATE(TE,UFOF("Light::getPointLightFramebuffers.")));
RET CN;
}

SV Light_removeShadowmap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Light::removeShadowmap" EAOE));
Light*f;
f=(Light*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->removeShadowmap());
RET CN;
}
CATE(TE,UFOF("Light::removeShadowmap.")));
RET CN;
}

void TextureSampler_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,TextureSampler))
CATE(TE,"TextureSampler::__del__ expects TextureSampler as first argument."));

DELETE((TextureSampler*)f->data);
}SV TextureSampler_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"TextureSampler's constructor" EAOE));
if(!TS(a[0],TextureSampler))
CATE(TE,"TextureSampler's constructor expects TextureSampler as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(TextureSampler_funcs,NEW(TextureSampler),EXT->TextureSampler_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],GfxTexture *))
RET STG::createNativeObject(TextureSampler_funcs,NEW(TextureSampler,val_to_c<GfxTexture *>::f(ctx,a[1])),EXT->TextureSampler_typeID);
if(a.getCount()==7)
if(true&&TS(a[1],float)&&TS(a[2],GfxFilter)&&TS(a[3],GfxFilter)&&TS(a[4],GfxMipmapMode)&&TS(a[5],GfxWrapMode)&&TS(a[6],bool))
RET STG::createNativeObject(TextureSampler_funcs,NEW(TextureSampler,val_to_c<float>::f(ctx,a[1]),val_to_c<GfxFilter>::f(ctx,a[2]),val_to_c<GfxFilter>::f(ctx,a[3]),val_to_c<GfxMipmapMode>::f(ctx,a[4]),val_to_c<GfxWrapMode>::f(ctx,a[5]),val_to_c<bool>::f(ctx,a[6])),EXT->TextureSampler_typeID);
CATE(TE,UFOF("TextureSampler's constructor.")));
RET CN;
}

SV TextureSampler_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("TextureSampler");
EI(keyStr=="__new__")
RET CNF(TextureSampler_new);
EI(keyStr=="__call__")
RET CNF(TextureSampler_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(TextureSampler_new);
 EI(keyStr == "createShadowmap")
RET CNF(TextureSampler_createShadowmap);
 EI(keyStr=="maxAnisotropy")
{
TextureSampler*obj=(TextureSampler*)f->data;
RET CV(obj->maxAnisotropy);
} EI(keyStr=="minFilter")
{
TextureSampler*obj=(TextureSampler*)f->data;
RET CV(obj->minFilter);
} EI(keyStr=="magFilter")
{
TextureSampler*obj=(TextureSampler*)f->data;
RET CV(obj->magFilter);
} EI(keyStr=="mipmapMode")
{
TextureSampler*obj=(TextureSampler*)f->data;
RET CV(obj->mipmapMode);
} EI(keyStr=="wrapMode")
{
TextureSampler*obj=(TextureSampler*)f->data;
RET CV(obj->wrapMode);
} EI(keyStr=="shadowmap")
{
TextureSampler*obj=(TextureSampler*)f->data;
RET CV(obj->shadowmap);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void TextureSampler_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="maxAnisotropy")
{
TextureSampler*obj=(TextureSampler*)f->data;
obj->maxAnisotropy=val_to_c<decltype(obj->maxAnisotropy)>::f(ctx,value);
} EI(keyStr=="minFilter")
{
TextureSampler*obj=(TextureSampler*)f->data;
obj->minFilter=val_to_c<decltype(obj->minFilter)>::f(ctx,value);
} EI(keyStr=="magFilter")
{
TextureSampler*obj=(TextureSampler*)f->data;
obj->magFilter=val_to_c<decltype(obj->magFilter)>::f(ctx,value);
} EI(keyStr=="mipmapMode")
{
TextureSampler*obj=(TextureSampler*)f->data;
obj->mipmapMode=val_to_c<decltype(obj->mipmapMode)>::f(ctx,value);
} EI(keyStr=="wrapMode")
{
TextureSampler*obj=(TextureSampler*)f->data;
obj->wrapMode=val_to_c<decltype(obj->wrapMode)>::f(ctx,value);
} EI(keyStr=="shadowmap")
{
TextureSampler*obj=(TextureSampler*)f->data;
obj->shadowmap=val_to_c<decltype(obj->shadowmap)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV TextureSampler_createShadowmap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"TextureSampler::createShadowmap" EAOE));
TextureSampler*f;
f=(TextureSampler*)((NO)a[0])->data;

CATE(TE,UFOF("TextureSampler::createShadowmap.")));
RET CN;
}

void Scene_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Scene))
CATE(TE,"Scene::__del__ expects Scene as first argument."));

Scene*obj=(Scene*)f->data;
if(obj!=nullptr){obj->release();}
}SV Scene_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Scene's constructor" EAOE));
if(!TS(a[0],Scene))
CATE(TE,"Scene's constructor expects Scene as first argument."));
CATE(TE,UFOF("Scene's constructor.")));
}

SV Scene_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Scene");
EI(keyStr=="__new__")
RET CNF(Scene_new);
EI(keyStr=="__call__")
RET CNF(Scene_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Scene_new);
 EI(keyStr == "removeContent")
RET CNF(Scene_removeContent);
 EI(keyStr == "handleInput")
RET CNF(Scene_handleInput);
 EI(keyStr == "update")
RET CNF(Scene_update);
 EI(keyStr == "fixedUpdate")
RET CNF(Scene_fixedUpdate);
 EI(keyStr == "render")
RET CNF(Scene_render);
 EI(keyStr == "getPhysicsWorld")
RET CNF(Scene_getPhysicsWorld);
 EI(keyStr == "getRenderer")
RET CNF(Scene_getRenderer);
 EI(keyStr == "getAudioWorld")
RET CNF(Scene_getAudioWorld);
 EI(keyStr == "save")
RET CNF(Scene_save);
 EI(keyStr == "createEntity")
RET CNF(Scene_createEntity);
 EI(keyStr == "removeEntity")
RET CNF(Scene_removeEntity);
 EI(keyStr == "getEntities")
RET CNF(Scene_getEntities);
 EI(keyStr == "addScript")
RET CNF(Scene_addScript);
 EI(keyStr == "removeScript")
RET CNF(Scene_removeScript);
 EI(keyStr == "getScripts")
RET CNF(Scene_getScripts);
 EI(keyStr == "findScriptInstanceByName")
RET CNF(Scene_findScriptInstanceByName);
 EI(keyStr == "load")
RET CNF(Scene_load);
 EI(keyStr == "copy")
RET CNF(Scene_copy);
 EI(keyStr == "getType")
RET CNF(Scene_getType);
 EI(keyStr == "release")
RET CNF(Scene_release);
 EI(keyStr == "getRefCount")
RET CNF(Scene_getRefCount);
 EI(keyStr == "getFilename")
RET CNF(Scene_getFilename);
 EI(keyStr == "setFilename")
RET CNF(Scene_setFilename);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Scene_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Scene_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::load" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("Scene::load.")));
RET CN;
}

SV Scene_render(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::render" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->render());
RET CN;
}
CATE(TE,UFOF("Scene::render.")));
RET CN;
}

SV Scene_findScriptInstanceByName(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::findScriptInstanceByName" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

CATE(TE,UFOF("Scene::findScriptInstanceByName.")));
RET CN;
}

SV Scene_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::setFilename" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
( f->setFilename(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Scene::setFilename.")));
RET CN;
}

SV Scene_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::getRefCount" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("Scene::getRefCount.")));
RET CN;
}

SV Scene_getScripts(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::getScripts" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

CATE(TE,UFOF("Scene::getScripts.")));
RET CN;
}

SV Scene_createEntity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::createEntity" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
RET CV( f->createEntity(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Scene::createEntity.")));
RET CN;
}

SV Scene_getRenderer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::getRenderer" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRenderer());
;
}
CATE(TE,UFOF("Scene::getRenderer.")));
RET CN;
}

SV Scene_handleInput(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::handleInput" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->handleInput());
RET CN;
}
CATE(TE,UFOF("Scene::handleInput.")));
RET CN;
}

SV Scene_removeEntity(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::removeEntity" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->removeEntity(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Scene::removeEntity.")));
RET CN;
}

SV Scene_addScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::addScript" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

CATE(TE,UFOF("Scene::addScript.")));
RET CN;
}

SV Scene_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::save" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("Scene::save.")));
RET CN;
}

SV Scene_getEntities(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::getEntities" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getEntities());
;
}
CATE(TE,UFOF("Scene::getEntities.")));
RET CN;
}

SV Scene_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::getFilename" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("Scene::getFilename.")));
RET CN;
}

SV Scene_getAudioWorld(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::getAudioWorld" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAudioWorld());
;
}
CATE(TE,UFOF("Scene::getAudioWorld.")));
RET CN;
}

SV Scene_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::getType" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("Scene::getType.")));
RET CN;
}

SV Scene_update(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::update" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->update());
RET CN;
}
CATE(TE,UFOF("Scene::update.")));
RET CN;
}

SV Scene_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::removeContent" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("Scene::removeContent.")));
RET CN;
}

SV Scene_fixedUpdate(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::fixedUpdate" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->fixedUpdate(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Scene::fixedUpdate.")));
RET CN;
}

SV Scene_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::copy" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("Scene::copy.")));
RET CN;
}

SV Scene_getPhysicsWorld(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::getPhysicsWorld" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getPhysicsWorld());
;
}
CATE(TE,UFOF("Scene::getPhysicsWorld.")));
RET CN;
}

SV Scene_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::release" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("Scene::release.")));
RET CN;
}

SV Scene_removeScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Scene::removeScript" EAOE));
Scene*f;
f=(Scene*)((NO)a[0])->data;

CATE(TE,UFOF("Scene::removeScript.")));
RET CN;
}

void Int3_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T3<int32_t>))
CATE(TE,"Int3::__del__ expects Int3 as first argument."));

DELETE((T3<int32_t>*)f->data);
}SV Int3_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3's constructor" EAOE));
if(!TS(a[0],T3<int32_t>))
CATE(TE,"Int3's constructor expects Int3 as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(Int3_funcs,NEW(T3<int32_t>),EXT->Int3_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],int32_t))
RET STG::createNativeObject(Int3_funcs,NEW(T3<int32_t>,val_to_c<int32_t>::f(ctx,a[1])),EXT->Int3_typeID);
if(a.getCount()==4)
if(true&&TS(a[1],int32_t)&&TS(a[2],int32_t)&&TS(a[3],int32_t))
RET STG::createNativeObject(Int3_funcs,NEW(T3<int32_t>,val_to_c<int32_t>::f(ctx,a[1]),val_to_c<int32_t>::f(ctx,a[2]),val_to_c<int32_t>::f(ctx,a[3])),EXT->Int3_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T3<float> &))
RET STG::createNativeObject(Int3_funcs,NEW(T3<int32_t>,val_to_c<const T3<float> &>::f(ctx,a[1])),EXT->Int3_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T3<int32_t> &))
RET STG::createNativeObject(Int3_funcs,NEW(T3<int32_t>,val_to_c<const T3<int32_t> &>::f(ctx,a[1])),EXT->Int3_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T3<uint32_t> &))
RET STG::createNativeObject(Int3_funcs,NEW(T3<int32_t>,val_to_c<const T3<uint32_t> &>::f(ctx,a[1])),EXT->Int3_typeID);
CATE(TE,UFOF("Int3's constructor.")));
RET CN;
}

SV Int3_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Int3");
EI(keyStr=="__new__")
RET CNF(Int3_new);
EI(keyStr=="__call__")
RET CNF(Int3_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Int3_new);
 EI(keyStr == "__add__")
RET CNF(Int3___add__);
 EI(keyStr == "__sub__")
RET CNF(Int3___sub__);
 EI(keyStr == "__mul__")
RET CNF(Int3___mul__);
 EI(keyStr == "__div__")
RET CNF(Int3___div__);
 EI(keyStr == "__eq__")
RET CNF(Int3___eq__);
 EI(keyStr == "__neq__")
RET CNF(Int3___neq__);
 EI(keyStr == "__less__")
RET CNF(Int3___less__);
 EI(keyStr == "__grtr__")
RET CNF(Int3___grtr__);
 EI(keyStr == "__leq__")
RET CNF(Int3___leq__);
 EI(keyStr == "__geq__")
RET CNF(Int3___geq__);
 EI(keyStr == "sum")
RET CNF(Int3_sum);
 EI(keyStr == "length")
RET CNF(Int3_length);
 EI(keyStr == "lengthSquared")
RET CNF(Int3_lengthSquared);
 EI(keyStr == "dot")
RET CNF(Int3_dot);
 EI(keyStr == "distance")
RET CNF(Int3_distance);
 EI(keyStr == "distanceSquared")
RET CNF(Int3_distanceSquared);
 EI(keyStr == "normalize")
RET CNF(Int3_normalize);
 EI(keyStr == "cross")
RET CNF(Int3_cross);
 EI(keyStr == "getXY")
RET CNF(Int3_getXY);
 EI(keyStr == "setXY")
RET CNF(Int3_setXY);
 EI(keyStr == "getXZ")
RET CNF(Int3_getXZ);
 EI(keyStr == "setXZ")
RET CNF(Int3_setXZ);
 EI(keyStr == "getYX")
RET CNF(Int3_getYX);
 EI(keyStr == "setYX")
RET CNF(Int3_setYX);
 EI(keyStr == "getYZ")
RET CNF(Int3_getYZ);
 EI(keyStr == "setYZ")
RET CNF(Int3_setYZ);
 EI(keyStr == "getZX")
RET CNF(Int3_getZX);
 EI(keyStr == "setZX")
RET CNF(Int3_setZX);
 EI(keyStr == "getZY")
RET CNF(Int3_getZY);
 EI(keyStr == "setZY")
RET CNF(Int3_setZY);
 EI(keyStr == "getXYZ")
RET CNF(Int3_getXYZ);
 EI(keyStr == "setXYZ")
RET CNF(Int3_setXYZ);
 EI(keyStr == "getXZY")
RET CNF(Int3_getXZY);
 EI(keyStr == "setXZY")
RET CNF(Int3_setXZY);
 EI(keyStr == "getYXZ")
RET CNF(Int3_getYXZ);
 EI(keyStr == "setYXZ")
RET CNF(Int3_setYXZ);
 EI(keyStr == "getYZX")
RET CNF(Int3_getYZX);
 EI(keyStr == "setYZX")
RET CNF(Int3_setYZX);
 EI(keyStr == "getZXY")
RET CNF(Int3_getZXY);
 EI(keyStr == "setZXY")
RET CNF(Int3_setZXY);
 EI(keyStr == "getZYX")
RET CNF(Int3_getZYX);
 EI(keyStr == "setZYX")
RET CNF(Int3_setZYX);
 EI(keyStr=="x")
{
T3<int32_t>*obj=(T3<int32_t>*)f->data;
RET CV(obj->x);
} EI(keyStr=="y")
{
T3<int32_t>*obj=(T3<int32_t>*)f->data;
RET CV(obj->y);
} EI(keyStr=="z")
{
T3<int32_t>*obj=(T3<int32_t>*)f->data;
RET CV(obj->z);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Int3_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="x")
{
T3<int32_t>*obj=(T3<int32_t>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr=="y")
{
T3<int32_t>*obj=(T3<int32_t>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} EI(keyStr=="z")
{
T3<int32_t>*obj=(T3<int32_t>*)f->data;
obj->z=val_to_c<decltype(obj->z)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Int3_setYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setYZX" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setYZX(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setYZX.")));
RET CN;
}

SV Int3_getZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getZXY" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXY());
;
}
CATE(TE,UFOF("Int3::getZXY.")));
RET CN;
}

SV Int3_setYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setYZ" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setYZ(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setYZ.")));
RET CN;
}

SV Int3_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setYX" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setYX.")));
RET CN;
}

SV Int3_setZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setZYX" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setZYX(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setZYX.")));
RET CN;
}

SV Int3_getZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getZY" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZY());
;
}
CATE(TE,UFOF("Int3::getZY.")));
RET CN;
}

SV Int3_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::distanceSquared" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Int3::distanceSquared.")));
RET CN;
}

SV Int3_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::normalize" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("Int3::normalize.")));
RET CN;
}

SV Int3_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getYX" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("Int3::getYX.")));
RET CN;
}

SV Int3___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__leq__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("Int3::__leq__.")));
RET CN;
}

SV Int3_setXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setXZY" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setXZY(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setXZY.")));
RET CN;
}

SV Int3_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::sum" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("Int3::sum.")));
RET CN;
}

SV Int3_cross(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::cross" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
RET CV( f->cross(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Int3::cross.")));
RET CN;
}

SV Int3_getXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getXYZ" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZ());
;
}
CATE(TE,UFOF("Int3::getXYZ.")));
RET CN;
}

SV Int3___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__less__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("Int3::__less__.")));
RET CN;
}

SV Int3___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__neq__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("Int3::__neq__.")));
RET CN;
}

SV Int3_getYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getYZ" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZ());
;
}
CATE(TE,UFOF("Int3::getYZ.")));
RET CN;
}

SV Int3_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::lengthSquared" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("Int3::lengthSquared.")));
RET CN;
}

SV Int3_getZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getZYX" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYX());
;
}
CATE(TE,UFOF("Int3::getZYX.")));
RET CN;
}

SV Int3___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__div__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("Int3::__div__.")));
RET CN;
}

SV Int3_setZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setZY" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setZY(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setZY.")));
RET CN;
}

SV Int3_setZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setZX" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setZX(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setZX.")));
RET CN;
}

SV Int3_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setXY" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setXY.")));
RET CN;
}

SV Int3___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__add__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("Int3::__add__.")));
RET CN;
}

SV Int3_setXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setXZ" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setXZ(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setXZ.")));
RET CN;
}

SV Int3___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__eq__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Int3::__eq__.")));
RET CN;
}

SV Int3_setZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setZXY" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setZXY(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setZXY.")));
RET CN;
}

SV Int3_setYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setYXZ" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setYXZ(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setYXZ.")));
RET CN;
}

SV Int3_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getXY" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("Int3::getXY.")));
RET CN;
}

SV Int3_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::distance" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Int3::distance.")));
RET CN;
}

SV Int3_getXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getXZ" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZ());
;
}
CATE(TE,UFOF("Int3::getXZ.")));
RET CN;
}

SV Int3___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__grtr__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("Int3::__grtr__.")));
RET CN;
}

SV Int3_getXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getXZY" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZY());
;
}
CATE(TE,UFOF("Int3::getXZY.")));
RET CN;
}

SV Int3_setXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::setXYZ" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setXYZ(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int3::setXYZ.")));
RET CN;
}

SV Int3_getYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getYZX" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZX());
;
}
CATE(TE,UFOF("Int3::getYZX.")));
RET CN;
}

SV Int3_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::length" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("Int3::length.")));
RET CN;
}

SV Int3___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__mul__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Int3::__mul__.")));
RET CN;
}

SV Int3_getYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getYXZ" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZ());
;
}
CATE(TE,UFOF("Int3::getYXZ.")));
RET CN;
}

SV Int3_getZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::getZX" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZX());
;
}
CATE(TE,UFOF("Int3::getZX.")));
RET CN;
}

SV Int3___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__sub__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("Int3::__sub__.")));
RET CN;
}

SV Int3___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::__geq__" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("Int3::__geq__.")));
RET CN;
}

SV Int3_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int3::dot" EAOE));
T3<int32_t>*f;
f=(T3<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("Int3::dot.")));
RET CN;
}

void ResizableData_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,ResizableData))
CATE(TE,"ResizableData::__del__ expects ResizableData as first argument."));

DELETE((ResizableData*)f->data);
}SV ResizableData_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData's constructor" EAOE));
if(!TS(a[0],ResizableData))
CATE(TE,"ResizableData's constructor expects ResizableData as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(ResizableData_funcs,NEW(ResizableData),EXT->ResizableData_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],std::size_t))
RET STG::createNativeObject(ResizableData_funcs,NEW(ResizableData,val_to_c<std::size_t>::f(ctx,a[1])),EXT->ResizableData_typeID);
CATE(TE,UFOF("ResizableData's constructor.")));
RET CN;
}

SV ResizableData_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("ResizableData");
EI(keyStr=="__new__")
RET CNF(ResizableData_new);
EI(keyStr=="__call__")
RET CNF(ResizableData_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(ResizableData_new);
 EI(keyStr == "__eq__")
RET CNF(ResizableData___eq__);
 EI(keyStr == "__neq__")
RET CNF(ResizableData___neq__);
 EI(keyStr == "getData")
RET CNF(ResizableData_getData);
 EI(keyStr == "getSize")
RET CNF(ResizableData_getSize);
 EI(keyStr == "resize")
RET CNF(ResizableData_resize);
 EI(keyStr == "insert")
RET CNF(ResizableData_insert);
 EI(keyStr == "append")
RET CNF(ResizableData_append);
 EI(keyStr == "remove")
RET CNF(ResizableData_remove);
 EI(keyStr == "clear")
RET CNF(ResizableData_clear);
 EI(keyStr == "copy")
RET CNF(ResizableData_copy);
 EI(keyStr == "getUInt8")
RET CNF(ResizableData_getUInt8);
 EI(keyStr == "getInt8")
RET CNF(ResizableData_getInt8);
 EI(keyStr == "getUInt16")
RET CNF(ResizableData_getUInt16);
 EI(keyStr == "getInt16")
RET CNF(ResizableData_getInt16);
 EI(keyStr == "getUInt32")
RET CNF(ResizableData_getUInt32);
 EI(keyStr == "getInt32")
RET CNF(ResizableData_getInt32);
 EI(keyStr == "getUInt64")
RET CNF(ResizableData_getUInt64);
 EI(keyStr == "getInt64")
RET CNF(ResizableData_getInt64);
 EI(keyStr == "getFloat32")
RET CNF(ResizableData_getFloat32);
 EI(keyStr == "getFloat64")
RET CNF(ResizableData_getFloat64);
 EI(keyStr == "getUInt16LE")
RET CNF(ResizableData_getUInt16LE);
 EI(keyStr == "getInt16LE")
RET CNF(ResizableData_getInt16LE);
 EI(keyStr == "getUInt32LE")
RET CNF(ResizableData_getUInt32LE);
 EI(keyStr == "getInt32LE")
RET CNF(ResizableData_getInt32LE);
 EI(keyStr == "getUInt64LE")
RET CNF(ResizableData_getUInt64LE);
 EI(keyStr == "getInt64LE")
RET CNF(ResizableData_getInt64LE);
 EI(keyStr == "getUInt16BE")
RET CNF(ResizableData_getUInt16BE);
 EI(keyStr == "getInt16BE")
RET CNF(ResizableData_getInt16BE);
 EI(keyStr == "getUInt32BE")
RET CNF(ResizableData_getUInt32BE);
 EI(keyStr == "getInt32BE")
RET CNF(ResizableData_getInt32BE);
 EI(keyStr == "getUInt64BE")
RET CNF(ResizableData_getUInt64BE);
 EI(keyStr == "getInt64BE")
RET CNF(ResizableData_getInt64BE);
 EI(keyStr == "setUInt8")
RET CNF(ResizableData_setUInt8);
 EI(keyStr == "setInt8")
RET CNF(ResizableData_setInt8);
 EI(keyStr == "setUInt16")
RET CNF(ResizableData_setUInt16);
 EI(keyStr == "setInt16")
RET CNF(ResizableData_setInt16);
 EI(keyStr == "setUInt32")
RET CNF(ResizableData_setUInt32);
 EI(keyStr == "setInt32")
RET CNF(ResizableData_setInt32);
 EI(keyStr == "setUInt64")
RET CNF(ResizableData_setUInt64);
 EI(keyStr == "setInt64")
RET CNF(ResizableData_setInt64);
 EI(keyStr == "setFloat32")
RET CNF(ResizableData_setFloat32);
 EI(keyStr == "setFloat64")
RET CNF(ResizableData_setFloat64);
 EI(keyStr == "setUInt16LE")
RET CNF(ResizableData_setUInt16LE);
 EI(keyStr == "setInt16LE")
RET CNF(ResizableData_setInt16LE);
 EI(keyStr == "setUInt32LE")
RET CNF(ResizableData_setUInt32LE);
 EI(keyStr == "setInt32LE")
RET CNF(ResizableData_setInt32LE);
 EI(keyStr == "setUInt64LE")
RET CNF(ResizableData_setUInt64LE);
 EI(keyStr == "setInt64LE")
RET CNF(ResizableData_setInt64LE);
 EI(keyStr == "setUInt16BE")
RET CNF(ResizableData_setUInt16BE);
 EI(keyStr == "setInt16BE")
RET CNF(ResizableData_setInt16BE);
 EI(keyStr == "setUInt32BE")
RET CNF(ResizableData_setUInt32BE);
 EI(keyStr == "setInt32BE")
RET CNF(ResizableData_setInt32BE);
 EI(keyStr == "setUInt64BE")
RET CNF(ResizableData_setUInt64BE);
 EI(keyStr == "setInt64BE")
RET CNF(ResizableData_setInt64BE);
 EI(keyStr == "getChar")
RET CNF(ResizableData_getChar);
 EI(keyStr == "setChar")
RET CNF(ResizableData_setChar);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void ResizableData_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV ResizableData_getInt64BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt64BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt64BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt64BE.")));
RET CN;
}

SV ResizableData_setUInt8(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt8" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint8_t))
{
( f->setUInt8(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt8.")));
RET CN;
}

SV ResizableData_getUInt64BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt64BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt64BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt64BE.")));
RET CN;
}

SV ResizableData_getUInt16BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt16BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt16BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt16BE.")));
RET CN;
}

SV ResizableData_getUInt64(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt64" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt64(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt64.")));
RET CN;
}

SV ResizableData_getSize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getSize" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getSize());
;
}
CATE(TE,UFOF("ResizableData::getSize.")));
RET CN;
}

SV ResizableData_setUInt16BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt16BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint16_t))
{
( f->setUInt16BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt16BE.")));
RET CN;
}

SV ResizableData_setFloat32(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setFloat32" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],float))
{
( f->setFloat32(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setFloat32.")));
RET CN;
}

SV ResizableData_getUInt8(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt8" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt8(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt8.")));
RET CN;
}

SV ResizableData_setInt16(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt16" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int16_t))
{
( f->setInt16(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int16_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt16.")));
RET CN;
}

SV ResizableData_setInt64(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt64" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int64_t))
{
( f->setInt64(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int64_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt64.")));
RET CN;
}

SV ResizableData_getInt16LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt16LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt16LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt16LE.")));
RET CN;
}

SV ResizableData_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::append" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const ResizableData &))
{
( f->append(val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("ResizableData::append.")));
RET CN;
}

SV ResizableData___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::__neq__" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const ResizableData &))
{
auto v=val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("ResizableData::__neq__.")));
RET CN;
}

SV ResizableData_getInt64(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt64" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt64(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt64.")));
RET CN;
}

SV ResizableData_getFloat64(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getFloat64" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getFloat64(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getFloat64.")));
RET CN;
}

SV ResizableData_setInt64BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt64BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int64_t))
{
( f->setInt64BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int64_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt64BE.")));
RET CN;
}

SV ResizableData_setInt32(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt32" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int32_t))
{
( f->setInt32(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt32.")));
RET CN;
}

SV ResizableData_getInt64LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt64LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt64LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt64LE.")));
RET CN;
}

SV ResizableData_setInt32LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt32LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int32_t))
{
( f->setInt32LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt32LE.")));
RET CN;
}

SV ResizableData_setUInt32(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt32" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint32_t))
{
( f->setUInt32(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt32.")));
RET CN;
}

SV ResizableData_setChar(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setChar" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],char))
{
( f->setChar(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<char>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setChar.")));
RET CN;
}

SV ResizableData_setUInt64LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt64LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint64_t))
{
( f->setUInt64LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint64_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt64LE.")));
RET CN;
}

SV ResizableData_setUInt64BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt64BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint64_t))
{
( f->setUInt64BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint64_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt64BE.")));
RET CN;
}

SV ResizableData_setUInt16LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt16LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint16_t))
{
( f->setUInt16LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt16LE.")));
RET CN;
}

SV ResizableData_setUInt32LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt32LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint32_t))
{
( f->setUInt32LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt32LE.")));
RET CN;
}

SV ResizableData_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getData" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

CATE(TE,UFOF("ResizableData::getData.")));
RET CN;
}

SV ResizableData_setUInt16(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt16" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint16_t))
{
( f->setUInt16(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt16.")));
RET CN;
}

SV ResizableData_getUInt32(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt32" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt32(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt32.")));
RET CN;
}

SV ResizableData_setInt16LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt16LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int16_t))
{
( f->setInt16LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int16_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt16LE.")));
RET CN;
}

SV ResizableData_getUInt16(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt16" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt16(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt16.")));
RET CN;
}

SV ResizableData_getUInt16LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt16LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt16LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt16LE.")));
RET CN;
}

SV ResizableData_setInt32BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt32BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int32_t))
{
( f->setInt32BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt32BE.")));
RET CN;
}

SV ResizableData_getUInt64LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt64LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt64LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt64LE.")));
RET CN;
}

SV ResizableData_setFloat64(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setFloat64" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],double))
{
( f->setFloat64(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<double>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setFloat64.")));
RET CN;
}

SV ResizableData_getUInt32BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt32BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt32BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt32BE.")));
RET CN;
}

SV ResizableData_setInt16BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt16BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int16_t))
{
( f->setInt16BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int16_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt16BE.")));
RET CN;
}

SV ResizableData_getInt32(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt32" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt32(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt32.")));
RET CN;
}

SV ResizableData_getInt32BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt32BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt32BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt32BE.")));
RET CN;
}

SV ResizableData_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::copy" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("ResizableData::copy.")));
RET CN;
}

SV ResizableData___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::__eq__" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const ResizableData &))
{
auto v=val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("ResizableData::__eq__.")));
RET CN;
}

SV ResizableData_resize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::resize" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],std::size_t))
{
( f->resize(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("ResizableData::resize.")));
RET CN;
}

SV ResizableData_getFloat32(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getFloat32" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getFloat32(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getFloat32.")));
RET CN;
}

SV ResizableData_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::insert" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const ResizableData &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::insert.")));
RET CN;
}

SV ResizableData_getInt16(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt16" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt16(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt16.")));
RET CN;
}

SV ResizableData_getInt16BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt16BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt16BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt16BE.")));
RET CN;
}

SV ResizableData_setUInt32BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt32BE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint32_t))
{
( f->setUInt32BE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt32BE.")));
RET CN;
}

SV ResizableData_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::clear" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("ResizableData::clear.")));
RET CN;
}

SV ResizableData_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::remove" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::remove.")));
RET CN;
}

SV ResizableData_setUInt64(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setUInt64" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],uint64_t))
{
( f->setUInt64(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<uint64_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setUInt64.")));
RET CN;
}

SV ResizableData_setInt64LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt64LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int64_t))
{
( f->setInt64LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int64_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt64LE.")));
RET CN;
}

SV ResizableData_setInt8(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::setInt8" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],int8_t))
{
( f->setInt8(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int8_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("ResizableData::setInt8.")));
RET CN;
}

SV ResizableData_getUInt32LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getUInt32LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getUInt32LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getUInt32LE.")));
RET CN;
}

SV ResizableData_getInt8(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt8" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt8(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt8.")));
RET CN;
}

SV ResizableData_getInt32LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getInt32LE" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getInt32LE(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getInt32LE.")));
RET CN;
}

SV ResizableData_getChar(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ResizableData::getChar" EAOE));
ResizableData*f;
f=(ResizableData*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getChar(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("ResizableData::getChar.")));
RET CN;
}

void Int4_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T4<int32_t>))
CATE(TE,"Int4::__del__ expects Int4 as first argument."));

DELETE((T4<int32_t>*)f->data);
}SV Int4_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4's constructor" EAOE));
if(!TS(a[0],T4<int32_t>))
CATE(TE,"Int4's constructor expects Int4 as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(Int4_funcs,NEW(T4<int32_t>),EXT->Int4_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],int32_t))
RET STG::createNativeObject(Int4_funcs,NEW(T4<int32_t>,val_to_c<int32_t>::f(ctx,a[1])),EXT->Int4_typeID);
if(a.getCount()==5)
if(true&&TS(a[1],int32_t)&&TS(a[2],int32_t)&&TS(a[3],int32_t)&&TS(a[4],int32_t))
RET STG::createNativeObject(Int4_funcs,NEW(T4<int32_t>,val_to_c<int32_t>::f(ctx,a[1]),val_to_c<int32_t>::f(ctx,a[2]),val_to_c<int32_t>::f(ctx,a[3]),val_to_c<int32_t>::f(ctx,a[4])),EXT->Int4_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T4<float> &))
RET STG::createNativeObject(Int4_funcs,NEW(T4<int32_t>,val_to_c<const T4<float> &>::f(ctx,a[1])),EXT->Int4_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T4<int32_t> &))
RET STG::createNativeObject(Int4_funcs,NEW(T4<int32_t>,val_to_c<const T4<int32_t> &>::f(ctx,a[1])),EXT->Int4_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T4<uint32_t> &))
RET STG::createNativeObject(Int4_funcs,NEW(T4<int32_t>,val_to_c<const T4<uint32_t> &>::f(ctx,a[1])),EXT->Int4_typeID);
CATE(TE,UFOF("Int4's constructor.")));
RET CN;
}

SV Int4_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Int4");
EI(keyStr=="__new__")
RET CNF(Int4_new);
EI(keyStr=="__call__")
RET CNF(Int4_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Int4_new);
 EI(keyStr == "__add__")
RET CNF(Int4___add__);
 EI(keyStr == "__sub__")
RET CNF(Int4___sub__);
 EI(keyStr == "__mul__")
RET CNF(Int4___mul__);
 EI(keyStr == "__div__")
RET CNF(Int4___div__);
 EI(keyStr == "__eq__")
RET CNF(Int4___eq__);
 EI(keyStr == "__neq__")
RET CNF(Int4___neq__);
 EI(keyStr == "__less__")
RET CNF(Int4___less__);
 EI(keyStr == "__grtr__")
RET CNF(Int4___grtr__);
 EI(keyStr == "__leq__")
RET CNF(Int4___leq__);
 EI(keyStr == "__geq__")
RET CNF(Int4___geq__);
 EI(keyStr == "sum")
RET CNF(Int4_sum);
 EI(keyStr == "length")
RET CNF(Int4_length);
 EI(keyStr == "lengthSquared")
RET CNF(Int4_lengthSquared);
 EI(keyStr == "dot")
RET CNF(Int4_dot);
 EI(keyStr == "distance")
RET CNF(Int4_distance);
 EI(keyStr == "distanceSquared")
RET CNF(Int4_distanceSquared);
 EI(keyStr == "normalize")
RET CNF(Int4_normalize);
 EI(keyStr == "getXY")
RET CNF(Int4_getXY);
 EI(keyStr == "setXY")
RET CNF(Int4_setXY);
 EI(keyStr == "getXZ")
RET CNF(Int4_getXZ);
 EI(keyStr == "setXZ")
RET CNF(Int4_setXZ);
 EI(keyStr == "getXW")
RET CNF(Int4_getXW);
 EI(keyStr == "setXW")
RET CNF(Int4_setXW);
 EI(keyStr == "getYX")
RET CNF(Int4_getYX);
 EI(keyStr == "setYX")
RET CNF(Int4_setYX);
 EI(keyStr == "getYZ")
RET CNF(Int4_getYZ);
 EI(keyStr == "setYZ")
RET CNF(Int4_setYZ);
 EI(keyStr == "getYW")
RET CNF(Int4_getYW);
 EI(keyStr == "setYW")
RET CNF(Int4_setYW);
 EI(keyStr == "getZX")
RET CNF(Int4_getZX);
 EI(keyStr == "setZX")
RET CNF(Int4_setZX);
 EI(keyStr == "getZY")
RET CNF(Int4_getZY);
 EI(keyStr == "setZY")
RET CNF(Int4_setZY);
 EI(keyStr == "getZW")
RET CNF(Int4_getZW);
 EI(keyStr == "setZW")
RET CNF(Int4_setZW);
 EI(keyStr == "getWX")
RET CNF(Int4_getWX);
 EI(keyStr == "setWX")
RET CNF(Int4_setWX);
 EI(keyStr == "getWY")
RET CNF(Int4_getWY);
 EI(keyStr == "setWY")
RET CNF(Int4_setWY);
 EI(keyStr == "getWZ")
RET CNF(Int4_getWZ);
 EI(keyStr == "setWZ")
RET CNF(Int4_setWZ);
 EI(keyStr == "getXYZ")
RET CNF(Int4_getXYZ);
 EI(keyStr == "setXYZ")
RET CNF(Int4_setXYZ);
 EI(keyStr == "getXYW")
RET CNF(Int4_getXYW);
 EI(keyStr == "setXYW")
RET CNF(Int4_setXYW);
 EI(keyStr == "getXZY")
RET CNF(Int4_getXZY);
 EI(keyStr == "setXZY")
RET CNF(Int4_setXZY);
 EI(keyStr == "getXZW")
RET CNF(Int4_getXZW);
 EI(keyStr == "setXZW")
RET CNF(Int4_setXZW);
 EI(keyStr == "getXWZ")
RET CNF(Int4_getXWZ);
 EI(keyStr == "setXWZ")
RET CNF(Int4_setXWZ);
 EI(keyStr == "getXWY")
RET CNF(Int4_getXWY);
 EI(keyStr == "setXWY")
RET CNF(Int4_setXWY);
 EI(keyStr == "getYXZ")
RET CNF(Int4_getYXZ);
 EI(keyStr == "setYXZ")
RET CNF(Int4_setYXZ);
 EI(keyStr == "getYXW")
RET CNF(Int4_getYXW);
 EI(keyStr == "setYXW")
RET CNF(Int4_setYXW);
 EI(keyStr == "getYZX")
RET CNF(Int4_getYZX);
 EI(keyStr == "setYZX")
RET CNF(Int4_setYZX);
 EI(keyStr == "getYZW")
RET CNF(Int4_getYZW);
 EI(keyStr == "setYZW")
RET CNF(Int4_setYZW);
 EI(keyStr == "getYWZ")
RET CNF(Int4_getYWZ);
 EI(keyStr == "setYWZ")
RET CNF(Int4_setYWZ);
 EI(keyStr == "getYWX")
RET CNF(Int4_getYWX);
 EI(keyStr == "setYWX")
RET CNF(Int4_setYWX);
 EI(keyStr == "getZXY")
RET CNF(Int4_getZXY);
 EI(keyStr == "setZXY")
RET CNF(Int4_setZXY);
 EI(keyStr == "getZXW")
RET CNF(Int4_getZXW);
 EI(keyStr == "setZXW")
RET CNF(Int4_setZXW);
 EI(keyStr == "getZYX")
RET CNF(Int4_getZYX);
 EI(keyStr == "setZYX")
RET CNF(Int4_setZYX);
 EI(keyStr == "getZYW")
RET CNF(Int4_getZYW);
 EI(keyStr == "setZYW")
RET CNF(Int4_setZYW);
 EI(keyStr == "getZWY")
RET CNF(Int4_getZWY);
 EI(keyStr == "setZWY")
RET CNF(Int4_setZWY);
 EI(keyStr == "getZWX")
RET CNF(Int4_getZWX);
 EI(keyStr == "setZWX")
RET CNF(Int4_setZWX);
 EI(keyStr == "getWXY")
RET CNF(Int4_getWXY);
 EI(keyStr == "setWXY")
RET CNF(Int4_setWXY);
 EI(keyStr == "getWXZ")
RET CNF(Int4_getWXZ);
 EI(keyStr == "setWXZ")
RET CNF(Int4_setWXZ);
 EI(keyStr == "getWYX")
RET CNF(Int4_getWYX);
 EI(keyStr == "setWYX")
RET CNF(Int4_setWYX);
 EI(keyStr == "getWYZ")
RET CNF(Int4_getWYZ);
 EI(keyStr == "setWYZ")
RET CNF(Int4_setWYZ);
 EI(keyStr == "getWZY")
RET CNF(Int4_getWZY);
 EI(keyStr == "setWZY")
RET CNF(Int4_setWZY);
 EI(keyStr == "getWZX")
RET CNF(Int4_getWZX);
 EI(keyStr == "setWZX")
RET CNF(Int4_setWZX);
 EI(keyStr == "getXYZW")
RET CNF(Int4_getXYZW);
 EI(keyStr == "setXYZW")
RET CNF(Int4_setXYZW);
 EI(keyStr == "getXYWZ")
RET CNF(Int4_getXYWZ);
 EI(keyStr == "setXYWZ")
RET CNF(Int4_setXYWZ);
 EI(keyStr == "getXZYW")
RET CNF(Int4_getXZYW);
 EI(keyStr == "setXZYW")
RET CNF(Int4_setXZYW);
 EI(keyStr == "getXZWY")
RET CNF(Int4_getXZWY);
 EI(keyStr == "setXZWY")
RET CNF(Int4_setXZWY);
 EI(keyStr == "getXWZY")
RET CNF(Int4_getXWZY);
 EI(keyStr == "setXWZY")
RET CNF(Int4_setXWZY);
 EI(keyStr == "getXWYZ")
RET CNF(Int4_getXWYZ);
 EI(keyStr == "setXWYZ")
RET CNF(Int4_setXWYZ);
 EI(keyStr == "getYXZW")
RET CNF(Int4_getYXZW);
 EI(keyStr == "setYXZW")
RET CNF(Int4_setYXZW);
 EI(keyStr == "getYXWZ")
RET CNF(Int4_getYXWZ);
 EI(keyStr == "setYXWZ")
RET CNF(Int4_setYXWZ);
 EI(keyStr == "getYZXW")
RET CNF(Int4_getYZXW);
 EI(keyStr == "setYZXW")
RET CNF(Int4_setYZXW);
 EI(keyStr == "getYZWX")
RET CNF(Int4_getYZWX);
 EI(keyStr == "setYZWX")
RET CNF(Int4_setYZWX);
 EI(keyStr == "getYWZX")
RET CNF(Int4_getYWZX);
 EI(keyStr == "setYWZX")
RET CNF(Int4_setYWZX);
 EI(keyStr == "getYWXZ")
RET CNF(Int4_getYWXZ);
 EI(keyStr == "setYWXZ")
RET CNF(Int4_setYWXZ);
 EI(keyStr == "getZYXW")
RET CNF(Int4_getZYXW);
 EI(keyStr == "setZYXW")
RET CNF(Int4_setZYXW);
 EI(keyStr == "getZYWX")
RET CNF(Int4_getZYWX);
 EI(keyStr == "setZYWX")
RET CNF(Int4_setZYWX);
 EI(keyStr == "getZXYW")
RET CNF(Int4_getZXYW);
 EI(keyStr == "setZXYW")
RET CNF(Int4_setZXYW);
 EI(keyStr == "getZXWY")
RET CNF(Int4_getZXWY);
 EI(keyStr == "setZXWY")
RET CNF(Int4_setZXWY);
 EI(keyStr == "getZWXY")
RET CNF(Int4_getZWXY);
 EI(keyStr == "setZWXY")
RET CNF(Int4_setZWXY);
 EI(keyStr == "getZWYX")
RET CNF(Int4_getZWYX);
 EI(keyStr == "setZWYX")
RET CNF(Int4_setZWYX);
 EI(keyStr == "getWYZX")
RET CNF(Int4_getWYZX);
 EI(keyStr == "setWYZX")
RET CNF(Int4_setWYZX);
 EI(keyStr == "getWYXZ")
RET CNF(Int4_getWYXZ);
 EI(keyStr == "setWYXZ")
RET CNF(Int4_setWYXZ);
 EI(keyStr == "getWZYX")
RET CNF(Int4_getWZYX);
 EI(keyStr == "setWZYX")
RET CNF(Int4_setWZYX);
 EI(keyStr == "getWZXY")
RET CNF(Int4_getWZXY);
 EI(keyStr == "setWZXY")
RET CNF(Int4_setWZXY);
 EI(keyStr == "getWXZY")
RET CNF(Int4_getWXZY);
 EI(keyStr == "setWXZY")
RET CNF(Int4_setWXZY);
 EI(keyStr == "getWXYZ")
RET CNF(Int4_getWXYZ);
 EI(keyStr == "setWXYZ")
RET CNF(Int4_setWXYZ);
 EI(keyStr=="x")
{
T4<int32_t>*obj=(T4<int32_t>*)f->data;
RET CV(obj->x);
} EI(keyStr=="y")
{
T4<int32_t>*obj=(T4<int32_t>*)f->data;
RET CV(obj->y);
} EI(keyStr=="z")
{
T4<int32_t>*obj=(T4<int32_t>*)f->data;
RET CV(obj->z);
} EI(keyStr=="w")
{
T4<int32_t>*obj=(T4<int32_t>*)f->data;
RET CV(obj->w);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Int4_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="x")
{
T4<int32_t>*obj=(T4<int32_t>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr=="y")
{
T4<int32_t>*obj=(T4<int32_t>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} EI(keyStr=="z")
{
T4<int32_t>*obj=(T4<int32_t>*)f->data;
obj->z=val_to_c<decltype(obj->z)>::f(ctx,value);
} EI(keyStr=="w")
{
T4<int32_t>*obj=(T4<int32_t>*)f->data;
obj->w=val_to_c<decltype(obj->w)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Int4_setZXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZXYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setZXYW(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZXYW.")));
RET CN;
}

SV Int4_setWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setWYZ(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWYZ.")));
RET CN;
}

SV Int4_setWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setWYX(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWYX.")));
RET CN;
}

SV Int4_getZWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZWYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWYX());
;
}
CATE(TE,UFOF("Int4::getZWYX.")));
RET CN;
}

SV Int4_getZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZW());
;
}
CATE(TE,UFOF("Int4::getZW.")));
RET CN;
}

SV Int4_getZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZY());
;
}
CATE(TE,UFOF("Int4::getZY.")));
RET CN;
}

SV Int4_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::distanceSquared" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Int4::distanceSquared.")));
RET CN;
}

SV Int4_getYXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYXZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZW());
;
}
CATE(TE,UFOF("Int4::getYXZW.")));
RET CN;
}

SV Int4_setYZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYZWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setYZWX(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYZWX.")));
RET CN;
}

SV Int4_getYWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYWZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWZX());
;
}
CATE(TE,UFOF("Int4::getYWZX.")));
RET CN;
}

SV Int4_getWZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWZXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZXY());
;
}
CATE(TE,UFOF("Int4::getWZXY.")));
RET CN;
}

SV Int4_getZYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZYXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYXW());
;
}
CATE(TE,UFOF("Int4::getZYXW.")));
RET CN;
}

SV Int4_setXWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXWYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setXWYZ(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXWYZ.")));
RET CN;
}

SV Int4_setZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setZY(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZY.")));
RET CN;
}

SV Int4_setZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setZX(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZX.")));
RET CN;
}

SV Int4_getZXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZXWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXWY());
;
}
CATE(TE,UFOF("Int4::getZXWY.")));
RET CN;
}

SV Int4_getXWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXWZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWZY());
;
}
CATE(TE,UFOF("Int4::getXWZY.")));
RET CN;
}

SV Int4_setZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setZW(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZW.")));
RET CN;
}

SV Int4_setZYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZYWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setZYWX(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZYWX.")));
RET CN;
}

SV Int4_getYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZX());
;
}
CATE(TE,UFOF("Int4::getYZX.")));
RET CN;
}

SV Int4_getXYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXYWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYWZ());
;
}
CATE(TE,UFOF("Int4::getXYWZ.")));
RET CN;
}

SV Int4_setYXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYXZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setYXZW(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYXZW.")));
RET CN;
}

SV Int4_getWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZY());
;
}
CATE(TE,UFOF("Int4::getWZY.")));
RET CN;
}

SV Int4_getWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZX());
;
}
CATE(TE,UFOF("Int4::getWZX.")));
RET CN;
}

SV Int4_getWZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWZYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZYX());
;
}
CATE(TE,UFOF("Int4::getWZYX.")));
RET CN;
}

SV Int4_setXWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXWZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setXWZY(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXWZY.")));
RET CN;
}

SV Int4_getZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXY());
;
}
CATE(TE,UFOF("Int4::getZXY.")));
RET CN;
}

SV Int4_setWZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWZYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setWZYX(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWZYX.")));
RET CN;
}

SV Int4_setZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setZYW(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZYW.")));
RET CN;
}

SV Int4_setZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setZYX(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZYX.")));
RET CN;
}

SV Int4_setXZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXZYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setXZYW(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXZYW.")));
RET CN;
}

SV Int4_getZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXW());
;
}
CATE(TE,UFOF("Int4::getZXW.")));
RET CN;
}

SV Int4_setYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setYZW(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYZW.")));
RET CN;
}

SV Int4_getYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWZ());
;
}
CATE(TE,UFOF("Int4::getYWZ.")));
RET CN;
}

SV Int4___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__leq__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("Int4::__leq__.")));
RET CN;
}

SV Int4_getYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWX());
;
}
CATE(TE,UFOF("Int4::getYWX.")));
RET CN;
}

SV Int4_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::sum" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("Int4::sum.")));
RET CN;
}

SV Int4_setYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setYZX(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYZX.")));
RET CN;
}

SV Int4_getXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZ());
;
}
CATE(TE,UFOF("Int4::getXYZ.")));
RET CN;
}

SV Int4_getZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZX());
;
}
CATE(TE,UFOF("Int4::getZX.")));
RET CN;
}

SV Int4_getXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYW());
;
}
CATE(TE,UFOF("Int4::getXYW.")));
RET CN;
}

SV Int4_setYWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYWZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setYWZX(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYWZX.")));
RET CN;
}

SV Int4_setWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setWXY(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWXY.")));
RET CN;
}

SV Int4_setWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setWXZ(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWXZ.")));
RET CN;
}

SV Int4_setZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setZXW(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZXW.")));
RET CN;
}

SV Int4_getXWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXWYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWYZ());
;
}
CATE(TE,UFOF("Int4::getXWYZ.")));
RET CN;
}

SV Int4_setWYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWYXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setWYXZ(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWYXZ.")));
RET CN;
}

SV Int4_setZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setZXY(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZXY.")));
RET CN;
}

SV Int4_getXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWY());
;
}
CATE(TE,UFOF("Int4::getXWY.")));
RET CN;
}

SV Int4_getYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXW());
;
}
CATE(TE,UFOF("Int4::getYXW.")));
RET CN;
}

SV Int4_getYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZ());
;
}
CATE(TE,UFOF("Int4::getYXZ.")));
RET CN;
}

SV Int4_setXYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXYWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setXYWZ(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXYWZ.")));
RET CN;
}

SV Int4_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::length" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("Int4::length.")));
RET CN;
}

SV Int4_setWXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWXZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setWXZY(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWXZY.")));
RET CN;
}

SV Int4_getYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZW());
;
}
CATE(TE,UFOF("Int4::getYZW.")));
RET CN;
}

SV Int4_setXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setXWZ(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXWZ.")));
RET CN;
}

SV Int4_setXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setXWY(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXWY.")));
RET CN;
}

SV Int4_getWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYZ());
;
}
CATE(TE,UFOF("Int4::getWYZ.")));
RET CN;
}

SV Int4_getWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYX());
;
}
CATE(TE,UFOF("Int4::getWYX.")));
RET CN;
}

SV Int4_getZYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZYWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYWX());
;
}
CATE(TE,UFOF("Int4::getZYWX.")));
RET CN;
}

SV Int4_getXYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXYZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZW());
;
}
CATE(TE,UFOF("Int4::getXYZW.")));
RET CN;
}

SV Int4_setZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setZWY(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZWY.")));
RET CN;
}

SV Int4_setZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setZWX(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZWX.")));
RET CN;
}

SV Int4_setWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setWX(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWX.")));
RET CN;
}

SV Int4_setWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setWY(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWY.")));
RET CN;
}

SV Int4_setWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setWZ(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWZ.")));
RET CN;
}

SV Int4_getZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWY());
;
}
CATE(TE,UFOF("Int4::getZWY.")));
RET CN;
}

SV Int4_getZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWX());
;
}
CATE(TE,UFOF("Int4::getZWX.")));
RET CN;
}

SV Int4_setYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setYXZ(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYXZ.")));
RET CN;
}

SV Int4_setYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setYXW(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYXW.")));
RET CN;
}

SV Int4_getXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWZ());
;
}
CATE(TE,UFOF("Int4::getXWZ.")));
RET CN;
}

SV Int4_getXZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXZWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZWY());
;
}
CATE(TE,UFOF("Int4::getXZWY.")));
RET CN;
}

SV Int4___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__less__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("Int4::__less__.")));
RET CN;
}

SV Int4_getZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYW());
;
}
CATE(TE,UFOF("Int4::getZYW.")));
RET CN;
}

SV Int4_setWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setWZY(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWZY.")));
RET CN;
}

SV Int4_setWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setWZX(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWZX.")));
RET CN;
}

SV Int4_setZYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZYXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setZYXW(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZYXW.")));
RET CN;
}

SV Int4_getYZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYZWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZWX());
;
}
CATE(TE,UFOF("Int4::getYZWX.")));
RET CN;
}

SV Int4_getZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYX());
;
}
CATE(TE,UFOF("Int4::getZYX.")));
RET CN;
}

SV Int4_getXZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXZYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZYW());
;
}
CATE(TE,UFOF("Int4::getXZYW.")));
RET CN;
}

SV Int4_setYXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYXWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setYXWZ(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYXWZ.")));
RET CN;
}

SV Int4___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__eq__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Int4::__eq__.")));
RET CN;
}

SV Int4_getWYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWYXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYXZ());
;
}
CATE(TE,UFOF("Int4::getWYXZ.")));
RET CN;
}

SV Int4_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::distance" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Int4::distance.")));
RET CN;
}

SV Int4_getXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZW());
;
}
CATE(TE,UFOF("Int4::getXZW.")));
RET CN;
}

SV Int4_setYZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYZXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setYZXW(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYZXW.")));
RET CN;
}

SV Int4_getZWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZWXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWXY());
;
}
CATE(TE,UFOF("Int4::getZWXY.")));
RET CN;
}

SV Int4_getXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZY());
;
}
CATE(TE,UFOF("Int4::getXZY.")));
RET CN;
}

SV Int4_getYZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYZXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZXW());
;
}
CATE(TE,UFOF("Int4::getYZXW.")));
RET CN;
}

SV Int4_setZWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZWYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setZWYX(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZWYX.")));
RET CN;
}

SV Int4___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__sub__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("Int4::__sub__.")));
RET CN;
}

SV Int4_getYXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYXWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXWZ());
;
}
CATE(TE,UFOF("Int4::getYXWZ.")));
RET CN;
}

SV Int4_setXZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXZWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setXZWY(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXZWY.")));
RET CN;
}

SV Int4_setYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setYWZ(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYWZ.")));
RET CN;
}

SV Int4_setYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setYWX(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYWX.")));
RET CN;
}

SV Int4_setYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setYZ(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYZ.")));
RET CN;
}

SV Int4_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYX.")));
RET CN;
}

SV Int4_setYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setYW(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYW.")));
RET CN;
}

SV Int4_getWXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWXYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXYZ());
;
}
CATE(TE,UFOF("Int4::getWXYZ.")));
RET CN;
}

SV Int4___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__neq__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("Int4::__neq__.")));
RET CN;
}

SV Int4_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::normalize" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("Int4::normalize.")));
RET CN;
}

SV Int4_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("Int4::getYX.")));
RET CN;
}

SV Int4_setXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setXZW(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXZW.")));
RET CN;
}

SV Int4_setXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setXZY(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXZY.")));
RET CN;
}

SV Int4_setXYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXYZW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setXYZW(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXYZW.")));
RET CN;
}

SV Int4_getYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYW());
;
}
CATE(TE,UFOF("Int4::getYW.")));
RET CN;
}

SV Int4_setWXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWXYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setWXYZ(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWXYZ.")));
RET CN;
}

SV Int4_getYWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYWXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWXZ());
;
}
CATE(TE,UFOF("Int4::getYWXZ.")));
RET CN;
}

SV Int4___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__mul__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Int4::__mul__.")));
RET CN;
}

SV Int4_getYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZ());
;
}
CATE(TE,UFOF("Int4::getYZ.")));
RET CN;
}

SV Int4_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::lengthSquared" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("Int4::lengthSquared.")));
RET CN;
}

SV Int4_getWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXY());
;
}
CATE(TE,UFOF("Int4::getWXY.")));
RET CN;
}

SV Int4_getWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXZ());
;
}
CATE(TE,UFOF("Int4::getWXZ.")));
RET CN;
}

SV Int4_getWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWX());
;
}
CATE(TE,UFOF("Int4::getWX.")));
RET CN;
}

SV Int4_getWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWY());
;
}
CATE(TE,UFOF("Int4::getWY.")));
RET CN;
}

SV Int4_getWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZ());
;
}
CATE(TE,UFOF("Int4::getWZ.")));
RET CN;
}

SV Int4_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXY.")));
RET CN;
}

SV Int4_getZXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getZXYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXYW());
;
}
CATE(TE,UFOF("Int4::getZXYW.")));
RET CN;
}

SV Int4___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__add__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("Int4::__add__.")));
RET CN;
}

SV Int4_setXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setXZ(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXZ.")));
RET CN;
}

SV Int4_getWYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWYZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYZX());
;
}
CATE(TE,UFOF("Int4::getWYZX.")));
RET CN;
}

SV Int4_setXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setXW(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXW.")));
RET CN;
}

SV Int4_getWXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getWXZY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXZY());
;
}
CATE(TE,UFOF("Int4::getWXZY.")));
RET CN;
}

SV Int4_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("Int4::getXY.")));
RET CN;
}

SV Int4_setZXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZXWY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setZXWY(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZXWY.")));
RET CN;
}

SV Int4_setXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXYW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setXYW(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXYW.")));
RET CN;
}

SV Int4_getXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZ());
;
}
CATE(TE,UFOF("Int4::getXZ.")));
RET CN;
}

SV Int4_setWZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWZXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setWZXY(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWZXY.")));
RET CN;
}

SV Int4___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__grtr__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("Int4::__grtr__.")));
RET CN;
}

SV Int4_setZWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setZWXY" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setZWXY(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setZWXY.")));
RET CN;
}

SV Int4_getXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::getXW" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXW());
;
}
CATE(TE,UFOF("Int4::getXW.")));
RET CN;
}

SV Int4_setXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setXYZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<int32_t> &))
{
( f->setXYZ(val_to_c<std::remove_reference<const T3<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setXYZ.")));
RET CN;
}

SV Int4___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__div__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("Int4::__div__.")));
RET CN;
}

SV Int4_setWYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setWYZX" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setWYZX(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setWYZX.")));
RET CN;
}

SV Int4_setYWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::setYWXZ" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
( f->setYWXZ(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int4::setYWXZ.")));
RET CN;
}

SV Int4___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::__geq__" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("Int4::__geq__.")));
RET CN;
}

SV Int4_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int4::dot" EAOE));
T4<int32_t>*f;
f=(T4<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<int32_t> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T4<int32_t> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("Int4::dot.")));
RET CN;
}

void Float3_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T3<float>))
CATE(TE,"Float3::__del__ expects Float3 as first argument."));

DELETE((T3<float>*)f->data);
}SV Float3_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3's constructor" EAOE));
if(!TS(a[0],T3<float>))
CATE(TE,"Float3's constructor expects Float3 as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(Float3_funcs,NEW(T3<float>),EXT->Float3_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],float))
RET STG::createNativeObject(Float3_funcs,NEW(T3<float>,val_to_c<float>::f(ctx,a[1])),EXT->Float3_typeID);
if(a.getCount()==4)
if(true&&TS(a[1],float)&&TS(a[2],float)&&TS(a[3],float))
RET STG::createNativeObject(Float3_funcs,NEW(T3<float>,val_to_c<float>::f(ctx,a[1]),val_to_c<float>::f(ctx,a[2]),val_to_c<float>::f(ctx,a[3])),EXT->Float3_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T3<float> &))
RET STG::createNativeObject(Float3_funcs,NEW(T3<float>,val_to_c<const T3<float> &>::f(ctx,a[1])),EXT->Float3_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T3<int32_t> &))
RET STG::createNativeObject(Float3_funcs,NEW(T3<float>,val_to_c<const T3<int32_t> &>::f(ctx,a[1])),EXT->Float3_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T3<uint32_t> &))
RET STG::createNativeObject(Float3_funcs,NEW(T3<float>,val_to_c<const T3<uint32_t> &>::f(ctx,a[1])),EXT->Float3_typeID);
CATE(TE,UFOF("Float3's constructor.")));
RET CN;
}

SV Float3_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Float3");
EI(keyStr=="__new__")
RET CNF(Float3_new);
EI(keyStr=="__call__")
RET CNF(Float3_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Float3_new);
 EI(keyStr == "__add__")
RET CNF(Float3___add__);
 EI(keyStr == "__sub__")
RET CNF(Float3___sub__);
 EI(keyStr == "__mul__")
RET CNF(Float3___mul__);
 EI(keyStr == "__div__")
RET CNF(Float3___div__);
 EI(keyStr == "__eq__")
RET CNF(Float3___eq__);
 EI(keyStr == "__neq__")
RET CNF(Float3___neq__);
 EI(keyStr == "__less__")
RET CNF(Float3___less__);
 EI(keyStr == "__grtr__")
RET CNF(Float3___grtr__);
 EI(keyStr == "__leq__")
RET CNF(Float3___leq__);
 EI(keyStr == "__geq__")
RET CNF(Float3___geq__);
 EI(keyStr == "sum")
RET CNF(Float3_sum);
 EI(keyStr == "length")
RET CNF(Float3_length);
 EI(keyStr == "lengthSquared")
RET CNF(Float3_lengthSquared);
 EI(keyStr == "dot")
RET CNF(Float3_dot);
 EI(keyStr == "distance")
RET CNF(Float3_distance);
 EI(keyStr == "distanceSquared")
RET CNF(Float3_distanceSquared);
 EI(keyStr == "normalize")
RET CNF(Float3_normalize);
 EI(keyStr == "cross")
RET CNF(Float3_cross);
 EI(keyStr == "getXY")
RET CNF(Float3_getXY);
 EI(keyStr == "setXY")
RET CNF(Float3_setXY);
 EI(keyStr == "getXZ")
RET CNF(Float3_getXZ);
 EI(keyStr == "setXZ")
RET CNF(Float3_setXZ);
 EI(keyStr == "getYX")
RET CNF(Float3_getYX);
 EI(keyStr == "setYX")
RET CNF(Float3_setYX);
 EI(keyStr == "getYZ")
RET CNF(Float3_getYZ);
 EI(keyStr == "setYZ")
RET CNF(Float3_setYZ);
 EI(keyStr == "getZX")
RET CNF(Float3_getZX);
 EI(keyStr == "setZX")
RET CNF(Float3_setZX);
 EI(keyStr == "getZY")
RET CNF(Float3_getZY);
 EI(keyStr == "setZY")
RET CNF(Float3_setZY);
 EI(keyStr == "getXYZ")
RET CNF(Float3_getXYZ);
 EI(keyStr == "setXYZ")
RET CNF(Float3_setXYZ);
 EI(keyStr == "getXZY")
RET CNF(Float3_getXZY);
 EI(keyStr == "setXZY")
RET CNF(Float3_setXZY);
 EI(keyStr == "getYXZ")
RET CNF(Float3_getYXZ);
 EI(keyStr == "setYXZ")
RET CNF(Float3_setYXZ);
 EI(keyStr == "getYZX")
RET CNF(Float3_getYZX);
 EI(keyStr == "setYZX")
RET CNF(Float3_setYZX);
 EI(keyStr == "getZXY")
RET CNF(Float3_getZXY);
 EI(keyStr == "setZXY")
RET CNF(Float3_setZXY);
 EI(keyStr == "getZYX")
RET CNF(Float3_getZYX);
 EI(keyStr == "setZYX")
RET CNF(Float3_setZYX);
 EI(keyStr=="x")
{
T3<float>*obj=(T3<float>*)f->data;
RET CV(obj->x);
} EI(keyStr=="y")
{
T3<float>*obj=(T3<float>*)f->data;
RET CV(obj->y);
} EI(keyStr=="z")
{
T3<float>*obj=(T3<float>*)f->data;
RET CV(obj->z);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Float3_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="x")
{
T3<float>*obj=(T3<float>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr=="y")
{
T3<float>*obj=(T3<float>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} EI(keyStr=="z")
{
T3<float>*obj=(T3<float>*)f->data;
obj->z=val_to_c<decltype(obj->z)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Float3_setYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setYZX" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setYZX(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setYZX.")));
RET CN;
}

SV Float3_getZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getZXY" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXY());
;
}
CATE(TE,UFOF("Float3::getZXY.")));
RET CN;
}

SV Float3_setYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setYZ" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setYZ(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setYZ.")));
RET CN;
}

SV Float3_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setYX" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setYX.")));
RET CN;
}

SV Float3_setZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setZYX" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setZYX(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setZYX.")));
RET CN;
}

SV Float3_getZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getZY" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZY());
;
}
CATE(TE,UFOF("Float3::getZY.")));
RET CN;
}

SV Float3_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::distanceSquared" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Float3::distanceSquared.")));
RET CN;
}

SV Float3_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::normalize" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("Float3::normalize.")));
RET CN;
}

SV Float3_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getYX" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("Float3::getYX.")));
RET CN;
}

SV Float3___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__leq__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("Float3::__leq__.")));
RET CN;
}

SV Float3_setXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setXZY" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setXZY(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setXZY.")));
RET CN;
}

SV Float3_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::sum" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("Float3::sum.")));
RET CN;
}

SV Float3_cross(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::cross" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
RET CV( f->cross(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Float3::cross.")));
RET CN;
}

SV Float3_getXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getXYZ" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZ());
;
}
CATE(TE,UFOF("Float3::getXYZ.")));
RET CN;
}

SV Float3___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__less__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("Float3::__less__.")));
RET CN;
}

SV Float3___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__neq__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("Float3::__neq__.")));
RET CN;
}

SV Float3_getYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getYZ" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZ());
;
}
CATE(TE,UFOF("Float3::getYZ.")));
RET CN;
}

SV Float3_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::lengthSquared" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("Float3::lengthSquared.")));
RET CN;
}

SV Float3_getZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getZYX" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYX());
;
}
CATE(TE,UFOF("Float3::getZYX.")));
RET CN;
}

SV Float3___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__div__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("Float3::__div__.")));
RET CN;
}

SV Float3_setZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setZY" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setZY(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setZY.")));
RET CN;
}

SV Float3_setZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setZX" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setZX(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setZX.")));
RET CN;
}

SV Float3_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setXY" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setXY.")));
RET CN;
}

SV Float3___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__add__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("Float3::__add__.")));
RET CN;
}

SV Float3_setXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setXZ" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setXZ(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setXZ.")));
RET CN;
}

SV Float3___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__eq__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Float3::__eq__.")));
RET CN;
}

SV Float3_setZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setZXY" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setZXY(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setZXY.")));
RET CN;
}

SV Float3_setYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setYXZ" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setYXZ(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setYXZ.")));
RET CN;
}

SV Float3_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getXY" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("Float3::getXY.")));
RET CN;
}

SV Float3_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::distance" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Float3::distance.")));
RET CN;
}

SV Float3_getXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getXZ" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZ());
;
}
CATE(TE,UFOF("Float3::getXZ.")));
RET CN;
}

SV Float3___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__grtr__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("Float3::__grtr__.")));
RET CN;
}

SV Float3_getXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getXZY" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZY());
;
}
CATE(TE,UFOF("Float3::getXZY.")));
RET CN;
}

SV Float3_setXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::setXYZ" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setXYZ(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float3::setXYZ.")));
RET CN;
}

SV Float3_getYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getYZX" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZX());
;
}
CATE(TE,UFOF("Float3::getYZX.")));
RET CN;
}

SV Float3_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::length" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("Float3::length.")));
RET CN;
}

SV Float3___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__mul__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Float3::__mul__.")));
RET CN;
}

SV Float3_getYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getYXZ" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZ());
;
}
CATE(TE,UFOF("Float3::getYXZ.")));
RET CN;
}

SV Float3_getZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::getZX" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZX());
;
}
CATE(TE,UFOF("Float3::getZX.")));
RET CN;
}

SV Float3___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__sub__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("Float3::__sub__.")));
RET CN;
}

SV Float3___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::__geq__" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
auto v=val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("Float3::__geq__.")));
RET CN;
}

SV Float3_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float3::dot" EAOE));
T3<float>*f;
f=(T3<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("Float3::dot.")));
RET CN;
}

void GfxBuffer_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxBuffer))
CATE(TE,"GfxBuffer::__del__ expects GfxBuffer as first argument."));

DELETE((GfxBuffer*)f->data);
}SV GfxBuffer_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxBuffer's constructor" EAOE));
if(!TS(a[0],GfxBuffer))
CATE(TE,"GfxBuffer's constructor expects GfxBuffer as first argument."));
CATE(TE,UFOF("GfxBuffer's constructor.")));
}

SV GfxBuffer_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxBuffer");
EI(keyStr=="__new__")
RET CNF(GfxBuffer_new);
EI(keyStr=="__call__")
RET CNF(GfxBuffer_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GfxBuffer_new);
 EI(keyStr == "allocData")
RET CNF(GfxBuffer_allocData);
 EI(keyStr == "setData")
RET CNF(GfxBuffer_setData);
 EI(keyStr == "getData")
RET CNF(GfxBuffer_getData);
 EI(keyStr == "getSize")
RET CNF(GfxBuffer_getSize);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GfxBuffer_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GfxBuffer_getSize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxBuffer::getSize" EAOE));
GfxBuffer*f;
f=(GfxBuffer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getSize());
;
}
CATE(TE,UFOF("GfxBuffer::getSize.")));
RET CN;
}

SV GfxBuffer_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxBuffer::getData" EAOE));
GfxBuffer*f;
f=(GfxBuffer*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t))
{
RET CV( f->getData(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("GfxBuffer::getData.")));
RET CN;
}

SV GfxBuffer_allocData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxBuffer::allocData" EAOE));
GfxBuffer*f;
f=(GfxBuffer*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],const ResizableData &)&&TS(a[2],GfxBufferUsage))
{
( f->allocData(val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxBufferUsage>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxBuffer::allocData.")));
RET CN;
}

SV GfxBuffer_setData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxBuffer::setData" EAOE));
GfxBuffer*f;
f=(GfxBuffer*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],const ResizableData &))
{
( f->setData(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxBuffer::setData.")));
RET CN;
}

void Transform_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Transform))
CATE(TE,"Transform::__del__ expects Transform as first argument."));

DELETE((Transform*)f->data);
}SV Transform_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Transform's constructor" EAOE));
if(!TS(a[0],Transform))
CATE(TE,"Transform's constructor expects Transform as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(Transform_funcs,NEW(Transform),EXT->Transform_typeID);
CATE(TE,UFOF("Transform's constructor.")));
RET CN;
}

SV Transform_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Transform");
EI(keyStr=="__new__")
RET CNF(Transform_new);
EI(keyStr=="__call__")
RET CNF(Transform_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Transform_new);
 EI(keyStr == "createMatrix")
RET CNF(Transform_createMatrix);
 EI(keyStr=="orientation")
{
Transform*obj=(Transform*)f->data;
RET CV(obj->orientation);
} EI(keyStr=="scale")
{
Transform*obj=(Transform*)f->data;
RET CV(obj->scale);
} EI(keyStr=="position")
{
Transform*obj=(Transform*)f->data;
RET CV(obj->position);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Transform_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="orientation")
{
Transform*obj=(Transform*)f->data;
obj->orientation=val_to_c<decltype(obj->orientation)>::f(ctx,value);
} EI(keyStr=="scale")
{
Transform*obj=(Transform*)f->data;
obj->scale=val_to_c<decltype(obj->scale)>::f(ctx,value);
} EI(keyStr=="position")
{
Transform*obj=(Transform*)f->data;
obj->position=val_to_c<decltype(obj->position)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Transform_createMatrix(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Transform::createMatrix" EAOE));
Transform*f;
f=(Transform*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->createMatrix());
;
}
CATE(TE,UFOF("Transform::createMatrix.")));
RET CN;
}

void AudioSourceList_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<AudioSource*>))
CATE(TE,"AudioSourceList::__del__ expects AudioSourceList as first argument."));

DELETE((List<AudioSource*>*)f->data);
}SV AudioSourceList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList's constructor" EAOE));
if(!TS(a[0],List<AudioSource*>))
CATE(TE,"AudioSourceList's constructor expects AudioSourceList as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(AudioSourceList_funcs,NEW(List<AudioSource*>),EXT->AudioSourceList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],std::size_t))
RET STG::createNativeObject(AudioSourceList_funcs,NEW(List<AudioSource*>,val_to_c<std::size_t>::f(ctx,a[1])),EXT->AudioSourceList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const List<AudioSource*> &))
RET STG::createNativeObject(AudioSourceList_funcs,NEW(List<AudioSource*>,val_to_c<const List<AudioSource*> &>::f(ctx,a[1])),EXT->AudioSourceList_typeID);
CATE(TE,UFOF("AudioSourceList's constructor.")));
RET CN;
}

SV AudioSourceList_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("AudioSourceList");
EI(keyStr=="__new__")
RET CNF(AudioSourceList_new);
EI(keyStr=="__call__")
RET CNF(AudioSourceList_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(AudioSourceList_new);
 EI(keyStr == "__eq__")
RET CNF(AudioSourceList___eq__);
 EI(keyStr == "__neq__")
RET CNF(AudioSourceList___neq__);
 EI(keyStr == "get")
RET CNF(AudioSourceList_get);
 EI(keyStr == "set")
RET CNF(AudioSourceList_set);
 EI(keyStr == "getCount")
RET CNF(AudioSourceList_getCount);
 EI(keyStr == "getData")
RET CNF(AudioSourceList_getData);
 EI(keyStr == "append")
RET CNF(AudioSourceList_append);
 EI(keyStr == "insert")
RET CNF(AudioSourceList_insert);
 EI(keyStr == "remove")
RET CNF(AudioSourceList_remove);
 EI(keyStr == "clear")
RET CNF(AudioSourceList_clear);
 EI(keyStr == "find")
RET CNF(AudioSourceList_find);
 EI(keyStr == "copy")
RET CNF(AudioSourceList_copy);
 EI(keyStr == "in")
RET CNF(AudioSourceList_in);
 EI(keyStr == "begin")
RET CNF(AudioSourceList_begin);
 EI(keyStr == "end")
RET CNF(AudioSourceList_end);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void AudioSourceList_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV AudioSourceList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::insert" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],AudioSource*))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<AudioSource*>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<AudioSource*> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<AudioSource*> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("AudioSourceList::insert.")));
RET CN;
}

SV AudioSourceList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::begin" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0])->data;

CATE(TE,UFOF("AudioSourceList::begin.")));
RET CN;
}

SV AudioSourceList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::set" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],AudioSource*))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<AudioSource*>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("AudioSourceList::set.")));
RET CN;
}

SV AudioSourceList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::end" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0])->data;

CATE(TE,UFOF("AudioSourceList::end.")));
RET CN;
}

SV AudioSourceList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::get" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("AudioSourceList::get.")));
RET CN;
}

SV AudioSourceList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::clear" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("AudioSourceList::clear.")));
RET CN;
}

SV AudioSourceList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::copy" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("AudioSourceList::copy.")));
RET CN;
}

SV AudioSourceList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::remove" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("AudioSourceList::remove.")));
RET CN;
}

SV AudioSourceList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::in" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],AudioSource*))
{
RET CV( f->in(val_to_c<std::remove_reference<AudioSource*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("AudioSourceList::in.")));
RET CN;
}

SV AudioSourceList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::getCount" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("AudioSourceList::getCount.")));
RET CN;
}

SV AudioSourceList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::getData" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0])->data;

CATE(TE,UFOF("AudioSourceList::getData.")));
RET CN;
}

SV AudioSourceList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::__eq__" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<AudioSource*> &))
{
auto v=val_to_c<std::remove_reference<const List<AudioSource*> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("AudioSourceList::__eq__.")));
RET CN;
}

SV AudioSourceList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::find" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],AudioSource*))
{
RET CV( f->find(val_to_c<std::remove_reference<AudioSource*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("AudioSourceList::find.")));
RET CN;
}

SV AudioSourceList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::append" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],AudioSource*))
{
( f->append(val_to_c<std::remove_reference<AudioSource*>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<AudioSource*> &))
{
( f->append(val_to_c<std::remove_reference<const List<AudioSource*> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioSourceList::append.")));
RET CN;
}

SV AudioSourceList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioSourceList::__neq__" EAOE));
List<AudioSource*>*f;
f=(List<AudioSource*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<AudioSource*> &))
{
auto v=val_to_c<std::remove_reference<const List<AudioSource*> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("AudioSourceList::__neq__.")));
RET CN;
}

void GfxMaterial_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxMaterial))
CATE(TE,"GfxMaterial::__del__ expects GfxMaterial as first argument."));

GfxMaterial*obj=(GfxMaterial*)f->data;
if(obj!=nullptr){obj->release();}
}SV GfxMaterial_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxMaterial's constructor" EAOE));
if(!TS(a[0],GfxMaterial))
CATE(TE,"GfxMaterial's constructor expects GfxMaterial as first argument."));
CATE(TE,UFOF("GfxMaterial's constructor.")));
}

SV GfxMaterial_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxMaterial");
EI(keyStr=="__new__")
RET CNF(GfxMaterial_new);
EI(keyStr=="__call__")
RET CNF(GfxMaterial_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GfxMaterial_new);
 EI(keyStr == "removeContent")
RET CNF(GfxMaterial_removeContent);
 EI(keyStr == "save")
RET CNF(GfxMaterial_save);
 EI(keyStr == "getShaderComb")
RET CNF(GfxMaterial_getShaderComb);
 EI(keyStr == "setMaterialMap")
RET CNF(GfxMaterial_setMaterialMap);
 EI(keyStr == "getMaterialMap")
RET CNF(GfxMaterial_getMaterialMap);
 EI(keyStr == "setAlbedoMap")
RET CNF(GfxMaterial_setAlbedoMap);
 EI(keyStr == "getAlbedoMap")
RET CNF(GfxMaterial_getAlbedoMap);
 EI(keyStr == "setNormalMap")
RET CNF(GfxMaterial_setNormalMap);
 EI(keyStr == "getNormalMap")
RET CNF(GfxMaterial_getNormalMap);
 EI(keyStr == "setParallaxHeightMap")
RET CNF(GfxMaterial_setParallaxHeightMap);
 EI(keyStr == "getParallaxHeightMap")
RET CNF(GfxMaterial_getParallaxHeightMap);
 EI(keyStr == "setPOMHeightMap")
RET CNF(GfxMaterial_setPOMHeightMap);
 EI(keyStr == "getPOMHeightMap")
RET CNF(GfxMaterial_getPOMHeightMap);
 EI(keyStr == "setDisplacementMap")
RET CNF(GfxMaterial_setDisplacementMap);
 EI(keyStr == "getDisplacementMap")
RET CNF(GfxMaterial_getDisplacementMap);
 EI(keyStr == "isForward")
RET CNF(GfxMaterial_isForward);
 EI(keyStr == "setForward")
RET CNF(GfxMaterial_setForward);
 EI(keyStr == "load")
RET CNF(GfxMaterial_load);
 EI(keyStr == "copy")
RET CNF(GfxMaterial_copy);
 EI(keyStr == "getType")
RET CNF(GfxMaterial_getType);
 EI(keyStr == "release")
RET CNF(GfxMaterial_release);
 EI(keyStr == "getRefCount")
RET CNF(GfxMaterial_getRefCount);
 EI(keyStr == "getFilename")
RET CNF(GfxMaterial_getFilename);
 EI(keyStr == "setFilename")
RET CNF(GfxMaterial_setFilename);
 EI(keyStr=="smoothness")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
RET CV(obj->smoothness);
} EI(keyStr=="metalMask")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
RET CV(obj->metalMask);
} EI(keyStr=="parallaxStrength")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
RET CV(obj->parallaxStrength);
} EI(keyStr=="parallaxEdgeDiscard")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
RET CV(obj->parallaxEdgeDiscard);
} EI(keyStr=="albedo")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
RET CV(obj->albedo);
} EI(keyStr=="pomMinLayers")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
RET CV(obj->pomMinLayers);
} EI(keyStr=="pomMaxLayers")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
RET CV(obj->pomMaxLayers);
} EI(keyStr=="minTessLevel")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
RET CV(obj->minTessLevel);
} EI(keyStr=="maxTessLevel")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
RET CV(obj->maxTessLevel);
} EI(keyStr=="tessMinDistance")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
RET CV(obj->tessMinDistance);
} EI(keyStr=="tessMaxDistance")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
RET CV(obj->tessMaxDistance);
} EI(keyStr=="displacementStrength")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
RET CV(obj->displacementStrength);
} EI(keyStr=="displacementMidlevel")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
RET CV(obj->displacementMidlevel);
} EI(keyStr=="shadowTesselation")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
RET CV(obj->shadowTesselation);
} EI(keyStr=="shadowMinTessLevel")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
RET CV(obj->shadowMinTessLevel);
} EI(keyStr=="shadowMaxTessLevel")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
RET CV(obj->shadowMaxTessLevel);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GfxMaterial_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="smoothness")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
obj->smoothness=val_to_c<decltype(obj->smoothness)>::f(ctx,value);
} EI(keyStr=="metalMask")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
obj->metalMask=val_to_c<decltype(obj->metalMask)>::f(ctx,value);
} EI(keyStr=="parallaxStrength")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
obj->parallaxStrength=val_to_c<decltype(obj->parallaxStrength)>::f(ctx,value);
} EI(keyStr=="parallaxEdgeDiscard")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
obj->parallaxEdgeDiscard=val_to_c<decltype(obj->parallaxEdgeDiscard)>::f(ctx,value);
} EI(keyStr=="albedo")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
obj->albedo=val_to_c<decltype(obj->albedo)>::f(ctx,value);
} EI(keyStr=="pomMinLayers")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
obj->pomMinLayers=val_to_c<decltype(obj->pomMinLayers)>::f(ctx,value);
} EI(keyStr=="pomMaxLayers")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
obj->pomMaxLayers=val_to_c<decltype(obj->pomMaxLayers)>::f(ctx,value);
} EI(keyStr=="minTessLevel")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
obj->minTessLevel=val_to_c<decltype(obj->minTessLevel)>::f(ctx,value);
} EI(keyStr=="maxTessLevel")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
obj->maxTessLevel=val_to_c<decltype(obj->maxTessLevel)>::f(ctx,value);
} EI(keyStr=="tessMinDistance")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
obj->tessMinDistance=val_to_c<decltype(obj->tessMinDistance)>::f(ctx,value);
} EI(keyStr=="tessMaxDistance")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
obj->tessMaxDistance=val_to_c<decltype(obj->tessMaxDistance)>::f(ctx,value);
} EI(keyStr=="displacementStrength")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
obj->displacementStrength=val_to_c<decltype(obj->displacementStrength)>::f(ctx,value);
} EI(keyStr=="displacementMidlevel")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
obj->displacementMidlevel=val_to_c<decltype(obj->displacementMidlevel)>::f(ctx,value);
} EI(keyStr=="shadowTesselation")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
obj->shadowTesselation=val_to_c<decltype(obj->shadowTesselation)>::f(ctx,value);
} EI(keyStr=="shadowMinTessLevel")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
obj->shadowMinTessLevel=val_to_c<decltype(obj->shadowMinTessLevel)>::f(ctx,value);
} EI(keyStr=="shadowMaxTessLevel")
{
GfxMaterial*obj=(GfxMaterial*)f->data;
obj->shadowMaxTessLevel=val_to_c<decltype(obj->shadowMaxTessLevel)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GfxMaterial_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::load" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("GfxMaterial::load.")));
RET CN;
}

SV GfxMaterial_setAlbedoMap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::setAlbedoMap" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxTexture *))
{
( f->setAlbedoMap(val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxMaterial::setAlbedoMap.")));
RET CN;
}

SV GfxMaterial_setPOMHeightMap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::setPOMHeightMap" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxTexture *))
{
( f->setPOMHeightMap(val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxMaterial::setPOMHeightMap.")));
RET CN;
}

SV GfxMaterial_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::setFilename" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
( f->setFilename(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxMaterial::setFilename.")));
RET CN;
}

SV GfxMaterial_setForward(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::setForward" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],bool))
{
( f->setForward(val_to_c<std::remove_reference<bool>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxMaterial::setForward.")));
RET CN;
}

SV GfxMaterial_getNormalMap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::getNormalMap" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getNormalMap());
;
}
CATE(TE,UFOF("GfxMaterial::getNormalMap.")));
RET CN;
}

SV GfxMaterial_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::save" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("GfxMaterial::save.")));
RET CN;
}

SV GfxMaterial_setNormalMap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::setNormalMap" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxTexture *))
{
( f->setNormalMap(val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxMaterial::setNormalMap.")));
RET CN;
}

SV GfxMaterial_getDisplacementMap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::getDisplacementMap" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDisplacementMap());
;
}
CATE(TE,UFOF("GfxMaterial::getDisplacementMap.")));
RET CN;
}

SV GfxMaterial_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::getFilename" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("GfxMaterial::getFilename.")));
RET CN;
}

SV GfxMaterial_getPOMHeightMap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::getPOMHeightMap" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getPOMHeightMap());
;
}
CATE(TE,UFOF("GfxMaterial::getPOMHeightMap.")));
RET CN;
}

SV GfxMaterial_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::getRefCount" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("GfxMaterial::getRefCount.")));
RET CN;
}

SV GfxMaterial_getMaterialMap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::getMaterialMap" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getMaterialMap());
;
}
CATE(TE,UFOF("GfxMaterial::getMaterialMap.")));
RET CN;
}

SV GfxMaterial_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::getType" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("GfxMaterial::getType.")));
RET CN;
}

SV GfxMaterial_setParallaxHeightMap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::setParallaxHeightMap" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxTexture *))
{
( f->setParallaxHeightMap(val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxMaterial::setParallaxHeightMap.")));
RET CN;
}

SV GfxMaterial_getParallaxHeightMap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::getParallaxHeightMap" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getParallaxHeightMap());
;
}
CATE(TE,UFOF("GfxMaterial::getParallaxHeightMap.")));
RET CN;
}

SV GfxMaterial_isForward(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::isForward" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->isForward());
;
}
CATE(TE,UFOF("GfxMaterial::isForward.")));
RET CN;
}

SV GfxMaterial_setMaterialMap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::setMaterialMap" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxTexture *))
{
( f->setMaterialMap(val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxMaterial::setMaterialMap.")));
RET CN;
}

SV GfxMaterial_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::copy" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("GfxMaterial::copy.")));
RET CN;
}

SV GfxMaterial_setDisplacementMap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::setDisplacementMap" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxTexture *))
{
( f->setDisplacementMap(val_to_c<std::remove_reference<GfxTexture *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxMaterial::setDisplacementMap.")));
RET CN;
}

SV GfxMaterial_getShaderComb(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::getShaderComb" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShaderComb());
;
}
CATE(TE,UFOF("GfxMaterial::getShaderComb.")));
RET CN;
}

SV GfxMaterial_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::removeContent" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("GfxMaterial::removeContent.")));
RET CN;
}

SV GfxMaterial_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::release" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("GfxMaterial::release.")));
RET CN;
}

SV GfxMaterial_getAlbedoMap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxMaterial::getAlbedoMap" EAOE));
GfxMaterial*f;
f=(GfxMaterial*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAlbedoMap());
;
}
CATE(TE,UFOF("GfxMaterial::getAlbedoMap.")));
RET CN;
}

void Quaternion_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Quaternion))
CATE(TE,"Quaternion::__del__ expects Quaternion as first argument."));

DELETE((Quaternion*)f->data);
}SV Quaternion_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion's constructor" EAOE));
if(!TS(a[0],Quaternion))
CATE(TE,"Quaternion's constructor expects Quaternion as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(Quaternion_funcs,NEW(Quaternion),EXT->Quaternion_typeID);
if(a.getCount()==3)
if(true&&TS(a[1],const Direction3D &)&&TS(a[2],float))
RET STG::createNativeObject(Quaternion_funcs,NEW(Quaternion,val_to_c<const Direction3D &>::f(ctx,a[1]),val_to_c<float>::f(ctx,a[2])),EXT->Quaternion_typeID);
if(a.getCount()==5)
if(true&&TS(a[1],float)&&TS(a[2],float)&&TS(a[3],float)&&TS(a[4],float))
RET STG::createNativeObject(Quaternion_funcs,NEW(Quaternion,val_to_c<float>::f(ctx,a[1]),val_to_c<float>::f(ctx,a[2]),val_to_c<float>::f(ctx,a[3]),val_to_c<float>::f(ctx,a[4])),EXT->Quaternion_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const Float3 &))
RET STG::createNativeObject(Quaternion_funcs,NEW(Quaternion,val_to_c<const Float3 &>::f(ctx,a[1])),EXT->Quaternion_typeID);
CATE(TE,UFOF("Quaternion's constructor.")));
RET CN;
}

SV Quaternion_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Quaternion");
EI(keyStr=="__new__")
RET CNF(Quaternion_new);
EI(keyStr=="__call__")
RET CNF(Quaternion_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Quaternion_new);
 EI(keyStr == "__mul__")
RET CNF(Quaternion___mul__);
 EI(keyStr == "toMatrix")
RET CNF(Quaternion_toMatrix);
 EI(keyStr == "__eq__")
RET CNF(Quaternion___eq__);
 EI(keyStr == "normalize")
RET CNF(Quaternion_normalize);
 EI(keyStr == "getAngle")
RET CNF(Quaternion_getAngle);
 EI(keyStr == "getXAxis")
RET CNF(Quaternion_getXAxis);
 EI(keyStr == "getYAxis")
RET CNF(Quaternion_getYAxis);
 EI(keyStr == "getZAxis")
RET CNF(Quaternion_getZAxis);
 EI(keyStr == "getAxis")
RET CNF(Quaternion_getAxis);
 EI(keyStr == "getAxisAndAngle")
RET CNF(Quaternion_getAxisAndAngle);
 EI(keyStr == "setAngle")
RET CNF(Quaternion_setAngle);
 EI(keyStr == "setXAxis")
RET CNF(Quaternion_setXAxis);
 EI(keyStr == "setYAxis")
RET CNF(Quaternion_setYAxis);
 EI(keyStr == "setZAxis")
RET CNF(Quaternion_setZAxis);
 EI(keyStr == "setAxis")
RET CNF(Quaternion_setAxis);
 EI(keyStr == "setAxisAndAngle")
RET CNF(Quaternion_setAxisAndAngle);
 EI(keyStr == "setEulerAngles")
RET CNF(Quaternion_setEulerAngles);
 EI(keyStr == "getEulerAngles")
RET CNF(Quaternion_getEulerAngles);
 EI(keyStr=="x")
{
Quaternion*obj=(Quaternion*)f->data;
RET CV(obj->x);
} EI(keyStr=="y")
{
Quaternion*obj=(Quaternion*)f->data;
RET CV(obj->y);
} EI(keyStr=="z")
{
Quaternion*obj=(Quaternion*)f->data;
RET CV(obj->z);
} EI(keyStr=="w")
{
Quaternion*obj=(Quaternion*)f->data;
RET CV(obj->w);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Quaternion_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="x")
{
Quaternion*obj=(Quaternion*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr=="y")
{
Quaternion*obj=(Quaternion*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} EI(keyStr=="z")
{
Quaternion*obj=(Quaternion*)f->data;
obj->z=val_to_c<decltype(obj->z)>::f(ctx,value);
} EI(keyStr=="w")
{
Quaternion*obj=(Quaternion*)f->data;
obj->w=val_to_c<decltype(obj->w)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Quaternion_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::normalize" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("Quaternion::normalize.")));
RET CN;
}

SV Quaternion_setEulerAngles(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::setEulerAngles" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
( f->setEulerAngles(val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Quaternion::setEulerAngles.")));
RET CN;
}

SV Quaternion_getAngle(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::getAngle" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAngle());
;
}
CATE(TE,UFOF("Quaternion::getAngle.")));
RET CN;
}

SV Quaternion_getAxis(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::getAxis" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAxis());
;
}
CATE(TE,UFOF("Quaternion::getAxis.")));
RET CN;
}

SV Quaternion_setAngle(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::setAngle" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setAngle(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Quaternion::setAngle.")));
RET CN;
}

SV Quaternion_setYAxis(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::setYAxis" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setYAxis(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Quaternion::setYAxis.")));
RET CN;
}

SV Quaternion_getEulerAngles(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::getEulerAngles" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getEulerAngles());
;
}
CATE(TE,UFOF("Quaternion::getEulerAngles.")));
RET CN;
}

SV Quaternion_setAxisAndAngle(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::setAxisAndAngle" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],const Direction3D &)&&TS(a[2],float))
{
( f->setAxisAndAngle(val_to_c<std::remove_reference<const Direction3D &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("Quaternion::setAxisAndAngle.")));
RET CN;
}

SV Quaternion_getAxisAndAngle(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::getAxisAndAngle" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAxisAndAngle());
;
}
CATE(TE,UFOF("Quaternion::getAxisAndAngle.")));
RET CN;
}

SV Quaternion_setAxis(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::setAxis" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Direction3D &))
{
( f->setAxis(val_to_c<std::remove_reference<const Direction3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Quaternion::setAxis.")));
RET CN;
}

SV Quaternion___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::__mul__" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Quaternion &))
{
auto v=val_to_c<std::remove_reference<const Quaternion &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Quaternion::__mul__.")));
RET CN;
}

SV Quaternion_getYAxis(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::getYAxis" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYAxis());
;
}
CATE(TE,UFOF("Quaternion::getYAxis.")));
RET CN;
}

SV Quaternion_getXAxis(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::getXAxis" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXAxis());
;
}
CATE(TE,UFOF("Quaternion::getXAxis.")));
RET CN;
}

SV Quaternion_toMatrix(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::toMatrix" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->toMatrix());
;
}
CATE(TE,UFOF("Quaternion::toMatrix.")));
RET CN;
}

SV Quaternion_setZAxis(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::setZAxis" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setZAxis(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Quaternion::setZAxis.")));
RET CN;
}

SV Quaternion_setXAxis(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::setXAxis" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setXAxis(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Quaternion::setXAxis.")));
RET CN;
}

SV Quaternion___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::__eq__" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Quaternion &))
{
auto v=val_to_c<std::remove_reference<const Quaternion &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Quaternion::__eq__.")));
RET CN;
}

SV Quaternion_getZAxis(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Quaternion::getZAxis" EAOE));
Quaternion*f;
f=(Quaternion*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZAxis());
;
}
CATE(TE,UFOF("Quaternion::getZAxis.")));
RET CN;
}

void GfxMeshAttrib_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxMeshAttrib))
CATE(TE,"GfxMeshAttrib::__del__ expects GfxMeshAttrib as first argument."));

DELETE((GfxMeshAttrib*)f->data);
}SV GfxMeshAttrib_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxMeshAttrib's constructor" EAOE));
if(!TS(a[0],GfxMeshAttrib))
CATE(TE,"GfxMeshAttrib's constructor expects GfxMeshAttrib as first argument."));
#define fjis GfxMeshAttrib
RET STG::createNativeObject(GfxMeshAttrib_funcs,NEW(fjis),EXT->GfxMeshAttrib_typeID);
}

SV GfxMeshAttrib_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxMeshAttrib");
EI(keyStr=="__new__")
RET CNF(GfxMeshAttrib_new);
EI(keyStr=="__call__")
RET CNF(GfxMeshAttrib_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GfxMeshAttrib_new);
 EI(keyStr=="type")
{
GfxMeshAttrib*obj=(GfxMeshAttrib*)f->data;
RET CV(obj->type);
} EI(keyStr=="dataType")
{
GfxMeshAttrib*obj=(GfxMeshAttrib*)f->data;
RET CV(obj->dataType);
} EI(keyStr=="data")
{
GfxMeshAttrib*obj=(GfxMeshAttrib*)f->data;
RET CV(obj->data);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GfxMeshAttrib_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="type")
{
GfxMeshAttrib*obj=(GfxMeshAttrib*)f->data;
obj->type=val_to_c<decltype(obj->type)>::f(ctx,value);
} EI(keyStr=="dataType")
{
GfxMeshAttrib*obj=(GfxMeshAttrib*)f->data;
obj->dataType=val_to_c<decltype(obj->dataType)>::f(ctx,value);
} EI(keyStr=="data")
{
GfxMeshAttrib*obj=(GfxMeshAttrib*)f->data;
obj->data=val_to_c<decltype(obj->data)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

void RenderComponent_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,RenderComponent))
CATE(TE,"RenderComponent::__del__ expects RenderComponent as first argument."));

}SV RenderComponent_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"RenderComponent's constructor" EAOE));
if(!TS(a[0],RenderComponent))
CATE(TE,"RenderComponent's constructor expects RenderComponent as first argument."));
CATE(TE,UFOF("RenderComponent's constructor.")));
}

SV RenderComponent_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("RenderComponent");
EI(keyStr=="__new__")
RET CNF(RenderComponent_new);
EI(keyStr=="__call__")
RET CNF(RenderComponent_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(RenderComponent_new);
 EI(keyStr == "getShadowCaster")
RET CNF(RenderComponent_getShadowCaster);
 EI(keyStr == "setShadowCaster")
RET CNF(RenderComponent_setShadowCaster);
 EI(keyStr == "getOverlayColor")
RET CNF(RenderComponent_getOverlayColor);
 EI(keyStr == "setOverlayColor")
RET CNF(RenderComponent_setOverlayColor);
 EI(keyStr == "setAnimationState")
RET CNF(RenderComponent_setAnimationState);
 EI(keyStr == "removeAnimationState")
RET CNF(RenderComponent_removeAnimationState);
 EI(keyStr == "getAnimationState")
RET CNF(RenderComponent_getAnimationState);
 EI(keyStr=="mode")
{
RenderComponent*obj=(RenderComponent*)f->data;
RET CV(obj->mode);
} EI(keyStr=="model")
{
RenderComponent*obj=(RenderComponent*)f->data;
RET CV(obj->model);
} EI(keyStr=="overlayTexture")
{
RenderComponent*obj=(RenderComponent*)f->data;
RET CV(obj->overlayTexture);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void RenderComponent_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="mode")
{
RenderComponent*obj=(RenderComponent*)f->data;
obj->mode=val_to_c<decltype(obj->mode)>::f(ctx,value);
} EI(keyStr=="model")
{
RenderComponent*obj=(RenderComponent*)f->data;
obj->model=val_to_c<decltype(obj->model)>::f(ctx,value);
} EI(keyStr=="overlayTexture")
{
RenderComponent*obj=(RenderComponent*)f->data;
obj->overlayTexture=val_to_c<decltype(obj->overlayTexture)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV RenderComponent_setOverlayColor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderComponent::setOverlayColor" EAOE));
RenderComponent*f;
f=(RenderComponent*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
( f->setOverlayColor(val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RenderComponent::setOverlayColor.")));
RET CN;
}

SV RenderComponent_getOverlayColor(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderComponent::getOverlayColor" EAOE));
RenderComponent*f;
f=(RenderComponent*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getOverlayColor());
;
}
CATE(TE,UFOF("RenderComponent::getOverlayColor.")));
RET CN;
}

SV RenderComponent_setShadowCaster(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderComponent::setShadowCaster" EAOE));
RenderComponent*f;
f=(RenderComponent*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],bool))
{
( f->setShadowCaster(val_to_c<std::remove_reference<bool>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RenderComponent::setShadowCaster.")));
RET CN;
}

SV RenderComponent_getShadowCaster(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderComponent::getShadowCaster" EAOE));
RenderComponent*f;
f=(RenderComponent*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShadowCaster());
;
}
CATE(TE,UFOF("RenderComponent::getShadowCaster.")));
RET CN;
}

SV RenderComponent_setAnimationState(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderComponent::setAnimationState" EAOE));
RenderComponent*f;
f=(RenderComponent*)((NO)a[0])->data;

CATE(TE,UFOF("RenderComponent::setAnimationState.")));
RET CN;
}

SV RenderComponent_getAnimationState(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderComponent::getAnimationState" EAOE));
RenderComponent*f;
f=(RenderComponent*)((NO)a[0])->data;

CATE(TE,UFOF("RenderComponent::getAnimationState.")));
RET CN;
}

SV RenderComponent_removeAnimationState(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RenderComponent::removeAnimationState" EAOE));
RenderComponent*f;
f=(RenderComponent*)((NO)a[0])->data;

CATE(TE,UFOF("RenderComponent::removeAnimationState.")));
RET CN;
}

void Int2_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T2<int32_t>))
CATE(TE,"Int2::__del__ expects Int2 as first argument."));

DELETE((T2<int32_t>*)f->data);
}SV Int2_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2's constructor" EAOE));
if(!TS(a[0],T2<int32_t>))
CATE(TE,"Int2's constructor expects Int2 as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(Int2_funcs,NEW(T2<int32_t>),EXT->Int2_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],int32_t))
RET STG::createNativeObject(Int2_funcs,NEW(T2<int32_t>,val_to_c<int32_t>::f(ctx,a[1])),EXT->Int2_typeID);
if(a.getCount()==3)
if(true&&TS(a[1],int32_t)&&TS(a[2],int32_t))
RET STG::createNativeObject(Int2_funcs,NEW(T2<int32_t>,val_to_c<int32_t>::f(ctx,a[1]),val_to_c<int32_t>::f(ctx,a[2])),EXT->Int2_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T2<float> &))
RET STG::createNativeObject(Int2_funcs,NEW(T2<int32_t>,val_to_c<const T2<float> &>::f(ctx,a[1])),EXT->Int2_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T2<int32_t> &))
RET STG::createNativeObject(Int2_funcs,NEW(T2<int32_t>,val_to_c<const T2<int32_t> &>::f(ctx,a[1])),EXT->Int2_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T2<uint32_t> &))
RET STG::createNativeObject(Int2_funcs,NEW(T2<int32_t>,val_to_c<const T2<uint32_t> &>::f(ctx,a[1])),EXT->Int2_typeID);
CATE(TE,UFOF("Int2's constructor.")));
RET CN;
}

SV Int2_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Int2");
EI(keyStr=="__new__")
RET CNF(Int2_new);
EI(keyStr=="__call__")
RET CNF(Int2_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Int2_new);
 EI(keyStr == "__add__")
RET CNF(Int2___add__);
 EI(keyStr == "__sub__")
RET CNF(Int2___sub__);
 EI(keyStr == "__mul__")
RET CNF(Int2___mul__);
 EI(keyStr == "__div__")
RET CNF(Int2___div__);
 EI(keyStr == "__eq__")
RET CNF(Int2___eq__);
 EI(keyStr == "__neq__")
RET CNF(Int2___neq__);
 EI(keyStr == "__less__")
RET CNF(Int2___less__);
 EI(keyStr == "__grtr__")
RET CNF(Int2___grtr__);
 EI(keyStr == "__leq__")
RET CNF(Int2___leq__);
 EI(keyStr == "__geq__")
RET CNF(Int2___geq__);
 EI(keyStr == "sum")
RET CNF(Int2_sum);
 EI(keyStr == "length")
RET CNF(Int2_length);
 EI(keyStr == "lengthSquared")
RET CNF(Int2_lengthSquared);
 EI(keyStr == "dot")
RET CNF(Int2_dot);
 EI(keyStr == "distance")
RET CNF(Int2_distance);
 EI(keyStr == "distanceSquared")
RET CNF(Int2_distanceSquared);
 EI(keyStr == "normalize")
RET CNF(Int2_normalize);
 EI(keyStr == "getXY")
RET CNF(Int2_getXY);
 EI(keyStr == "setXY")
RET CNF(Int2_setXY);
 EI(keyStr == "getYX")
RET CNF(Int2_getYX);
 EI(keyStr == "setYX")
RET CNF(Int2_setYX);
 EI(keyStr=="x")
{
T2<int32_t>*obj=(T2<int32_t>*)f->data;
RET CV(obj->x);
} EI(keyStr=="y")
{
T2<int32_t>*obj=(T2<int32_t>*)f->data;
RET CV(obj->y);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Int2_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="x")
{
T2<int32_t>*obj=(T2<int32_t>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr=="y")
{
T2<int32_t>*obj=(T2<int32_t>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Int2_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::normalize" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("Int2::normalize.")));
RET CN;
}

SV Int2_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::distance" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Int2::distance.")));
RET CN;
}

SV Int2_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::lengthSquared" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("Int2::lengthSquared.")));
RET CN;
}

SV Int2___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__leq__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("Int2::__leq__.")));
RET CN;
}

SV Int2_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::setYX" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int2::setYX.")));
RET CN;
}

SV Int2___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__grtr__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("Int2::__grtr__.")));
RET CN;
}

SV Int2_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::sum" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("Int2::sum.")));
RET CN;
}

SV Int2_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::getXY" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("Int2::getXY.")));
RET CN;
}

SV Int2_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::length" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("Int2::length.")));
RET CN;
}

SV Int2_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::getYX" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("Int2::getYX.")));
RET CN;
}

SV Int2___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__div__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("Int2::__div__.")));
RET CN;
}

SV Int2_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::setXY" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Int2::setXY.")));
RET CN;
}

SV Int2___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__mul__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Int2::__mul__.")));
RET CN;
}

SV Int2___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__add__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("Int2::__add__.")));
RET CN;
}

SV Int2___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__less__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("Int2::__less__.")));
RET CN;
}

SV Int2___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__sub__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
auto v=val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("Int2::__sub__.")));
RET CN;
}

SV Int2___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__geq__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("Int2::__geq__.")));
RET CN;
}

SV Int2_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::distanceSquared" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Int2::distanceSquared.")));
RET CN;
}

SV Int2___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__eq__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Int2::__eq__.")));
RET CN;
}

SV Int2_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::dot" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("Int2::dot.")));
RET CN;
}

SV Int2___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Int2::__neq__" EAOE));
T2<int32_t>*f;
f=(T2<int32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<int32_t> &))
{
auto v=val_to_c<std::remove_reference<const T2<int32_t> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("Int2::__neq__.")));
RET CN;
}

void AudioWorld_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,AudioWorld))
CATE(TE,"AudioWorld::__del__ expects AudioWorld as first argument."));

DELETE((AudioWorld*)f->data);
}SV AudioWorld_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioWorld's constructor" EAOE));
if(!TS(a[0],AudioWorld))
CATE(TE,"AudioWorld's constructor expects AudioWorld as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(AudioWorld_funcs,NEW(AudioWorld),EXT->AudioWorld_typeID);
CATE(TE,UFOF("AudioWorld's constructor.")));
RET CN;
}

SV AudioWorld_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("AudioWorld");
EI(keyStr=="__new__")
RET CNF(AudioWorld_new);
EI(keyStr=="__call__")
RET CNF(AudioWorld_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(AudioWorld_new);
 EI(keyStr == "createSource")
RET CNF(AudioWorld_createSource);
 EI(keyStr == "destroySource")
RET CNF(AudioWorld_destroySource);
 EI(keyStr == "clearSources")
RET CNF(AudioWorld_clearSources);
 EI(keyStr == "getSources")
RET CNF(AudioWorld_getSources);
 EI(keyStr == "addToAudioDevice")
RET CNF(AudioWorld_addToAudioDevice);
 EI(keyStr == "removeFromAudioDevice")
RET CNF(AudioWorld_removeFromAudioDevice);
 EI(keyStr=="listenerVelocity")
{
AudioWorld*obj=(AudioWorld*)f->data;
RET CV(obj->listenerVelocity);
} EI(keyStr=="dopplerFactor")
{
AudioWorld*obj=(AudioWorld*)f->data;
RET CV(obj->dopplerFactor);
} EI(keyStr=="listenerPosition")
{
AudioWorld*obj=(AudioWorld*)f->data;
RET CV(obj->listenerPosition);
} EI(keyStr=="speedOfSound")
{
AudioWorld*obj=(AudioWorld*)f->data;
RET CV(obj->speedOfSound);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void AudioWorld_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="listenerVelocity")
{
AudioWorld*obj=(AudioWorld*)f->data;
obj->listenerVelocity=val_to_c<decltype(obj->listenerVelocity)>::f(ctx,value);
} EI(keyStr=="dopplerFactor")
{
AudioWorld*obj=(AudioWorld*)f->data;
obj->dopplerFactor=val_to_c<decltype(obj->dopplerFactor)>::f(ctx,value);
} EI(keyStr=="listenerPosition")
{
AudioWorld*obj=(AudioWorld*)f->data;
obj->listenerPosition=val_to_c<decltype(obj->listenerPosition)>::f(ctx,value);
} EI(keyStr=="speedOfSound")
{
AudioWorld*obj=(AudioWorld*)f->data;
obj->speedOfSound=val_to_c<decltype(obj->speedOfSound)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV AudioWorld_destroySource(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioWorld::destroySource" EAOE));
AudioWorld*f;
f=(AudioWorld*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],AudioSource *))
{
( f->destroySource(val_to_c<std::remove_reference<AudioSource *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioWorld::destroySource.")));
RET CN;
}

SV AudioWorld_getSources(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioWorld::getSources" EAOE));
AudioWorld*f;
f=(AudioWorld*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getSources());
;
}
CATE(TE,UFOF("AudioWorld::getSources.")));
RET CN;
}

SV AudioWorld_addToAudioDevice(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioWorld::addToAudioDevice" EAOE));
AudioWorld*f;
f=(AudioWorld*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],AudioDevice *))
{
( f->addToAudioDevice(val_to_c<std::remove_reference<AudioDevice *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioWorld::addToAudioDevice.")));
RET CN;
}

SV AudioWorld_createSource(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioWorld::createSource" EAOE));
AudioWorld*f;
f=(AudioWorld*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],Audio *))
{
RET CV( f->createSource(val_to_c<std::remove_reference<Audio *>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("AudioWorld::createSource.")));
RET CN;
}

SV AudioWorld_removeFromAudioDevice(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioWorld::removeFromAudioDevice" EAOE));
AudioWorld*f;
f=(AudioWorld*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],AudioDevice *))
{
( f->removeFromAudioDevice(val_to_c<std::remove_reference<AudioDevice *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioWorld::removeFromAudioDevice.")));
RET CN;
}

SV AudioWorld_clearSources(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioWorld::clearSources" EAOE));
AudioWorld*f;
f=(AudioWorld*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->clearSources());
RET CN;
}
CATE(TE,UFOF("AudioWorld::clearSources.")));
RET CN;
}

void GuiPlacer_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GuiPlacer))
CATE(TE,"GuiPlacer::__del__ expects GuiPlacer as first argument."));

DELETE((GuiPlacer*)f->data);
}SV GuiPlacer_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer's constructor" EAOE));
if(!TS(a[0],GuiPlacer))
CATE(TE,"GuiPlacer's constructor expects GuiPlacer as first argument."));
if(a.getCount()==5)
if(true&&TS(a[1],ImGui *)&&TS(a[2],int)&&TS(a[3],int)&&TS(a[4],size_t))
RET STG::createNativeObject(GuiPlacer_funcs,NEW(GuiPlacer,val_to_c<ImGui *>::f(ctx,a[1]),val_to_c<int>::f(ctx,a[2]),val_to_c<int>::f(ctx,a[3]),val_to_c<size_t>::f(ctx,a[4])),EXT->GuiPlacer_typeID);
CATE(TE,UFOF("GuiPlacer's constructor.")));
RET CN;
}

SV GuiPlacer_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GuiPlacer");
EI(keyStr=="__new__")
RET CNF(GuiPlacer_new);
EI(keyStr=="__call__")
RET CNF(GuiPlacer_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GuiPlacer_new);
 EI(keyStr == "button")
RET CNF(GuiPlacer_button);
 EI(keyStr == "label")
RET CNF(GuiPlacer_label);
 EI(keyStr == "placer")
RET CNF(GuiPlacer_placer);
 EI(keyStr == "advanceY")
RET CNF(GuiPlacer_advanceY);
 EI(keyStr == "resetY")
RET CNF(GuiPlacer_resetY);
 EI(keyStr == "setXOrigin")
RET CNF(GuiPlacer_setXOrigin);
 EI(keyStr == "getXOriginMode")
RET CNF(GuiPlacer_getXOriginMode);
 EI(keyStr == "getXOrigin")
RET CNF(GuiPlacer_getXOrigin);
 EI(keyStr == "getPadding")
RET CNF(GuiPlacer_getPadding);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GuiPlacer_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GuiPlacer_advanceY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::advanceY" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->advanceY());
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const GuiPlacer &))
{
( f->advanceY(val_to_c<std::remove_reference<const GuiPlacer &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GuiPlacer::advanceY.")));
RET CN;
}

SV GuiPlacer_placer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::placer" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t))
{
RET CV( f->placer(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("GuiPlacer::placer.")));
RET CN;
}

SV GuiPlacer_getPadding(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::getPadding" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getPadding());
;
}
CATE(TE,UFOF("GuiPlacer::getPadding.")));
RET CN;
}

SV GuiPlacer_button(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::button" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0])->data;

if(a.getCount()==4)
if(1&&TS(a[1],const char *)&&TS(a[2],size_t)&&TS(a[3],size_t))
{
RET CV( f->button(val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[3])));
;
}
CATE(TE,UFOF("GuiPlacer::button.")));
RET CN;
}

SV GuiPlacer_label(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::label" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const char *))
{
( f->label(val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GuiPlacer::label.")));
RET CN;
}

SV GuiPlacer_resetY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::resetY" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->resetY());
RET CN;
}
CATE(TE,UFOF("GuiPlacer::resetY.")));
RET CN;
}

SV GuiPlacer_getXOriginMode(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::getXOriginMode" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXOriginMode());
;
}
CATE(TE,UFOF("GuiPlacer::getXOriginMode.")));
RET CN;
}

SV GuiPlacer_setXOrigin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::setXOrigin" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],XOrigin)&&TS(a[2],int))
{
( f->setXOrigin(val_to_c<std::remove_reference<XOrigin>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GuiPlacer::setXOrigin.")));
RET CN;
}

SV GuiPlacer_getXOrigin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GuiPlacer::getXOrigin" EAOE));
GuiPlacer*f;
f=(GuiPlacer*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXOrigin());
;
}
CATE(TE,UFOF("GuiPlacer::getXOrigin.")));
RET CN;
}

void ImGui_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,ImGui))
CATE(TE,"ImGui::__del__ expects ImGui as first argument."));

DELETE((ImGui*)f->data);
}SV ImGui_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui's constructor" EAOE));
if(!TS(a[0],ImGui))
CATE(TE,"ImGui's constructor expects ImGui as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(ImGui_funcs,NEW(ImGui),EXT->ImGui_typeID);
CATE(TE,UFOF("ImGui's constructor.")));
RET CN;
}

SV ImGui_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("ImGui");
EI(keyStr=="__new__")
RET CNF(ImGui_new);
EI(keyStr=="__call__")
RET CNF(ImGui_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(ImGui_new);
 EI(keyStr == "rectangle")
RET CNF(ImGui_rectangle);
 EI(keyStr == "beginContainer")
RET CNF(ImGui_beginContainer);
 EI(keyStr == "endContainer")
RET CNF(ImGui_endContainer);
 EI(keyStr == "verticalScrollBar")
RET CNF(ImGui_verticalScrollBar);
 EI(keyStr == "horizontalScrollBar")
RET CNF(ImGui_horizontalScrollBar);
 EI(keyStr == "button")
RET CNF(ImGui_button);
 EI(keyStr == "label")
RET CNF(ImGui_label);
 EI(keyStr == "render")
RET CNF(ImGui_render);
 EI(keyStr=="buttonTextColor")
{
ImGui*obj=(ImGui*)f->data;
RET CV(obj->buttonTextColor);
} EI(keyStr=="labelColor")
{
ImGui*obj=(ImGui*)f->data;
RET CV(obj->labelColor);
} EI(keyStr=="textSize")
{
ImGui*obj=(ImGui*)f->data;
RET CV(obj->textSize);
} EI(keyStr=="scrollSpeed")
{
ImGui*obj=(ImGui*)f->data;
RET CV(obj->scrollSpeed);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void ImGui_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="buttonTextColor")
{
ImGui*obj=(ImGui*)f->data;
obj->buttonTextColor=val_to_c<decltype(obj->buttonTextColor)>::f(ctx,value);
} EI(keyStr=="labelColor")
{
ImGui*obj=(ImGui*)f->data;
obj->labelColor=val_to_c<decltype(obj->labelColor)>::f(ctx,value);
} EI(keyStr=="textSize")
{
ImGui*obj=(ImGui*)f->data;
obj->textSize=val_to_c<decltype(obj->textSize)>::f(ctx,value);
} EI(keyStr=="scrollSpeed")
{
ImGui*obj=(ImGui*)f->data;
obj->scrollSpeed=val_to_c<decltype(obj->scrollSpeed)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV ImGui_endContainer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui::endContainer" EAOE));
ImGui*f;
f=(ImGui*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],Container *))
{
( f->endContainer(val_to_c<std::remove_reference<Container *>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("ImGui::endContainer.")));
RET CN;
}

SV ImGui_render(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui::render" EAOE));
ImGui*f;
f=(ImGui*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->render());
RET CN;
}
CATE(TE,UFOF("ImGui::render.")));
RET CN;
}

SV ImGui_beginContainer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui::beginContainer" EAOE));
ImGui*f;
f=(ImGui*)((NO)a[0])->data;

CATE(TE,UFOF("ImGui::beginContainer.")));
RET CN;
}

SV ImGui_button(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui::button" EAOE));
ImGui*f;
f=(ImGui*)((NO)a[0])->data;

if(a.getCount()==6)
if(1&&TS(a[1],const char *)&&TS(a[2],int)&&TS(a[3],int)&&TS(a[4],int)&&TS(a[5],int))
{
RET CV( f->button(val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[5])));
;
}
CATE(TE,UFOF("ImGui::button.")));
RET CN;
}

SV ImGui_label(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui::label" EAOE));
ImGui*f;
f=(ImGui*)((NO)a[0])->data;

if(a.getCount()==6)
if(1&&TS(a[1],const char *)&&TS(a[2],int)&&TS(a[3],int)&&TS(a[4],bool)&&TS(a[5],bool))
{
RET CV( f->label(val_to_c<std::remove_reference<const char *>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<bool>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<bool>::type>::f(ctx,a[5])));
;
}
CATE(TE,UFOF("ImGui::label.")));
RET CN;
}

SV ImGui_verticalScrollBar(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui::verticalScrollBar" EAOE));
ImGui*f;
f=(ImGui*)((NO)a[0])->data;

if(a.getCount()==8)
if(1&&TS(a[1],int)&&TS(a[2],int)&&TS(a[3],int)&&TS(a[4],int)&&TS(a[5],bool)&&TS(a[6],bool)&&TS(a[7],ScrollBar *))
{
( f->verticalScrollBar(val_to_c<std::remove_reference<int>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<bool>::type>::f(ctx,a[5]), val_to_c<std::remove_reference<bool>::type>::f(ctx,a[6]), val_to_c<std::remove_reference<ScrollBar *>::type>::f(ctx,a[7])));
RET CN;
}
CATE(TE,UFOF("ImGui::verticalScrollBar.")));
RET CN;
}

SV ImGui_horizontalScrollBar(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui::horizontalScrollBar" EAOE));
ImGui*f;
f=(ImGui*)((NO)a[0])->data;

if(a.getCount()==8)
if(1&&TS(a[1],int)&&TS(a[2],int)&&TS(a[3],int)&&TS(a[4],int)&&TS(a[5],bool)&&TS(a[6],bool)&&TS(a[7],ScrollBar *))
{
( f->horizontalScrollBar(val_to_c<std::remove_reference<int>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<bool>::type>::f(ctx,a[5]), val_to_c<std::remove_reference<bool>::type>::f(ctx,a[6]), val_to_c<std::remove_reference<ScrollBar *>::type>::f(ctx,a[7])));
RET CN;
}
CATE(TE,UFOF("ImGui::horizontalScrollBar.")));
RET CN;
}

SV ImGui_rectangle(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"ImGui::rectangle" EAOE));
ImGui*f;
f=(ImGui*)((NO)a[0])->data;

if(a.getCount()==11)
if(1&&TS(a[1],int)&&TS(a[2],int)&&TS(a[3],int)&&TS(a[4],int)&&TS(a[5],float)&&TS(a[6],float)&&TS(a[7],float)&&TS(a[8],float)&&TS(a[9],Float3)&&TS(a[10],Float4))
{
( f->rectangle(val_to_c<std::remove_reference<int>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<int>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[5]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[6]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[7]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[8]), val_to_c<std::remove_reference<Float3>::type>::f(ctx,a[9]), val_to_c<std::remove_reference<Float4>::type>::f(ctx,a[10])));
RET CN;
}
CATE(TE,UFOF("ImGui::rectangle.")));
RET CN;
}

void StringList_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<String>))
CATE(TE,"StringList::__del__ expects StringList as first argument."));

DELETE((List<String>*)f->data);
}SV StringList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList's constructor" EAOE));
if(!TS(a[0],List<String>))
CATE(TE,"StringList's constructor expects StringList as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(StringList_funcs,NEW(List<String>),EXT->StringList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],std::size_t))
RET STG::createNativeObject(StringList_funcs,NEW(List<String>,val_to_c<std::size_t>::f(ctx,a[1])),EXT->StringList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const List<String> &))
RET STG::createNativeObject(StringList_funcs,NEW(List<String>,val_to_c<const List<String> &>::f(ctx,a[1])),EXT->StringList_typeID);
CATE(TE,UFOF("StringList's constructor.")));
RET CN;
}

SV StringList_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("StringList");
EI(keyStr=="__new__")
RET CNF(StringList_new);
EI(keyStr=="__call__")
RET CNF(StringList_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(StringList_new);
 EI(keyStr == "__eq__")
RET CNF(StringList___eq__);
 EI(keyStr == "__neq__")
RET CNF(StringList___neq__);
 EI(keyStr == "get")
RET CNF(StringList_get);
 EI(keyStr == "set")
RET CNF(StringList_set);
 EI(keyStr == "getCount")
RET CNF(StringList_getCount);
 EI(keyStr == "getData")
RET CNF(StringList_getData);
 EI(keyStr == "append")
RET CNF(StringList_append);
 EI(keyStr == "insert")
RET CNF(StringList_insert);
 EI(keyStr == "remove")
RET CNF(StringList_remove);
 EI(keyStr == "clear")
RET CNF(StringList_clear);
 EI(keyStr == "find")
RET CNF(StringList_find);
 EI(keyStr == "copy")
RET CNF(StringList_copy);
 EI(keyStr == "in")
RET CNF(StringList_in);
 EI(keyStr == "begin")
RET CNF(StringList_begin);
 EI(keyStr == "end")
RET CNF(StringList_end);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void StringList_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV StringList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::insert" EAOE));
List<String>*f;
f=(List<String>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],String))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<String>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<String> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<String> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("StringList::insert.")));
RET CN;
}

SV StringList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::begin" EAOE));
List<String>*f;
f=(List<String>*)((NO)a[0])->data;

CATE(TE,UFOF("StringList::begin.")));
RET CN;
}

SV StringList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::set" EAOE));
List<String>*f;
f=(List<String>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],String))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<String>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("StringList::set.")));
RET CN;
}

SV StringList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::end" EAOE));
List<String>*f;
f=(List<String>*)((NO)a[0])->data;

CATE(TE,UFOF("StringList::end.")));
RET CN;
}

SV StringList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::get" EAOE));
List<String>*f;
f=(List<String>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("StringList::get.")));
RET CN;
}

SV StringList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::clear" EAOE));
List<String>*f;
f=(List<String>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("StringList::clear.")));
RET CN;
}

SV StringList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::copy" EAOE));
List<String>*f;
f=(List<String>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("StringList::copy.")));
RET CN;
}

SV StringList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::remove" EAOE));
List<String>*f;
f=(List<String>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("StringList::remove.")));
RET CN;
}

SV StringList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::in" EAOE));
List<String>*f;
f=(List<String>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],String))
{
RET CV( f->in(val_to_c<std::remove_reference<String>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("StringList::in.")));
RET CN;
}

SV StringList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::getCount" EAOE));
List<String>*f;
f=(List<String>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("StringList::getCount.")));
RET CN;
}

SV StringList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::getData" EAOE));
List<String>*f;
f=(List<String>*)((NO)a[0])->data;

CATE(TE,UFOF("StringList::getData.")));
RET CN;
}

SV StringList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::__eq__" EAOE));
List<String>*f;
f=(List<String>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<String> &))
{
auto v=val_to_c<std::remove_reference<const List<String> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("StringList::__eq__.")));
RET CN;
}

SV StringList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::find" EAOE));
List<String>*f;
f=(List<String>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],String))
{
RET CV( f->find(val_to_c<std::remove_reference<String>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("StringList::find.")));
RET CN;
}

SV StringList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::append" EAOE));
List<String>*f;
f=(List<String>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],String))
{
( f->append(val_to_c<std::remove_reference<String>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<String> &))
{
( f->append(val_to_c<std::remove_reference<const List<String> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("StringList::append.")));
RET CN;
}

SV StringList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"StringList::__neq__" EAOE));
List<String>*f;
f=(List<String>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<String> &))
{
auto v=val_to_c<std::remove_reference<const List<String> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("StringList::__neq__.")));
RET CN;
}

void Application_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Application))
CATE(TE,"Application::__del__ expects Application as first argument."));

DELETE((Application*)f->data);
}SV Application_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application's constructor" EAOE));
if(!TS(a[0],Application))
CATE(TE,"Application's constructor expects Application as first argument."));
if(a.getCount()==2)
if(true&&TS(a[1],const char *))
RET STG::createNativeObject(Application_funcs,NEW(Application,val_to_c<const char *>::f(ctx,a[1])),EXT->Application_typeID);
CATE(TE,UFOF("Application's constructor.")));
RET CN;
}

SV Application_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Application");
EI(keyStr=="__new__")
RET CNF(Application_new);
EI(keyStr=="__call__")
RET CNF(Application_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Application_new);
 EI(keyStr == "mainloop")
RET CNF(Application_mainloop);
 EI(keyStr == "getPlatform")
RET CNF(Application_getPlatform);
 EI(keyStr == "getResourceManager")
RET CNF(Application_getResourceManager);
 EI(keyStr == "getGfxApi")
RET CNF(Application_getGfxApi);
 EI(keyStr == "getFilesystem")
RET CNF(Application_getFilesystem);
 EI(keyStr == "getDebugDrawer")
RET CNF(Application_getDebugDrawer);
 EI(keyStr == "getFreeType")
RET CNF(Application_getFreeType);
 EI(keyStr == "getAudioDevice")
RET CNF(Application_getAudioDevice);
 EI(keyStr == "getScriptEngine")
RET CNF(Application_getScriptEngine);
 EI(keyStr == "setNextScript")
RET CNF(Application_setNextScript);
 EI(keyStr == "getNextScript")
RET CNF(Application_getNextScript);
 EI(keyStr == "getScript")
RET CNF(Application_getScript);
 EI(keyStr == "getStats")
RET CNF(Application_getStats);
 EI(keyStr=="fixedTimestep")
{
Application*obj=(Application*)f->data;
RET CV(obj->fixedTimestep);
} EI(keyStr=="running")
{
Application*obj=(Application*)f->data;
RET CV(obj->running);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Application_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="fixedTimestep")
{
Application*obj=(Application*)f->data;
obj->fixedTimestep=val_to_c<decltype(obj->fixedTimestep)>::f(ctx,value);
} EI(keyStr=="running")
{
Application*obj=(Application*)f->data;
obj->running=val_to_c<decltype(obj->running)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Application_getAudioDevice(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getAudioDevice" EAOE));
Application*f;
f=(Application*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getAudioDevice());
;
}
CATE(TE,UFOF("Application::getAudioDevice.")));
RET CN;
}

SV Application_getGfxApi(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getGfxApi" EAOE));
Application*f;
f=(Application*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGfxApi());
;
}
CATE(TE,UFOF("Application::getGfxApi.")));
RET CN;
}

SV Application_getResourceManager(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getResourceManager" EAOE));
Application*f;
f=(Application*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getResourceManager());
;
}
CATE(TE,UFOF("Application::getResourceManager.")));
RET CN;
}

SV Application_mainloop(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::mainloop" EAOE));
Application*f;
f=(Application*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->mainloop());
RET CN;
}
CATE(TE,UFOF("Application::mainloop.")));
RET CN;
}

SV Application_getFilesystem(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getFilesystem" EAOE));
Application*f;
f=(Application*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilesystem());
;
}
CATE(TE,UFOF("Application::getFilesystem.")));
RET CN;
}

SV Application_getPlatform(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getPlatform" EAOE));
Application*f;
f=(Application*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getPlatform());
;
}
CATE(TE,UFOF("Application::getPlatform.")));
RET CN;
}

SV Application_getNextScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getNextScript" EAOE));
Application*f;
f=(Application*)((NO)a[0])->data;

CATE(TE,UFOF("Application::getNextScript.")));
RET CN;
}

SV Application_getScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getScript" EAOE));
Application*f;
f=(Application*)((NO)a[0])->data;

CATE(TE,UFOF("Application::getScript.")));
RET CN;
}

SV Application_getStats(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getStats" EAOE));
Application*f;
f=(Application*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getStats());
;
}
CATE(TE,UFOF("Application::getStats.")));
RET CN;
}

SV Application_setNextScript(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::setNextScript" EAOE));
Application*f;
f=(Application*)((NO)a[0])->data;

CATE(TE,UFOF("Application::setNextScript.")));
RET CN;
}

SV Application_getDebugDrawer(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getDebugDrawer" EAOE));
Application*f;
f=(Application*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDebugDrawer());
;
}
CATE(TE,UFOF("Application::getDebugDrawer.")));
RET CN;
}

SV Application_getScriptEngine(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getScriptEngine" EAOE));
Application*f;
f=(Application*)((NO)a[0])->data;

CATE(TE,UFOF("Application::getScriptEngine.")));
RET CN;
}

SV Application_getFreeType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Application::getFreeType" EAOE));
Application*f;
f=(Application*)((NO)a[0])->data;

CATE(TE,UFOF("Application::getFreeType.")));
RET CN;
}

void LightPointData_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,LightPointData))
CATE(TE,"LightPointData::__del__ expects LightPointData as first argument."));

DELETE((LightPointData*)f->data);
}SV LightPointData_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"LightPointData's constructor" EAOE));
if(!TS(a[0],LightPointData))
CATE(TE,"LightPointData's constructor expects LightPointData as first argument."));
#define fjis LightPointData
RET STG::createNativeObject(LightPointData_funcs,NEW(fjis),EXT->LightPointData_typeID);
}

SV LightPointData_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("LightPointData");
EI(keyStr=="__new__")
RET CNF(LightPointData_new);
EI(keyStr=="__call__")
RET CNF(LightPointData_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(LightPointData_new);
 EI(keyStr=="position")
{
LightPointData*obj=(LightPointData*)f->data;
RET CV(obj->position);
} EI(keyStr=="radius")
{
LightPointData*obj=(LightPointData*)f->data;
RET CV(obj->radius);
} EI(keyStr=="singlePassShadowMap")
{
LightPointData*obj=(LightPointData*)f->data;
RET CV(obj->singlePassShadowMap);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void LightPointData_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="position")
{
LightPointData*obj=(LightPointData*)f->data;
obj->position=val_to_c<decltype(obj->position)>::f(ctx,value);
} EI(keyStr=="radius")
{
LightPointData*obj=(LightPointData*)f->data;
obj->radius=val_to_c<decltype(obj->radius)>::f(ctx,value);
} EI(keyStr=="singlePassShadowMap")
{
LightPointData*obj=(LightPointData*)f->data;
obj->singlePassShadowMap=val_to_c<decltype(obj->singlePassShadowMap)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

void Float4_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T4<float>))
CATE(TE,"Float4::__del__ expects Float4 as first argument."));

DELETE((T4<float>*)f->data);
}SV Float4_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4's constructor" EAOE));
if(!TS(a[0],T4<float>))
CATE(TE,"Float4's constructor expects Float4 as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(Float4_funcs,NEW(T4<float>),EXT->Float4_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],float))
RET STG::createNativeObject(Float4_funcs,NEW(T4<float>,val_to_c<float>::f(ctx,a[1])),EXT->Float4_typeID);
if(a.getCount()==5)
if(true&&TS(a[1],float)&&TS(a[2],float)&&TS(a[3],float)&&TS(a[4],float))
RET STG::createNativeObject(Float4_funcs,NEW(T4<float>,val_to_c<float>::f(ctx,a[1]),val_to_c<float>::f(ctx,a[2]),val_to_c<float>::f(ctx,a[3]),val_to_c<float>::f(ctx,a[4])),EXT->Float4_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T4<float> &))
RET STG::createNativeObject(Float4_funcs,NEW(T4<float>,val_to_c<const T4<float> &>::f(ctx,a[1])),EXT->Float4_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T4<int32_t> &))
RET STG::createNativeObject(Float4_funcs,NEW(T4<float>,val_to_c<const T4<int32_t> &>::f(ctx,a[1])),EXT->Float4_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T4<uint32_t> &))
RET STG::createNativeObject(Float4_funcs,NEW(T4<float>,val_to_c<const T4<uint32_t> &>::f(ctx,a[1])),EXT->Float4_typeID);
CATE(TE,UFOF("Float4's constructor.")));
RET CN;
}

SV Float4_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Float4");
EI(keyStr=="__new__")
RET CNF(Float4_new);
EI(keyStr=="__call__")
RET CNF(Float4_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Float4_new);
 EI(keyStr == "__add__")
RET CNF(Float4___add__);
 EI(keyStr == "__sub__")
RET CNF(Float4___sub__);
 EI(keyStr == "__mul__")
RET CNF(Float4___mul__);
 EI(keyStr == "__div__")
RET CNF(Float4___div__);
 EI(keyStr == "__eq__")
RET CNF(Float4___eq__);
 EI(keyStr == "__neq__")
RET CNF(Float4___neq__);
 EI(keyStr == "__less__")
RET CNF(Float4___less__);
 EI(keyStr == "__grtr__")
RET CNF(Float4___grtr__);
 EI(keyStr == "__leq__")
RET CNF(Float4___leq__);
 EI(keyStr == "__geq__")
RET CNF(Float4___geq__);
 EI(keyStr == "sum")
RET CNF(Float4_sum);
 EI(keyStr == "length")
RET CNF(Float4_length);
 EI(keyStr == "lengthSquared")
RET CNF(Float4_lengthSquared);
 EI(keyStr == "dot")
RET CNF(Float4_dot);
 EI(keyStr == "distance")
RET CNF(Float4_distance);
 EI(keyStr == "distanceSquared")
RET CNF(Float4_distanceSquared);
 EI(keyStr == "normalize")
RET CNF(Float4_normalize);
 EI(keyStr == "getXY")
RET CNF(Float4_getXY);
 EI(keyStr == "setXY")
RET CNF(Float4_setXY);
 EI(keyStr == "getXZ")
RET CNF(Float4_getXZ);
 EI(keyStr == "setXZ")
RET CNF(Float4_setXZ);
 EI(keyStr == "getXW")
RET CNF(Float4_getXW);
 EI(keyStr == "setXW")
RET CNF(Float4_setXW);
 EI(keyStr == "getYX")
RET CNF(Float4_getYX);
 EI(keyStr == "setYX")
RET CNF(Float4_setYX);
 EI(keyStr == "getYZ")
RET CNF(Float4_getYZ);
 EI(keyStr == "setYZ")
RET CNF(Float4_setYZ);
 EI(keyStr == "getYW")
RET CNF(Float4_getYW);
 EI(keyStr == "setYW")
RET CNF(Float4_setYW);
 EI(keyStr == "getZX")
RET CNF(Float4_getZX);
 EI(keyStr == "setZX")
RET CNF(Float4_setZX);
 EI(keyStr == "getZY")
RET CNF(Float4_getZY);
 EI(keyStr == "setZY")
RET CNF(Float4_setZY);
 EI(keyStr == "getZW")
RET CNF(Float4_getZW);
 EI(keyStr == "setZW")
RET CNF(Float4_setZW);
 EI(keyStr == "getWX")
RET CNF(Float4_getWX);
 EI(keyStr == "setWX")
RET CNF(Float4_setWX);
 EI(keyStr == "getWY")
RET CNF(Float4_getWY);
 EI(keyStr == "setWY")
RET CNF(Float4_setWY);
 EI(keyStr == "getWZ")
RET CNF(Float4_getWZ);
 EI(keyStr == "setWZ")
RET CNF(Float4_setWZ);
 EI(keyStr == "getXYZ")
RET CNF(Float4_getXYZ);
 EI(keyStr == "setXYZ")
RET CNF(Float4_setXYZ);
 EI(keyStr == "getXYW")
RET CNF(Float4_getXYW);
 EI(keyStr == "setXYW")
RET CNF(Float4_setXYW);
 EI(keyStr == "getXZY")
RET CNF(Float4_getXZY);
 EI(keyStr == "setXZY")
RET CNF(Float4_setXZY);
 EI(keyStr == "getXZW")
RET CNF(Float4_getXZW);
 EI(keyStr == "setXZW")
RET CNF(Float4_setXZW);
 EI(keyStr == "getXWZ")
RET CNF(Float4_getXWZ);
 EI(keyStr == "setXWZ")
RET CNF(Float4_setXWZ);
 EI(keyStr == "getXWY")
RET CNF(Float4_getXWY);
 EI(keyStr == "setXWY")
RET CNF(Float4_setXWY);
 EI(keyStr == "getYXZ")
RET CNF(Float4_getYXZ);
 EI(keyStr == "setYXZ")
RET CNF(Float4_setYXZ);
 EI(keyStr == "getYXW")
RET CNF(Float4_getYXW);
 EI(keyStr == "setYXW")
RET CNF(Float4_setYXW);
 EI(keyStr == "getYZX")
RET CNF(Float4_getYZX);
 EI(keyStr == "setYZX")
RET CNF(Float4_setYZX);
 EI(keyStr == "getYZW")
RET CNF(Float4_getYZW);
 EI(keyStr == "setYZW")
RET CNF(Float4_setYZW);
 EI(keyStr == "getYWZ")
RET CNF(Float4_getYWZ);
 EI(keyStr == "setYWZ")
RET CNF(Float4_setYWZ);
 EI(keyStr == "getYWX")
RET CNF(Float4_getYWX);
 EI(keyStr == "setYWX")
RET CNF(Float4_setYWX);
 EI(keyStr == "getZXY")
RET CNF(Float4_getZXY);
 EI(keyStr == "setZXY")
RET CNF(Float4_setZXY);
 EI(keyStr == "getZXW")
RET CNF(Float4_getZXW);
 EI(keyStr == "setZXW")
RET CNF(Float4_setZXW);
 EI(keyStr == "getZYX")
RET CNF(Float4_getZYX);
 EI(keyStr == "setZYX")
RET CNF(Float4_setZYX);
 EI(keyStr == "getZYW")
RET CNF(Float4_getZYW);
 EI(keyStr == "setZYW")
RET CNF(Float4_setZYW);
 EI(keyStr == "getZWY")
RET CNF(Float4_getZWY);
 EI(keyStr == "setZWY")
RET CNF(Float4_setZWY);
 EI(keyStr == "getZWX")
RET CNF(Float4_getZWX);
 EI(keyStr == "setZWX")
RET CNF(Float4_setZWX);
 EI(keyStr == "getWXY")
RET CNF(Float4_getWXY);
 EI(keyStr == "setWXY")
RET CNF(Float4_setWXY);
 EI(keyStr == "getWXZ")
RET CNF(Float4_getWXZ);
 EI(keyStr == "setWXZ")
RET CNF(Float4_setWXZ);
 EI(keyStr == "getWYX")
RET CNF(Float4_getWYX);
 EI(keyStr == "setWYX")
RET CNF(Float4_setWYX);
 EI(keyStr == "getWYZ")
RET CNF(Float4_getWYZ);
 EI(keyStr == "setWYZ")
RET CNF(Float4_setWYZ);
 EI(keyStr == "getWZY")
RET CNF(Float4_getWZY);
 EI(keyStr == "setWZY")
RET CNF(Float4_setWZY);
 EI(keyStr == "getWZX")
RET CNF(Float4_getWZX);
 EI(keyStr == "setWZX")
RET CNF(Float4_setWZX);
 EI(keyStr == "getXYZW")
RET CNF(Float4_getXYZW);
 EI(keyStr == "setXYZW")
RET CNF(Float4_setXYZW);
 EI(keyStr == "getXYWZ")
RET CNF(Float4_getXYWZ);
 EI(keyStr == "setXYWZ")
RET CNF(Float4_setXYWZ);
 EI(keyStr == "getXZYW")
RET CNF(Float4_getXZYW);
 EI(keyStr == "setXZYW")
RET CNF(Float4_setXZYW);
 EI(keyStr == "getXZWY")
RET CNF(Float4_getXZWY);
 EI(keyStr == "setXZWY")
RET CNF(Float4_setXZWY);
 EI(keyStr == "getXWZY")
RET CNF(Float4_getXWZY);
 EI(keyStr == "setXWZY")
RET CNF(Float4_setXWZY);
 EI(keyStr == "getXWYZ")
RET CNF(Float4_getXWYZ);
 EI(keyStr == "setXWYZ")
RET CNF(Float4_setXWYZ);
 EI(keyStr == "getYXZW")
RET CNF(Float4_getYXZW);
 EI(keyStr == "setYXZW")
RET CNF(Float4_setYXZW);
 EI(keyStr == "getYXWZ")
RET CNF(Float4_getYXWZ);
 EI(keyStr == "setYXWZ")
RET CNF(Float4_setYXWZ);
 EI(keyStr == "getYZXW")
RET CNF(Float4_getYZXW);
 EI(keyStr == "setYZXW")
RET CNF(Float4_setYZXW);
 EI(keyStr == "getYZWX")
RET CNF(Float4_getYZWX);
 EI(keyStr == "setYZWX")
RET CNF(Float4_setYZWX);
 EI(keyStr == "getYWZX")
RET CNF(Float4_getYWZX);
 EI(keyStr == "setYWZX")
RET CNF(Float4_setYWZX);
 EI(keyStr == "getYWXZ")
RET CNF(Float4_getYWXZ);
 EI(keyStr == "setYWXZ")
RET CNF(Float4_setYWXZ);
 EI(keyStr == "getZYXW")
RET CNF(Float4_getZYXW);
 EI(keyStr == "setZYXW")
RET CNF(Float4_setZYXW);
 EI(keyStr == "getZYWX")
RET CNF(Float4_getZYWX);
 EI(keyStr == "setZYWX")
RET CNF(Float4_setZYWX);
 EI(keyStr == "getZXYW")
RET CNF(Float4_getZXYW);
 EI(keyStr == "setZXYW")
RET CNF(Float4_setZXYW);
 EI(keyStr == "getZXWY")
RET CNF(Float4_getZXWY);
 EI(keyStr == "setZXWY")
RET CNF(Float4_setZXWY);
 EI(keyStr == "getZWXY")
RET CNF(Float4_getZWXY);
 EI(keyStr == "setZWXY")
RET CNF(Float4_setZWXY);
 EI(keyStr == "getZWYX")
RET CNF(Float4_getZWYX);
 EI(keyStr == "setZWYX")
RET CNF(Float4_setZWYX);
 EI(keyStr == "getWYZX")
RET CNF(Float4_getWYZX);
 EI(keyStr == "setWYZX")
RET CNF(Float4_setWYZX);
 EI(keyStr == "getWYXZ")
RET CNF(Float4_getWYXZ);
 EI(keyStr == "setWYXZ")
RET CNF(Float4_setWYXZ);
 EI(keyStr == "getWZYX")
RET CNF(Float4_getWZYX);
 EI(keyStr == "setWZYX")
RET CNF(Float4_setWZYX);
 EI(keyStr == "getWZXY")
RET CNF(Float4_getWZXY);
 EI(keyStr == "setWZXY")
RET CNF(Float4_setWZXY);
 EI(keyStr == "getWXZY")
RET CNF(Float4_getWXZY);
 EI(keyStr == "setWXZY")
RET CNF(Float4_setWXZY);
 EI(keyStr == "getWXYZ")
RET CNF(Float4_getWXYZ);
 EI(keyStr == "setWXYZ")
RET CNF(Float4_setWXYZ);
 EI(keyStr=="x")
{
T4<float>*obj=(T4<float>*)f->data;
RET CV(obj->x);
} EI(keyStr=="y")
{
T4<float>*obj=(T4<float>*)f->data;
RET CV(obj->y);
} EI(keyStr=="z")
{
T4<float>*obj=(T4<float>*)f->data;
RET CV(obj->z);
} EI(keyStr=="w")
{
T4<float>*obj=(T4<float>*)f->data;
RET CV(obj->w);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Float4_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="x")
{
T4<float>*obj=(T4<float>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr=="y")
{
T4<float>*obj=(T4<float>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} EI(keyStr=="z")
{
T4<float>*obj=(T4<float>*)f->data;
obj->z=val_to_c<decltype(obj->z)>::f(ctx,value);
} EI(keyStr=="w")
{
T4<float>*obj=(T4<float>*)f->data;
obj->w=val_to_c<decltype(obj->w)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Float4_setZXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZXYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setZXYW(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZXYW.")));
RET CN;
}

SV Float4_setWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setWYZ(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWYZ.")));
RET CN;
}

SV Float4_setWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setWYX(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWYX.")));
RET CN;
}

SV Float4_getZWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZWYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWYX());
;
}
CATE(TE,UFOF("Float4::getZWYX.")));
RET CN;
}

SV Float4_getZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZW());
;
}
CATE(TE,UFOF("Float4::getZW.")));
RET CN;
}

SV Float4_getZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZY());
;
}
CATE(TE,UFOF("Float4::getZY.")));
RET CN;
}

SV Float4_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::distanceSquared" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Float4::distanceSquared.")));
RET CN;
}

SV Float4_getYXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYXZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZW());
;
}
CATE(TE,UFOF("Float4::getYXZW.")));
RET CN;
}

SV Float4_setYZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYZWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setYZWX(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYZWX.")));
RET CN;
}

SV Float4_getYWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYWZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWZX());
;
}
CATE(TE,UFOF("Float4::getYWZX.")));
RET CN;
}

SV Float4_getWZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWZXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZXY());
;
}
CATE(TE,UFOF("Float4::getWZXY.")));
RET CN;
}

SV Float4_getZYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZYXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYXW());
;
}
CATE(TE,UFOF("Float4::getZYXW.")));
RET CN;
}

SV Float4_setXWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXWYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setXWYZ(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXWYZ.")));
RET CN;
}

SV Float4_setZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setZY(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZY.")));
RET CN;
}

SV Float4_setZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setZX(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZX.")));
RET CN;
}

SV Float4_getZXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZXWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXWY());
;
}
CATE(TE,UFOF("Float4::getZXWY.")));
RET CN;
}

SV Float4_getXWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXWZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWZY());
;
}
CATE(TE,UFOF("Float4::getXWZY.")));
RET CN;
}

SV Float4_setZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setZW(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZW.")));
RET CN;
}

SV Float4_setZYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZYWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setZYWX(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZYWX.")));
RET CN;
}

SV Float4_getYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZX());
;
}
CATE(TE,UFOF("Float4::getYZX.")));
RET CN;
}

SV Float4_getXYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXYWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYWZ());
;
}
CATE(TE,UFOF("Float4::getXYWZ.")));
RET CN;
}

SV Float4_setYXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYXZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setYXZW(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYXZW.")));
RET CN;
}

SV Float4_getWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZY());
;
}
CATE(TE,UFOF("Float4::getWZY.")));
RET CN;
}

SV Float4_getWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZX());
;
}
CATE(TE,UFOF("Float4::getWZX.")));
RET CN;
}

SV Float4_getWZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWZYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZYX());
;
}
CATE(TE,UFOF("Float4::getWZYX.")));
RET CN;
}

SV Float4_setXWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXWZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setXWZY(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXWZY.")));
RET CN;
}

SV Float4_getZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXY());
;
}
CATE(TE,UFOF("Float4::getZXY.")));
RET CN;
}

SV Float4_setWZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWZYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setWZYX(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWZYX.")));
RET CN;
}

SV Float4_setZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setZYW(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZYW.")));
RET CN;
}

SV Float4_setZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setZYX(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZYX.")));
RET CN;
}

SV Float4_setXZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXZYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setXZYW(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXZYW.")));
RET CN;
}

SV Float4_getZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXW());
;
}
CATE(TE,UFOF("Float4::getZXW.")));
RET CN;
}

SV Float4_setYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setYZW(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYZW.")));
RET CN;
}

SV Float4_getYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWZ());
;
}
CATE(TE,UFOF("Float4::getYWZ.")));
RET CN;
}

SV Float4___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__leq__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("Float4::__leq__.")));
RET CN;
}

SV Float4_getYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWX());
;
}
CATE(TE,UFOF("Float4::getYWX.")));
RET CN;
}

SV Float4_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::sum" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("Float4::sum.")));
RET CN;
}

SV Float4_setYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setYZX(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYZX.")));
RET CN;
}

SV Float4_getXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZ());
;
}
CATE(TE,UFOF("Float4::getXYZ.")));
RET CN;
}

SV Float4_getZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZX());
;
}
CATE(TE,UFOF("Float4::getZX.")));
RET CN;
}

SV Float4_getXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYW());
;
}
CATE(TE,UFOF("Float4::getXYW.")));
RET CN;
}

SV Float4_setYWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYWZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setYWZX(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYWZX.")));
RET CN;
}

SV Float4_setWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setWXY(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWXY.")));
RET CN;
}

SV Float4_setWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setWXZ(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWXZ.")));
RET CN;
}

SV Float4_setZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setZXW(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZXW.")));
RET CN;
}

SV Float4_getXWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXWYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWYZ());
;
}
CATE(TE,UFOF("Float4::getXWYZ.")));
RET CN;
}

SV Float4_setWYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWYXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setWYXZ(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWYXZ.")));
RET CN;
}

SV Float4_setZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setZXY(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZXY.")));
RET CN;
}

SV Float4_getXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWY());
;
}
CATE(TE,UFOF("Float4::getXWY.")));
RET CN;
}

SV Float4_getYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXW());
;
}
CATE(TE,UFOF("Float4::getYXW.")));
RET CN;
}

SV Float4_getYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZ());
;
}
CATE(TE,UFOF("Float4::getYXZ.")));
RET CN;
}

SV Float4_setXYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXYWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setXYWZ(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXYWZ.")));
RET CN;
}

SV Float4_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::length" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("Float4::length.")));
RET CN;
}

SV Float4_setWXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWXZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setWXZY(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWXZY.")));
RET CN;
}

SV Float4_getYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZW());
;
}
CATE(TE,UFOF("Float4::getYZW.")));
RET CN;
}

SV Float4_setXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setXWZ(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXWZ.")));
RET CN;
}

SV Float4_setXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setXWY(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXWY.")));
RET CN;
}

SV Float4_getWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYZ());
;
}
CATE(TE,UFOF("Float4::getWYZ.")));
RET CN;
}

SV Float4_getWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYX());
;
}
CATE(TE,UFOF("Float4::getWYX.")));
RET CN;
}

SV Float4_getZYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZYWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYWX());
;
}
CATE(TE,UFOF("Float4::getZYWX.")));
RET CN;
}

SV Float4_getXYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXYZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZW());
;
}
CATE(TE,UFOF("Float4::getXYZW.")));
RET CN;
}

SV Float4_setZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setZWY(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZWY.")));
RET CN;
}

SV Float4_setZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setZWX(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZWX.")));
RET CN;
}

SV Float4_setWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setWX(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWX.")));
RET CN;
}

SV Float4_setWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setWY(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWY.")));
RET CN;
}

SV Float4_setWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setWZ(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWZ.")));
RET CN;
}

SV Float4_getZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWY());
;
}
CATE(TE,UFOF("Float4::getZWY.")));
RET CN;
}

SV Float4_getZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWX());
;
}
CATE(TE,UFOF("Float4::getZWX.")));
RET CN;
}

SV Float4_setYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setYXZ(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYXZ.")));
RET CN;
}

SV Float4_setYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setYXW(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYXW.")));
RET CN;
}

SV Float4_getXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWZ());
;
}
CATE(TE,UFOF("Float4::getXWZ.")));
RET CN;
}

SV Float4_getXZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXZWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZWY());
;
}
CATE(TE,UFOF("Float4::getXZWY.")));
RET CN;
}

SV Float4___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__less__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("Float4::__less__.")));
RET CN;
}

SV Float4_getZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYW());
;
}
CATE(TE,UFOF("Float4::getZYW.")));
RET CN;
}

SV Float4_setWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setWZY(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWZY.")));
RET CN;
}

SV Float4_setWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setWZX(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWZX.")));
RET CN;
}

SV Float4_setZYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZYXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setZYXW(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZYXW.")));
RET CN;
}

SV Float4_getYZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYZWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZWX());
;
}
CATE(TE,UFOF("Float4::getYZWX.")));
RET CN;
}

SV Float4_getZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYX());
;
}
CATE(TE,UFOF("Float4::getZYX.")));
RET CN;
}

SV Float4_getXZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXZYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZYW());
;
}
CATE(TE,UFOF("Float4::getXZYW.")));
RET CN;
}

SV Float4_setYXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYXWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setYXWZ(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYXWZ.")));
RET CN;
}

SV Float4___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__eq__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Float4::__eq__.")));
RET CN;
}

SV Float4_getWYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWYXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYXZ());
;
}
CATE(TE,UFOF("Float4::getWYXZ.")));
RET CN;
}

SV Float4_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::distance" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Float4::distance.")));
RET CN;
}

SV Float4_getXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZW());
;
}
CATE(TE,UFOF("Float4::getXZW.")));
RET CN;
}

SV Float4_setYZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYZXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setYZXW(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYZXW.")));
RET CN;
}

SV Float4_getZWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZWXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWXY());
;
}
CATE(TE,UFOF("Float4::getZWXY.")));
RET CN;
}

SV Float4_getXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZY());
;
}
CATE(TE,UFOF("Float4::getXZY.")));
RET CN;
}

SV Float4_getYZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYZXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZXW());
;
}
CATE(TE,UFOF("Float4::getYZXW.")));
RET CN;
}

SV Float4_setZWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZWYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setZWYX(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZWYX.")));
RET CN;
}

SV Float4___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__sub__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("Float4::__sub__.")));
RET CN;
}

SV Float4_getYXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYXWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXWZ());
;
}
CATE(TE,UFOF("Float4::getYXWZ.")));
RET CN;
}

SV Float4_setXZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXZWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setXZWY(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXZWY.")));
RET CN;
}

SV Float4_setYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setYWZ(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYWZ.")));
RET CN;
}

SV Float4_setYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setYWX(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYWX.")));
RET CN;
}

SV Float4_setYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setYZ(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYZ.")));
RET CN;
}

SV Float4_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYX.")));
RET CN;
}

SV Float4_setYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setYW(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYW.")));
RET CN;
}

SV Float4_getWXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWXYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXYZ());
;
}
CATE(TE,UFOF("Float4::getWXYZ.")));
RET CN;
}

SV Float4___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__neq__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("Float4::__neq__.")));
RET CN;
}

SV Float4_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::normalize" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("Float4::normalize.")));
RET CN;
}

SV Float4_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("Float4::getYX.")));
RET CN;
}

SV Float4_setXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setXZW(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXZW.")));
RET CN;
}

SV Float4_setXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setXZY(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXZY.")));
RET CN;
}

SV Float4_setXYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXYZW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setXYZW(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXYZW.")));
RET CN;
}

SV Float4_getYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYW());
;
}
CATE(TE,UFOF("Float4::getYW.")));
RET CN;
}

SV Float4_setWXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWXYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setWXYZ(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWXYZ.")));
RET CN;
}

SV Float4_getYWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYWXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWXZ());
;
}
CATE(TE,UFOF("Float4::getYWXZ.")));
RET CN;
}

SV Float4___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__mul__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Float4::__mul__.")));
RET CN;
}

SV Float4_getYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZ());
;
}
CATE(TE,UFOF("Float4::getYZ.")));
RET CN;
}

SV Float4_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::lengthSquared" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("Float4::lengthSquared.")));
RET CN;
}

SV Float4_getWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXY());
;
}
CATE(TE,UFOF("Float4::getWXY.")));
RET CN;
}

SV Float4_getWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXZ());
;
}
CATE(TE,UFOF("Float4::getWXZ.")));
RET CN;
}

SV Float4_getWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWX());
;
}
CATE(TE,UFOF("Float4::getWX.")));
RET CN;
}

SV Float4_getWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWY());
;
}
CATE(TE,UFOF("Float4::getWY.")));
RET CN;
}

SV Float4_getWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZ());
;
}
CATE(TE,UFOF("Float4::getWZ.")));
RET CN;
}

SV Float4_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXY.")));
RET CN;
}

SV Float4_getZXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getZXYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXYW());
;
}
CATE(TE,UFOF("Float4::getZXYW.")));
RET CN;
}

SV Float4___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__add__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("Float4::__add__.")));
RET CN;
}

SV Float4_setXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setXZ(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXZ.")));
RET CN;
}

SV Float4_getWYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWYZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYZX());
;
}
CATE(TE,UFOF("Float4::getWYZX.")));
RET CN;
}

SV Float4_setXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<float> &))
{
( f->setXW(val_to_c<std::remove_reference<const T2<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXW.")));
RET CN;
}

SV Float4_getWXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getWXZY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXZY());
;
}
CATE(TE,UFOF("Float4::getWXZY.")));
RET CN;
}

SV Float4_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("Float4::getXY.")));
RET CN;
}

SV Float4_setZXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZXWY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setZXWY(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZXWY.")));
RET CN;
}

SV Float4_setXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXYW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setXYW(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXYW.")));
RET CN;
}

SV Float4_getXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZ());
;
}
CATE(TE,UFOF("Float4::getXZ.")));
RET CN;
}

SV Float4_setWZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWZXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setWZXY(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWZXY.")));
RET CN;
}

SV Float4___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__grtr__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("Float4::__grtr__.")));
RET CN;
}

SV Float4_setZWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setZWXY" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setZWXY(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setZWXY.")));
RET CN;
}

SV Float4_getXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::getXW" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXW());
;
}
CATE(TE,UFOF("Float4::getXW.")));
RET CN;
}

SV Float4_setXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setXYZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<float> &))
{
( f->setXYZ(val_to_c<std::remove_reference<const T3<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setXYZ.")));
RET CN;
}

SV Float4___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__div__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("Float4::__div__.")));
RET CN;
}

SV Float4_setWYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setWYZX" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setWYZX(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setWYZX.")));
RET CN;
}

SV Float4_setYWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::setYWXZ" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
( f->setYWXZ(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Float4::setYWXZ.")));
RET CN;
}

SV Float4___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::__geq__" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
auto v=val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("Float4::__geq__.")));
RET CN;
}

SV Float4_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Float4::dot" EAOE));
T4<float>*f;
f=(T4<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<float> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T4<float> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("Float4::dot.")));
RET CN;
}

void FloatList_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<float>))
CATE(TE,"FloatList::__del__ expects FloatList as first argument."));

DELETE((List<float>*)f->data);
}SV FloatList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList's constructor" EAOE));
if(!TS(a[0],List<float>))
CATE(TE,"FloatList's constructor expects FloatList as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(FloatList_funcs,NEW(List<float>),EXT->FloatList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],std::size_t))
RET STG::createNativeObject(FloatList_funcs,NEW(List<float>,val_to_c<std::size_t>::f(ctx,a[1])),EXT->FloatList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const List<float> &))
RET STG::createNativeObject(FloatList_funcs,NEW(List<float>,val_to_c<const List<float> &>::f(ctx,a[1])),EXT->FloatList_typeID);
CATE(TE,UFOF("FloatList's constructor.")));
RET CN;
}

SV FloatList_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("FloatList");
EI(keyStr=="__new__")
RET CNF(FloatList_new);
EI(keyStr=="__call__")
RET CNF(FloatList_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(FloatList_new);
 EI(keyStr == "__eq__")
RET CNF(FloatList___eq__);
 EI(keyStr == "__neq__")
RET CNF(FloatList___neq__);
 EI(keyStr == "get")
RET CNF(FloatList_get);
 EI(keyStr == "set")
RET CNF(FloatList_set);
 EI(keyStr == "getCount")
RET CNF(FloatList_getCount);
 EI(keyStr == "getData")
RET CNF(FloatList_getData);
 EI(keyStr == "append")
RET CNF(FloatList_append);
 EI(keyStr == "insert")
RET CNF(FloatList_insert);
 EI(keyStr == "remove")
RET CNF(FloatList_remove);
 EI(keyStr == "clear")
RET CNF(FloatList_clear);
 EI(keyStr == "find")
RET CNF(FloatList_find);
 EI(keyStr == "copy")
RET CNF(FloatList_copy);
 EI(keyStr == "in")
RET CNF(FloatList_in);
 EI(keyStr == "begin")
RET CNF(FloatList_begin);
 EI(keyStr == "end")
RET CNF(FloatList_end);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void FloatList_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV FloatList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::insert" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],float))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<float> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<float> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("FloatList::insert.")));
RET CN;
}

SV FloatList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::begin" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0])->data;

CATE(TE,UFOF("FloatList::begin.")));
RET CN;
}

SV FloatList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::set" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],float))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("FloatList::set.")));
RET CN;
}

SV FloatList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::end" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0])->data;

CATE(TE,UFOF("FloatList::end.")));
RET CN;
}

SV FloatList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::get" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("FloatList::get.")));
RET CN;
}

SV FloatList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::clear" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("FloatList::clear.")));
RET CN;
}

SV FloatList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::copy" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("FloatList::copy.")));
RET CN;
}

SV FloatList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::remove" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("FloatList::remove.")));
RET CN;
}

SV FloatList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::in" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->in(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("FloatList::in.")));
RET CN;
}

SV FloatList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::getCount" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("FloatList::getCount.")));
RET CN;
}

SV FloatList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::getData" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0])->data;

CATE(TE,UFOF("FloatList::getData.")));
RET CN;
}

SV FloatList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::__eq__" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<float> &))
{
auto v=val_to_c<std::remove_reference<const List<float> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("FloatList::__eq__.")));
RET CN;
}

SV FloatList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::find" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->find(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("FloatList::find.")));
RET CN;
}

SV FloatList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::append" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->append(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<float> &))
{
( f->append(val_to_c<std::remove_reference<const List<float> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("FloatList::append.")));
RET CN;
}

SV FloatList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"FloatList::__neq__" EAOE));
List<float>*f;
f=(List<float>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<float> &))
{
auto v=val_to_c<std::remove_reference<const List<float> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("FloatList::__neq__.")));
RET CN;
}

void Container_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Container))
CATE(TE,"Container::__del__ expects Container as first argument."));

DELETE((Container*)f->data);
}SV Container_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Container's constructor" EAOE));
if(!TS(a[0],Container))
CATE(TE,"Container's constructor expects Container as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(Container_funcs,NEW(Container),EXT->Container_typeID);
CATE(TE,UFOF("Container's constructor.")));
RET CN;
}

SV Container_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Container");
EI(keyStr=="__new__")
RET CNF(Container_new);
EI(keyStr=="__call__")
RET CNF(Container_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Container_new);
 EI(keyStr=="vertical")
{
Container*obj=(Container*)f->data;
RET CV(obj->vertical);
} EI(keyStr=="horizonal")
{
Container*obj=(Container*)f->data;
RET CV(obj->horizonal);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Container_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="vertical")
{
Container*obj=(Container*)f->data;
obj->vertical=val_to_c<decltype(obj->vertical)>::f(ctx,value);
} EI(keyStr=="horizonal")
{
Container*obj=(Container*)f->data;
obj->horizonal=val_to_c<decltype(obj->horizonal)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

void LightDirectionalData_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,LightDirectionalData))
CATE(TE,"LightDirectionalData::__del__ expects LightDirectionalData as first argument."));

DELETE((LightDirectionalData*)f->data);
}SV LightDirectionalData_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"LightDirectionalData's constructor" EAOE));
if(!TS(a[0],LightDirectionalData))
CATE(TE,"LightDirectionalData's constructor expects LightDirectionalData as first argument."));
#define fjis LightDirectionalData
RET STG::createNativeObject(LightDirectionalData_funcs,NEW(fjis),EXT->LightDirectionalData_typeID);
}

SV LightDirectionalData_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("LightDirectionalData");
EI(keyStr=="__new__")
RET CNF(LightDirectionalData_new);
EI(keyStr=="__call__")
RET CNF(LightDirectionalData_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(LightDirectionalData_new);
 EI(keyStr=="direction")
{
LightDirectionalData*obj=(LightDirectionalData*)f->data;
RET CV(obj->direction);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void LightDirectionalData_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="direction")
{
LightDirectionalData*obj=(LightDirectionalData*)f->data;
obj->direction=val_to_c<decltype(obj->direction)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

void Matrix4x4_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Matrix4x4))
CATE(TE,"Matrix4x4::__del__ expects Matrix4x4 as first argument."));

DELETE((Matrix4x4*)f->data);
}SV Matrix4x4_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4's constructor" EAOE));
if(!TS(a[0],Matrix4x4))
CATE(TE,"Matrix4x4's constructor expects Matrix4x4 as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(Matrix4x4_funcs,NEW(Matrix4x4),EXT->Matrix4x4_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const Matrix3x3 &))
RET STG::createNativeObject(Matrix4x4_funcs,NEW(Matrix4x4,val_to_c<const Matrix3x3 &>::f(ctx,a[1])),EXT->Matrix4x4_typeID);
if(a.getCount()==5)
if(true&&TS(a[1],const Float4 &)&&TS(a[2],const Float4 &)&&TS(a[3],const Float4 &)&&TS(a[4],const Float4 &))
RET STG::createNativeObject(Matrix4x4_funcs,NEW(Matrix4x4,val_to_c<const Float4 &>::f(ctx,a[1]),val_to_c<const Float4 &>::f(ctx,a[2]),val_to_c<const Float4 &>::f(ctx,a[3]),val_to_c<const Float4 &>::f(ctx,a[4])),EXT->Matrix4x4_typeID);
CATE(TE,UFOF("Matrix4x4's constructor.")));
RET CN;
}

SV Matrix4x4_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Matrix4x4");
EI(keyStr=="__new__")
RET CNF(Matrix4x4_new);
EI(keyStr=="__call__")
RET CNF(Matrix4x4_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Matrix4x4_new);
 EI(keyStr == "__mul__")
RET CNF(Matrix4x4___mul__);
 EI(keyStr == "__div__")
RET CNF(Matrix4x4___div__);
 EI(keyStr == "get")
RET CNF(Matrix4x4_get);
 EI(keyStr == "set")
RET CNF(Matrix4x4_set);
 EI(keyStr == "__eq__")
RET CNF(Matrix4x4___eq__);
 EI(keyStr == "transpose")
RET CNF(Matrix4x4_transpose);
 EI(keyStr == "inverse")
RET CNF(Matrix4x4_inverse);
 EI(keyStr == "translate")
RET CNF(Matrix4x4_translate);
 EI(keyStr == "scale")
RET CNF(Matrix4x4_scale);
 EI(keyStr == "rotate")
RET CNF(Matrix4x4_rotate);
 EI(keyStr == "rotatex")
RET CNF(Matrix4x4_rotatex);
 EI(keyStr == "rotatey")
RET CNF(Matrix4x4_rotatey);
 EI(keyStr == "rotatez")
RET CNF(Matrix4x4_rotatez);
 EI(keyStr == "perspective")
RET CNF(Matrix4x4_perspective);
 EI(keyStr == "orthographic")
RET CNF(Matrix4x4_orthographic);
 EI(keyStr == "lookAt")
RET CNF(Matrix4x4_lookAt);
 EI(keyStr == "lookAtDir")
RET CNF(Matrix4x4_lookAtDir);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Matrix4x4_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Matrix4x4_perspective(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::perspective" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0])->data;

if(a.getCount()==5)
if(1&&TS(a[1],float)&&TS(a[2],float)&&TS(a[3],float)&&TS(a[4],float))
{
RET CV( f->perspective(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[4])));
;
}
CATE(TE,UFOF("Matrix4x4::perspective.")));
RET CN;
}

SV Matrix4x4_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::set" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0])->data;

if(a.getCount()==4)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t)&&TS(a[3],float))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("Matrix4x4::set.")));
RET CN;
}

SV Matrix4x4_lookAtDir(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::lookAtDir" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0])->data;

if(a.getCount()==4)
if(1&&TS(a[1],const Position3D &)&&TS(a[2],const Direction3D &)&&TS(a[3],const Direction3D &))
{
RET CV( f->lookAtDir(val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Direction3D &>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Direction3D &>::type>::f(ctx,a[3])));
;
}
CATE(TE,UFOF("Matrix4x4::lookAtDir.")));
RET CN;
}

SV Matrix4x4_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::get" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("Matrix4x4::get.")));
RET CN;
}

SV Matrix4x4_transpose(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::transpose" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->transpose());
;
}
CATE(TE,UFOF("Matrix4x4::transpose.")));
RET CN;
}

SV Matrix4x4_rotatez(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::rotatez" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->rotatez(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix4x4::rotatez.")));
RET CN;
}

SV Matrix4x4_rotatex(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::rotatex" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->rotatex(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix4x4::rotatex.")));
RET CN;
}

SV Matrix4x4_rotatey(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::rotatey" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->rotatey(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix4x4::rotatey.")));
RET CN;
}

SV Matrix4x4___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::__div__" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("Matrix4x4::__div__.")));
RET CN;
}

SV Matrix4x4_inverse(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::inverse" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->inverse());
;
}
CATE(TE,UFOF("Matrix4x4::inverse.")));
RET CN;
}

SV Matrix4x4_lookAt(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::lookAt" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0])->data;

if(a.getCount()==4)
if(1&&TS(a[1],const Position3D &)&&TS(a[2],const Position3D &)&&TS(a[3],const Direction3D &))
{
RET CV( f->lookAt(val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Direction3D &>::type>::f(ctx,a[3])));
;
}
CATE(TE,UFOF("Matrix4x4::lookAt.")));
RET CN;
}

SV Matrix4x4___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::__mul__" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Matrix4x4 &))
{
auto v=val_to_c<std::remove_reference<const Matrix4x4 &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],const Float4 &))
{
auto v=val_to_c<std::remove_reference<const Float4 &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Matrix4x4::__mul__.")));
RET CN;
}

SV Matrix4x4_orthographic(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::orthographic" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0])->data;

if(a.getCount()==7)
if(1&&TS(a[1],float)&&TS(a[2],float)&&TS(a[3],float)&&TS(a[4],float)&&TS(a[5],float)&&TS(a[6],float))
{
RET CV( f->orthographic(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[5]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[6])));
;
}
CATE(TE,UFOF("Matrix4x4::orthographic.")));
RET CN;
}

SV Matrix4x4_translate(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::translate" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
RET CV( f->translate(val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix4x4::translate.")));
RET CN;
}

SV Matrix4x4___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::__eq__" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Matrix4x4 &))
{
auto v=val_to_c<std::remove_reference<const Matrix4x4 &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Matrix4x4::__eq__.")));
RET CN;
}

SV Matrix4x4_rotate(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::rotate" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->rotate(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix4x4::rotate.")));
RET CN;
}

SV Matrix4x4_scale(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix4x4::scale" EAOE));
Matrix4x4*f;
f=(Matrix4x4*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
RET CV( f->scale(val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix4x4::scale.")));
RET CN;
}

void Map_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,HashMap<scripting::Value*,scripting::Value*>))
CATE(TE,"Map::__del__ expects Map as first argument."));

DELETE((HashMap<scripting::Value*,scripting::Value*>*)f->data);
}SV Map_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Map's constructor" EAOE));
if(!TS(a[0],HashMap<scripting::Value*,scripting::Value*>))
CATE(TE,"Map's constructor expects Map as first argument."));
#define fjis HashMap<scripting::Value*,scripting::Value*>
RET STG::createNativeObject(Map_funcs,NEW(fjis),EXT->Map_typeID);
}

SV Map_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Map");
EI(keyStr=="__new__")
RET CNF(Map_new);
EI(keyStr=="__call__")
RET CNF(Map_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Map_new);
 EI(keyStr == "__eq__")
RET CNF(Map___eq__);
 EI(keyStr == "__neq__")
RET CNF(Map___neq__);
 EI(keyStr == "getEntryCount")
RET CNF(Map_getEntryCount);
 EI(keyStr == "findEntry")
RET CNF(Map_findEntry);
 EI(keyStr == "getKey")
RET CNF(Map_getKey);
 EI(keyStr == "getValue")
RET CNF(Map_getValue);
 EI(keyStr == "getKeyHash")
RET CNF(Map_getKeyHash);
 EI(keyStr == "get")
RET CNF(Map_get);
 EI(keyStr == "set")
RET CNF(Map_set);
 EI(keyStr == "removeEntry")
RET CNF(Map_removeEntry);
 EI(keyStr == "remove")
RET CNF(Map_remove);
 EI(keyStr == "clear")
RET CNF(Map_clear);
 EI(keyStr == "append")
RET CNF(Map_append);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Map_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Map_removeEntry(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::removeEntry" EAOE));
HashMap<scripting::Value*,scripting::Value*>*f;
f=(HashMap<scripting::Value*,scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],int))
{
( f->removeEntry(val_to_c<std::remove_reference<int>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Map::removeEntry.")));
RET CN;
}

SV Map_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::set" EAOE));
HashMap<scripting::Value*,scripting::Value*>*f;
f=(HashMap<scripting::Value*,scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],scripting::Value*)&&TS(a[2],scripting::Value*))
{
RET CV( f->set(val_to_c<std::remove_reference<scripting::Value*>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<scripting::Value*>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("Map::set.")));
RET CN;
}

SV Map_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::get" EAOE));
HashMap<scripting::Value*,scripting::Value*>*f;
f=(HashMap<scripting::Value*,scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],scripting::Value*))
{
RET CV( f->get(val_to_c<std::remove_reference<scripting::Value*>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==2)
if(1&&TS(a[1],scripting::Value*))
{
RET CV( f->get(val_to_c<std::remove_reference<scripting::Value*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Map::get.")));
RET CN;
}

SV Map_getEntryCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::getEntryCount" EAOE));
HashMap<scripting::Value*,scripting::Value*>*f;
f=(HashMap<scripting::Value*,scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getEntryCount());
;
}
CATE(TE,UFOF("Map::getEntryCount.")));
RET CN;
}

SV Map_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::clear" EAOE));
HashMap<scripting::Value*,scripting::Value*>*f;
f=(HashMap<scripting::Value*,scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("Map::clear.")));
RET CN;
}

SV Map_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::remove" EAOE));
HashMap<scripting::Value*,scripting::Value*>*f;
f=(HashMap<scripting::Value*,scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],scripting::Value*))
{
( f->remove(val_to_c<std::remove_reference<scripting::Value*>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Map::remove.")));
RET CN;
}

SV Map_getValue(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::getValue" EAOE));
HashMap<scripting::Value*,scripting::Value*>*f;
f=(HashMap<scripting::Value*,scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getValue(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getValue(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Map::getValue.")));
RET CN;
}

SV Map_getKeyHash(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::getKeyHash" EAOE));
HashMap<scripting::Value*,scripting::Value*>*f;
f=(HashMap<scripting::Value*,scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getKeyHash(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Map::getKeyHash.")));
RET CN;
}

SV Map_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::append" EAOE));
HashMap<scripting::Value*,scripting::Value*>*f;
f=(HashMap<scripting::Value*,scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const HashMap<scripting::Value*, scripting::Value*> &))
{
( f->append(val_to_c<std::remove_reference<const HashMap<scripting::Value*, scripting::Value*> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Map::append.")));
RET CN;
}

SV Map_getKey(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::getKey" EAOE));
HashMap<scripting::Value*,scripting::Value*>*f;
f=(HashMap<scripting::Value*,scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getKey(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getKey(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Map::getKey.")));
RET CN;
}

SV Map___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::__eq__" EAOE));
HashMap<scripting::Value*,scripting::Value*>*f;
f=(HashMap<scripting::Value*,scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const HashMap<scripting::Value*, scripting::Value*> &))
{
auto v=val_to_c<std::remove_reference<const HashMap<scripting::Value*, scripting::Value*> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Map::__eq__.")));
RET CN;
}

SV Map_findEntry(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::findEntry" EAOE));
HashMap<scripting::Value*,scripting::Value*>*f;
f=(HashMap<scripting::Value*,scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],scripting::Value*))
{
RET CV( f->findEntry(val_to_c<std::remove_reference<scripting::Value*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Map::findEntry.")));
RET CN;
}

SV Map___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Map::__neq__" EAOE));
HashMap<scripting::Value*,scripting::Value*>*f;
f=(HashMap<scripting::Value*,scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const HashMap<scripting::Value*, scripting::Value*> &))
{
auto v=val_to_c<std::remove_reference<const HashMap<scripting::Value*, scripting::Value*> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("Map::__neq__.")));
RET CN;
}

void UInt3_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T3<uint32_t>))
CATE(TE,"UInt3::__del__ expects UInt3 as first argument."));

DELETE((T3<uint32_t>*)f->data);
}SV UInt3_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3's constructor" EAOE));
if(!TS(a[0],T3<uint32_t>))
CATE(TE,"UInt3's constructor expects UInt3 as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(UInt3_funcs,NEW(T3<uint32_t>),EXT->UInt3_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],uint32_t))
RET STG::createNativeObject(UInt3_funcs,NEW(T3<uint32_t>,val_to_c<uint32_t>::f(ctx,a[1])),EXT->UInt3_typeID);
if(a.getCount()==4)
if(true&&TS(a[1],uint32_t)&&TS(a[2],uint32_t)&&TS(a[3],uint32_t))
RET STG::createNativeObject(UInt3_funcs,NEW(T3<uint32_t>,val_to_c<uint32_t>::f(ctx,a[1]),val_to_c<uint32_t>::f(ctx,a[2]),val_to_c<uint32_t>::f(ctx,a[3])),EXT->UInt3_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T3<float> &))
RET STG::createNativeObject(UInt3_funcs,NEW(T3<uint32_t>,val_to_c<const T3<float> &>::f(ctx,a[1])),EXT->UInt3_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T3<int32_t> &))
RET STG::createNativeObject(UInt3_funcs,NEW(T3<uint32_t>,val_to_c<const T3<int32_t> &>::f(ctx,a[1])),EXT->UInt3_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T3<uint32_t> &))
RET STG::createNativeObject(UInt3_funcs,NEW(T3<uint32_t>,val_to_c<const T3<uint32_t> &>::f(ctx,a[1])),EXT->UInt3_typeID);
CATE(TE,UFOF("UInt3's constructor.")));
RET CN;
}

SV UInt3_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("UInt3");
EI(keyStr=="__new__")
RET CNF(UInt3_new);
EI(keyStr=="__call__")
RET CNF(UInt3_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(UInt3_new);
 EI(keyStr == "__add__")
RET CNF(UInt3___add__);
 EI(keyStr == "__sub__")
RET CNF(UInt3___sub__);
 EI(keyStr == "__mul__")
RET CNF(UInt3___mul__);
 EI(keyStr == "__div__")
RET CNF(UInt3___div__);
 EI(keyStr == "__eq__")
RET CNF(UInt3___eq__);
 EI(keyStr == "__neq__")
RET CNF(UInt3___neq__);
 EI(keyStr == "__less__")
RET CNF(UInt3___less__);
 EI(keyStr == "__grtr__")
RET CNF(UInt3___grtr__);
 EI(keyStr == "__leq__")
RET CNF(UInt3___leq__);
 EI(keyStr == "__geq__")
RET CNF(UInt3___geq__);
 EI(keyStr == "sum")
RET CNF(UInt3_sum);
 EI(keyStr == "length")
RET CNF(UInt3_length);
 EI(keyStr == "lengthSquared")
RET CNF(UInt3_lengthSquared);
 EI(keyStr == "dot")
RET CNF(UInt3_dot);
 EI(keyStr == "distance")
RET CNF(UInt3_distance);
 EI(keyStr == "distanceSquared")
RET CNF(UInt3_distanceSquared);
 EI(keyStr == "normalize")
RET CNF(UInt3_normalize);
 EI(keyStr == "cross")
RET CNF(UInt3_cross);
 EI(keyStr == "getXY")
RET CNF(UInt3_getXY);
 EI(keyStr == "setXY")
RET CNF(UInt3_setXY);
 EI(keyStr == "getXZ")
RET CNF(UInt3_getXZ);
 EI(keyStr == "setXZ")
RET CNF(UInt3_setXZ);
 EI(keyStr == "getYX")
RET CNF(UInt3_getYX);
 EI(keyStr == "setYX")
RET CNF(UInt3_setYX);
 EI(keyStr == "getYZ")
RET CNF(UInt3_getYZ);
 EI(keyStr == "setYZ")
RET CNF(UInt3_setYZ);
 EI(keyStr == "getZX")
RET CNF(UInt3_getZX);
 EI(keyStr == "setZX")
RET CNF(UInt3_setZX);
 EI(keyStr == "getZY")
RET CNF(UInt3_getZY);
 EI(keyStr == "setZY")
RET CNF(UInt3_setZY);
 EI(keyStr == "getXYZ")
RET CNF(UInt3_getXYZ);
 EI(keyStr == "setXYZ")
RET CNF(UInt3_setXYZ);
 EI(keyStr == "getXZY")
RET CNF(UInt3_getXZY);
 EI(keyStr == "setXZY")
RET CNF(UInt3_setXZY);
 EI(keyStr == "getYXZ")
RET CNF(UInt3_getYXZ);
 EI(keyStr == "setYXZ")
RET CNF(UInt3_setYXZ);
 EI(keyStr == "getYZX")
RET CNF(UInt3_getYZX);
 EI(keyStr == "setYZX")
RET CNF(UInt3_setYZX);
 EI(keyStr == "getZXY")
RET CNF(UInt3_getZXY);
 EI(keyStr == "setZXY")
RET CNF(UInt3_setZXY);
 EI(keyStr == "getZYX")
RET CNF(UInt3_getZYX);
 EI(keyStr == "setZYX")
RET CNF(UInt3_setZYX);
 EI(keyStr=="x")
{
T3<uint32_t>*obj=(T3<uint32_t>*)f->data;
RET CV(obj->x);
} EI(keyStr=="y")
{
T3<uint32_t>*obj=(T3<uint32_t>*)f->data;
RET CV(obj->y);
} EI(keyStr=="z")
{
T3<uint32_t>*obj=(T3<uint32_t>*)f->data;
RET CV(obj->z);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void UInt3_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="x")
{
T3<uint32_t>*obj=(T3<uint32_t>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr=="y")
{
T3<uint32_t>*obj=(T3<uint32_t>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} EI(keyStr=="z")
{
T3<uint32_t>*obj=(T3<uint32_t>*)f->data;
obj->z=val_to_c<decltype(obj->z)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV UInt3_setYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setYZX" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setYZX(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setYZX.")));
RET CN;
}

SV UInt3_getZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getZXY" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXY());
;
}
CATE(TE,UFOF("UInt3::getZXY.")));
RET CN;
}

SV UInt3_setYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setYZ" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setYZ(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setYZ.")));
RET CN;
}

SV UInt3_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setYX" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setYX.")));
RET CN;
}

SV UInt3_setZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setZYX" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setZYX(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setZYX.")));
RET CN;
}

SV UInt3_getZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getZY" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZY());
;
}
CATE(TE,UFOF("UInt3::getZY.")));
RET CN;
}

SV UInt3_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::distanceSquared" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("UInt3::distanceSquared.")));
RET CN;
}

SV UInt3_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::normalize" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("UInt3::normalize.")));
RET CN;
}

SV UInt3_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getYX" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("UInt3::getYX.")));
RET CN;
}

SV UInt3___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__leq__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("UInt3::__leq__.")));
RET CN;
}

SV UInt3_setXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setXZY" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setXZY(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setXZY.")));
RET CN;
}

SV UInt3_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::sum" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("UInt3::sum.")));
RET CN;
}

SV UInt3_cross(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::cross" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
RET CV( f->cross(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("UInt3::cross.")));
RET CN;
}

SV UInt3_getXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getXYZ" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZ());
;
}
CATE(TE,UFOF("UInt3::getXYZ.")));
RET CN;
}

SV UInt3___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__less__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("UInt3::__less__.")));
RET CN;
}

SV UInt3___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__neq__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("UInt3::__neq__.")));
RET CN;
}

SV UInt3_getYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getYZ" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZ());
;
}
CATE(TE,UFOF("UInt3::getYZ.")));
RET CN;
}

SV UInt3_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::lengthSquared" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("UInt3::lengthSquared.")));
RET CN;
}

SV UInt3_getZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getZYX" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYX());
;
}
CATE(TE,UFOF("UInt3::getZYX.")));
RET CN;
}

SV UInt3___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__div__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("UInt3::__div__.")));
RET CN;
}

SV UInt3_setZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setZY" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setZY(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setZY.")));
RET CN;
}

SV UInt3_setZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setZX" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setZX(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setZX.")));
RET CN;
}

SV UInt3_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setXY" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setXY.")));
RET CN;
}

SV UInt3___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__add__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("UInt3::__add__.")));
RET CN;
}

SV UInt3_setXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setXZ" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setXZ(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setXZ.")));
RET CN;
}

SV UInt3___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__eq__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("UInt3::__eq__.")));
RET CN;
}

SV UInt3_setZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setZXY" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setZXY(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setZXY.")));
RET CN;
}

SV UInt3_setYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setYXZ" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setYXZ(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setYXZ.")));
RET CN;
}

SV UInt3_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getXY" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("UInt3::getXY.")));
RET CN;
}

SV UInt3_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::distance" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("UInt3::distance.")));
RET CN;
}

SV UInt3_getXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getXZ" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZ());
;
}
CATE(TE,UFOF("UInt3::getXZ.")));
RET CN;
}

SV UInt3___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__grtr__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("UInt3::__grtr__.")));
RET CN;
}

SV UInt3_getXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getXZY" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZY());
;
}
CATE(TE,UFOF("UInt3::getXZY.")));
RET CN;
}

SV UInt3_setXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::setXYZ" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setXYZ(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt3::setXYZ.")));
RET CN;
}

SV UInt3_getYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getYZX" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZX());
;
}
CATE(TE,UFOF("UInt3::getYZX.")));
RET CN;
}

SV UInt3_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::length" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("UInt3::length.")));
RET CN;
}

SV UInt3___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__mul__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("UInt3::__mul__.")));
RET CN;
}

SV UInt3_getYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getYXZ" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZ());
;
}
CATE(TE,UFOF("UInt3::getYXZ.")));
RET CN;
}

SV UInt3_getZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::getZX" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZX());
;
}
CATE(TE,UFOF("UInt3::getZX.")));
RET CN;
}

SV UInt3___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__sub__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("UInt3::__sub__.")));
RET CN;
}

SV UInt3___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::__geq__" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("UInt3::__geq__.")));
RET CN;
}

SV UInt3_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt3::dot" EAOE));
T3<uint32_t>*f;
f=(T3<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("UInt3::dot.")));
RET CN;
}

void LightSpotData_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,LightSpotData))
CATE(TE,"LightSpotData::__del__ expects LightSpotData as first argument."));

DELETE((LightSpotData*)f->data);
}SV LightSpotData_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"LightSpotData's constructor" EAOE));
if(!TS(a[0],LightSpotData))
CATE(TE,"LightSpotData's constructor expects LightSpotData as first argument."));
#define fjis LightSpotData
RET STG::createNativeObject(LightSpotData_funcs,NEW(fjis),EXT->LightSpotData_typeID);
}

SV LightSpotData_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("LightSpotData");
EI(keyStr=="__new__")
RET CNF(LightSpotData_new);
EI(keyStr=="__call__")
RET CNF(LightSpotData_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(LightSpotData_new);
 EI(keyStr=="position")
{
LightSpotData*obj=(LightSpotData*)f->data;
RET CV(obj->position);
} EI(keyStr=="direction")
{
LightSpotData*obj=(LightSpotData*)f->data;
RET CV(obj->direction);
} EI(keyStr=="innerCutoff")
{
LightSpotData*obj=(LightSpotData*)f->data;
RET CV(obj->innerCutoff);
} EI(keyStr=="outerCutoff")
{
LightSpotData*obj=(LightSpotData*)f->data;
RET CV(obj->outerCutoff);
} EI(keyStr=="radius")
{
LightSpotData*obj=(LightSpotData*)f->data;
RET CV(obj->radius);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void LightSpotData_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="position")
{
LightSpotData*obj=(LightSpotData*)f->data;
obj->position=val_to_c<decltype(obj->position)>::f(ctx,value);
} EI(keyStr=="direction")
{
LightSpotData*obj=(LightSpotData*)f->data;
obj->direction=val_to_c<decltype(obj->direction)>::f(ctx,value);
} EI(keyStr=="innerCutoff")
{
LightSpotData*obj=(LightSpotData*)f->data;
obj->innerCutoff=val_to_c<decltype(obj->innerCutoff)>::f(ctx,value);
} EI(keyStr=="outerCutoff")
{
LightSpotData*obj=(LightSpotData*)f->data;
obj->outerCutoff=val_to_c<decltype(obj->outerCutoff)>::f(ctx,value);
} EI(keyStr=="radius")
{
LightSpotData*obj=(LightSpotData*)f->data;
obj->radius=val_to_c<decltype(obj->radius)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

void PhysicsShape_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,PhysicsShape))
CATE(TE,"PhysicsShape::__del__ expects PhysicsShape as first argument."));

PhysicsShape*obj=(PhysicsShape*)f->data;
if(obj!=nullptr){obj->release();}
}SV PhysicsShape_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"PhysicsShape's constructor" EAOE));
if(!TS(a[0],PhysicsShape))
CATE(TE,"PhysicsShape's constructor expects PhysicsShape as first argument."));
CATE(TE,UFOF("PhysicsShape's constructor.")));
}

SV PhysicsShape_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("PhysicsShape");
EI(keyStr=="__new__")
RET CNF(PhysicsShape_new);
EI(keyStr=="__call__")
RET CNF(PhysicsShape_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(PhysicsShape_new);
 EI(keyStr == "removeContent")
RET CNF(PhysicsShape_removeContent);
 EI(keyStr == "getImpl")
RET CNF(PhysicsShape_getImpl);
 EI(keyStr == "getShapeType")
RET CNF(PhysicsShape_getShapeType);
 EI(keyStr == "getMargin")
RET CNF(PhysicsShape_getMargin);
 EI(keyStr == "setMargin")
RET CNF(PhysicsShape_setMargin);
 EI(keyStr == "getScale")
RET CNF(PhysicsShape_getScale);
 EI(keyStr == "setScale")
RET CNF(PhysicsShape_setScale);
 EI(keyStr == "getBulletShape")
RET CNF(PhysicsShape_getBulletShape);
 EI(keyStr == "setEmpty")
RET CNF(PhysicsShape_setEmpty);
 EI(keyStr == "setSphere")
RET CNF(PhysicsShape_setSphere);
 EI(keyStr == "setBox")
RET CNF(PhysicsShape_setBox);
 EI(keyStr == "setCylinder")
RET CNF(PhysicsShape_setCylinder);
 EI(keyStr == "setCapsule")
RET CNF(PhysicsShape_setCapsule);
 EI(keyStr == "setCone")
RET CNF(PhysicsShape_setCone);
 EI(keyStr == "setConvexHull")
RET CNF(PhysicsShape_setConvexHull);
 EI(keyStr == "setStaticTriangleMesh")
RET CNF(PhysicsShape_setStaticTriangleMesh);
 EI(keyStr == "setHeightfield")
RET CNF(PhysicsShape_setHeightfield);
 EI(keyStr == "setPlane")
RET CNF(PhysicsShape_setPlane);
 EI(keyStr == "setCompound")
RET CNF(PhysicsShape_setCompound);
 EI(keyStr == "save")
RET CNF(PhysicsShape_save);
 EI(keyStr == "load")
RET CNF(PhysicsShape_load);
 EI(keyStr == "copy")
RET CNF(PhysicsShape_copy);
 EI(keyStr == "getType")
RET CNF(PhysicsShape_getType);
 EI(keyStr == "release")
RET CNF(PhysicsShape_release);
 EI(keyStr == "getRefCount")
RET CNF(PhysicsShape_getRefCount);
 EI(keyStr == "getFilename")
RET CNF(PhysicsShape_getFilename);
 EI(keyStr == "setFilename")
RET CNF(PhysicsShape_setFilename);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void PhysicsShape_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV PhysicsShape_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::load" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("PhysicsShape::load.")));
RET CN;
}

SV PhysicsShape_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setFilename" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
( f->setFilename(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("PhysicsShape::setFilename.")));
RET CN;
}

SV PhysicsShape_setScale(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setScale" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->setScale(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("PhysicsShape::setScale.")));
RET CN;
}

SV PhysicsShape_setEmpty(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setEmpty" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->setEmpty());
RET CN;
}
CATE(TE,UFOF("PhysicsShape::setEmpty.")));
RET CN;
}

SV PhysicsShape_getImpl(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::getImpl" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

CATE(TE,UFOF("PhysicsShape::getImpl.")));
RET CN;
}

SV PhysicsShape_setCompound(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setCompound" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

CATE(TE,UFOF("PhysicsShape::setCompound.")));
RET CN;
}

SV PhysicsShape_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::save" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("PhysicsShape::save.")));
RET CN;
}

SV PhysicsShape_setPlane(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setPlane" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],const Vector3D &)&&TS(a[2],float))
{
( f->setPlane(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("PhysicsShape::setPlane.")));
RET CN;
}

SV PhysicsShape_setCapsule(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setCapsule" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

CATE(TE,UFOF("PhysicsShape::setCapsule.")));
RET CN;
}

SV PhysicsShape_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::getFilename" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("PhysicsShape::getFilename.")));
RET CN;
}

SV PhysicsShape_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::getRefCount" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("PhysicsShape::getRefCount.")));
RET CN;
}

SV PhysicsShape_setBox(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setBox" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->setBox(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("PhysicsShape::setBox.")));
RET CN;
}

SV PhysicsShape_setConvexHull(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setConvexHull" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

CATE(TE,UFOF("PhysicsShape::setConvexHull.")));
RET CN;
}

SV PhysicsShape_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::getType" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("PhysicsShape::getType.")));
RET CN;
}

SV PhysicsShape_getMargin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::getMargin" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getMargin());
;
}
CATE(TE,UFOF("PhysicsShape::getMargin.")));
RET CN;
}

SV PhysicsShape_setStaticTriangleMesh(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setStaticTriangleMesh" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

CATE(TE,UFOF("PhysicsShape::setStaticTriangleMesh.")));
RET CN;
}

SV PhysicsShape_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::removeContent" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("PhysicsShape::removeContent.")));
RET CN;
}

SV PhysicsShape_setMargin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setMargin" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setMargin(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("PhysicsShape::setMargin.")));
RET CN;
}

SV PhysicsShape_getScale(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::getScale" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getScale());
;
}
CATE(TE,UFOF("PhysicsShape::getScale.")));
RET CN;
}

SV PhysicsShape_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::copy" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("PhysicsShape::copy.")));
RET CN;
}

SV PhysicsShape_getBulletShape(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::getBulletShape" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

CATE(TE,UFOF("PhysicsShape::getBulletShape.")));
RET CN;
}

SV PhysicsShape_setCylinder(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setCylinder" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

CATE(TE,UFOF("PhysicsShape::setCylinder.")));
RET CN;
}

SV PhysicsShape_setCone(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setCone" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

CATE(TE,UFOF("PhysicsShape::setCone.")));
RET CN;
}

SV PhysicsShape_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::release" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("PhysicsShape::release.")));
RET CN;
}

SV PhysicsShape_setHeightfield(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setHeightfield" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

CATE(TE,UFOF("PhysicsShape::setHeightfield.")));
RET CN;
}

SV PhysicsShape_setSphere(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::setSphere" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setSphere(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("PhysicsShape::setSphere.")));
RET CN;
}

SV PhysicsShape_getShapeType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"PhysicsShape::getShapeType" EAOE));
PhysicsShape*f;
f=(PhysicsShape*)((NO)a[0])->data;

CATE(TE,UFOF("PhysicsShape::getShapeType.")));
RET CN;
}

void AudioDevice_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,AudioDevice))
CATE(TE,"AudioDevice::__del__ expects AudioDevice as first argument."));

DELETE((AudioDevice*)f->data);
}SV AudioDevice_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice's constructor" EAOE));
if(!TS(a[0],AudioDevice))
CATE(TE,"AudioDevice's constructor expects AudioDevice as first argument."));
if(a.getCount()==4)
if(true&&TS(a[1],size_t)&&TS(a[2],size_t)&&TS(a[3],size_t))
RET STG::createNativeObject(AudioDevice_funcs,NEW(AudioDevice,val_to_c<size_t>::f(ctx,a[1]),val_to_c<size_t>::f(ctx,a[2]),val_to_c<size_t>::f(ctx,a[3])),EXT->AudioDevice_typeID);
CATE(TE,UFOF("AudioDevice's constructor.")));
RET CN;
}

SV AudioDevice_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("AudioDevice");
EI(keyStr=="__new__")
RET CNF(AudioDevice_new);
EI(keyStr=="__call__")
RET CNF(AudioDevice_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(AudioDevice_new);
 EI(keyStr == "getName")
RET CNF(AudioDevice_getName);
 EI(keyStr == "getDeviceCount")
RET CNF(AudioDevice_getDeviceCount);
 EI(keyStr == "setIndex")
RET CNF(AudioDevice_setIndex);
 EI(keyStr == "setFrequency")
RET CNF(AudioDevice_setFrequency);
 EI(keyStr == "setSamples")
RET CNF(AudioDevice_setSamples);
 EI(keyStr == "getIndex")
RET CNF(AudioDevice_getIndex);
 EI(keyStr == "getFrequency")
RET CNF(AudioDevice_getFrequency);
 EI(keyStr == "getSamples")
RET CNF(AudioDevice_getSamples);
 EI(keyStr == "getNumQueuedSamples")
RET CNF(AudioDevice_getNumQueuedSamples);
 EI(keyStr == "pause")
RET CNF(AudioDevice_pause);
 EI(keyStr == "play")
RET CNF(AudioDevice_play);
 EI(keyStr == "getPaused")
RET CNF(AudioDevice_getPaused);
 EI(keyStr == "runCallbacks")
RET CNF(AudioDevice_runCallbacks);
 EI(keyStr=="volume")
{
AudioDevice*obj=(AudioDevice*)f->data;
RET CV(obj->volume);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void AudioDevice_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="volume")
{
AudioDevice*obj=(AudioDevice*)f->data;
obj->volume=val_to_c<decltype(obj->volume)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV AudioDevice_getIndex(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::getIndex" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getIndex());
;
}
CATE(TE,UFOF("AudioDevice::getIndex.")));
RET CN;
}

SV AudioDevice_getFrequency(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::getFrequency" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFrequency());
;
}
CATE(TE,UFOF("AudioDevice::getFrequency.")));
RET CN;
}

SV AudioDevice_pause(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::pause" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->pause());
RET CN;
}
CATE(TE,UFOF("AudioDevice::pause.")));
RET CN;
}

SV AudioDevice_runCallbacks(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::runCallbacks" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->runCallbacks(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioDevice::runCallbacks.")));
RET CN;
}

SV AudioDevice_getName(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::getName" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getName());
;
}
if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getName(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("AudioDevice::getName.")));
RET CN;
}

SV AudioDevice_getPaused(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::getPaused" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getPaused());
;
}
CATE(TE,UFOF("AudioDevice::getPaused.")));
RET CN;
}

SV AudioDevice_setIndex(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::setIndex" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->setIndex(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioDevice::setIndex.")));
RET CN;
}

SV AudioDevice_play(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::play" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->play());
RET CN;
}
CATE(TE,UFOF("AudioDevice::play.")));
RET CN;
}

SV AudioDevice_getSamples(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::getSamples" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getSamples());
;
}
CATE(TE,UFOF("AudioDevice::getSamples.")));
RET CN;
}

SV AudioDevice_setFrequency(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::setFrequency" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->setFrequency(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioDevice::setFrequency.")));
RET CN;
}

SV AudioDevice_getNumQueuedSamples(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::getNumQueuedSamples" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getNumQueuedSamples());
;
}
CATE(TE,UFOF("AudioDevice::getNumQueuedSamples.")));
RET CN;
}

SV AudioDevice_getDeviceCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::getDeviceCount" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDeviceCount());
;
}
CATE(TE,UFOF("AudioDevice::getDeviceCount.")));
RET CN;
}

SV AudioDevice_setSamples(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AudioDevice::setSamples" EAOE));
AudioDevice*f;
f=(AudioDevice*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
( f->setSamples(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AudioDevice::setSamples.")));
RET CN;
}

void RigidBodyList_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<RigidBody*>))
CATE(TE,"RigidBodyList::__del__ expects RigidBodyList as first argument."));

DELETE((List<RigidBody*>*)f->data);
}SV RigidBodyList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList's constructor" EAOE));
if(!TS(a[0],List<RigidBody*>))
CATE(TE,"RigidBodyList's constructor expects RigidBodyList as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(RigidBodyList_funcs,NEW(List<RigidBody*>),EXT->RigidBodyList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],std::size_t))
RET STG::createNativeObject(RigidBodyList_funcs,NEW(List<RigidBody*>,val_to_c<std::size_t>::f(ctx,a[1])),EXT->RigidBodyList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const List<RigidBody*> &))
RET STG::createNativeObject(RigidBodyList_funcs,NEW(List<RigidBody*>,val_to_c<const List<RigidBody*> &>::f(ctx,a[1])),EXT->RigidBodyList_typeID);
CATE(TE,UFOF("RigidBodyList's constructor.")));
RET CN;
}

SV RigidBodyList_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("RigidBodyList");
EI(keyStr=="__new__")
RET CNF(RigidBodyList_new);
EI(keyStr=="__call__")
RET CNF(RigidBodyList_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(RigidBodyList_new);
 EI(keyStr == "__eq__")
RET CNF(RigidBodyList___eq__);
 EI(keyStr == "__neq__")
RET CNF(RigidBodyList___neq__);
 EI(keyStr == "get")
RET CNF(RigidBodyList_get);
 EI(keyStr == "set")
RET CNF(RigidBodyList_set);
 EI(keyStr == "getCount")
RET CNF(RigidBodyList_getCount);
 EI(keyStr == "getData")
RET CNF(RigidBodyList_getData);
 EI(keyStr == "append")
RET CNF(RigidBodyList_append);
 EI(keyStr == "insert")
RET CNF(RigidBodyList_insert);
 EI(keyStr == "remove")
RET CNF(RigidBodyList_remove);
 EI(keyStr == "clear")
RET CNF(RigidBodyList_clear);
 EI(keyStr == "find")
RET CNF(RigidBodyList_find);
 EI(keyStr == "copy")
RET CNF(RigidBodyList_copy);
 EI(keyStr == "in")
RET CNF(RigidBodyList_in);
 EI(keyStr == "begin")
RET CNF(RigidBodyList_begin);
 EI(keyStr == "end")
RET CNF(RigidBodyList_end);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void RigidBodyList_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV RigidBodyList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::insert" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],RigidBody*))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<RigidBody*>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<RigidBody*> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<RigidBody*> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("RigidBodyList::insert.")));
RET CN;
}

SV RigidBodyList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::begin" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0])->data;

CATE(TE,UFOF("RigidBodyList::begin.")));
RET CN;
}

SV RigidBodyList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::set" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],RigidBody*))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<RigidBody*>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("RigidBodyList::set.")));
RET CN;
}

SV RigidBodyList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::end" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0])->data;

CATE(TE,UFOF("RigidBodyList::end.")));
RET CN;
}

SV RigidBodyList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::get" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("RigidBodyList::get.")));
RET CN;
}

SV RigidBodyList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::clear" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("RigidBodyList::clear.")));
RET CN;
}

SV RigidBodyList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::copy" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("RigidBodyList::copy.")));
RET CN;
}

SV RigidBodyList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::remove" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("RigidBodyList::remove.")));
RET CN;
}

SV RigidBodyList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::in" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],RigidBody*))
{
RET CV( f->in(val_to_c<std::remove_reference<RigidBody*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("RigidBodyList::in.")));
RET CN;
}

SV RigidBodyList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::getCount" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("RigidBodyList::getCount.")));
RET CN;
}

SV RigidBodyList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::getData" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0])->data;

CATE(TE,UFOF("RigidBodyList::getData.")));
RET CN;
}

SV RigidBodyList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::__eq__" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<RigidBody*> &))
{
auto v=val_to_c<std::remove_reference<const List<RigidBody*> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("RigidBodyList::__eq__.")));
RET CN;
}

SV RigidBodyList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::find" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],RigidBody*))
{
RET CV( f->find(val_to_c<std::remove_reference<RigidBody*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("RigidBodyList::find.")));
RET CN;
}

SV RigidBodyList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::append" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],RigidBody*))
{
( f->append(val_to_c<std::remove_reference<RigidBody*>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<RigidBody*> &))
{
( f->append(val_to_c<std::remove_reference<const List<RigidBody*> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("RigidBodyList::append.")));
RET CN;
}

SV RigidBodyList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyList::__neq__" EAOE));
List<RigidBody*>*f;
f=(List<RigidBody*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<RigidBody*> &))
{
auto v=val_to_c<std::remove_reference<const List<RigidBody*> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("RigidBodyList::__neq__.")));
RET CN;
}

void UInt4_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T4<uint32_t>))
CATE(TE,"UInt4::__del__ expects UInt4 as first argument."));

DELETE((T4<uint32_t>*)f->data);
}SV UInt4_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4's constructor" EAOE));
if(!TS(a[0],T4<uint32_t>))
CATE(TE,"UInt4's constructor expects UInt4 as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(UInt4_funcs,NEW(T4<uint32_t>),EXT->UInt4_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],uint32_t))
RET STG::createNativeObject(UInt4_funcs,NEW(T4<uint32_t>,val_to_c<uint32_t>::f(ctx,a[1])),EXT->UInt4_typeID);
if(a.getCount()==5)
if(true&&TS(a[1],uint32_t)&&TS(a[2],uint32_t)&&TS(a[3],uint32_t)&&TS(a[4],uint32_t))
RET STG::createNativeObject(UInt4_funcs,NEW(T4<uint32_t>,val_to_c<uint32_t>::f(ctx,a[1]),val_to_c<uint32_t>::f(ctx,a[2]),val_to_c<uint32_t>::f(ctx,a[3]),val_to_c<uint32_t>::f(ctx,a[4])),EXT->UInt4_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T4<float> &))
RET STG::createNativeObject(UInt4_funcs,NEW(T4<uint32_t>,val_to_c<const T4<float> &>::f(ctx,a[1])),EXT->UInt4_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T4<int32_t> &))
RET STG::createNativeObject(UInt4_funcs,NEW(T4<uint32_t>,val_to_c<const T4<int32_t> &>::f(ctx,a[1])),EXT->UInt4_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const T4<uint32_t> &))
RET STG::createNativeObject(UInt4_funcs,NEW(T4<uint32_t>,val_to_c<const T4<uint32_t> &>::f(ctx,a[1])),EXT->UInt4_typeID);
CATE(TE,UFOF("UInt4's constructor.")));
RET CN;
}

SV UInt4_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("UInt4");
EI(keyStr=="__new__")
RET CNF(UInt4_new);
EI(keyStr=="__call__")
RET CNF(UInt4_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(UInt4_new);
 EI(keyStr == "__add__")
RET CNF(UInt4___add__);
 EI(keyStr == "__sub__")
RET CNF(UInt4___sub__);
 EI(keyStr == "__mul__")
RET CNF(UInt4___mul__);
 EI(keyStr == "__div__")
RET CNF(UInt4___div__);
 EI(keyStr == "__eq__")
RET CNF(UInt4___eq__);
 EI(keyStr == "__neq__")
RET CNF(UInt4___neq__);
 EI(keyStr == "__less__")
RET CNF(UInt4___less__);
 EI(keyStr == "__grtr__")
RET CNF(UInt4___grtr__);
 EI(keyStr == "__leq__")
RET CNF(UInt4___leq__);
 EI(keyStr == "__geq__")
RET CNF(UInt4___geq__);
 EI(keyStr == "sum")
RET CNF(UInt4_sum);
 EI(keyStr == "length")
RET CNF(UInt4_length);
 EI(keyStr == "lengthSquared")
RET CNF(UInt4_lengthSquared);
 EI(keyStr == "dot")
RET CNF(UInt4_dot);
 EI(keyStr == "distance")
RET CNF(UInt4_distance);
 EI(keyStr == "distanceSquared")
RET CNF(UInt4_distanceSquared);
 EI(keyStr == "normalize")
RET CNF(UInt4_normalize);
 EI(keyStr == "getXY")
RET CNF(UInt4_getXY);
 EI(keyStr == "setXY")
RET CNF(UInt4_setXY);
 EI(keyStr == "getXZ")
RET CNF(UInt4_getXZ);
 EI(keyStr == "setXZ")
RET CNF(UInt4_setXZ);
 EI(keyStr == "getXW")
RET CNF(UInt4_getXW);
 EI(keyStr == "setXW")
RET CNF(UInt4_setXW);
 EI(keyStr == "getYX")
RET CNF(UInt4_getYX);
 EI(keyStr == "setYX")
RET CNF(UInt4_setYX);
 EI(keyStr == "getYZ")
RET CNF(UInt4_getYZ);
 EI(keyStr == "setYZ")
RET CNF(UInt4_setYZ);
 EI(keyStr == "getYW")
RET CNF(UInt4_getYW);
 EI(keyStr == "setYW")
RET CNF(UInt4_setYW);
 EI(keyStr == "getZX")
RET CNF(UInt4_getZX);
 EI(keyStr == "setZX")
RET CNF(UInt4_setZX);
 EI(keyStr == "getZY")
RET CNF(UInt4_getZY);
 EI(keyStr == "setZY")
RET CNF(UInt4_setZY);
 EI(keyStr == "getZW")
RET CNF(UInt4_getZW);
 EI(keyStr == "setZW")
RET CNF(UInt4_setZW);
 EI(keyStr == "getWX")
RET CNF(UInt4_getWX);
 EI(keyStr == "setWX")
RET CNF(UInt4_setWX);
 EI(keyStr == "getWY")
RET CNF(UInt4_getWY);
 EI(keyStr == "setWY")
RET CNF(UInt4_setWY);
 EI(keyStr == "getWZ")
RET CNF(UInt4_getWZ);
 EI(keyStr == "setWZ")
RET CNF(UInt4_setWZ);
 EI(keyStr == "getXYZ")
RET CNF(UInt4_getXYZ);
 EI(keyStr == "setXYZ")
RET CNF(UInt4_setXYZ);
 EI(keyStr == "getXYW")
RET CNF(UInt4_getXYW);
 EI(keyStr == "setXYW")
RET CNF(UInt4_setXYW);
 EI(keyStr == "getXZY")
RET CNF(UInt4_getXZY);
 EI(keyStr == "setXZY")
RET CNF(UInt4_setXZY);
 EI(keyStr == "getXZW")
RET CNF(UInt4_getXZW);
 EI(keyStr == "setXZW")
RET CNF(UInt4_setXZW);
 EI(keyStr == "getXWZ")
RET CNF(UInt4_getXWZ);
 EI(keyStr == "setXWZ")
RET CNF(UInt4_setXWZ);
 EI(keyStr == "getXWY")
RET CNF(UInt4_getXWY);
 EI(keyStr == "setXWY")
RET CNF(UInt4_setXWY);
 EI(keyStr == "getYXZ")
RET CNF(UInt4_getYXZ);
 EI(keyStr == "setYXZ")
RET CNF(UInt4_setYXZ);
 EI(keyStr == "getYXW")
RET CNF(UInt4_getYXW);
 EI(keyStr == "setYXW")
RET CNF(UInt4_setYXW);
 EI(keyStr == "getYZX")
RET CNF(UInt4_getYZX);
 EI(keyStr == "setYZX")
RET CNF(UInt4_setYZX);
 EI(keyStr == "getYZW")
RET CNF(UInt4_getYZW);
 EI(keyStr == "setYZW")
RET CNF(UInt4_setYZW);
 EI(keyStr == "getYWZ")
RET CNF(UInt4_getYWZ);
 EI(keyStr == "setYWZ")
RET CNF(UInt4_setYWZ);
 EI(keyStr == "getYWX")
RET CNF(UInt4_getYWX);
 EI(keyStr == "setYWX")
RET CNF(UInt4_setYWX);
 EI(keyStr == "getZXY")
RET CNF(UInt4_getZXY);
 EI(keyStr == "setZXY")
RET CNF(UInt4_setZXY);
 EI(keyStr == "getZXW")
RET CNF(UInt4_getZXW);
 EI(keyStr == "setZXW")
RET CNF(UInt4_setZXW);
 EI(keyStr == "getZYX")
RET CNF(UInt4_getZYX);
 EI(keyStr == "setZYX")
RET CNF(UInt4_setZYX);
 EI(keyStr == "getZYW")
RET CNF(UInt4_getZYW);
 EI(keyStr == "setZYW")
RET CNF(UInt4_setZYW);
 EI(keyStr == "getZWY")
RET CNF(UInt4_getZWY);
 EI(keyStr == "setZWY")
RET CNF(UInt4_setZWY);
 EI(keyStr == "getZWX")
RET CNF(UInt4_getZWX);
 EI(keyStr == "setZWX")
RET CNF(UInt4_setZWX);
 EI(keyStr == "getWXY")
RET CNF(UInt4_getWXY);
 EI(keyStr == "setWXY")
RET CNF(UInt4_setWXY);
 EI(keyStr == "getWXZ")
RET CNF(UInt4_getWXZ);
 EI(keyStr == "setWXZ")
RET CNF(UInt4_setWXZ);
 EI(keyStr == "getWYX")
RET CNF(UInt4_getWYX);
 EI(keyStr == "setWYX")
RET CNF(UInt4_setWYX);
 EI(keyStr == "getWYZ")
RET CNF(UInt4_getWYZ);
 EI(keyStr == "setWYZ")
RET CNF(UInt4_setWYZ);
 EI(keyStr == "getWZY")
RET CNF(UInt4_getWZY);
 EI(keyStr == "setWZY")
RET CNF(UInt4_setWZY);
 EI(keyStr == "getWZX")
RET CNF(UInt4_getWZX);
 EI(keyStr == "setWZX")
RET CNF(UInt4_setWZX);
 EI(keyStr == "getXYZW")
RET CNF(UInt4_getXYZW);
 EI(keyStr == "setXYZW")
RET CNF(UInt4_setXYZW);
 EI(keyStr == "getXYWZ")
RET CNF(UInt4_getXYWZ);
 EI(keyStr == "setXYWZ")
RET CNF(UInt4_setXYWZ);
 EI(keyStr == "getXZYW")
RET CNF(UInt4_getXZYW);
 EI(keyStr == "setXZYW")
RET CNF(UInt4_setXZYW);
 EI(keyStr == "getXZWY")
RET CNF(UInt4_getXZWY);
 EI(keyStr == "setXZWY")
RET CNF(UInt4_setXZWY);
 EI(keyStr == "getXWZY")
RET CNF(UInt4_getXWZY);
 EI(keyStr == "setXWZY")
RET CNF(UInt4_setXWZY);
 EI(keyStr == "getXWYZ")
RET CNF(UInt4_getXWYZ);
 EI(keyStr == "setXWYZ")
RET CNF(UInt4_setXWYZ);
 EI(keyStr == "getYXZW")
RET CNF(UInt4_getYXZW);
 EI(keyStr == "setYXZW")
RET CNF(UInt4_setYXZW);
 EI(keyStr == "getYXWZ")
RET CNF(UInt4_getYXWZ);
 EI(keyStr == "setYXWZ")
RET CNF(UInt4_setYXWZ);
 EI(keyStr == "getYZXW")
RET CNF(UInt4_getYZXW);
 EI(keyStr == "setYZXW")
RET CNF(UInt4_setYZXW);
 EI(keyStr == "getYZWX")
RET CNF(UInt4_getYZWX);
 EI(keyStr == "setYZWX")
RET CNF(UInt4_setYZWX);
 EI(keyStr == "getYWZX")
RET CNF(UInt4_getYWZX);
 EI(keyStr == "setYWZX")
RET CNF(UInt4_setYWZX);
 EI(keyStr == "getYWXZ")
RET CNF(UInt4_getYWXZ);
 EI(keyStr == "setYWXZ")
RET CNF(UInt4_setYWXZ);
 EI(keyStr == "getZYXW")
RET CNF(UInt4_getZYXW);
 EI(keyStr == "setZYXW")
RET CNF(UInt4_setZYXW);
 EI(keyStr == "getZYWX")
RET CNF(UInt4_getZYWX);
 EI(keyStr == "setZYWX")
RET CNF(UInt4_setZYWX);
 EI(keyStr == "getZXYW")
RET CNF(UInt4_getZXYW);
 EI(keyStr == "setZXYW")
RET CNF(UInt4_setZXYW);
 EI(keyStr == "getZXWY")
RET CNF(UInt4_getZXWY);
 EI(keyStr == "setZXWY")
RET CNF(UInt4_setZXWY);
 EI(keyStr == "getZWXY")
RET CNF(UInt4_getZWXY);
 EI(keyStr == "setZWXY")
RET CNF(UInt4_setZWXY);
 EI(keyStr == "getZWYX")
RET CNF(UInt4_getZWYX);
 EI(keyStr == "setZWYX")
RET CNF(UInt4_setZWYX);
 EI(keyStr == "getWYZX")
RET CNF(UInt4_getWYZX);
 EI(keyStr == "setWYZX")
RET CNF(UInt4_setWYZX);
 EI(keyStr == "getWYXZ")
RET CNF(UInt4_getWYXZ);
 EI(keyStr == "setWYXZ")
RET CNF(UInt4_setWYXZ);
 EI(keyStr == "getWZYX")
RET CNF(UInt4_getWZYX);
 EI(keyStr == "setWZYX")
RET CNF(UInt4_setWZYX);
 EI(keyStr == "getWZXY")
RET CNF(UInt4_getWZXY);
 EI(keyStr == "setWZXY")
RET CNF(UInt4_setWZXY);
 EI(keyStr == "getWXZY")
RET CNF(UInt4_getWXZY);
 EI(keyStr == "setWXZY")
RET CNF(UInt4_setWXZY);
 EI(keyStr == "getWXYZ")
RET CNF(UInt4_getWXYZ);
 EI(keyStr == "setWXYZ")
RET CNF(UInt4_setWXYZ);
 EI(keyStr=="x")
{
T4<uint32_t>*obj=(T4<uint32_t>*)f->data;
RET CV(obj->x);
} EI(keyStr=="y")
{
T4<uint32_t>*obj=(T4<uint32_t>*)f->data;
RET CV(obj->y);
} EI(keyStr=="z")
{
T4<uint32_t>*obj=(T4<uint32_t>*)f->data;
RET CV(obj->z);
} EI(keyStr=="w")
{
T4<uint32_t>*obj=(T4<uint32_t>*)f->data;
RET CV(obj->w);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void UInt4_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="x")
{
T4<uint32_t>*obj=(T4<uint32_t>*)f->data;
obj->x=val_to_c<decltype(obj->x)>::f(ctx,value);
} EI(keyStr=="y")
{
T4<uint32_t>*obj=(T4<uint32_t>*)f->data;
obj->y=val_to_c<decltype(obj->y)>::f(ctx,value);
} EI(keyStr=="z")
{
T4<uint32_t>*obj=(T4<uint32_t>*)f->data;
obj->z=val_to_c<decltype(obj->z)>::f(ctx,value);
} EI(keyStr=="w")
{
T4<uint32_t>*obj=(T4<uint32_t>*)f->data;
obj->w=val_to_c<decltype(obj->w)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV UInt4_setZXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZXYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setZXYW(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZXYW.")));
RET CN;
}

SV UInt4_setWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setWYZ(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWYZ.")));
RET CN;
}

SV UInt4_setWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setWYX(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWYX.")));
RET CN;
}

SV UInt4_getZWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZWYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWYX());
;
}
CATE(TE,UFOF("UInt4::getZWYX.")));
RET CN;
}

SV UInt4_getZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZW());
;
}
CATE(TE,UFOF("UInt4::getZW.")));
RET CN;
}

SV UInt4_getZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZY());
;
}
CATE(TE,UFOF("UInt4::getZY.")));
RET CN;
}

SV UInt4_distanceSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::distanceSquared" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
RET CV( f->distanceSquared(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("UInt4::distanceSquared.")));
RET CN;
}

SV UInt4_getYXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYXZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZW());
;
}
CATE(TE,UFOF("UInt4::getYXZW.")));
RET CN;
}

SV UInt4_setYZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYZWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setYZWX(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYZWX.")));
RET CN;
}

SV UInt4_getYWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYWZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWZX());
;
}
CATE(TE,UFOF("UInt4::getYWZX.")));
RET CN;
}

SV UInt4_getWZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWZXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZXY());
;
}
CATE(TE,UFOF("UInt4::getWZXY.")));
RET CN;
}

SV UInt4_getZYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZYXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYXW());
;
}
CATE(TE,UFOF("UInt4::getZYXW.")));
RET CN;
}

SV UInt4_setXWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXWYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setXWYZ(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXWYZ.")));
RET CN;
}

SV UInt4_setZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setZY(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZY.")));
RET CN;
}

SV UInt4_setZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setZX(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZX.")));
RET CN;
}

SV UInt4_getZXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZXWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXWY());
;
}
CATE(TE,UFOF("UInt4::getZXWY.")));
RET CN;
}

SV UInt4_getXWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXWZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWZY());
;
}
CATE(TE,UFOF("UInt4::getXWZY.")));
RET CN;
}

SV UInt4_setZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setZW(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZW.")));
RET CN;
}

SV UInt4_setZYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZYWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setZYWX(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZYWX.")));
RET CN;
}

SV UInt4_getYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZX());
;
}
CATE(TE,UFOF("UInt4::getYZX.")));
RET CN;
}

SV UInt4_getXYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXYWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYWZ());
;
}
CATE(TE,UFOF("UInt4::getXYWZ.")));
RET CN;
}

SV UInt4_setYXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYXZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setYXZW(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYXZW.")));
RET CN;
}

SV UInt4_getWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZY());
;
}
CATE(TE,UFOF("UInt4::getWZY.")));
RET CN;
}

SV UInt4_getWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZX());
;
}
CATE(TE,UFOF("UInt4::getWZX.")));
RET CN;
}

SV UInt4_getWZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWZYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZYX());
;
}
CATE(TE,UFOF("UInt4::getWZYX.")));
RET CN;
}

SV UInt4_setXWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXWZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setXWZY(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXWZY.")));
RET CN;
}

SV UInt4_getZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXY());
;
}
CATE(TE,UFOF("UInt4::getZXY.")));
RET CN;
}

SV UInt4_setWZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWZYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setWZYX(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWZYX.")));
RET CN;
}

SV UInt4_setZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setZYW(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZYW.")));
RET CN;
}

SV UInt4_setZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setZYX(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZYX.")));
RET CN;
}

SV UInt4_setXZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXZYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setXZYW(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXZYW.")));
RET CN;
}

SV UInt4_getZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXW());
;
}
CATE(TE,UFOF("UInt4::getZXW.")));
RET CN;
}

SV UInt4_setYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setYZW(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYZW.")));
RET CN;
}

SV UInt4_getYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWZ());
;
}
CATE(TE,UFOF("UInt4::getYWZ.")));
RET CN;
}

SV UInt4___leq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__leq__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f <= v);
}
CATE(TE,UFOF("UInt4::__leq__.")));
RET CN;
}

SV UInt4_getYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWX());
;
}
CATE(TE,UFOF("UInt4::getYWX.")));
RET CN;
}

SV UInt4_sum(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::sum" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->sum());
;
}
CATE(TE,UFOF("UInt4::sum.")));
RET CN;
}

SV UInt4_setYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setYZX(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYZX.")));
RET CN;
}

SV UInt4_getXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZ());
;
}
CATE(TE,UFOF("UInt4::getXYZ.")));
RET CN;
}

SV UInt4_getZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZX());
;
}
CATE(TE,UFOF("UInt4::getZX.")));
RET CN;
}

SV UInt4_getXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYW());
;
}
CATE(TE,UFOF("UInt4::getXYW.")));
RET CN;
}

SV UInt4_setYWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYWZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setYWZX(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYWZX.")));
RET CN;
}

SV UInt4_setWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setWXY(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWXY.")));
RET CN;
}

SV UInt4_setWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setWXZ(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWXZ.")));
RET CN;
}

SV UInt4_setZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setZXW(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZXW.")));
RET CN;
}

SV UInt4_getXWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXWYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWYZ());
;
}
CATE(TE,UFOF("UInt4::getXWYZ.")));
RET CN;
}

SV UInt4_setWYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWYXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setWYXZ(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWYXZ.")));
RET CN;
}

SV UInt4_setZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setZXY(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZXY.")));
RET CN;
}

SV UInt4_getXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWY());
;
}
CATE(TE,UFOF("UInt4::getXWY.")));
RET CN;
}

SV UInt4_getYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXW());
;
}
CATE(TE,UFOF("UInt4::getYXW.")));
RET CN;
}

SV UInt4_getYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXZ());
;
}
CATE(TE,UFOF("UInt4::getYXZ.")));
RET CN;
}

SV UInt4_setXYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXYWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setXYWZ(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXYWZ.")));
RET CN;
}

SV UInt4_length(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::length" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->length());
;
}
CATE(TE,UFOF("UInt4::length.")));
RET CN;
}

SV UInt4_setWXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWXZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setWXZY(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWXZY.")));
RET CN;
}

SV UInt4_getYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZW());
;
}
CATE(TE,UFOF("UInt4::getYZW.")));
RET CN;
}

SV UInt4_setXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setXWZ(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXWZ.")));
RET CN;
}

SV UInt4_setXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setXWY(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXWY.")));
RET CN;
}

SV UInt4_getWYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYZ());
;
}
CATE(TE,UFOF("UInt4::getWYZ.")));
RET CN;
}

SV UInt4_getWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYX());
;
}
CATE(TE,UFOF("UInt4::getWYX.")));
RET CN;
}

SV UInt4_getZYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZYWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYWX());
;
}
CATE(TE,UFOF("UInt4::getZYWX.")));
RET CN;
}

SV UInt4_getXYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXYZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXYZW());
;
}
CATE(TE,UFOF("UInt4::getXYZW.")));
RET CN;
}

SV UInt4_setZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setZWY(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZWY.")));
RET CN;
}

SV UInt4_setZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setZWX(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZWX.")));
RET CN;
}

SV UInt4_setWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setWX(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWX.")));
RET CN;
}

SV UInt4_setWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setWY(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWY.")));
RET CN;
}

SV UInt4_setWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setWZ(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWZ.")));
RET CN;
}

SV UInt4_getZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWY());
;
}
CATE(TE,UFOF("UInt4::getZWY.")));
RET CN;
}

SV UInt4_getZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWX());
;
}
CATE(TE,UFOF("UInt4::getZWX.")));
RET CN;
}

SV UInt4_setYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setYXZ(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYXZ.")));
RET CN;
}

SV UInt4_setYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setYXW(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYXW.")));
RET CN;
}

SV UInt4_getXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXWZ());
;
}
CATE(TE,UFOF("UInt4::getXWZ.")));
RET CN;
}

SV UInt4_getXZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXZWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZWY());
;
}
CATE(TE,UFOF("UInt4::getXZWY.")));
RET CN;
}

SV UInt4___less__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__less__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f < v);
}
CATE(TE,UFOF("UInt4::__less__.")));
RET CN;
}

SV UInt4_getZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYW());
;
}
CATE(TE,UFOF("UInt4::getZYW.")));
RET CN;
}

SV UInt4_setWZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setWZY(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWZY.")));
RET CN;
}

SV UInt4_setWZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setWZX(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWZX.")));
RET CN;
}

SV UInt4_setZYXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZYXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setZYXW(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZYXW.")));
RET CN;
}

SV UInt4_getYZWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYZWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZWX());
;
}
CATE(TE,UFOF("UInt4::getYZWX.")));
RET CN;
}

SV UInt4_getZYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZYX());
;
}
CATE(TE,UFOF("UInt4::getZYX.")));
RET CN;
}

SV UInt4_getXZYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXZYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZYW());
;
}
CATE(TE,UFOF("UInt4::getXZYW.")));
RET CN;
}

SV UInt4_setYXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYXWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setYXWZ(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYXWZ.")));
RET CN;
}

SV UInt4___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__eq__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("UInt4::__eq__.")));
RET CN;
}

SV UInt4_getWYXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWYXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYXZ());
;
}
CATE(TE,UFOF("UInt4::getWYXZ.")));
RET CN;
}

SV UInt4_distance(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::distance" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
RET CV( f->distance(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("UInt4::distance.")));
RET CN;
}

SV UInt4_getXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZW());
;
}
CATE(TE,UFOF("UInt4::getXZW.")));
RET CN;
}

SV UInt4_setYZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYZXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setYZXW(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYZXW.")));
RET CN;
}

SV UInt4_getZWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZWXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZWXY());
;
}
CATE(TE,UFOF("UInt4::getZWXY.")));
RET CN;
}

SV UInt4_getXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZY());
;
}
CATE(TE,UFOF("UInt4::getXZY.")));
RET CN;
}

SV UInt4_getYZXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYZXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZXW());
;
}
CATE(TE,UFOF("UInt4::getYZXW.")));
RET CN;
}

SV UInt4_setZWYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZWYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setZWYX(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZWYX.")));
RET CN;
}

SV UInt4___sub__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__sub__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f - v);
}
CATE(TE,UFOF("UInt4::__sub__.")));
RET CN;
}

SV UInt4_getYXWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYXWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYXWZ());
;
}
CATE(TE,UFOF("UInt4::getYXWZ.")));
RET CN;
}

SV UInt4_setXZWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXZWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setXZWY(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXZWY.")));
RET CN;
}

SV UInt4_setYWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setYWZ(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYWZ.")));
RET CN;
}

SV UInt4_setYWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setYWX(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYWX.")));
RET CN;
}

SV UInt4_setYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setYZ(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYZ.")));
RET CN;
}

SV UInt4_setYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setYX(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYX.")));
RET CN;
}

SV UInt4_setYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setYW(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYW.")));
RET CN;
}

SV UInt4_getWXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWXYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXYZ());
;
}
CATE(TE,UFOF("UInt4::getWXYZ.")));
RET CN;
}

SV UInt4___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__neq__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("UInt4::__neq__.")));
RET CN;
}

SV UInt4_normalize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::normalize" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->normalize());
;
}
CATE(TE,UFOF("UInt4::normalize.")));
RET CN;
}

SV UInt4_getYX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYX());
;
}
CATE(TE,UFOF("UInt4::getYX.")));
RET CN;
}

SV UInt4_setXZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setXZW(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXZW.")));
RET CN;
}

SV UInt4_setXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setXZY(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXZY.")));
RET CN;
}

SV UInt4_setXYZW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXYZW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setXYZW(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXYZW.")));
RET CN;
}

SV UInt4_getYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYW());
;
}
CATE(TE,UFOF("UInt4::getYW.")));
RET CN;
}

SV UInt4_setWXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWXYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setWXYZ(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWXYZ.")));
RET CN;
}

SV UInt4_getYWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYWXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYWXZ());
;
}
CATE(TE,UFOF("UInt4::getYWXZ.")));
RET CN;
}

SV UInt4___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__mul__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("UInt4::__mul__.")));
RET CN;
}

SV UInt4_getYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getYZ());
;
}
CATE(TE,UFOF("UInt4::getYZ.")));
RET CN;
}

SV UInt4_lengthSquared(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::lengthSquared" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->lengthSquared());
;
}
CATE(TE,UFOF("UInt4::lengthSquared.")));
RET CN;
}

SV UInt4_getWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXY());
;
}
CATE(TE,UFOF("UInt4::getWXY.")));
RET CN;
}

SV UInt4_getWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXZ());
;
}
CATE(TE,UFOF("UInt4::getWXZ.")));
RET CN;
}

SV UInt4_getWX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWX());
;
}
CATE(TE,UFOF("UInt4::getWX.")));
RET CN;
}

SV UInt4_getWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWY());
;
}
CATE(TE,UFOF("UInt4::getWY.")));
RET CN;
}

SV UInt4_getWZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWZ());
;
}
CATE(TE,UFOF("UInt4::getWZ.")));
RET CN;
}

SV UInt4_setXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setXY(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXY.")));
RET CN;
}

SV UInt4_getZXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getZXYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getZXYW());
;
}
CATE(TE,UFOF("UInt4::getZXYW.")));
RET CN;
}

SV UInt4___add__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__add__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f + v);
}
CATE(TE,UFOF("UInt4::__add__.")));
RET CN;
}

SV UInt4_setXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setXZ(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXZ.")));
RET CN;
}

SV UInt4_getWYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWYZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWYZX());
;
}
CATE(TE,UFOF("UInt4::getWYZX.")));
RET CN;
}

SV UInt4_setXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T2<uint32_t> &))
{
( f->setXW(val_to_c<std::remove_reference<const T2<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXW.")));
RET CN;
}

SV UInt4_getWXZY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getWXZY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWXZY());
;
}
CATE(TE,UFOF("UInt4::getWXZY.")));
RET CN;
}

SV UInt4_getXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXY());
;
}
CATE(TE,UFOF("UInt4::getXY.")));
RET CN;
}

SV UInt4_setZXWY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZXWY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setZXWY(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZXWY.")));
RET CN;
}

SV UInt4_setXYW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXYW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setXYW(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXYW.")));
RET CN;
}

SV UInt4_getXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXZ());
;
}
CATE(TE,UFOF("UInt4::getXZ.")));
RET CN;
}

SV UInt4_setWZXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWZXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setWZXY(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWZXY.")));
RET CN;
}

SV UInt4___grtr__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__grtr__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f > v);
}
CATE(TE,UFOF("UInt4::__grtr__.")));
RET CN;
}

SV UInt4_setZWXY(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setZWXY" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setZWXY(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setZWXY.")));
RET CN;
}

SV UInt4_getXW(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::getXW" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getXW());
;
}
CATE(TE,UFOF("UInt4::getXW.")));
RET CN;
}

SV UInt4_setXYZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setXYZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T3<uint32_t> &))
{
( f->setXYZ(val_to_c<std::remove_reference<const T3<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setXYZ.")));
RET CN;
}

SV UInt4___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__div__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
auto v=val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("UInt4::__div__.")));
RET CN;
}

SV UInt4_setWYZX(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setWYZX" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setWYZX(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setWYZX.")));
RET CN;
}

SV UInt4_setYWXZ(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::setYWXZ" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
( f->setYWXZ(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("UInt4::setYWXZ.")));
RET CN;
}

SV UInt4___geq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::__geq__" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
auto v=val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1]);
RET CV(*f >= v);
}
CATE(TE,UFOF("UInt4::__geq__.")));
RET CN;
}

SV UInt4_dot(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"UInt4::dot" EAOE));
T4<uint32_t>*f;
f=(T4<uint32_t>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const T4<uint32_t> &))
{
RET CV( f->dot(val_to_c<std::remove_reference<const T4<uint32_t> &>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==1)
if(1)
{
RET CV( f->dot());
;
}
CATE(TE,UFOF("UInt4::dot.")));
RET CN;
}

void RayCastResult_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,RayCastResult))
CATE(TE,"RayCastResult::__del__ expects RayCastResult as first argument."));

DELETE((RayCastResult*)f->data);
}SV RayCastResult_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResult's constructor" EAOE));
if(!TS(a[0],RayCastResult))
CATE(TE,"RayCastResult's constructor expects RayCastResult as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(RayCastResult_funcs,NEW(RayCastResult),EXT->RayCastResult_typeID);
CATE(TE,UFOF("RayCastResult's constructor.")));
RET CN;
}

SV RayCastResult_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("RayCastResult");
EI(keyStr=="__new__")
RET CNF(RayCastResult_new);
EI(keyStr=="__call__")
RET CNF(RayCastResult_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(RayCastResult_new);
 EI(keyStr == "getRigidBody")
RET CNF(RayCastResult_getRigidBody);
 EI(keyStr == "getGhost")
RET CNF(RayCastResult_getGhost);
 EI(keyStr == "__eq__")
RET CNF(RayCastResult___eq__);
 EI(keyStr=="distance")
{
RayCastResult*obj=(RayCastResult*)f->data;
RET CV(obj->distance);
} EI(keyStr=="normal")
{
RayCastResult*obj=(RayCastResult*)f->data;
RET CV(obj->normal);
} EI(keyStr=="objType")
{
RayCastResult*obj=(RayCastResult*)f->data;
RET CV(obj->objType);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void RayCastResult_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="distance")
{
RayCastResult*obj=(RayCastResult*)f->data;
obj->distance=val_to_c<decltype(obj->distance)>::f(ctx,value);
} EI(keyStr=="normal")
{
RayCastResult*obj=(RayCastResult*)f->data;
obj->normal=val_to_c<decltype(obj->normal)>::f(ctx,value);
} EI(keyStr=="objType")
{
RayCastResult*obj=(RayCastResult*)f->data;
obj->objType=val_to_c<decltype(obj->objType)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV RayCastResult_getRigidBody(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResult::getRigidBody" EAOE));
RayCastResult*f;
f=(RayCastResult*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRigidBody());
;
}
CATE(TE,UFOF("RayCastResult::getRigidBody.")));
RET CN;
}

SV RayCastResult___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResult::__eq__" EAOE));
RayCastResult*f;
f=(RayCastResult*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const RayCastResult &))
{
auto v=val_to_c<std::remove_reference<const RayCastResult &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("RayCastResult::__eq__.")));
RET CN;
}

SV RayCastResult_getGhost(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RayCastResult::getGhost" EAOE));
RayCastResult*f;
f=(RayCastResult*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getGhost());
;
}
CATE(TE,UFOF("RayCastResult::getGhost.")));
RET CN;
}

void GfxLOD_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxLOD))
CATE(TE,"GfxLOD::__del__ expects GfxLOD as first argument."));

DELETE((GfxLOD*)f->data);
}SV GfxLOD_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLOD's constructor" EAOE));
if(!TS(a[0],GfxLOD))
CATE(TE,"GfxLOD's constructor expects GfxLOD as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(GfxLOD_funcs,NEW(GfxLOD),EXT->GfxLOD_typeID);
CATE(TE,UFOF("GfxLOD's constructor.")));
RET CN;
}

SV GfxLOD_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxLOD");
EI(keyStr=="__new__")
RET CNF(GfxLOD_new);
EI(keyStr=="__call__")
RET CNF(GfxLOD_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GfxLOD_new);
 EI(keyStr == "__eq__")
RET CNF(GfxLOD___eq__);
 EI(keyStr=="minDistance")
{
GfxLOD*obj=(GfxLOD*)f->data;
RET CV(obj->minDistance);
} EI(keyStr=="maxDistance")
{
GfxLOD*obj=(GfxLOD*)f->data;
RET CV(obj->maxDistance);
} EI(keyStr=="worldMatrix")
{
GfxLOD*obj=(GfxLOD*)f->data;
RET CV(obj->worldMatrix);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GfxLOD_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="minDistance")
{
GfxLOD*obj=(GfxLOD*)f->data;
obj->minDistance=val_to_c<decltype(obj->minDistance)>::f(ctx,value);
} EI(keyStr=="maxDistance")
{
GfxLOD*obj=(GfxLOD*)f->data;
obj->maxDistance=val_to_c<decltype(obj->maxDistance)>::f(ctx,value);
} EI(keyStr=="worldMatrix")
{
GfxLOD*obj=(GfxLOD*)f->data;
obj->worldMatrix=val_to_c<decltype(obj->worldMatrix)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GfxLOD___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLOD::__eq__" EAOE));
GfxLOD*f;
f=(GfxLOD*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const GfxLOD &))
{
auto v=val_to_c<std::remove_reference<const GfxLOD &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("GfxLOD::__eq__.")));
RET CN;
}

void File_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,File))
CATE(TE,"File::__del__ expects File as first argument."));

DELETE((File*)f->data);
}SV File_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File's constructor" EAOE));
if(!TS(a[0],File))
CATE(TE,"File's constructor expects File as first argument."));
if(a.getCount()==3)
if(true&&TS(a[1],const char *)&&TS(a[2],const char *))
RET STG::createNativeObject(File_funcs,NEW(File,val_to_c<const char *>::f(ctx,a[1]),val_to_c<const char *>::f(ctx,a[2])),EXT->File_typeID);
CATE(TE,UFOF("File's constructor.")));
RET CN;
}

SV File_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("File");
EI(keyStr=="__new__")
RET CNF(File_new);
EI(keyStr=="__call__")
RET CNF(File_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(File_new);
 EI(keyStr == "read")
RET CNF(File_read);
 EI(keyStr == "write")
RET CNF(File_write);
 EI(keyStr == "seek")
RET CNF(File_seek);
 EI(keyStr == "tell")
RET CNF(File_tell);
 EI(keyStr == "flush")
RET CNF(File_flush);
 EI(keyStr == "isAtEndOfFile")
RET CNF(File_isAtEndOfFile);
 EI(keyStr == "getSize")
RET CNF(File_getSize);
 EI(keyStr == "readUInt8")
RET CNF(File_readUInt8);
 EI(keyStr == "readInt8")
RET CNF(File_readInt8);
 EI(keyStr == "readUInt16LE")
RET CNF(File_readUInt16LE);
 EI(keyStr == "readInt16LE")
RET CNF(File_readInt16LE);
 EI(keyStr == "readUInt32LE")
RET CNF(File_readUInt32LE);
 EI(keyStr == "readInt32LE")
RET CNF(File_readInt32LE);
 EI(keyStr == "readUInt64LE")
RET CNF(File_readUInt64LE);
 EI(keyStr == "readInt64LE")
RET CNF(File_readInt64LE);
 EI(keyStr == "readUInt16BE")
RET CNF(File_readUInt16BE);
 EI(keyStr == "readInt16BE")
RET CNF(File_readInt16BE);
 EI(keyStr == "readUInt32BE")
RET CNF(File_readUInt32BE);
 EI(keyStr == "readInt32BE")
RET CNF(File_readInt32BE);
 EI(keyStr == "readUInt64BE")
RET CNF(File_readUInt64BE);
 EI(keyStr == "readInt64BE")
RET CNF(File_readInt64BE);
 EI(keyStr == "readFloat32")
RET CNF(File_readFloat32);
 EI(keyStr == "readChar")
RET CNF(File_readChar);
 EI(keyStr == "writeUInt8")
RET CNF(File_writeUInt8);
 EI(keyStr == "writeInt8")
RET CNF(File_writeInt8);
 EI(keyStr == "writeUInt16LE")
RET CNF(File_writeUInt16LE);
 EI(keyStr == "writeInt16LE")
RET CNF(File_writeInt16LE);
 EI(keyStr == "writeUInt32LE")
RET CNF(File_writeUInt32LE);
 EI(keyStr == "writeInt32LE")
RET CNF(File_writeInt32LE);
 EI(keyStr == "writeUInt64LE")
RET CNF(File_writeUInt64LE);
 EI(keyStr == "writeInt64LE")
RET CNF(File_writeInt64LE);
 EI(keyStr == "writeUInt16BE")
RET CNF(File_writeUInt16BE);
 EI(keyStr == "writeInt16BE")
RET CNF(File_writeInt16BE);
 EI(keyStr == "writeUInt32BE")
RET CNF(File_writeUInt32BE);
 EI(keyStr == "writeInt32BE")
RET CNF(File_writeInt32BE);
 EI(keyStr == "writeUInt64BE")
RET CNF(File_writeUInt64BE);
 EI(keyStr == "writeInt64BE")
RET CNF(File_writeInt64BE);
 EI(keyStr == "writeFloat32")
RET CNF(File_writeFloat32);
 EI(keyStr == "printf")
RET CNF(File_printf);
 EI(keyStr == "vprintf")
RET CNF(File_vprintf);
 EI(keyStr == "writeChar")
RET CNF(File_writeChar);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void File_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV File_readFloat32(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readFloat32" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readFloat32());
;
}
CATE(TE,UFOF("File::readFloat32.")));
RET CN;
}

SV File_printf(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::printf" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

CATE(TE,UFOF("File::printf.")));
RET CN;
}

SV File_readUInt8(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readUInt8" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readUInt8());
;
}
CATE(TE,UFOF("File::readUInt8.")));
RET CN;
}

SV File_getSize(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::getSize" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getSize());
;
}
CATE(TE,UFOF("File::getSize.")));
RET CN;
}

SV File_readInt32LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readInt32LE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readInt32LE());
;
}
CATE(TE,UFOF("File::readInt32LE.")));
RET CN;
}

SV File_flush(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::flush" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->flush());
RET CN;
}
CATE(TE,UFOF("File::flush.")));
RET CN;
}

SV File_writeChar(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeChar" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],char))
{
( f->writeChar(val_to_c<std::remove_reference<char>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeChar.")));
RET CN;
}

SV File_seek(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::seek" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],long)&&TS(a[2],FileOrigin))
{
( f->seek(val_to_c<std::remove_reference<long>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<FileOrigin>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("File::seek.")));
RET CN;
}

SV File_readInt8(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readInt8" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readInt8());
;
}
CATE(TE,UFOF("File::readInt8.")));
RET CN;
}

SV File_readInt32BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readInt32BE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readInt32BE());
;
}
CATE(TE,UFOF("File::readInt32BE.")));
RET CN;
}

SV File_writeInt32BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeInt32BE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
( f->writeInt32BE(val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeInt32BE.")));
RET CN;
}

SV File_readInt64LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readInt64LE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readInt64LE());
;
}
CATE(TE,UFOF("File::readInt64LE.")));
RET CN;
}

SV File_writeUInt32BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeUInt32BE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
( f->writeUInt32BE(val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeUInt32BE.")));
RET CN;
}

SV File_writeUInt64LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeUInt64LE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],uint64_t))
{
( f->writeUInt64LE(val_to_c<std::remove_reference<uint64_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeUInt64LE.")));
RET CN;
}

SV File_write(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::write" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const ResizableData &))
{
( f->write(val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::write.")));
RET CN;
}

SV File_writeFloat32(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeFloat32" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->writeFloat32(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeFloat32.")));
RET CN;
}

SV File_writeInt64BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeInt64BE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],int64_t))
{
( f->writeInt64BE(val_to_c<std::remove_reference<int64_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeInt64BE.")));
RET CN;
}

SV File_readUInt32LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readUInt32LE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readUInt32LE());
;
}
CATE(TE,UFOF("File::readUInt32LE.")));
RET CN;
}

SV File_tell(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::tell" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->tell());
;
}
CATE(TE,UFOF("File::tell.")));
RET CN;
}

SV File_writeUInt32LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeUInt32LE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],uint32_t))
{
( f->writeUInt32LE(val_to_c<std::remove_reference<uint32_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeUInt32LE.")));
RET CN;
}

SV File_vprintf(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::vprintf" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

CATE(TE,UFOF("File::vprintf.")));
RET CN;
}

SV File_writeUInt64BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeUInt64BE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],uint64_t))
{
( f->writeUInt64BE(val_to_c<std::remove_reference<uint64_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeUInt64BE.")));
RET CN;
}

SV File_read(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::read" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->read(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("File::read.")));
RET CN;
}

SV File_readInt64BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readInt64BE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readInt64BE());
;
}
CATE(TE,UFOF("File::readInt64BE.")));
RET CN;
}

SV File_writeInt16LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeInt16LE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],int16_t))
{
( f->writeInt16LE(val_to_c<std::remove_reference<int16_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeInt16LE.")));
RET CN;
}

SV File_isAtEndOfFile(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::isAtEndOfFile" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->isAtEndOfFile());
;
}
CATE(TE,UFOF("File::isAtEndOfFile.")));
RET CN;
}

SV File_writeInt64LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeInt64LE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],int64_t))
{
( f->writeInt64LE(val_to_c<std::remove_reference<int64_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeInt64LE.")));
RET CN;
}

SV File_readUInt32BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readUInt32BE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readUInt32BE());
;
}
CATE(TE,UFOF("File::readUInt32BE.")));
RET CN;
}

SV File_readChar(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readChar" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readChar());
;
}
CATE(TE,UFOF("File::readChar.")));
RET CN;
}

SV File_readUInt16BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readUInt16BE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readUInt16BE());
;
}
CATE(TE,UFOF("File::readUInt16BE.")));
RET CN;
}

SV File_writeInt32LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeInt32LE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],int32_t))
{
( f->writeInt32LE(val_to_c<std::remove_reference<int32_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeInt32LE.")));
RET CN;
}

SV File_readUInt64LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readUInt64LE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readUInt64LE());
;
}
CATE(TE,UFOF("File::readUInt64LE.")));
RET CN;
}

SV File_writeUInt16LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeUInt16LE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],uint16_t))
{
( f->writeUInt16LE(val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeUInt16LE.")));
RET CN;
}

SV File_writeInt8(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeInt8" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],int8_t))
{
( f->writeInt8(val_to_c<std::remove_reference<int8_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeInt8.")));
RET CN;
}

SV File_readInt16BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readInt16BE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readInt16BE());
;
}
CATE(TE,UFOF("File::readInt16BE.")));
RET CN;
}

SV File_writeUInt16BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeUInt16BE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],uint16_t))
{
( f->writeUInt16BE(val_to_c<std::remove_reference<uint16_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeUInt16BE.")));
RET CN;
}

SV File_writeUInt8(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeUInt8" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],uint8_t))
{
( f->writeUInt8(val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeUInt8.")));
RET CN;
}

SV File_readInt16LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readInt16LE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readInt16LE());
;
}
CATE(TE,UFOF("File::readInt16LE.")));
RET CN;
}

SV File_readUInt16LE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readUInt16LE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readUInt16LE());
;
}
CATE(TE,UFOF("File::readUInt16LE.")));
RET CN;
}

SV File_readUInt64BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::readUInt64BE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->readUInt64BE());
;
}
CATE(TE,UFOF("File::readUInt64BE.")));
RET CN;
}

SV File_writeInt16BE(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"File::writeInt16BE" EAOE));
File*f;
f=(File*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],int16_t))
{
( f->writeInt16BE(val_to_c<std::remove_reference<int16_t>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("File::writeInt16BE.")));
RET CN;
}

void AABB_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,AABB))
CATE(TE,"AABB::__del__ expects AABB as first argument."));

DELETE((AABB*)f->data);
}SV AABB_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AABB's constructor" EAOE));
if(!TS(a[0],AABB))
CATE(TE,"AABB's constructor expects AABB as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(AABB_funcs,NEW(AABB),EXT->AABB_typeID);
if(a.getCount()==3)
if(true&&TS(a[1],const Position3D &)&&TS(a[2],const Position3D &))
RET STG::createNativeObject(AABB_funcs,NEW(AABB,val_to_c<const Position3D &>::f(ctx,a[1]),val_to_c<const Position3D &>::f(ctx,a[2])),EXT->AABB_typeID);
CATE(TE,UFOF("AABB's constructor.")));
RET CN;
}

SV AABB_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("AABB");
EI(keyStr=="__new__")
RET CNF(AABB_new);
EI(keyStr=="__call__")
RET CNF(AABB_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(AABB_new);
 EI(keyStr == "transform")
RET CNF(AABB_transform);
 EI(keyStr == "extend")
RET CNF(AABB_extend);
 EI(keyStr == "grow")
RET CNF(AABB_grow);
 EI(keyStr=="min")
{
AABB*obj=(AABB*)f->data;
RET CV(obj->min);
} EI(keyStr=="max")
{
AABB*obj=(AABB*)f->data;
RET CV(obj->max);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void AABB_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="min")
{
AABB*obj=(AABB*)f->data;
obj->min=val_to_c<decltype(obj->min)>::f(ctx,value);
} EI(keyStr=="max")
{
AABB*obj=(AABB*)f->data;
obj->max=val_to_c<decltype(obj->max)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV AABB_transform(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AABB::transform" EAOE));
AABB*f;
f=(AABB*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Matrix4x4 &))
{
RET CV( f->transform(val_to_c<std::remove_reference<const Matrix4x4 &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("AABB::transform.")));
RET CN;
}

SV AABB_extend(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AABB::extend" EAOE));
AABB*f;
f=(AABB*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Position3D &))
{
( f->extend(val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const AABB &))
{
( f->extend(val_to_c<std::remove_reference<const AABB &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AABB::extend.")));
RET CN;
}

SV AABB_grow(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"AABB::grow" EAOE));
AABB*f;
f=(AABB*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Vector3D &))
{
( f->grow(val_to_c<std::remove_reference<const Vector3D &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("AABB::grow.")));
RET CN;
}

void RigidBodyConstructionInfo_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,RigidBodyConstructionInfo))
CATE(TE,"RigidBodyConstructionInfo::__del__ expects RigidBodyConstructionInfo as first argument."));

DELETE((RigidBodyConstructionInfo*)f->data);
}SV RigidBodyConstructionInfo_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"RigidBodyConstructionInfo's constructor" EAOE));
if(!TS(a[0],RigidBodyConstructionInfo))
CATE(TE,"RigidBodyConstructionInfo's constructor expects RigidBodyConstructionInfo as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(RigidBodyConstructionInfo_funcs,NEW(RigidBodyConstructionInfo),EXT->RigidBodyConstructionInfo_typeID);
CATE(TE,UFOF("RigidBodyConstructionInfo's constructor.")));
RET CN;
}

SV RigidBodyConstructionInfo_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("RigidBodyConstructionInfo");
EI(keyStr=="__new__")
RET CNF(RigidBodyConstructionInfo_new);
EI(keyStr=="__call__")
RET CNF(RigidBodyConstructionInfo_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(RigidBodyConstructionInfo_new);
 EI(keyStr=="type")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->type);
} EI(keyStr=="mass")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->mass);
} EI(keyStr=="entity")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->entity);
} EI(keyStr=="linearDamping")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->linearDamping);
} EI(keyStr=="angularDamping")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->angularDamping);
} EI(keyStr=="friction")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->friction);
} EI(keyStr=="rollingFriction")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->rollingFriction);
} EI(keyStr=="restitution")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->restitution);
} EI(keyStr=="linearSleepingThreshold")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->linearSleepingThreshold);
} EI(keyStr=="angularSleepingThreshold")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->angularSleepingThreshold);
} EI(keyStr=="collisionMask")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
RET CV(obj->collisionMask);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void RigidBodyConstructionInfo_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="type")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->type=val_to_c<decltype(obj->type)>::f(ctx,value);
} EI(keyStr=="mass")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->mass=val_to_c<decltype(obj->mass)>::f(ctx,value);
} EI(keyStr=="entity")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->entity=val_to_c<decltype(obj->entity)>::f(ctx,value);
} EI(keyStr=="linearDamping")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->linearDamping=val_to_c<decltype(obj->linearDamping)>::f(ctx,value);
} EI(keyStr=="angularDamping")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->angularDamping=val_to_c<decltype(obj->angularDamping)>::f(ctx,value);
} EI(keyStr=="friction")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->friction=val_to_c<decltype(obj->friction)>::f(ctx,value);
} EI(keyStr=="rollingFriction")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->rollingFriction=val_to_c<decltype(obj->rollingFriction)>::f(ctx,value);
} EI(keyStr=="restitution")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->restitution=val_to_c<decltype(obj->restitution)>::f(ctx,value);
} EI(keyStr=="linearSleepingThreshold")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->linearSleepingThreshold=val_to_c<decltype(obj->linearSleepingThreshold)>::f(ctx,value);
} EI(keyStr=="angularSleepingThreshold")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->angularSleepingThreshold=val_to_c<decltype(obj->angularSleepingThreshold)>::f(ctx,value);
} EI(keyStr=="collisionMask")
{
RigidBodyConstructionInfo*obj=(RigidBodyConstructionInfo*)f->data;
obj->collisionMask=val_to_c<decltype(obj->collisionMask)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

void List_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<scripting::Value*>))
CATE(TE,"List::__del__ expects List as first argument."));

DELETE((List<scripting::Value*>*)f->data);
}SV List_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List's constructor" EAOE));
if(!TS(a[0],List<scripting::Value*>))
CATE(TE,"List's constructor expects List as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(List_funcs,NEW(List<scripting::Value*>),EXT->List_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],std::size_t))
RET STG::createNativeObject(List_funcs,NEW(List<scripting::Value*>,val_to_c<std::size_t>::f(ctx,a[1])),EXT->List_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const List<scripting::Value*> &))
RET STG::createNativeObject(List_funcs,NEW(List<scripting::Value*>,val_to_c<const List<scripting::Value*> &>::f(ctx,a[1])),EXT->List_typeID);
CATE(TE,UFOF("List's constructor.")));
RET CN;
}

SV List_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("List");
EI(keyStr=="__new__")
RET CNF(List_new);
EI(keyStr=="__call__")
RET CNF(List_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(List_new);
 EI(keyStr == "__eq__")
RET CNF(List___eq__);
 EI(keyStr == "__neq__")
RET CNF(List___neq__);
 EI(keyStr == "get")
RET CNF(List_get);
 EI(keyStr == "set")
RET CNF(List_set);
 EI(keyStr == "getCount")
RET CNF(List_getCount);
 EI(keyStr == "getData")
RET CNF(List_getData);
 EI(keyStr == "append")
RET CNF(List_append);
 EI(keyStr == "insert")
RET CNF(List_insert);
 EI(keyStr == "remove")
RET CNF(List_remove);
 EI(keyStr == "clear")
RET CNF(List_clear);
 EI(keyStr == "find")
RET CNF(List_find);
 EI(keyStr == "copy")
RET CNF(List_copy);
 EI(keyStr == "in")
RET CNF(List_in);
 EI(keyStr == "begin")
RET CNF(List_begin);
 EI(keyStr == "end")
RET CNF(List_end);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void List_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV List_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::insert" EAOE));
List<scripting::Value*>*f;
f=(List<scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],scripting::Value*))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<scripting::Value*>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<scripting::Value*> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<scripting::Value*> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("List::insert.")));
RET CN;
}

SV List_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::begin" EAOE));
List<scripting::Value*>*f;
f=(List<scripting::Value*>*)((NO)a[0])->data;

CATE(TE,UFOF("List::begin.")));
RET CN;
}

SV List_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::set" EAOE));
List<scripting::Value*>*f;
f=(List<scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],scripting::Value*))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<scripting::Value*>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("List::set.")));
RET CN;
}

SV List_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::end" EAOE));
List<scripting::Value*>*f;
f=(List<scripting::Value*>*)((NO)a[0])->data;

CATE(TE,UFOF("List::end.")));
RET CN;
}

SV List_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::get" EAOE));
List<scripting::Value*>*f;
f=(List<scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("List::get.")));
RET CN;
}

SV List_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::clear" EAOE));
List<scripting::Value*>*f;
f=(List<scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("List::clear.")));
RET CN;
}

SV List_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::copy" EAOE));
List<scripting::Value*>*f;
f=(List<scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("List::copy.")));
RET CN;
}

SV List_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::remove" EAOE));
List<scripting::Value*>*f;
f=(List<scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("List::remove.")));
RET CN;
}

SV List_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::in" EAOE));
List<scripting::Value*>*f;
f=(List<scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],scripting::Value*))
{
RET CV( f->in(val_to_c<std::remove_reference<scripting::Value*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("List::in.")));
RET CN;
}

SV List_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::getCount" EAOE));
List<scripting::Value*>*f;
f=(List<scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("List::getCount.")));
RET CN;
}

SV List_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::getData" EAOE));
List<scripting::Value*>*f;
f=(List<scripting::Value*>*)((NO)a[0])->data;

CATE(TE,UFOF("List::getData.")));
RET CN;
}

SV List___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::__eq__" EAOE));
List<scripting::Value*>*f;
f=(List<scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<scripting::Value*> &))
{
auto v=val_to_c<std::remove_reference<const List<scripting::Value*> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("List::__eq__.")));
RET CN;
}

SV List_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::find" EAOE));
List<scripting::Value*>*f;
f=(List<scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],scripting::Value*))
{
RET CV( f->find(val_to_c<std::remove_reference<scripting::Value*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("List::find.")));
RET CN;
}

SV List_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::append" EAOE));
List<scripting::Value*>*f;
f=(List<scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],scripting::Value*))
{
( f->append(val_to_c<std::remove_reference<scripting::Value*>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<scripting::Value*> &))
{
( f->append(val_to_c<std::remove_reference<const List<scripting::Value*> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("List::append.")));
RET CN;
}

SV List___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"List::__neq__" EAOE));
List<scripting::Value*>*f;
f=(List<scripting::Value*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<scripting::Value*> &))
{
auto v=val_to_c<std::remove_reference<const List<scripting::Value*> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("List::__neq__.")));
RET CN;
}

void Audio_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Audio))
CATE(TE,"Audio::__del__ expects Audio as first argument."));

Audio*obj=(Audio*)f->data;
if(obj!=nullptr){obj->release();}
}SV Audio_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Audio's constructor" EAOE));
if(!TS(a[0],Audio))
CATE(TE,"Audio's constructor expects Audio as first argument."));
CATE(TE,UFOF("Audio's constructor.")));
}

SV Audio_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Audio");
EI(keyStr=="__new__")
RET CNF(Audio_new);
EI(keyStr=="__call__")
RET CNF(Audio_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Audio_new);
 EI(keyStr == "removeContent")
RET CNF(Audio_removeContent);
 EI(keyStr == "changeSampleFrequency")
RET CNF(Audio_changeSampleFrequency);
 EI(keyStr == "getNumSamples")
RET CNF(Audio_getNumSamples);
 EI(keyStr == "getSample")
RET CNF(Audio_getSample);
 EI(keyStr == "getMonoSample")
RET CNF(Audio_getMonoSample);
 EI(keyStr == "setSample")
RET CNF(Audio_setSample);
 EI(keyStr == "setMonoSample")
RET CNF(Audio_setMonoSample);
 EI(keyStr == "getDuration")
RET CNF(Audio_getDuration);
 EI(keyStr == "getSampleIndex")
RET CNF(Audio_getSampleIndex);
 EI(keyStr == "load")
RET CNF(Audio_load);
 EI(keyStr == "save")
RET CNF(Audio_save);
 EI(keyStr == "copy")
RET CNF(Audio_copy);
 EI(keyStr == "getType")
RET CNF(Audio_getType);
 EI(keyStr == "release")
RET CNF(Audio_release);
 EI(keyStr == "getRefCount")
RET CNF(Audio_getRefCount);
 EI(keyStr == "getFilename")
RET CNF(Audio_getFilename);
 EI(keyStr == "setFilename")
RET CNF(Audio_setFilename);
 EI(keyStr=="frequency")
{
Audio*obj=(Audio*)f->data;
RET CV(obj->frequency);
} EI(keyStr=="data")
{
Audio*obj=(Audio*)f->data;
RET CV(obj->data);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Audio_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="frequency")
{
Audio*obj=(Audio*)f->data;
obj->frequency=val_to_c<decltype(obj->frequency)>::f(ctx,value);
} EI(keyStr=="data")
{
Audio*obj=(Audio*)f->data;
obj->data=val_to_c<decltype(obj->data)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Audio_getSampleIndex(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::getSampleIndex" EAOE));
Audio*f;
f=(Audio*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->getSampleIndex(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
if(a.getCount()==4)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t)&&TS(a[3],float))
{
RET CV( f->getSampleIndex(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
;
}
CATE(TE,UFOF("Audio::getSampleIndex.")));
RET CN;
}

SV Audio_changeSampleFrequency(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::changeSampleFrequency" EAOE));
Audio*f;
f=(Audio*)((NO)a[0])->data;

if(a.getCount()==4)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t)&&TS(a[3],size_t))
{
RET CV( f->changeSampleFrequency(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[3])));
;
}
CATE(TE,UFOF("Audio::changeSampleFrequency.")));
RET CN;
}

SV Audio_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::save" EAOE));
Audio*f;
f=(Audio*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("Audio::save.")));
RET CN;
}

SV Audio_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::setFilename" EAOE));
Audio*f;
f=(Audio*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
( f->setFilename(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("Audio::setFilename.")));
RET CN;
}

SV Audio_setMonoSample(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::setMonoSample" EAOE));
Audio*f;
f=(Audio*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],float))
{
( f->setMonoSample(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("Audio::setMonoSample.")));
RET CN;
}

SV Audio_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::getType" EAOE));
Audio*f;
f=(Audio*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("Audio::getType.")));
RET CN;
}

SV Audio_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::load" EAOE));
Audio*f;
f=(Audio*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("Audio::load.")));
RET CN;
}

SV Audio_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::copy" EAOE));
Audio*f;
f=(Audio*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("Audio::copy.")));
RET CN;
}

SV Audio_getMonoSample(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::getMonoSample" EAOE));
Audio*f;
f=(Audio*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->getMonoSample(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Audio::getMonoSample.")));
RET CN;
}

SV Audio_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::release" EAOE));
Audio*f;
f=(Audio*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("Audio::release.")));
RET CN;
}

SV Audio_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::removeContent" EAOE));
Audio*f;
f=(Audio*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("Audio::removeContent.")));
RET CN;
}

SV Audio_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::getRefCount" EAOE));
Audio*f;
f=(Audio*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("Audio::getRefCount.")));
RET CN;
}

SV Audio_getDuration(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::getDuration" EAOE));
Audio*f;
f=(Audio*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getDuration());
;
}
CATE(TE,UFOF("Audio::getDuration.")));
RET CN;
}

SV Audio_getNumSamples(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::getNumSamples" EAOE));
Audio*f;
f=(Audio*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getNumSamples());
;
}
CATE(TE,UFOF("Audio::getNumSamples.")));
RET CN;
}

SV Audio_getSample(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::getSample" EAOE));
Audio*f;
f=(Audio*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t))
{
RET CV( f->getSample(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("Audio::getSample.")));
RET CN;
}

SV Audio_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::getFilename" EAOE));
Audio*f;
f=(Audio*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("Audio::getFilename.")));
RET CN;
}

SV Audio_setSample(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Audio::setSample" EAOE));
Audio*f;
f=(Audio*)((NO)a[0])->data;

if(a.getCount()==4)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t)&&TS(a[3],float))
{
( f->setSample(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("Audio::setSample.")));
RET CN;
}

void GfxTexture_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxTexture))
CATE(TE,"GfxTexture::__del__ expects GfxTexture as first argument."));

GfxTexture*obj=(GfxTexture*)f->data;
if(obj!=nullptr){obj->release();}
}SV GfxTexture_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxTexture's constructor" EAOE));
if(!TS(a[0],GfxTexture))
CATE(TE,"GfxTexture's constructor expects GfxTexture as first argument."));
CATE(TE,UFOF("GfxTexture's constructor.")));
}

SV GfxTexture_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxTexture");
EI(keyStr=="__new__")
RET CNF(GfxTexture_new);
EI(keyStr=="__call__")
RET CNF(GfxTexture_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GfxTexture_new);
 EI(keyStr == "removeContent")
RET CNF(GfxTexture_removeContent);
 EI(keyStr == "startCreation")
RET CNF(GfxTexture_startCreation);
 EI(keyStr == "allocMipmapFace")
RET CNF(GfxTexture_allocMipmapFace);
 EI(keyStr == "allocMipmap")
RET CNF(GfxTexture_allocMipmap);
 EI(keyStr == "getMipmapFace")
RET CNF(GfxTexture_getMipmapFace);
 EI(keyStr == "getMipmap")
RET CNF(GfxTexture_getMipmap);
 EI(keyStr == "generateMipmaps")
RET CNF(GfxTexture_generateMipmaps);
 EI(keyStr == "getTextureType")
RET CNF(GfxTexture_getTextureType);
 EI(keyStr == "shouldCompress")
RET CNF(GfxTexture_shouldCompress);
 EI(keyStr == "getMaximumAnisotropy")
RET CNF(GfxTexture_getMaximumAnisotropy);
 EI(keyStr == "getMinFilter")
RET CNF(GfxTexture_getMinFilter);
 EI(keyStr == "getMagFilter")
RET CNF(GfxTexture_getMagFilter);
 EI(keyStr == "getMipmapMode")
RET CNF(GfxTexture_getMipmapMode);
 EI(keyStr == "getWrapMode")
RET CNF(GfxTexture_getWrapMode);
 EI(keyStr == "getBaseWidth")
RET CNF(GfxTexture_getBaseWidth);
 EI(keyStr == "getBaseHeight")
RET CNF(GfxTexture_getBaseHeight);
 EI(keyStr == "getBaseDepth")
RET CNF(GfxTexture_getBaseDepth);
 EI(keyStr == "getCompressionQuality")
RET CNF(GfxTexture_getCompressionQuality);
 EI(keyStr == "getPurpose")
RET CNF(GfxTexture_getPurpose);
 EI(keyStr == "getFormat")
RET CNF(GfxTexture_getFormat);
 EI(keyStr == "getShadowmap")
RET CNF(GfxTexture_getShadowmap);
 EI(keyStr == "setMaximumAnisotropy")
RET CNF(GfxTexture_setMaximumAnisotropy);
 EI(keyStr == "setMinFilter")
RET CNF(GfxTexture_setMinFilter);
 EI(keyStr == "setMagFilter")
RET CNF(GfxTexture_setMagFilter);
 EI(keyStr == "setMipmapMode")
RET CNF(GfxTexture_setMipmapMode);
 EI(keyStr == "setWrapMode")
RET CNF(GfxTexture_setWrapMode);
 EI(keyStr == "setShadowmap")
RET CNF(GfxTexture_setShadowmap);
 EI(keyStr == "getImpl")
RET CNF(GfxTexture_getImpl);
 EI(keyStr == "save")
RET CNF(GfxTexture_save);
 EI(keyStr == "load")
RET CNF(GfxTexture_load);
 EI(keyStr == "copy")
RET CNF(GfxTexture_copy);
 EI(keyStr == "getType")
RET CNF(GfxTexture_getType);
 EI(keyStr == "release")
RET CNF(GfxTexture_release);
 EI(keyStr == "getRefCount")
RET CNF(GfxTexture_getRefCount);
 EI(keyStr == "getFilename")
RET CNF(GfxTexture_getFilename);
 EI(keyStr == "setFilename")
RET CNF(GfxTexture_setFilename);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GfxTexture_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GfxTexture_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::load" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("GfxTexture::load.")));
RET CN;
}

SV GfxTexture_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getFilename" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("GfxTexture::getFilename.")));
RET CN;
}

SV GfxTexture_setShadowmap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::setShadowmap" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],bool))
{
( f->setShadowmap(val_to_c<std::remove_reference<bool>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxTexture::setShadowmap.")));
RET CN;
}

SV GfxTexture_setMinFilter(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::setMinFilter" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxFilter))
{
( f->setMinFilter(val_to_c<std::remove_reference<GfxFilter>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxTexture::setMinFilter.")));
RET CN;
}

SV GfxTexture_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::copy" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("GfxTexture::copy.")));
RET CN;
}

SV GfxTexture_allocMipmap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::allocMipmap" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==5)
if(1&&TS(a[1],unsigned int)&&TS(a[2],unsigned int)&&TS(a[3],GfxFace)&&TS(a[4],const ResizableData &))
{
( f->allocMipmap(val_to_c<std::remove_reference<unsigned int>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<unsigned int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<GfxFace>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[4])));
RET CN;
}
if(a.getCount()==4)
if(1&&TS(a[1],unsigned int)&&TS(a[2],unsigned int)&&TS(a[3],const ResizableData &))
{
( f->allocMipmap(val_to_c<std::remove_reference<unsigned int>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<unsigned int>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const ResizableData &>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("GfxTexture::allocMipmap.")));
RET CN;
}

SV GfxTexture_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getRefCount" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("GfxTexture::getRefCount.")));
RET CN;
}

SV GfxTexture_getBaseDepth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getBaseDepth" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBaseDepth());
;
}
CATE(TE,UFOF("GfxTexture::getBaseDepth.")));
RET CN;
}

SV GfxTexture_startCreation(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::startCreation" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==9)
if(1&&TS(a[1],GfxTextureType)&&TS(a[2],bool)&&TS(a[3],unsigned int)&&TS(a[4],unsigned int)&&TS(a[5],unsigned int)&&TS(a[6],uint8_t)&&TS(a[7],GfxTexPurpose)&&TS(a[8],GfxTexFormat))
{
( f->startCreation(val_to_c<std::remove_reference<GfxTextureType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<bool>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<unsigned int>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<unsigned int>::type>::f(ctx,a[4]), val_to_c<std::remove_reference<unsigned int>::type>::f(ctx,a[5]), val_to_c<std::remove_reference<uint8_t>::type>::f(ctx,a[6]), val_to_c<std::remove_reference<GfxTexPurpose>::type>::f(ctx,a[7]), val_to_c<std::remove_reference<GfxTexFormat>::type>::f(ctx,a[8])));
RET CN;
}
CATE(TE,UFOF("GfxTexture::startCreation.")));
RET CN;
}

SV GfxTexture_getBaseWidth(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getBaseWidth" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBaseWidth());
;
}
CATE(TE,UFOF("GfxTexture::getBaseWidth.")));
RET CN;
}

SV GfxTexture_generateMipmaps(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::generateMipmaps" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->generateMipmaps());
RET CN;
}
CATE(TE,UFOF("GfxTexture::generateMipmaps.")));
RET CN;
}

SV GfxTexture_getMipmap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getMipmap" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

CATE(TE,UFOF("GfxTexture::getMipmap.")));
RET CN;
}

SV GfxTexture_getShadowmap(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getShadowmap" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getShadowmap());
;
}
CATE(TE,UFOF("GfxTexture::getShadowmap.")));
RET CN;
}

SV GfxTexture_getImpl(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getImpl" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

CATE(TE,UFOF("GfxTexture::getImpl.")));
RET CN;
}

SV GfxTexture_getMinFilter(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getMinFilter" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getMinFilter());
;
}
CATE(TE,UFOF("GfxTexture::getMinFilter.")));
RET CN;
}

SV GfxTexture_allocMipmapFace(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::allocMipmapFace" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

CATE(TE,UFOF("GfxTexture::allocMipmapFace.")));
RET CN;
}

SV GfxTexture_setMipmapMode(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::setMipmapMode" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxMipmapMode))
{
( f->setMipmapMode(val_to_c<std::remove_reference<GfxMipmapMode>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxTexture::setMipmapMode.")));
RET CN;
}

SV GfxTexture_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::save" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("GfxTexture::save.")));
RET CN;
}

SV GfxTexture_getMipmapMode(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getMipmapMode" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getMipmapMode());
;
}
CATE(TE,UFOF("GfxTexture::getMipmapMode.")));
RET CN;
}

SV GfxTexture_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getType" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("GfxTexture::getType.")));
RET CN;
}

SV GfxTexture_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::setFilename" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
( f->setFilename(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxTexture::setFilename.")));
RET CN;
}

SV GfxTexture_shouldCompress(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::shouldCompress" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->shouldCompress());
;
}
CATE(TE,UFOF("GfxTexture::shouldCompress.")));
RET CN;
}

SV GfxTexture_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::removeContent" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("GfxTexture::removeContent.")));
RET CN;
}

SV GfxTexture_setWrapMode(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::setWrapMode" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxWrapMode))
{
( f->setWrapMode(val_to_c<std::remove_reference<GfxWrapMode>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxTexture::setWrapMode.")));
RET CN;
}

SV GfxTexture_getBaseHeight(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getBaseHeight" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getBaseHeight());
;
}
CATE(TE,UFOF("GfxTexture::getBaseHeight.")));
RET CN;
}

SV GfxTexture_setMaximumAnisotropy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::setMaximumAnisotropy" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
( f->setMaximumAnisotropy(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxTexture::setMaximumAnisotropy.")));
RET CN;
}

SV GfxTexture_getTextureType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getTextureType" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getTextureType());
;
}
CATE(TE,UFOF("GfxTexture::getTextureType.")));
RET CN;
}

SV GfxTexture_getFormat(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getFormat" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFormat());
;
}
CATE(TE,UFOF("GfxTexture::getFormat.")));
RET CN;
}

SV GfxTexture_getMipmapFace(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getMipmapFace" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

CATE(TE,UFOF("GfxTexture::getMipmapFace.")));
RET CN;
}

SV GfxTexture_getPurpose(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getPurpose" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getPurpose());
;
}
CATE(TE,UFOF("GfxTexture::getPurpose.")));
RET CN;
}

SV GfxTexture_getMaximumAnisotropy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getMaximumAnisotropy" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getMaximumAnisotropy());
;
}
CATE(TE,UFOF("GfxTexture::getMaximumAnisotropy.")));
RET CN;
}

SV GfxTexture_setMagFilter(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::setMagFilter" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxFilter))
{
( f->setMagFilter(val_to_c<std::remove_reference<GfxFilter>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxTexture::setMagFilter.")));
RET CN;
}

SV GfxTexture_getWrapMode(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getWrapMode" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getWrapMode());
;
}
CATE(TE,UFOF("GfxTexture::getWrapMode.")));
RET CN;
}

SV GfxTexture_getMagFilter(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getMagFilter" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getMagFilter());
;
}
CATE(TE,UFOF("GfxTexture::getMagFilter.")));
RET CN;
}

SV GfxTexture_getCompressionQuality(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::getCompressionQuality" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCompressionQuality());
;
}
CATE(TE,UFOF("GfxTexture::getCompressionQuality.")));
RET CN;
}

SV GfxTexture_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxTexture::release" EAOE));
GfxTexture*f;
f=(GfxTexture*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("GfxTexture::release.")));
RET CN;
}

void GfxSubModelList_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<GfxModel::SubModel>))
CATE(TE,"GfxSubModelList::__del__ expects GfxSubModelList as first argument."));

DELETE((List<GfxModel::SubModel>*)f->data);
}SV GfxSubModelList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList's constructor" EAOE));
if(!TS(a[0],List<GfxModel::SubModel>))
CATE(TE,"GfxSubModelList's constructor expects GfxSubModelList as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(GfxSubModelList_funcs,NEW(List<GfxModel::SubModel>),EXT->GfxSubModelList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],std::size_t))
RET STG::createNativeObject(GfxSubModelList_funcs,NEW(List<GfxModel::SubModel>,val_to_c<std::size_t>::f(ctx,a[1])),EXT->GfxSubModelList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const List<GfxModel::SubModel> &))
RET STG::createNativeObject(GfxSubModelList_funcs,NEW(List<GfxModel::SubModel>,val_to_c<const List<GfxModel::SubModel> &>::f(ctx,a[1])),EXT->GfxSubModelList_typeID);
CATE(TE,UFOF("GfxSubModelList's constructor.")));
RET CN;
}

SV GfxSubModelList_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxSubModelList");
EI(keyStr=="__new__")
RET CNF(GfxSubModelList_new);
EI(keyStr=="__call__")
RET CNF(GfxSubModelList_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GfxSubModelList_new);
 EI(keyStr == "__eq__")
RET CNF(GfxSubModelList___eq__);
 EI(keyStr == "__neq__")
RET CNF(GfxSubModelList___neq__);
 EI(keyStr == "get")
RET CNF(GfxSubModelList_get);
 EI(keyStr == "set")
RET CNF(GfxSubModelList_set);
 EI(keyStr == "getCount")
RET CNF(GfxSubModelList_getCount);
 EI(keyStr == "getData")
RET CNF(GfxSubModelList_getData);
 EI(keyStr == "append")
RET CNF(GfxSubModelList_append);
 EI(keyStr == "insert")
RET CNF(GfxSubModelList_insert);
 EI(keyStr == "remove")
RET CNF(GfxSubModelList_remove);
 EI(keyStr == "clear")
RET CNF(GfxSubModelList_clear);
 EI(keyStr == "find")
RET CNF(GfxSubModelList_find);
 EI(keyStr == "copy")
RET CNF(GfxSubModelList_copy);
 EI(keyStr == "in")
RET CNF(GfxSubModelList_in);
 EI(keyStr == "begin")
RET CNF(GfxSubModelList_begin);
 EI(keyStr == "end")
RET CNF(GfxSubModelList_end);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GfxSubModelList_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GfxSubModelList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::insert" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],GfxModel::SubModel))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxModel::SubModel>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<GfxModel::SubModel> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<GfxModel::SubModel> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxSubModelList::insert.")));
RET CN;
}

SV GfxSubModelList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::begin" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0])->data;

CATE(TE,UFOF("GfxSubModelList::begin.")));
RET CN;
}

SV GfxSubModelList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::set" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],GfxModel::SubModel))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxModel::SubModel>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxSubModelList::set.")));
RET CN;
}

SV GfxSubModelList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::end" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0])->data;

CATE(TE,UFOF("GfxSubModelList::end.")));
RET CN;
}

SV GfxSubModelList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::get" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxSubModelList::get.")));
RET CN;
}

SV GfxSubModelList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::clear" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("GfxSubModelList::clear.")));
RET CN;
}

SV GfxSubModelList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::copy" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("GfxSubModelList::copy.")));
RET CN;
}

SV GfxSubModelList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::remove" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxSubModelList::remove.")));
RET CN;
}

SV GfxSubModelList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::in" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxModel::SubModel))
{
RET CV( f->in(val_to_c<std::remove_reference<GfxModel::SubModel>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxSubModelList::in.")));
RET CN;
}

SV GfxSubModelList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::getCount" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("GfxSubModelList::getCount.")));
RET CN;
}

SV GfxSubModelList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::getData" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0])->data;

CATE(TE,UFOF("GfxSubModelList::getData.")));
RET CN;
}

SV GfxSubModelList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::__eq__" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<GfxModel::SubModel> &))
{
auto v=val_to_c<std::remove_reference<const List<GfxModel::SubModel> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("GfxSubModelList::__eq__.")));
RET CN;
}

SV GfxSubModelList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::find" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxModel::SubModel))
{
RET CV( f->find(val_to_c<std::remove_reference<GfxModel::SubModel>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxSubModelList::find.")));
RET CN;
}

SV GfxSubModelList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::append" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxModel::SubModel))
{
( f->append(val_to_c<std::remove_reference<GfxModel::SubModel>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<GfxModel::SubModel> &))
{
( f->append(val_to_c<std::remove_reference<const List<GfxModel::SubModel> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxSubModelList::append.")));
RET CN;
}

SV GfxSubModelList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxSubModelList::__neq__" EAOE));
List<GfxModel::SubModel>*f;
f=(List<GfxModel::SubModel>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<GfxModel::SubModel> &))
{
auto v=val_to_c<std::remove_reference<const List<GfxModel::SubModel> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("GfxSubModelList::__neq__.")));
RET CN;
}

void GfxModel_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxModel))
CATE(TE,"GfxModel::__del__ expects GfxModel as first argument."));

GfxModel*obj=(GfxModel*)f->data;
if(obj!=nullptr){obj->release();}
}SV GfxModel_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxModel's constructor" EAOE));
if(!TS(a[0],GfxModel))
CATE(TE,"GfxModel's constructor expects GfxModel as first argument."));
CATE(TE,UFOF("GfxModel's constructor.")));
}

SV GfxModel_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxModel");
EI(keyStr=="__new__")
RET CNF(GfxModel_new);
EI(keyStr=="__call__")
RET CNF(GfxModel_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GfxModel_new);
 EI(keyStr == "removeContent")
RET CNF(GfxModel_removeContent);
 EI(keyStr == "save")
RET CNF(GfxModel_save);
 EI(keyStr == "load")
RET CNF(GfxModel_load);
 EI(keyStr == "copy")
RET CNF(GfxModel_copy);
 EI(keyStr == "getType")
RET CNF(GfxModel_getType);
 EI(keyStr == "release")
RET CNF(GfxModel_release);
 EI(keyStr == "getRefCount")
RET CNF(GfxModel_getRefCount);
 EI(keyStr == "getFilename")
RET CNF(GfxModel_getFilename);
 EI(keyStr == "setFilename")
RET CNF(GfxModel_setFilename);
 EI(keyStr=="subModels")
{
GfxModel*obj=(GfxModel*)f->data;
RET CV(obj->subModels);
} else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GfxModel_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} EI(keyStr=="subModels")
{
GfxModel*obj=(GfxModel*)f->data;
obj->subModels=val_to_c<decltype(obj->subModels)>::f(ctx,value);
} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GfxModel_load(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::load" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->load());
RET CN;
}
CATE(TE,UFOF("GfxModel::load.")));
RET CN;
}

SV GfxModel_getFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::getFilename" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getFilename());
;
}
CATE(TE,UFOF("GfxModel::getFilename.")));
RET CN;
}

SV GfxModel_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::copy" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("GfxModel::copy.")));
RET CN;
}

SV GfxModel_getType(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::getType" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getType());
;
}
CATE(TE,UFOF("GfxModel::getType.")));
RET CN;
}

SV GfxModel_setFilename(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::setFilename" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const String &))
{
( f->setFilename(val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxModel::setFilename.")));
RET CN;
}

SV GfxModel_removeContent(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::removeContent" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->removeContent());
RET CN;
}
CATE(TE,UFOF("GfxModel::removeContent.")));
RET CN;
}

SV GfxModel_getRefCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::getRefCount" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getRefCount());
;
}
CATE(TE,UFOF("GfxModel::getRefCount.")));
RET CN;
}

SV GfxModel_release(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::release" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->release());
RET CN;
}
CATE(TE,UFOF("GfxModel::release.")));
RET CN;
}

SV GfxModel_save(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxModel::save" EAOE));
GfxModel*f;
f=(GfxModel*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
if(a.getCount()==1)
if(1)
{
( f->save());
RET CN;
}
CATE(TE,UFOF("GfxModel::save.")));
RET CN;
}

void GfxLODList_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<GfxLOD>))
CATE(TE,"GfxLODList::__del__ expects GfxLODList as first argument."));

DELETE((List<GfxLOD>*)f->data);
}SV GfxLODList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList's constructor" EAOE));
if(!TS(a[0],List<GfxLOD>))
CATE(TE,"GfxLODList's constructor expects GfxLODList as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(GfxLODList_funcs,NEW(List<GfxLOD>),EXT->GfxLODList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],std::size_t))
RET STG::createNativeObject(GfxLODList_funcs,NEW(List<GfxLOD>,val_to_c<std::size_t>::f(ctx,a[1])),EXT->GfxLODList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const List<GfxLOD> &))
RET STG::createNativeObject(GfxLODList_funcs,NEW(List<GfxLOD>,val_to_c<const List<GfxLOD> &>::f(ctx,a[1])),EXT->GfxLODList_typeID);
CATE(TE,UFOF("GfxLODList's constructor.")));
RET CN;
}

SV GfxLODList_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxLODList");
EI(keyStr=="__new__")
RET CNF(GfxLODList_new);
EI(keyStr=="__call__")
RET CNF(GfxLODList_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GfxLODList_new);
 EI(keyStr == "__eq__")
RET CNF(GfxLODList___eq__);
 EI(keyStr == "__neq__")
RET CNF(GfxLODList___neq__);
 EI(keyStr == "get")
RET CNF(GfxLODList_get);
 EI(keyStr == "set")
RET CNF(GfxLODList_set);
 EI(keyStr == "getCount")
RET CNF(GfxLODList_getCount);
 EI(keyStr == "getData")
RET CNF(GfxLODList_getData);
 EI(keyStr == "append")
RET CNF(GfxLODList_append);
 EI(keyStr == "insert")
RET CNF(GfxLODList_insert);
 EI(keyStr == "remove")
RET CNF(GfxLODList_remove);
 EI(keyStr == "clear")
RET CNF(GfxLODList_clear);
 EI(keyStr == "find")
RET CNF(GfxLODList_find);
 EI(keyStr == "copy")
RET CNF(GfxLODList_copy);
 EI(keyStr == "in")
RET CNF(GfxLODList_in);
 EI(keyStr == "begin")
RET CNF(GfxLODList_begin);
 EI(keyStr == "end")
RET CNF(GfxLODList_end);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GfxLODList_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GfxLODList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::insert" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],GfxLOD))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxLOD>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<GfxLOD> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<GfxLOD> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxLODList::insert.")));
RET CN;
}

SV GfxLODList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::begin" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0])->data;

CATE(TE,UFOF("GfxLODList::begin.")));
RET CN;
}

SV GfxLODList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::set" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],GfxLOD))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxLOD>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxLODList::set.")));
RET CN;
}

SV GfxLODList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::end" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0])->data;

CATE(TE,UFOF("GfxLODList::end.")));
RET CN;
}

SV GfxLODList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::get" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxLODList::get.")));
RET CN;
}

SV GfxLODList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::clear" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("GfxLODList::clear.")));
RET CN;
}

SV GfxLODList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::copy" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("GfxLODList::copy.")));
RET CN;
}

SV GfxLODList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::remove" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxLODList::remove.")));
RET CN;
}

SV GfxLODList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::in" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxLOD))
{
RET CV( f->in(val_to_c<std::remove_reference<GfxLOD>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxLODList::in.")));
RET CN;
}

SV GfxLODList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::getCount" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("GfxLODList::getCount.")));
RET CN;
}

SV GfxLODList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::getData" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0])->data;

CATE(TE,UFOF("GfxLODList::getData.")));
RET CN;
}

SV GfxLODList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::__eq__" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<GfxLOD> &))
{
auto v=val_to_c<std::remove_reference<const List<GfxLOD> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("GfxLODList::__eq__.")));
RET CN;
}

SV GfxLODList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::find" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxLOD))
{
RET CV( f->find(val_to_c<std::remove_reference<GfxLOD>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxLODList::find.")));
RET CN;
}

SV GfxLODList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::append" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxLOD))
{
( f->append(val_to_c<std::remove_reference<GfxLOD>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<GfxLOD> &))
{
( f->append(val_to_c<std::remove_reference<const List<GfxLOD> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxLODList::append.")));
RET CN;
}

SV GfxLODList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxLODList::__neq__" EAOE));
List<GfxLOD>*f;
f=(List<GfxLOD>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<GfxLOD> &))
{
auto v=val_to_c<std::remove_reference<const List<GfxLOD> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("GfxLODList::__neq__.")));
RET CN;
}

void EntityList_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<Entity*>))
CATE(TE,"EntityList::__del__ expects EntityList as first argument."));

DELETE((List<Entity*>*)f->data);
}SV EntityList_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList's constructor" EAOE));
if(!TS(a[0],List<Entity*>))
CATE(TE,"EntityList's constructor expects EntityList as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(EntityList_funcs,NEW(List<Entity*>),EXT->EntityList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],std::size_t))
RET STG::createNativeObject(EntityList_funcs,NEW(List<Entity*>,val_to_c<std::size_t>::f(ctx,a[1])),EXT->EntityList_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const List<Entity*> &))
RET STG::createNativeObject(EntityList_funcs,NEW(List<Entity*>,val_to_c<const List<Entity*> &>::f(ctx,a[1])),EXT->EntityList_typeID);
CATE(TE,UFOF("EntityList's constructor.")));
RET CN;
}

SV EntityList_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("EntityList");
EI(keyStr=="__new__")
RET CNF(EntityList_new);
EI(keyStr=="__call__")
RET CNF(EntityList_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(EntityList_new);
 EI(keyStr == "__eq__")
RET CNF(EntityList___eq__);
 EI(keyStr == "__neq__")
RET CNF(EntityList___neq__);
 EI(keyStr == "get")
RET CNF(EntityList_get);
 EI(keyStr == "set")
RET CNF(EntityList_set);
 EI(keyStr == "getCount")
RET CNF(EntityList_getCount);
 EI(keyStr == "getData")
RET CNF(EntityList_getData);
 EI(keyStr == "append")
RET CNF(EntityList_append);
 EI(keyStr == "insert")
RET CNF(EntityList_insert);
 EI(keyStr == "remove")
RET CNF(EntityList_remove);
 EI(keyStr == "clear")
RET CNF(EntityList_clear);
 EI(keyStr == "find")
RET CNF(EntityList_find);
 EI(keyStr == "copy")
RET CNF(EntityList_copy);
 EI(keyStr == "in")
RET CNF(EntityList_in);
 EI(keyStr == "begin")
RET CNF(EntityList_begin);
 EI(keyStr == "end")
RET CNF(EntityList_end);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void EntityList_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV EntityList_insert(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::insert" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],Entity*))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<Entity*>::type>::f(ctx,a[2])));
RET CN;
}
if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],const List<Entity*> &))
{
( f->insert(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const List<Entity*> &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("EntityList::insert.")));
RET CN;
}

SV EntityList_begin(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::begin" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0])->data;

CATE(TE,UFOF("EntityList::begin.")));
RET CN;
}

SV EntityList_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::set" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],Entity*))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<Entity*>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("EntityList::set.")));
RET CN;
}

SV EntityList_end(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::end" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0])->data;

CATE(TE,UFOF("EntityList::end.")));
RET CN;
}

SV EntityList_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::get" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("EntityList::get.")));
RET CN;
}

SV EntityList_clear(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::clear" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
( f->clear());
RET CN;
}
CATE(TE,UFOF("EntityList::clear.")));
RET CN;
}

SV EntityList_copy(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::copy" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->copy());
;
}
CATE(TE,UFOF("EntityList::copy.")));
RET CN;
}

SV EntityList_remove(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::remove" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],std::size_t)&&TS(a[2],std::size_t))
{
( f->remove(val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<std::size_t>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("EntityList::remove.")));
RET CN;
}

SV EntityList_in(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::in" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],Entity*))
{
RET CV( f->in(val_to_c<std::remove_reference<Entity*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("EntityList::in.")));
RET CN;
}

SV EntityList_getCount(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::getCount" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->getCount());
;
}
CATE(TE,UFOF("EntityList::getCount.")));
RET CN;
}

SV EntityList_getData(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::getData" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0])->data;

CATE(TE,UFOF("EntityList::getData.")));
RET CN;
}

SV EntityList___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::__eq__" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<Entity*> &))
{
auto v=val_to_c<std::remove_reference<const List<Entity*> &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("EntityList::__eq__.")));
RET CN;
}

SV EntityList_find(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::find" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],Entity*))
{
RET CV( f->find(val_to_c<std::remove_reference<Entity*>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("EntityList::find.")));
RET CN;
}

SV EntityList_append(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::append" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],Entity*))
{
( f->append(val_to_c<std::remove_reference<Entity*>::type>::f(ctx,a[1])));
RET CN;
}
if(a.getCount()==2)
if(1&&TS(a[1],const List<Entity*> &))
{
( f->append(val_to_c<std::remove_reference<const List<Entity*> &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("EntityList::append.")));
RET CN;
}

SV EntityList___neq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"EntityList::__neq__" EAOE));
List<Entity*>*f;
f=(List<Entity*>*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const List<Entity*> &))
{
auto v=val_to_c<std::remove_reference<const List<Entity*> &>::type>::f(ctx,a[1]);
RET CV(*f != v);
}
CATE(TE,UFOF("EntityList::__neq__.")));
RET CN;
}

void GfxShaderCombination_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxShaderCombination))
CATE(TE,"GfxShaderCombination::__del__ expects GfxShaderCombination as first argument."));

DELETE((GfxShaderCombination*)f->data);
}SV GfxShaderCombination_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShaderCombination's constructor" EAOE));
if(!TS(a[0],GfxShaderCombination))
CATE(TE,"GfxShaderCombination's constructor expects GfxShaderCombination as first argument."));
if(a.getCount()==3)
if(true&&TS(a[1],GfxShader *)&&TS(a[2],GfxShader *))
RET STG::createNativeObject(GfxShaderCombination_funcs,NEW(GfxShaderCombination,val_to_c<GfxShader *>::f(ctx,a[1]),val_to_c<GfxShader *>::f(ctx,a[2])),EXT->GfxShaderCombination_typeID);
CATE(TE,UFOF("GfxShaderCombination's constructor.")));
RET CN;
}

SV GfxShaderCombination_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxShaderCombination");
EI(keyStr=="__new__")
RET CNF(GfxShaderCombination_new);
EI(keyStr=="__call__")
RET CNF(GfxShaderCombination_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GfxShaderCombination_new);
 EI(keyStr == "setDefine")
RET CNF(GfxShaderCombination_setDefine);
 EI(keyStr == "getDefine")
RET CNF(GfxShaderCombination_getDefine);
 EI(keyStr == "removeDefine")
RET CNF(GfxShaderCombination_removeDefine);
 EI(keyStr == "getShader")
RET CNF(GfxShaderCombination_getShader);
 EI(keyStr == "setShader")
RET CNF(GfxShaderCombination_setShader);
 EI(keyStr == "getCompiled")
RET CNF(GfxShaderCombination_getCompiled);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GfxShaderCombination_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GfxShaderCombination_setShader(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShaderCombination::setShader" EAOE));
GfxShaderCombination*f;
f=(GfxShaderCombination*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],GfxShaderType)&&TS(a[2],GfxShader *))
{
( f->setShader(val_to_c<std::remove_reference<GfxShaderType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<GfxShader *>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxShaderCombination::setShader.")));
RET CN;
}

SV GfxShaderCombination_getShader(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShaderCombination::getShader" EAOE));
GfxShaderCombination*f;
f=(GfxShaderCombination*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxShaderType))
{
RET CV( f->getShader(val_to_c<std::remove_reference<GfxShaderType>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxShaderCombination::getShader.")));
RET CN;
}

SV GfxShaderCombination_getCompiled(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShaderCombination::getCompiled" EAOE));
GfxShaderCombination*f;
f=(GfxShaderCombination*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],GfxShaderType))
{
RET CV( f->getCompiled(val_to_c<std::remove_reference<GfxShaderType>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("GfxShaderCombination::getCompiled.")));
RET CN;
}

SV GfxShaderCombination_getDefine(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShaderCombination::getDefine" EAOE));
GfxShaderCombination*f;
f=(GfxShaderCombination*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],GfxShaderType)&&TS(a[2],const String &))
{
RET CV( f->getDefine(val_to_c<std::remove_reference<GfxShaderType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("GfxShaderCombination::getDefine.")));
RET CN;
}

SV GfxShaderCombination_removeDefine(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShaderCombination::removeDefine" EAOE));
GfxShaderCombination*f;
f=(GfxShaderCombination*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],GfxShaderType)&&TS(a[2],const String &))
{
( f->removeDefine(val_to_c<std::remove_reference<GfxShaderType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[2])));
RET CN;
}
CATE(TE,UFOF("GfxShaderCombination::removeDefine.")));
RET CN;
}

SV GfxShaderCombination_setDefine(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxShaderCombination::setDefine" EAOE));
GfxShaderCombination*f;
f=(GfxShaderCombination*)((NO)a[0])->data;

if(a.getCount()==4)
if(1&&TS(a[1],GfxShaderType)&&TS(a[2],const String &)&&TS(a[3],const String &))
{
( f->setDefine(val_to_c<std::remove_reference<GfxShaderType>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const String &>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("GfxShaderCombination::setDefine.")));
RET CN;
}

void Matrix3x3_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Matrix3x3))
CATE(TE,"Matrix3x3::__del__ expects Matrix3x3 as first argument."));

DELETE((Matrix3x3*)f->data);
}SV Matrix3x3_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3's constructor" EAOE));
if(!TS(a[0],Matrix3x3))
CATE(TE,"Matrix3x3's constructor expects Matrix3x3 as first argument."));
if(a.getCount()==1)
if(true)
RET STG::createNativeObject(Matrix3x3_funcs,NEW(Matrix3x3),EXT->Matrix3x3_typeID);
if(a.getCount()==2)
if(true&&TS(a[1],const Matrix4x4 &))
RET STG::createNativeObject(Matrix3x3_funcs,NEW(Matrix3x3,val_to_c<const Matrix4x4 &>::f(ctx,a[1])),EXT->Matrix3x3_typeID);
if(a.getCount()==4)
if(true&&TS(a[1],const Float3 &)&&TS(a[2],const Float3 &)&&TS(a[3],const Float3 &))
RET STG::createNativeObject(Matrix3x3_funcs,NEW(Matrix3x3,val_to_c<const Float3 &>::f(ctx,a[1]),val_to_c<const Float3 &>::f(ctx,a[2]),val_to_c<const Float3 &>::f(ctx,a[3])),EXT->Matrix3x3_typeID);
CATE(TE,UFOF("Matrix3x3's constructor.")));
RET CN;
}

SV Matrix3x3_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Matrix3x3");
EI(keyStr=="__new__")
RET CNF(Matrix3x3_new);
EI(keyStr=="__call__")
RET CNF(Matrix3x3_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(Matrix3x3_new);
 EI(keyStr == "__mul__")
RET CNF(Matrix3x3___mul__);
 EI(keyStr == "__div__")
RET CNF(Matrix3x3___div__);
 EI(keyStr == "get")
RET CNF(Matrix3x3_get);
 EI(keyStr == "set")
RET CNF(Matrix3x3_set);
 EI(keyStr == "__eq__")
RET CNF(Matrix3x3___eq__);
 EI(keyStr == "transpose")
RET CNF(Matrix3x3_transpose);
 EI(keyStr == "inverse")
RET CNF(Matrix3x3_inverse);
 EI(keyStr == "translate")
RET CNF(Matrix3x3_translate);
 EI(keyStr == "scale")
RET CNF(Matrix3x3_scale);
 EI(keyStr == "rotate")
RET CNF(Matrix3x3_rotate);
 EI(keyStr == "rotatex")
RET CNF(Matrix3x3_rotatex);
 EI(keyStr == "rotatey")
RET CNF(Matrix3x3_rotatey);
 EI(keyStr == "rotatez")
RET CNF(Matrix3x3_rotatez);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void Matrix3x3_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV Matrix3x3_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::set" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0])->data;

if(a.getCount()==4)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t)&&TS(a[3],float))
{
( f->set(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<float>::type>::f(ctx,a[3])));
RET CN;
}
CATE(TE,UFOF("Matrix3x3::set.")));
RET CN;
}

SV Matrix3x3_get(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::get" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0])->data;

if(a.getCount()==3)
if(1&&TS(a[1],size_t)&&TS(a[2],size_t))
{
RET CV( f->get(val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<size_t>::type>::f(ctx,a[2])));
;
}
CATE(TE,UFOF("Matrix3x3::get.")));
RET CN;
}

SV Matrix3x3_transpose(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::transpose" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->transpose());
;
}
CATE(TE,UFOF("Matrix3x3::transpose.")));
RET CN;
}

SV Matrix3x3_rotatez(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::rotatez" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->rotatez(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix3x3::rotatez.")));
RET CN;
}

SV Matrix3x3_rotatex(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::rotatex" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->rotatex(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix3x3::rotatex.")));
RET CN;
}

SV Matrix3x3_rotatey(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::rotatey" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->rotatey(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix3x3::rotatey.")));
RET CN;
}

SV Matrix3x3___div__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::__div__" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
auto v=val_to_c<std::remove_reference<float>::type>::f(ctx,a[1]);
RET CV(*f / v);
}
CATE(TE,UFOF("Matrix3x3::__div__.")));
RET CN;
}

SV Matrix3x3_inverse(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::inverse" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0])->data;

if(a.getCount()==1)
if(1)
{
RET CV( f->inverse());
;
}
CATE(TE,UFOF("Matrix3x3::inverse.")));
RET CN;
}

SV Matrix3x3___mul__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::__mul__" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Matrix3x3 &))
{
auto v=val_to_c<std::remove_reference<const Matrix3x3 &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
auto v=val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1]);
RET CV(*f * v);
}
CATE(TE,UFOF("Matrix3x3::__mul__.")));
RET CN;
}

SV Matrix3x3_translate(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::translate" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float2 &))
{
RET CV( f->translate(val_to_c<std::remove_reference<const Float2 &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix3x3::translate.")));
RET CN;
}

SV Matrix3x3___eq__(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::__eq__" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Matrix3x3 &))
{
auto v=val_to_c<std::remove_reference<const Matrix3x3 &>::type>::f(ctx,a[1]);
RET CV(*f == v);
}
CATE(TE,UFOF("Matrix3x3::__eq__.")));
RET CN;
}

SV Matrix3x3_rotate(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::rotate" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],float))
{
RET CV( f->rotate(val_to_c<std::remove_reference<float>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix3x3::rotate.")));
RET CN;
}

SV Matrix3x3_scale(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"Matrix3x3::scale" EAOE));
Matrix3x3*f;
f=(Matrix3x3*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Float3 &))
{
RET CV( f->scale(val_to_c<std::remove_reference<const Float3 &>::type>::f(ctx,a[1])));
;
}
CATE(TE,UFOF("Matrix3x3::scale.")));
RET CN;
}

void GfxDebugDrawer_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxDebugDrawer))
CATE(TE,"GfxDebugDrawer::__del__ expects GfxDebugDrawer as first argument."));

DELETE((GfxDebugDrawer*)f->data);
}SV GfxDebugDrawer_new(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxDebugDrawer's constructor" EAOE));
if(!TS(a[0],GfxDebugDrawer))
CATE(TE,"GfxDebugDrawer's constructor expects GfxDebugDrawer as first argument."));
CATE(TE,UFOF("GfxDebugDrawer's constructor.")));
RET CN;
}

SV GfxDebugDrawer_get_member(CTX ctx,NO f,SV key)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxDebugDrawer");
EI(keyStr=="__new__")
RET CNF(GfxDebugDrawer_new);
EI(keyStr=="__call__")
RET CNF(GfxDebugDrawer_new);
else
 CATE(KE,"Unknown member."));
} else
{
if(keyStr=="__classTypeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__init__")
RET CNF(GfxDebugDrawer_new);
 EI(keyStr == "addLine")
RET CNF(GfxDebugDrawer_addLine);
 EI(keyStr == "render")
RET CNF(GfxDebugDrawer_render);
 else
 CATE(KE,"Unknown member."));
}
}
RET CN;
}

void GfxDebugDrawer_set_member(CTX ctx,NO f,SV key,SV value)
{
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue*)key)->value;
if(f->data==NULL)
CATE(KE,"Native classes are read-only."));
else
{
if(0) {} else
 CATE(KE,"Unknown member or member if read-only."));
}
}
}

SV GfxDebugDrawer_addLine(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxDebugDrawer::addLine" EAOE));
GfxDebugDrawer*f;
f=(GfxDebugDrawer*)((NO)a[0])->data;

if(a.getCount()==5)
if(1&&TS(a[1],const Position3D &)&&TS(a[2],const Position3D &)&&TS(a[3],const Float4 &)&&TS(a[4],const Float4 &))
{
( f->addLine(val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[1]), val_to_c<std::remove_reference<const Position3D &>::type>::f(ctx,a[2]), val_to_c<std::remove_reference<const Float4 &>::type>::f(ctx,a[3]), val_to_c<std::remove_reference<const Float4 &>::type>::f(ctx,a[4])));
RET CN;
}
CATE(TE,UFOF("GfxDebugDrawer::addLine.")));
RET CN;
}

SV GfxDebugDrawer_render(CTX ctx,const List<SV>&a)
{
if(a.getCount()<1)
CATE(VE,"GfxDebugDrawer::render" EAOE));
GfxDebugDrawer*f;
f=(GfxDebugDrawer*)((NO)a[0])->data;

if(a.getCount()==2)
if(1&&TS(a[1],const Camera &))
{
( f->render(val_to_c<std::remove_reference<const Camera &>::type>::f(ctx,a[1])));
RET CN;
}
CATE(TE,UFOF("GfxDebugDrawer::render.")));
RET CN;
}

SV getFileSys_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==0)
if(1)
{
RET CV( getFileSys());
;
}
CATE(TE,UFOF("getFileSys")));
RET CN;
}

SV getAudioDevice_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==0)
if(1)
{
RET CV( getAudioDevice());
;
}
CATE(TE,UFOF("getAudioDevice")));
RET CN;
}

SV listFiles_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==1)
if(1&&TS(a[0],const char *))
{
RET CV( listFiles(val_to_c<const char *>::f(ctx,a[0])));
;
}
CATE(TE,UFOF("listFiles")));
RET CN;
}

SV getResMgr_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==0)
if(1)
{
RET CV( getResMgr());
;
}
CATE(TE,UFOF("getResMgr")));
RET CN;
}

SV getApp_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==0)
if(1)
{
RET CV( getApp());
;
}
CATE(TE,UFOF("getApp")));
RET CN;
}

SV getDebugDrawer_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==0)
if(1)
{
RET CV( getDebugDrawer());
;
}
CATE(TE,UFOF("getDebugDrawer")));
RET CN;
}

SV getPlatform_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==0)
if(1)
{
RET CV( getPlatform());
;
}
CATE(TE,UFOF("getPlatform")));
RET CN;
}

SV getGfxApi_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==0)
if(1)
{
RET CV( getGfxApi());
;
}
CATE(TE,UFOF("getGfxApi")));
RET CN;
}

SV doesFileExist_binding(CTX ctx,const List<SV>&a)
{
if(a.getCount()==1)
if(1&&TS(a[0],const char *))
{
RET CV( doesFileExist(val_to_c<const char *>::f(ctx,a[0])));
;
}
CATE(TE,UFOF("doesFileExist")));
RET CN;
}

SV GhostObject_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GhostObject;
NO obj=(NO)GhostObject_new(ctx, args2);
obj->funcs=GhostObject_ptr_funcs;
obj->typeID=EXT->GhostObject_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GhostObject_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GhostObjectRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,GhostObject*))
CATE(TE,"GhostObjectRef::deref expects GhostObjectRef as first argument."));
CATE(TE,"GhostObject objects are not copyable."));
}
SV GhostObject_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GhostObject::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,GhostObject*))
CATE(TE,"GhostObjectRef::refset expects GhostObjectRef as first argument."));
CATE(TE,"GhostObject objects are not copyable."));
RET CN;
}

void GhostObject_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GhostObject*))
CATE(TE,"GhostObjectRef::__del__ expects GhostObjectRef as first argument."));
}
SV GhostObject_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,GhostObject*))
CATE(TE,FAE("GhostObjectRef's get method","GhostObjectRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GhostObjectPtr");
EI(keyStr=="__new__")
RET CNF(GhostObject_ptr_new);
EI(keyStr=="__call__")
RET CNF(GhostObject_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GhostObject_ptr_deref);
if(keyStr=="refset")RET CNF(GhostObject_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GhostObject_funcs;
obj.typeID=EXT->GhostObject_typeID;
obj.refCount=1;
obj.data=f->data;
RET GhostObject_get_member(ctx, &obj, key);
}
void GhostObject_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,GhostObject*))
CATE(TE,FAE("GhostObjectRef's set method","GhostObjectRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GhostObject_funcs;
obj.typeID=EXT->GhostObject_typeID;
obj.refCount=1;
obj.data=f->data;
GhostObject_set_member(ctx, &obj, key, value);
}
SV Filesystem_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Filesystem;
NO obj=(NO)Filesystem_new(ctx, args2);
obj->funcs=Filesystem_ptr_funcs;
obj->typeID=EXT->Filesystem_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Filesystem_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"FilesystemRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,Filesystem*))
CATE(TE,"FilesystemRef::deref expects FilesystemRef as first argument."));
RET CV(*(Filesystem *)((NO)f)->data);
}
SV Filesystem_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Filesystem::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,Filesystem*))
CATE(TE,"FilesystemRef::refset expects FilesystemRef as first argument."));
*((Filesystem *)((NO)f)->data) = val_to_c<Filesystem>::f(ctx,a[1]);
RET CN;
}

void Filesystem_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Filesystem*))
CATE(TE,"FilesystemRef::__del__ expects FilesystemRef as first argument."));
SCRIPT_DELETE((Filesystem *)f->data);
}
SV Filesystem_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,Filesystem*))
CATE(TE,FAE("FilesystemRef's get method","FilesystemRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("FilesystemPtr");
EI(keyStr=="__new__")
RET CNF(Filesystem_ptr_new);
EI(keyStr=="__call__")
RET CNF(Filesystem_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Filesystem_ptr_deref);
if(keyStr=="refset")RET CNF(Filesystem_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Filesystem_funcs;
obj.typeID=EXT->Filesystem_typeID;
obj.refCount=1;
obj.data=f->data;
RET Filesystem_get_member(ctx, &obj, key);
}
void Filesystem_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,Filesystem*))
CATE(TE,FAE("FilesystemRef's set method","FilesystemRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Filesystem_funcs;
obj.typeID=EXT->Filesystem_typeID;
obj.refCount=1;
obj.data=f->data;
Filesystem_set_member(ctx, &obj, key, value);
}
SV StrStrMap_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->StrStrMap;
NO obj=(NO)StrStrMap_new(ctx, args2);
obj->funcs=StrStrMap_ptr_funcs;
obj->typeID=EXT->StrStrMap_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV StrStrMap_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"StrStrMapRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,HashMap<String,String>*))
CATE(TE,"StrStrMapRef::deref expects StrStrMapRef as first argument."));
RET CV(*(HashMap<String,String> *)((NO)f)->data);
}
SV StrStrMap_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"StrStrMap::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,HashMap<String,String>*))
CATE(TE,"StrStrMapRef::refset expects StrStrMapRef as first argument."));
*((HashMap<String,String> *)((NO)f)->data) = val_to_c<HashMap<String,String>>::f(ctx,a[1]);
RET CN;
}

void StrStrMap_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,HashMap<String,String>*))
CATE(TE,"StrStrMapRef::__del__ expects StrStrMapRef as first argument."));
SCRIPT_DELETE((HashMap<String,String> *)f->data);
}
SV StrStrMap_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,HashMap<String,String>*))
CATE(TE,FAE("StrStrMapRef's get method","StrStrMapRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("StrStrMapPtr");
EI(keyStr=="__new__")
RET CNF(StrStrMap_ptr_new);
EI(keyStr=="__call__")
RET CNF(StrStrMap_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(StrStrMap_ptr_deref);
if(keyStr=="refset")RET CNF(StrStrMap_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=StrStrMap_funcs;
obj.typeID=EXT->StrStrMap_typeID;
obj.refCount=1;
obj.data=f->data;
RET StrStrMap_get_member(ctx, &obj, key);
}
void StrStrMap_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,HashMap<String,String>*))
CATE(TE,FAE("StrStrMapRef's set method","StrStrMapRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=StrStrMap_funcs;
obj.typeID=EXT->StrStrMap_typeID;
obj.refCount=1;
obj.data=f->data;
StrStrMap_set_member(ctx, &obj, key, value);
}
SV GfxApi_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GfxApi;
NO obj=(NO)GfxApi_new(ctx, args2);
obj->funcs=GfxApi_ptr_funcs;
obj->typeID=EXT->GfxApi_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GfxApi_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxApiRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,GfxApi*))
CATE(TE,"GfxApiRef::deref expects GfxApiRef as first argument."));
CATE(TE,"GfxApi objects are not copyable."));
}
SV GfxApi_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GfxApi::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,GfxApi*))
CATE(TE,"GfxApiRef::refset expects GfxApiRef as first argument."));
CATE(TE,"GfxApi objects are not copyable."));
RET CN;
}

void GfxApi_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxApi*))
CATE(TE,"GfxApiRef::__del__ expects GfxApiRef as first argument."));
SCRIPT_DELETE((GfxApi *)f->data);
}
SV GfxApi_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,GfxApi*))
CATE(TE,FAE("GfxApiRef's get method","GfxApiRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxApiPtr");
EI(keyStr=="__new__")
RET CNF(GfxApi_ptr_new);
EI(keyStr=="__call__")
RET CNF(GfxApi_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GfxApi_ptr_deref);
if(keyStr=="refset")RET CNF(GfxApi_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxApi_funcs;
obj.typeID=EXT->GfxApi_typeID;
obj.refCount=1;
obj.data=f->data;
RET GfxApi_get_member(ctx, &obj, key);
}
void GfxApi_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,GfxApi*))
CATE(TE,FAE("GfxApiRef's set method","GfxApiRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxApi_funcs;
obj.typeID=EXT->GfxApi_typeID;
obj.refCount=1;
obj.data=f->data;
GfxApi_set_member(ctx, &obj, key, value);
}
SV GfxCompiledShader_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GfxCompiledShader;
NO obj=(NO)GfxCompiledShader_new(ctx, args2);
obj->funcs=GfxCompiledShader_ptr_funcs;
obj->typeID=EXT->GfxCompiledShader_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GfxCompiledShader_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxCompiledShaderRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,GfxCompiledShader*))
CATE(TE,"GfxCompiledShaderRef::deref expects GfxCompiledShaderRef as first argument."));
RET CV(*(GfxCompiledShader *)((NO)f)->data);
}
SV GfxCompiledShader_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GfxCompiledShader::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,GfxCompiledShader*))
CATE(TE,"GfxCompiledShaderRef::refset expects GfxCompiledShaderRef as first argument."));
*((GfxCompiledShader *)((NO)f)->data) = val_to_c<GfxCompiledShader>::f(ctx,a[1]);
RET CN;
}

void GfxCompiledShader_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxCompiledShader*))
CATE(TE,"GfxCompiledShaderRef::__del__ expects GfxCompiledShaderRef as first argument."));
SCRIPT_DELETE((GfxCompiledShader *)f->data);
}
SV GfxCompiledShader_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,GfxCompiledShader*))
CATE(TE,FAE("GfxCompiledShaderRef's get method","GfxCompiledShaderRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxCompiledShaderPtr");
EI(keyStr=="__new__")
RET CNF(GfxCompiledShader_ptr_new);
EI(keyStr=="__call__")
RET CNF(GfxCompiledShader_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GfxCompiledShader_ptr_deref);
if(keyStr=="refset")RET CNF(GfxCompiledShader_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxCompiledShader_funcs;
obj.typeID=EXT->GfxCompiledShader_typeID;
obj.refCount=1;
obj.data=f->data;
RET GfxCompiledShader_get_member(ctx, &obj, key);
}
void GfxCompiledShader_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,GfxCompiledShader*))
CATE(TE,FAE("GfxCompiledShaderRef's set method","GfxCompiledShaderRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxCompiledShader_funcs;
obj.typeID=EXT->GfxCompiledShader_typeID;
obj.refCount=1;
obj.data=f->data;
GfxCompiledShader_set_member(ctx, &obj, key, value);
}
SV ScrollBar_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->ScrollBar;
NO obj=(NO)ScrollBar_new(ctx, args2);
obj->funcs=ScrollBar_ptr_funcs;
obj->typeID=EXT->ScrollBar_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV ScrollBar_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"ScrollBarRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,ScrollBar*))
CATE(TE,"ScrollBarRef::deref expects ScrollBarRef as first argument."));
RET CV(*(ScrollBar *)((NO)f)->data);
}
SV ScrollBar_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"ScrollBar::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,ScrollBar*))
CATE(TE,"ScrollBarRef::refset expects ScrollBarRef as first argument."));
*((ScrollBar *)((NO)f)->data) = val_to_c<ScrollBar>::f(ctx,a[1]);
RET CN;
}

void ScrollBar_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,ScrollBar*))
CATE(TE,"ScrollBarRef::__del__ expects ScrollBarRef as first argument."));
SCRIPT_DELETE((ScrollBar *)f->data);
}
SV ScrollBar_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,ScrollBar*))
CATE(TE,FAE("ScrollBarRef's get method","ScrollBarRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("ScrollBarPtr");
EI(keyStr=="__new__")
RET CNF(ScrollBar_ptr_new);
EI(keyStr=="__call__")
RET CNF(ScrollBar_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(ScrollBar_ptr_deref);
if(keyStr=="refset")RET CNF(ScrollBar_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=ScrollBar_funcs;
obj.typeID=EXT->ScrollBar_typeID;
obj.refCount=1;
obj.data=f->data;
RET ScrollBar_get_member(ctx, &obj, key);
}
void ScrollBar_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,ScrollBar*))
CATE(TE,FAE("ScrollBarRef's set method","ScrollBarRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=ScrollBar_funcs;
obj.typeID=EXT->ScrollBar_typeID;
obj.refCount=1;
obj.data=f->data;
ScrollBar_set_member(ctx, &obj, key, value);
}
SV GhostObjList_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GhostObjList;
NO obj=(NO)GhostObjList_new(ctx, args2);
obj->funcs=GhostObjList_ptr_funcs;
obj->typeID=EXT->GhostObjList_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GhostObjList_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GhostObjListRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,List<GhostObject*>*))
CATE(TE,"GhostObjListRef::deref expects GhostObjListRef as first argument."));
RET CV(*(List<GhostObject*> *)((NO)f)->data);
}
SV GhostObjList_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GhostObjList::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,List<GhostObject*>*))
CATE(TE,"GhostObjListRef::refset expects GhostObjListRef as first argument."));
*((List<GhostObject*> *)((NO)f)->data) = val_to_c<List<GhostObject*>>::f(ctx,a[1]);
RET CN;
}

void GhostObjList_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<GhostObject*>*))
CATE(TE,"GhostObjListRef::__del__ expects GhostObjListRef as first argument."));
SCRIPT_DELETE((List<GhostObject*> *)f->data);
}
SV GhostObjList_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,List<GhostObject*>*))
CATE(TE,FAE("GhostObjListRef's get method","GhostObjListRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GhostObjListPtr");
EI(keyStr=="__new__")
RET CNF(GhostObjList_ptr_new);
EI(keyStr=="__call__")
RET CNF(GhostObjList_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GhostObjList_ptr_deref);
if(keyStr=="refset")RET CNF(GhostObjList_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GhostObjList_funcs;
obj.typeID=EXT->GhostObjList_typeID;
obj.refCount=1;
obj.data=f->data;
RET GhostObjList_get_member(ctx, &obj, key);
}
void GhostObjList_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,List<GhostObject*>*))
CATE(TE,FAE("GhostObjListRef's set method","GhostObjListRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GhostObjList_funcs;
obj.typeID=EXT->GhostObjList_typeID;
obj.refCount=1;
obj.data=f->data;
GhostObjList_set_member(ctx, &obj, key, value);
}
SV GPUTimer_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GPUTimer;
NO obj=(NO)GPUTimer_new(ctx, args2);
obj->funcs=GPUTimer_ptr_funcs;
obj->typeID=EXT->GPUTimer_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GPUTimer_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GPUTimerRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,GPUTimer*))
CATE(TE,"GPUTimerRef::deref expects GPUTimerRef as first argument."));
CATE(TE,"GPUTimer objects are not copyable."));
}
SV GPUTimer_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GPUTimer::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,GPUTimer*))
CATE(TE,"GPUTimerRef::refset expects GPUTimerRef as first argument."));
CATE(TE,"GPUTimer objects are not copyable."));
RET CN;
}

void GPUTimer_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GPUTimer*))
CATE(TE,"GPUTimerRef::__del__ expects GPUTimerRef as first argument."));
SCRIPT_DELETE((GPUTimer *)f->data);
}
SV GPUTimer_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,GPUTimer*))
CATE(TE,FAE("GPUTimerRef's get method","GPUTimerRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GPUTimerPtr");
EI(keyStr=="__new__")
RET CNF(GPUTimer_ptr_new);
EI(keyStr=="__call__")
RET CNF(GPUTimer_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GPUTimer_ptr_deref);
if(keyStr=="refset")RET CNF(GPUTimer_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GPUTimer_funcs;
obj.typeID=EXT->GPUTimer_typeID;
obj.refCount=1;
obj.data=f->data;
RET GPUTimer_get_member(ctx, &obj, key);
}
void GPUTimer_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,GPUTimer*))
CATE(TE,FAE("GPUTimerRef's set method","GPUTimerRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GPUTimer_funcs;
obj.typeID=EXT->GPUTimer_typeID;
obj.refCount=1;
obj.data=f->data;
GPUTimer_set_member(ctx, &obj, key, value);
}
SV RigidBody_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->RigidBody;
NO obj=(NO)RigidBody_new(ctx, args2);
obj->funcs=RigidBody_ptr_funcs;
obj->typeID=EXT->RigidBody_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV RigidBody_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"RigidBodyRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,RigidBody*))
CATE(TE,"RigidBodyRef::deref expects RigidBodyRef as first argument."));
CATE(TE,"RigidBody objects are not copyable."));
}
SV RigidBody_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"RigidBody::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,RigidBody*))
CATE(TE,"RigidBodyRef::refset expects RigidBodyRef as first argument."));
CATE(TE,"RigidBody objects are not copyable."));
RET CN;
}

void RigidBody_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,RigidBody*))
CATE(TE,"RigidBodyRef::__del__ expects RigidBodyRef as first argument."));
}
SV RigidBody_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,RigidBody*))
CATE(TE,FAE("RigidBodyRef's get method","RigidBodyRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("RigidBodyPtr");
EI(keyStr=="__new__")
RET CNF(RigidBody_ptr_new);
EI(keyStr=="__call__")
RET CNF(RigidBody_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(RigidBody_ptr_deref);
if(keyStr=="refset")RET CNF(RigidBody_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=RigidBody_funcs;
obj.typeID=EXT->RigidBody_typeID;
obj.refCount=1;
obj.data=f->data;
RET RigidBody_get_member(ctx, &obj, key);
}
void RigidBody_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,RigidBody*))
CATE(TE,FAE("RigidBodyRef's set method","RigidBodyRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=RigidBody_funcs;
obj.typeID=EXT->RigidBody_typeID;
obj.refCount=1;
obj.data=f->data;
RigidBody_set_member(ctx, &obj, key, value);
}
SV UInt2_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->UInt2;
NO obj=(NO)UInt2_new(ctx, args2);
obj->funcs=UInt2_ptr_funcs;
obj->typeID=EXT->UInt2_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV UInt2_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"UInt2Ref::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,T2<uint32_t>*))
CATE(TE,"UInt2Ref::deref expects UInt2Ref as first argument."));
RET CV(*(T2<uint32_t> *)((NO)f)->data);
}
SV UInt2_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"UInt2::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,T2<uint32_t>*))
CATE(TE,"UInt2Ref::refset expects UInt2Ref as first argument."));
*((T2<uint32_t> *)((NO)f)->data) = val_to_c<T2<uint32_t>>::f(ctx,a[1]);
RET CN;
}

void UInt2_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T2<uint32_t>*))
CATE(TE,"UInt2Ref::__del__ expects UInt2Ref as first argument."));
SCRIPT_DELETE((T2<uint32_t> *)f->data);
}
SV UInt2_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,T2<uint32_t>*))
CATE(TE,FAE("UInt2Ref's get method","UInt2Ref")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("UInt2Ptr");
EI(keyStr=="__new__")
RET CNF(UInt2_ptr_new);
EI(keyStr=="__call__")
RET CNF(UInt2_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(UInt2_ptr_deref);
if(keyStr=="refset")RET CNF(UInt2_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=UInt2_funcs;
obj.typeID=EXT->UInt2_typeID;
obj.refCount=1;
obj.data=f->data;
RET UInt2_get_member(ctx, &obj, key);
}
void UInt2_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,T2<uint32_t>*))
CATE(TE,FAE("UInt2Ref's set method","UInt2Ref")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=UInt2_funcs;
obj.typeID=EXT->UInt2_typeID;
obj.refCount=1;
obj.data=f->data;
UInt2_set_member(ctx, &obj, key, value);
}
SV LightList_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->LightList;
NO obj=(NO)LightList_new(ctx, args2);
obj->funcs=LightList_ptr_funcs;
obj->typeID=EXT->LightList_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV LightList_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"LightListRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,List<Light*>*))
CATE(TE,"LightListRef::deref expects LightListRef as first argument."));
RET CV(*(List<Light*> *)((NO)f)->data);
}
SV LightList_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"LightList::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,List<Light*>*))
CATE(TE,"LightListRef::refset expects LightListRef as first argument."));
*((List<Light*> *)((NO)f)->data) = val_to_c<List<Light*>>::f(ctx,a[1]);
RET CN;
}

void LightList_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<Light*>*))
CATE(TE,"LightListRef::__del__ expects LightListRef as first argument."));
SCRIPT_DELETE((List<Light*> *)f->data);
}
SV LightList_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,List<Light*>*))
CATE(TE,FAE("LightListRef's get method","LightListRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("LightListPtr");
EI(keyStr=="__new__")
RET CNF(LightList_ptr_new);
EI(keyStr=="__call__")
RET CNF(LightList_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(LightList_ptr_deref);
if(keyStr=="refset")RET CNF(LightList_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=LightList_funcs;
obj.typeID=EXT->LightList_typeID;
obj.refCount=1;
obj.data=f->data;
RET LightList_get_member(ctx, &obj, key);
}
void LightList_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,List<Light*>*))
CATE(TE,FAE("LightListRef's set method","LightListRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=LightList_funcs;
obj.typeID=EXT->LightList_typeID;
obj.refCount=1;
obj.data=f->data;
LightList_set_member(ctx, &obj, key, value);
}
SV ResourceManager_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->ResourceManager;
NO obj=(NO)ResourceManager_new(ctx, args2);
obj->funcs=ResourceManager_ptr_funcs;
obj->typeID=EXT->ResourceManager_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV ResourceManager_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"ResourceManagerRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,ResourceManager*))
CATE(TE,"ResourceManagerRef::deref expects ResourceManagerRef as first argument."));
CATE(TE,"ResourceManager objects are not copyable."));
}
SV ResourceManager_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"ResourceManager::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,ResourceManager*))
CATE(TE,"ResourceManagerRef::refset expects ResourceManagerRef as first argument."));
CATE(TE,"ResourceManager objects are not copyable."));
RET CN;
}

void ResourceManager_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,ResourceManager*))
CATE(TE,"ResourceManagerRef::__del__ expects ResourceManagerRef as first argument."));
SCRIPT_DELETE((ResourceManager *)f->data);
}
SV ResourceManager_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,ResourceManager*))
CATE(TE,FAE("ResourceManagerRef's get method","ResourceManagerRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("ResourceManagerPtr");
EI(keyStr=="__new__")
RET CNF(ResourceManager_ptr_new);
EI(keyStr=="__call__")
RET CNF(ResourceManager_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(ResourceManager_ptr_deref);
if(keyStr=="refset")RET CNF(ResourceManager_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=ResourceManager_funcs;
obj.typeID=EXT->ResourceManager_typeID;
obj.refCount=1;
obj.data=f->data;
RET ResourceManager_get_member(ctx, &obj, key);
}
void ResourceManager_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,ResourceManager*))
CATE(TE,FAE("ResourceManagerRef's set method","ResourceManagerRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=ResourceManager_funcs;
obj.typeID=EXT->ResourceManager_typeID;
obj.refCount=1;
obj.data=f->data;
ResourceManager_set_member(ctx, &obj, key, value);
}
SV Entity_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Entity;
NO obj=(NO)Entity_new(ctx, args2);
obj->funcs=Entity_ptr_funcs;
obj->typeID=EXT->Entity_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Entity_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"EntityRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,Entity*))
CATE(TE,"EntityRef::deref expects EntityRef as first argument."));
CATE(TE,"Entity objects are not copyable."));
}
SV Entity_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Entity::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,Entity*))
CATE(TE,"EntityRef::refset expects EntityRef as first argument."));
CATE(TE,"Entity objects are not copyable."));
RET CN;
}

void Entity_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Entity*))
CATE(TE,"EntityRef::__del__ expects EntityRef as first argument."));
}
SV Entity_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,Entity*))
CATE(TE,FAE("EntityRef's get method","EntityRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("EntityPtr");
EI(keyStr=="__new__")
RET CNF(Entity_ptr_new);
EI(keyStr=="__call__")
RET CNF(Entity_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Entity_ptr_deref);
if(keyStr=="refset")RET CNF(Entity_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Entity_funcs;
obj.typeID=EXT->Entity_typeID;
obj.refCount=1;
obj.data=f->data;
RET Entity_get_member(ctx, &obj, key);
}
void Entity_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,Entity*))
CATE(TE,FAE("EntityRef's set method","EntityRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Entity_funcs;
obj.typeID=EXT->Entity_typeID;
obj.refCount=1;
obj.data=f->data;
Entity_set_member(ctx, &obj, key, value);
}
SV GfxRenderer_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GfxRenderer;
NO obj=(NO)GfxRenderer_new(ctx, args2);
obj->funcs=GfxRenderer_ptr_funcs;
obj->typeID=EXT->GfxRenderer_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GfxRenderer_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxRendererRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,GfxRenderer*))
CATE(TE,"GfxRendererRef::deref expects GfxRendererRef as first argument."));
RET CV(*(GfxRenderer *)((NO)f)->data);
}
SV GfxRenderer_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GfxRenderer::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,GfxRenderer*))
CATE(TE,"GfxRendererRef::refset expects GfxRendererRef as first argument."));
*((GfxRenderer *)((NO)f)->data) = val_to_c<GfxRenderer>::f(ctx,a[1]);
RET CN;
}

void GfxRenderer_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxRenderer*))
CATE(TE,"GfxRendererRef::__del__ expects GfxRendererRef as first argument."));
SCRIPT_DELETE((GfxRenderer *)f->data);
}
SV GfxRenderer_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,GfxRenderer*))
CATE(TE,FAE("GfxRendererRef's get method","GfxRendererRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxRendererPtr");
EI(keyStr=="__new__")
RET CNF(GfxRenderer_ptr_new);
EI(keyStr=="__call__")
RET CNF(GfxRenderer_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GfxRenderer_ptr_deref);
if(keyStr=="refset")RET CNF(GfxRenderer_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxRenderer_funcs;
obj.typeID=EXT->GfxRenderer_typeID;
obj.refCount=1;
obj.data=f->data;
RET GfxRenderer_get_member(ctx, &obj, key);
}
void GfxRenderer_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,GfxRenderer*))
CATE(TE,FAE("GfxRendererRef's set method","GfxRendererRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxRenderer_funcs;
obj.typeID=EXT->GfxRenderer_typeID;
obj.refCount=1;
obj.data=f->data;
GfxRenderer_set_member(ctx, &obj, key, value);
}
SV Float2_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Float2;
NO obj=(NO)Float2_new(ctx, args2);
obj->funcs=Float2_ptr_funcs;
obj->typeID=EXT->Float2_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Float2_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Float2Ref::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,T2<float>*))
CATE(TE,"Float2Ref::deref expects Float2Ref as first argument."));
RET CV(*(T2<float> *)((NO)f)->data);
}
SV Float2_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Float2::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,T2<float>*))
CATE(TE,"Float2Ref::refset expects Float2Ref as first argument."));
*((T2<float> *)((NO)f)->data) = val_to_c<T2<float>>::f(ctx,a[1]);
RET CN;
}

void Float2_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T2<float>*))
CATE(TE,"Float2Ref::__del__ expects Float2Ref as first argument."));
SCRIPT_DELETE((T2<float> *)f->data);
}
SV Float2_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,T2<float>*))
CATE(TE,FAE("Float2Ref's get method","Float2Ref")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Float2Ptr");
EI(keyStr=="__new__")
RET CNF(Float2_ptr_new);
EI(keyStr=="__call__")
RET CNF(Float2_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Float2_ptr_deref);
if(keyStr=="refset")RET CNF(Float2_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Float2_funcs;
obj.typeID=EXT->Float2_typeID;
obj.refCount=1;
obj.data=f->data;
RET Float2_get_member(ctx, &obj, key);
}
void Float2_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,T2<float>*))
CATE(TE,FAE("Float2Ref's set method","Float2Ref")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Float2_funcs;
obj.typeID=EXT->Float2_typeID;
obj.refCount=1;
obj.data=f->data;
Float2_set_member(ctx, &obj, key, value);
}
SV GfxFramebuffer_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GfxFramebuffer;
NO obj=(NO)GfxFramebuffer_new(ctx, args2);
obj->funcs=GfxFramebuffer_ptr_funcs;
obj->typeID=EXT->GfxFramebuffer_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GfxFramebuffer_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxFramebufferRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,GfxFramebuffer*))
CATE(TE,"GfxFramebufferRef::deref expects GfxFramebufferRef as first argument."));
CATE(TE,"GfxFramebuffer objects are not copyable."));
}
SV GfxFramebuffer_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GfxFramebuffer::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,GfxFramebuffer*))
CATE(TE,"GfxFramebufferRef::refset expects GfxFramebufferRef as first argument."));
CATE(TE,"GfxFramebuffer objects are not copyable."));
RET CN;
}

void GfxFramebuffer_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxFramebuffer*))
CATE(TE,"GfxFramebufferRef::__del__ expects GfxFramebufferRef as first argument."));
SCRIPT_DELETE((GfxFramebuffer *)f->data);
}
SV GfxFramebuffer_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,GfxFramebuffer*))
CATE(TE,FAE("GfxFramebufferRef's get method","GfxFramebufferRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxFramebufferPtr");
EI(keyStr=="__new__")
RET CNF(GfxFramebuffer_ptr_new);
EI(keyStr=="__call__")
RET CNF(GfxFramebuffer_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GfxFramebuffer_ptr_deref);
if(keyStr=="refset")RET CNF(GfxFramebuffer_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxFramebuffer_funcs;
obj.typeID=EXT->GfxFramebuffer_typeID;
obj.refCount=1;
obj.data=f->data;
RET GfxFramebuffer_get_member(ctx, &obj, key);
}
void GfxFramebuffer_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,GfxFramebuffer*))
CATE(TE,FAE("GfxFramebufferRef's set method","GfxFramebufferRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxFramebuffer_funcs;
obj.typeID=EXT->GfxFramebuffer_typeID;
obj.refCount=1;
obj.data=f->data;
GfxFramebuffer_set_member(ctx, &obj, key, value);
}
SV Font_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Font;
NO obj=(NO)Font_new(ctx, args2);
obj->funcs=Font_ptr_funcs;
obj->typeID=EXT->Font_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Font_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"FontRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,Font*))
CATE(TE,"FontRef::deref expects FontRef as first argument."));
CATE(TE,"Font objects are not copyable."));
}
SV Font_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Font::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,Font*))
CATE(TE,"FontRef::refset expects FontRef as first argument."));
CATE(TE,"Font objects are not copyable."));
RET CN;
}

void Font_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Font*))
CATE(TE,"FontRef::__del__ expects FontRef as first argument."));
Font*obj=(Font*)f->data;
if(shouldScriptDelete(f->data) && (obj != NULL)) {obj->release();}
}
SV Font_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,Font*))
CATE(TE,FAE("FontRef's get method","FontRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("FontPtr");
EI(keyStr=="__new__")
RET CNF(Font_ptr_new);
EI(keyStr=="__call__")
RET CNF(Font_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Font_ptr_deref);
if(keyStr=="refset")RET CNF(Font_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Font_funcs;
obj.typeID=EXT->Font_typeID;
obj.refCount=1;
obj.data=f->data;
RET Font_get_member(ctx, &obj, key);
}
void Font_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,Font*))
CATE(TE,FAE("FontRef's set method","FontRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Font_funcs;
obj.typeID=EXT->Font_typeID;
obj.refCount=1;
obj.data=f->data;
Font_set_member(ctx, &obj, key, value);
}
SV Event_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Event;
NO obj=(NO)Event_new(ctx, args2);
obj->funcs=Event_ptr_funcs;
obj->typeID=EXT->Event_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Event_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"EventRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,Event*))
CATE(TE,"EventRef::deref expects EventRef as first argument."));
RET CV(*(Event *)((NO)f)->data);
}
SV Event_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Event::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,Event*))
CATE(TE,"EventRef::refset expects EventRef as first argument."));
*((Event *)((NO)f)->data) = val_to_c<Event>::f(ctx,a[1]);
RET CN;
}

void Event_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Event*))
CATE(TE,"EventRef::__del__ expects EventRef as first argument."));
SCRIPT_DELETE((Event *)f->data);
}
SV Event_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,Event*))
CATE(TE,FAE("EventRef's get method","EventRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("EventPtr");
EI(keyStr=="__new__")
RET CNF(Event_ptr_new);
EI(keyStr=="__call__")
RET CNF(Event_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Event_ptr_deref);
if(keyStr=="refset")RET CNF(Event_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Event_funcs;
obj.typeID=EXT->Event_typeID;
obj.refCount=1;
obj.data=f->data;
RET Event_get_member(ctx, &obj, key);
}
void Event_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,Event*))
CATE(TE,FAE("EventRef's set method","EventRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Event_funcs;
obj.typeID=EXT->Event_typeID;
obj.refCount=1;
obj.data=f->data;
Event_set_member(ctx, &obj, key, value);
}
SV PhysicsWorld_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->PhysicsWorld;
NO obj=(NO)PhysicsWorld_new(ctx, args2);
obj->funcs=PhysicsWorld_ptr_funcs;
obj->typeID=EXT->PhysicsWorld_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV PhysicsWorld_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"PhysicsWorldRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,PhysicsWorld*))
CATE(TE,"PhysicsWorldRef::deref expects PhysicsWorldRef as first argument."));
CATE(TE,"PhysicsWorld objects are not copyable."));
}
SV PhysicsWorld_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"PhysicsWorld::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,PhysicsWorld*))
CATE(TE,"PhysicsWorldRef::refset expects PhysicsWorldRef as first argument."));
CATE(TE,"PhysicsWorld objects are not copyable."));
RET CN;
}

void PhysicsWorld_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,PhysicsWorld*))
CATE(TE,"PhysicsWorldRef::__del__ expects PhysicsWorldRef as first argument."));
SCRIPT_DELETE((PhysicsWorld *)f->data);
}
SV PhysicsWorld_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,PhysicsWorld*))
CATE(TE,FAE("PhysicsWorldRef's get method","PhysicsWorldRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("PhysicsWorldPtr");
EI(keyStr=="__new__")
RET CNF(PhysicsWorld_ptr_new);
EI(keyStr=="__call__")
RET CNF(PhysicsWorld_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(PhysicsWorld_ptr_deref);
if(keyStr=="refset")RET CNF(PhysicsWorld_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=PhysicsWorld_funcs;
obj.typeID=EXT->PhysicsWorld_typeID;
obj.refCount=1;
obj.data=f->data;
RET PhysicsWorld_get_member(ctx, &obj, key);
}
void PhysicsWorld_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,PhysicsWorld*))
CATE(TE,FAE("PhysicsWorldRef's set method","PhysicsWorldRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=PhysicsWorld_funcs;
obj.typeID=EXT->PhysicsWorld_typeID;
obj.refCount=1;
obj.data=f->data;
PhysicsWorld_set_member(ctx, &obj, key, value);
}
SV Stats_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Stats;
NO obj=(NO)Stats_new(ctx, args2);
obj->funcs=Stats_ptr_funcs;
obj->typeID=EXT->Stats_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Stats_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"StatsRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,Stats*))
CATE(TE,"StatsRef::deref expects StatsRef as first argument."));
RET CV(*(Stats *)((NO)f)->data);
}
SV Stats_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Stats::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,Stats*))
CATE(TE,"StatsRef::refset expects StatsRef as first argument."));
*((Stats *)((NO)f)->data) = val_to_c<Stats>::f(ctx,a[1]);
RET CN;
}

void Stats_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Stats*))
CATE(TE,"StatsRef::__del__ expects StatsRef as first argument."));
SCRIPT_DELETE((Stats *)f->data);
}
SV Stats_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,Stats*))
CATE(TE,FAE("StatsRef's get method","StatsRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("StatsPtr");
EI(keyStr=="__new__")
RET CNF(Stats_ptr_new);
EI(keyStr=="__call__")
RET CNF(Stats_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Stats_ptr_deref);
if(keyStr=="refset")RET CNF(Stats_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Stats_funcs;
obj.typeID=EXT->Stats_typeID;
obj.refCount=1;
obj.data=f->data;
RET Stats_get_member(ctx, &obj, key);
}
void Stats_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,Stats*))
CATE(TE,FAE("StatsRef's set method","StatsRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Stats_funcs;
obj.typeID=EXT->Stats_typeID;
obj.refCount=1;
obj.data=f->data;
Stats_set_member(ctx, &obj, key, value);
}
SV AudioSource_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->AudioSource;
NO obj=(NO)AudioSource_new(ctx, args2);
obj->funcs=AudioSource_ptr_funcs;
obj->typeID=EXT->AudioSource_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV AudioSource_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"AudioSourceRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,AudioSource*))
CATE(TE,"AudioSourceRef::deref expects AudioSourceRef as first argument."));
RET CV(*(AudioSource *)((NO)f)->data);
}
SV AudioSource_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"AudioSource::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,AudioSource*))
CATE(TE,"AudioSourceRef::refset expects AudioSourceRef as first argument."));
*((AudioSource *)((NO)f)->data) = val_to_c<AudioSource>::f(ctx,a[1]);
RET CN;
}

void AudioSource_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,AudioSource*))
CATE(TE,"AudioSourceRef::__del__ expects AudioSourceRef as first argument."));
SCRIPT_DELETE((AudioSource *)f->data);
}
SV AudioSource_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,AudioSource*))
CATE(TE,FAE("AudioSourceRef's get method","AudioSourceRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("AudioSourcePtr");
EI(keyStr=="__new__")
RET CNF(AudioSource_ptr_new);
EI(keyStr=="__call__")
RET CNF(AudioSource_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(AudioSource_ptr_deref);
if(keyStr=="refset")RET CNF(AudioSource_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=AudioSource_funcs;
obj.typeID=EXT->AudioSource_typeID;
obj.refCount=1;
obj.data=f->data;
RET AudioSource_get_member(ctx, &obj, key);
}
void AudioSource_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,AudioSource*))
CATE(TE,FAE("AudioSourceRef's set method","AudioSourceRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=AudioSource_funcs;
obj.typeID=EXT->AudioSource_typeID;
obj.refCount=1;
obj.data=f->data;
AudioSource_set_member(ctx, &obj, key, value);
}
SV RayCastResultList_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->RayCastResultList;
NO obj=(NO)RayCastResultList_new(ctx, args2);
obj->funcs=RayCastResultList_ptr_funcs;
obj->typeID=EXT->RayCastResultList_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV RayCastResultList_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"RayCastResultListRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,List<RayCastResult>*))
CATE(TE,"RayCastResultListRef::deref expects RayCastResultListRef as first argument."));
RET CV(*(List<RayCastResult> *)((NO)f)->data);
}
SV RayCastResultList_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"RayCastResultList::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,List<RayCastResult>*))
CATE(TE,"RayCastResultListRef::refset expects RayCastResultListRef as first argument."));
*((List<RayCastResult> *)((NO)f)->data) = val_to_c<List<RayCastResult>>::f(ctx,a[1]);
RET CN;
}

void RayCastResultList_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<RayCastResult>*))
CATE(TE,"RayCastResultListRef::__del__ expects RayCastResultListRef as first argument."));
SCRIPT_DELETE((List<RayCastResult> *)f->data);
}
SV RayCastResultList_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,List<RayCastResult>*))
CATE(TE,FAE("RayCastResultListRef's get method","RayCastResultListRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("RayCastResultListPtr");
EI(keyStr=="__new__")
RET CNF(RayCastResultList_ptr_new);
EI(keyStr=="__call__")
RET CNF(RayCastResultList_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(RayCastResultList_ptr_deref);
if(keyStr=="refset")RET CNF(RayCastResultList_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=RayCastResultList_funcs;
obj.typeID=EXT->RayCastResultList_typeID;
obj.refCount=1;
obj.data=f->data;
RET RayCastResultList_get_member(ctx, &obj, key);
}
void RayCastResultList_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,List<RayCastResult>*))
CATE(TE,FAE("RayCastResultListRef's set method","RayCastResultListRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=RayCastResultList_funcs;
obj.typeID=EXT->RayCastResultList_typeID;
obj.refCount=1;
obj.data=f->data;
RayCastResultList_set_member(ctx, &obj, key, value);
}
SV Platform_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Platform;
NO obj=(NO)Platform_new(ctx, args2);
obj->funcs=Platform_ptr_funcs;
obj->typeID=EXT->Platform_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Platform_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"PlatformRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,Platform*))
CATE(TE,"PlatformRef::deref expects PlatformRef as first argument."));
CATE(TE,"Platform objects are not copyable."));
}
SV Platform_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Platform::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,Platform*))
CATE(TE,"PlatformRef::refset expects PlatformRef as first argument."));
CATE(TE,"Platform objects are not copyable."));
RET CN;
}

void Platform_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Platform*))
CATE(TE,"PlatformRef::__del__ expects PlatformRef as first argument."));
SCRIPT_DELETE((Platform *)f->data);
}
SV Platform_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,Platform*))
CATE(TE,FAE("PlatformRef's get method","PlatformRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("PlatformPtr");
EI(keyStr=="__new__")
RET CNF(Platform_ptr_new);
EI(keyStr=="__call__")
RET CNF(Platform_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Platform_ptr_deref);
if(keyStr=="refset")RET CNF(Platform_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Platform_funcs;
obj.typeID=EXT->Platform_typeID;
obj.refCount=1;
obj.data=f->data;
RET Platform_get_member(ctx, &obj, key);
}
void Platform_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,Platform*))
CATE(TE,FAE("PlatformRef's set method","PlatformRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Platform_funcs;
obj.typeID=EXT->Platform_typeID;
obj.refCount=1;
obj.data=f->data;
Platform_set_member(ctx, &obj, key, value);
}
SV Camera_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Camera;
NO obj=(NO)Camera_new(ctx, args2);
obj->funcs=Camera_ptr_funcs;
obj->typeID=EXT->Camera_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Camera_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"CameraRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,Camera*))
CATE(TE,"CameraRef::deref expects CameraRef as first argument."));
RET CV(*(Camera *)((NO)f)->data);
}
SV Camera_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Camera::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,Camera*))
CATE(TE,"CameraRef::refset expects CameraRef as first argument."));
*((Camera *)((NO)f)->data) = val_to_c<Camera>::f(ctx,a[1]);
RET CN;
}

void Camera_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Camera*))
CATE(TE,"CameraRef::__del__ expects CameraRef as first argument."));
SCRIPT_DELETE((Camera *)f->data);
}
SV Camera_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,Camera*))
CATE(TE,FAE("CameraRef's get method","CameraRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("CameraPtr");
EI(keyStr=="__new__")
RET CNF(Camera_ptr_new);
EI(keyStr=="__call__")
RET CNF(Camera_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Camera_ptr_deref);
if(keyStr=="refset")RET CNF(Camera_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Camera_funcs;
obj.typeID=EXT->Camera_typeID;
obj.refCount=1;
obj.data=f->data;
RET Camera_get_member(ctx, &obj, key);
}
void Camera_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,Camera*))
CATE(TE,FAE("CameraRef's set method","CameraRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Camera_funcs;
obj.typeID=EXT->Camera_typeID;
obj.refCount=1;
obj.data=f->data;
Camera_set_member(ctx, &obj, key, value);
}
SV GfxMesh_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GfxMesh;
NO obj=(NO)GfxMesh_new(ctx, args2);
obj->funcs=GfxMesh_ptr_funcs;
obj->typeID=EXT->GfxMesh_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GfxMesh_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxMeshRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,GfxMesh*))
CATE(TE,"GfxMeshRef::deref expects GfxMeshRef as first argument."));
CATE(TE,"GfxMesh objects are not copyable."));
}
SV GfxMesh_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GfxMesh::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,GfxMesh*))
CATE(TE,"GfxMeshRef::refset expects GfxMeshRef as first argument."));
CATE(TE,"GfxMesh objects are not copyable."));
RET CN;
}

void GfxMesh_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxMesh*))
CATE(TE,"GfxMeshRef::__del__ expects GfxMeshRef as first argument."));
GfxMesh*obj=(GfxMesh*)f->data;
if(shouldScriptDelete(f->data) && (obj != NULL)) {obj->release();}
}
SV GfxMesh_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,GfxMesh*))
CATE(TE,FAE("GfxMeshRef's get method","GfxMeshRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxMeshPtr");
EI(keyStr=="__new__")
RET CNF(GfxMesh_ptr_new);
EI(keyStr=="__call__")
RET CNF(GfxMesh_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GfxMesh_ptr_deref);
if(keyStr=="refset")RET CNF(GfxMesh_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxMesh_funcs;
obj.typeID=EXT->GfxMesh_typeID;
obj.refCount=1;
obj.data=f->data;
RET GfxMesh_get_member(ctx, &obj, key);
}
void GfxMesh_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,GfxMesh*))
CATE(TE,FAE("GfxMeshRef's set method","GfxMeshRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxMesh_funcs;
obj.typeID=EXT->GfxMesh_typeID;
obj.refCount=1;
obj.data=f->data;
GfxMesh_set_member(ctx, &obj, key, value);
}
SV Resource_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Resource;
NO obj=(NO)Resource_new(ctx, args2);
obj->funcs=Resource_ptr_funcs;
obj->typeID=EXT->Resource_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Resource_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"ResourceRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,Resource*))
CATE(TE,"ResourceRef::deref expects ResourceRef as first argument."));
CATE(TE,"Resource objects are not copyable."));
}
SV Resource_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Resource::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,Resource*))
CATE(TE,"ResourceRef::refset expects ResourceRef as first argument."));
CATE(TE,"Resource objects are not copyable."));
RET CN;
}

void Resource_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Resource*))
CATE(TE,"ResourceRef::__del__ expects ResourceRef as first argument."));
Resource*obj=(Resource*)f->data;
if(shouldScriptDelete(f->data) && (obj != NULL)) {obj->release();}
}
SV Resource_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,Resource*))
CATE(TE,FAE("ResourceRef's get method","ResourceRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("ResourcePtr");
EI(keyStr=="__new__")
RET CNF(Resource_ptr_new);
EI(keyStr=="__call__")
RET CNF(Resource_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Resource_ptr_deref);
if(keyStr=="refset")RET CNF(Resource_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Resource_funcs;
obj.typeID=EXT->Resource_typeID;
obj.refCount=1;
obj.data=f->data;
RET Resource_get_member(ctx, &obj, key);
}
void Resource_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,Resource*))
CATE(TE,FAE("ResourceRef's set method","ResourceRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Resource_funcs;
obj.typeID=EXT->Resource_typeID;
obj.refCount=1;
obj.data=f->data;
Resource_set_member(ctx, &obj, key, value);
}
SV GfxShader_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GfxShader;
NO obj=(NO)GfxShader_new(ctx, args2);
obj->funcs=GfxShader_ptr_funcs;
obj->typeID=EXT->GfxShader_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GfxShader_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxShaderRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,GfxShader*))
CATE(TE,"GfxShaderRef::deref expects GfxShaderRef as first argument."));
CATE(TE,"GfxShader objects are not copyable."));
}
SV GfxShader_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GfxShader::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,GfxShader*))
CATE(TE,"GfxShaderRef::refset expects GfxShaderRef as first argument."));
CATE(TE,"GfxShader objects are not copyable."));
RET CN;
}

void GfxShader_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxShader*))
CATE(TE,"GfxShaderRef::__del__ expects GfxShaderRef as first argument."));
GfxShader*obj=(GfxShader*)f->data;
if(shouldScriptDelete(f->data) && (obj != NULL)) {obj->release();}
}
SV GfxShader_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,GfxShader*))
CATE(TE,FAE("GfxShaderRef's get method","GfxShaderRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxShaderPtr");
EI(keyStr=="__new__")
RET CNF(GfxShader_ptr_new);
EI(keyStr=="__call__")
RET CNF(GfxShader_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GfxShader_ptr_deref);
if(keyStr=="refset")RET CNF(GfxShader_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxShader_funcs;
obj.typeID=EXT->GfxShader_typeID;
obj.refCount=1;
obj.data=f->data;
RET GfxShader_get_member(ctx, &obj, key);
}
void GfxShader_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,GfxShader*))
CATE(TE,FAE("GfxShaderRef's set method","GfxShaderRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxShader_funcs;
obj.typeID=EXT->GfxShader_typeID;
obj.refCount=1;
obj.data=f->data;
GfxShader_set_member(ctx, &obj, key, value);
}
SV Light_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Light;
NO obj=(NO)Light_new(ctx, args2);
obj->funcs=Light_ptr_funcs;
obj->typeID=EXT->Light_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Light_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"LightRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,Light*))
CATE(TE,"LightRef::deref expects LightRef as first argument."));
CATE(TE,"Light objects are not copyable."));
}
SV Light_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Light::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,Light*))
CATE(TE,"LightRef::refset expects LightRef as first argument."));
CATE(TE,"Light objects are not copyable."));
RET CN;
}

void Light_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Light*))
CATE(TE,"LightRef::__del__ expects LightRef as first argument."));
SCRIPT_DELETE((Light *)f->data);
}
SV Light_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,Light*))
CATE(TE,FAE("LightRef's get method","LightRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("LightPtr");
EI(keyStr=="__new__")
RET CNF(Light_ptr_new);
EI(keyStr=="__call__")
RET CNF(Light_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Light_ptr_deref);
if(keyStr=="refset")RET CNF(Light_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Light_funcs;
obj.typeID=EXT->Light_typeID;
obj.refCount=1;
obj.data=f->data;
RET Light_get_member(ctx, &obj, key);
}
void Light_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,Light*))
CATE(TE,FAE("LightRef's set method","LightRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Light_funcs;
obj.typeID=EXT->Light_typeID;
obj.refCount=1;
obj.data=f->data;
Light_set_member(ctx, &obj, key, value);
}
SV TextureSampler_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->TextureSampler;
NO obj=(NO)TextureSampler_new(ctx, args2);
obj->funcs=TextureSampler_ptr_funcs;
obj->typeID=EXT->TextureSampler_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV TextureSampler_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"TextureSamplerRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,TextureSampler*))
CATE(TE,"TextureSamplerRef::deref expects TextureSamplerRef as first argument."));
RET CV(*(TextureSampler *)((NO)f)->data);
}
SV TextureSampler_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"TextureSampler::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,TextureSampler*))
CATE(TE,"TextureSamplerRef::refset expects TextureSamplerRef as first argument."));
*((TextureSampler *)((NO)f)->data) = val_to_c<TextureSampler>::f(ctx,a[1]);
RET CN;
}

void TextureSampler_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,TextureSampler*))
CATE(TE,"TextureSamplerRef::__del__ expects TextureSamplerRef as first argument."));
SCRIPT_DELETE((TextureSampler *)f->data);
}
SV TextureSampler_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,TextureSampler*))
CATE(TE,FAE("TextureSamplerRef's get method","TextureSamplerRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("TextureSamplerPtr");
EI(keyStr=="__new__")
RET CNF(TextureSampler_ptr_new);
EI(keyStr=="__call__")
RET CNF(TextureSampler_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(TextureSampler_ptr_deref);
if(keyStr=="refset")RET CNF(TextureSampler_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=TextureSampler_funcs;
obj.typeID=EXT->TextureSampler_typeID;
obj.refCount=1;
obj.data=f->data;
RET TextureSampler_get_member(ctx, &obj, key);
}
void TextureSampler_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,TextureSampler*))
CATE(TE,FAE("TextureSamplerRef's set method","TextureSamplerRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=TextureSampler_funcs;
obj.typeID=EXT->TextureSampler_typeID;
obj.refCount=1;
obj.data=f->data;
TextureSampler_set_member(ctx, &obj, key, value);
}
SV Scene_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Scene;
NO obj=(NO)Scene_new(ctx, args2);
obj->funcs=Scene_ptr_funcs;
obj->typeID=EXT->Scene_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Scene_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"SceneRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,Scene*))
CATE(TE,"SceneRef::deref expects SceneRef as first argument."));
CATE(TE,"Scene objects are not copyable."));
}
SV Scene_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Scene::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,Scene*))
CATE(TE,"SceneRef::refset expects SceneRef as first argument."));
CATE(TE,"Scene objects are not copyable."));
RET CN;
}

void Scene_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Scene*))
CATE(TE,"SceneRef::__del__ expects SceneRef as first argument."));
Scene*obj=(Scene*)f->data;
if(shouldScriptDelete(f->data) && (obj != NULL)) {obj->release();}
}
SV Scene_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,Scene*))
CATE(TE,FAE("SceneRef's get method","SceneRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("ScenePtr");
EI(keyStr=="__new__")
RET CNF(Scene_ptr_new);
EI(keyStr=="__call__")
RET CNF(Scene_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Scene_ptr_deref);
if(keyStr=="refset")RET CNF(Scene_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Scene_funcs;
obj.typeID=EXT->Scene_typeID;
obj.refCount=1;
obj.data=f->data;
RET Scene_get_member(ctx, &obj, key);
}
void Scene_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,Scene*))
CATE(TE,FAE("SceneRef's set method","SceneRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Scene_funcs;
obj.typeID=EXT->Scene_typeID;
obj.refCount=1;
obj.data=f->data;
Scene_set_member(ctx, &obj, key, value);
}
SV Int3_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Int3;
NO obj=(NO)Int3_new(ctx, args2);
obj->funcs=Int3_ptr_funcs;
obj->typeID=EXT->Int3_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Int3_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Int3Ref::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,T3<int32_t>*))
CATE(TE,"Int3Ref::deref expects Int3Ref as first argument."));
RET CV(*(T3<int32_t> *)((NO)f)->data);
}
SV Int3_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Int3::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,T3<int32_t>*))
CATE(TE,"Int3Ref::refset expects Int3Ref as first argument."));
*((T3<int32_t> *)((NO)f)->data) = val_to_c<T3<int32_t>>::f(ctx,a[1]);
RET CN;
}

void Int3_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T3<int32_t>*))
CATE(TE,"Int3Ref::__del__ expects Int3Ref as first argument."));
SCRIPT_DELETE((T3<int32_t> *)f->data);
}
SV Int3_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,T3<int32_t>*))
CATE(TE,FAE("Int3Ref's get method","Int3Ref")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Int3Ptr");
EI(keyStr=="__new__")
RET CNF(Int3_ptr_new);
EI(keyStr=="__call__")
RET CNF(Int3_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Int3_ptr_deref);
if(keyStr=="refset")RET CNF(Int3_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Int3_funcs;
obj.typeID=EXT->Int3_typeID;
obj.refCount=1;
obj.data=f->data;
RET Int3_get_member(ctx, &obj, key);
}
void Int3_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,T3<int32_t>*))
CATE(TE,FAE("Int3Ref's set method","Int3Ref")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Int3_funcs;
obj.typeID=EXT->Int3_typeID;
obj.refCount=1;
obj.data=f->data;
Int3_set_member(ctx, &obj, key, value);
}
SV ResizableData_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->ResizableData;
NO obj=(NO)ResizableData_new(ctx, args2);
obj->funcs=ResizableData_ptr_funcs;
obj->typeID=EXT->ResizableData_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV ResizableData_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"ResizableDataRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,ResizableData*))
CATE(TE,"ResizableDataRef::deref expects ResizableDataRef as first argument."));
RET CV(*(ResizableData *)((NO)f)->data);
}
SV ResizableData_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"ResizableData::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,ResizableData*))
CATE(TE,"ResizableDataRef::refset expects ResizableDataRef as first argument."));
*((ResizableData *)((NO)f)->data) = val_to_c<ResizableData>::f(ctx,a[1]);
RET CN;
}

void ResizableData_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,ResizableData*))
CATE(TE,"ResizableDataRef::__del__ expects ResizableDataRef as first argument."));
SCRIPT_DELETE((ResizableData *)f->data);
}
SV ResizableData_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,ResizableData*))
CATE(TE,FAE("ResizableDataRef's get method","ResizableDataRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("ResizableDataPtr");
EI(keyStr=="__new__")
RET CNF(ResizableData_ptr_new);
EI(keyStr=="__call__")
RET CNF(ResizableData_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(ResizableData_ptr_deref);
if(keyStr=="refset")RET CNF(ResizableData_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=ResizableData_funcs;
obj.typeID=EXT->ResizableData_typeID;
obj.refCount=1;
obj.data=f->data;
RET ResizableData_get_member(ctx, &obj, key);
}
void ResizableData_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,ResizableData*))
CATE(TE,FAE("ResizableDataRef's set method","ResizableDataRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=ResizableData_funcs;
obj.typeID=EXT->ResizableData_typeID;
obj.refCount=1;
obj.data=f->data;
ResizableData_set_member(ctx, &obj, key, value);
}
SV Int4_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Int4;
NO obj=(NO)Int4_new(ctx, args2);
obj->funcs=Int4_ptr_funcs;
obj->typeID=EXT->Int4_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Int4_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Int4Ref::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,T4<int32_t>*))
CATE(TE,"Int4Ref::deref expects Int4Ref as first argument."));
RET CV(*(T4<int32_t> *)((NO)f)->data);
}
SV Int4_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Int4::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,T4<int32_t>*))
CATE(TE,"Int4Ref::refset expects Int4Ref as first argument."));
*((T4<int32_t> *)((NO)f)->data) = val_to_c<T4<int32_t>>::f(ctx,a[1]);
RET CN;
}

void Int4_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T4<int32_t>*))
CATE(TE,"Int4Ref::__del__ expects Int4Ref as first argument."));
SCRIPT_DELETE((T4<int32_t> *)f->data);
}
SV Int4_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,T4<int32_t>*))
CATE(TE,FAE("Int4Ref's get method","Int4Ref")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Int4Ptr");
EI(keyStr=="__new__")
RET CNF(Int4_ptr_new);
EI(keyStr=="__call__")
RET CNF(Int4_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Int4_ptr_deref);
if(keyStr=="refset")RET CNF(Int4_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Int4_funcs;
obj.typeID=EXT->Int4_typeID;
obj.refCount=1;
obj.data=f->data;
RET Int4_get_member(ctx, &obj, key);
}
void Int4_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,T4<int32_t>*))
CATE(TE,FAE("Int4Ref's set method","Int4Ref")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Int4_funcs;
obj.typeID=EXT->Int4_typeID;
obj.refCount=1;
obj.data=f->data;
Int4_set_member(ctx, &obj, key, value);
}
SV Float3_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Float3;
NO obj=(NO)Float3_new(ctx, args2);
obj->funcs=Float3_ptr_funcs;
obj->typeID=EXT->Float3_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Float3_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Float3Ref::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,T3<float>*))
CATE(TE,"Float3Ref::deref expects Float3Ref as first argument."));
RET CV(*(T3<float> *)((NO)f)->data);
}
SV Float3_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Float3::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,T3<float>*))
CATE(TE,"Float3Ref::refset expects Float3Ref as first argument."));
*((T3<float> *)((NO)f)->data) = val_to_c<T3<float>>::f(ctx,a[1]);
RET CN;
}

void Float3_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T3<float>*))
CATE(TE,"Float3Ref::__del__ expects Float3Ref as first argument."));
SCRIPT_DELETE((T3<float> *)f->data);
}
SV Float3_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,T3<float>*))
CATE(TE,FAE("Float3Ref's get method","Float3Ref")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Float3Ptr");
EI(keyStr=="__new__")
RET CNF(Float3_ptr_new);
EI(keyStr=="__call__")
RET CNF(Float3_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Float3_ptr_deref);
if(keyStr=="refset")RET CNF(Float3_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Float3_funcs;
obj.typeID=EXT->Float3_typeID;
obj.refCount=1;
obj.data=f->data;
RET Float3_get_member(ctx, &obj, key);
}
void Float3_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,T3<float>*))
CATE(TE,FAE("Float3Ref's set method","Float3Ref")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Float3_funcs;
obj.typeID=EXT->Float3_typeID;
obj.refCount=1;
obj.data=f->data;
Float3_set_member(ctx, &obj, key, value);
}
SV GfxBuffer_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GfxBuffer;
NO obj=(NO)GfxBuffer_new(ctx, args2);
obj->funcs=GfxBuffer_ptr_funcs;
obj->typeID=EXT->GfxBuffer_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GfxBuffer_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxBufferRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,GfxBuffer*))
CATE(TE,"GfxBufferRef::deref expects GfxBufferRef as first argument."));
CATE(TE,"GfxBuffer objects are not copyable."));
}
SV GfxBuffer_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GfxBuffer::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,GfxBuffer*))
CATE(TE,"GfxBufferRef::refset expects GfxBufferRef as first argument."));
CATE(TE,"GfxBuffer objects are not copyable."));
RET CN;
}

void GfxBuffer_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxBuffer*))
CATE(TE,"GfxBufferRef::__del__ expects GfxBufferRef as first argument."));
SCRIPT_DELETE((GfxBuffer *)f->data);
}
SV GfxBuffer_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,GfxBuffer*))
CATE(TE,FAE("GfxBufferRef's get method","GfxBufferRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxBufferPtr");
EI(keyStr=="__new__")
RET CNF(GfxBuffer_ptr_new);
EI(keyStr=="__call__")
RET CNF(GfxBuffer_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GfxBuffer_ptr_deref);
if(keyStr=="refset")RET CNF(GfxBuffer_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxBuffer_funcs;
obj.typeID=EXT->GfxBuffer_typeID;
obj.refCount=1;
obj.data=f->data;
RET GfxBuffer_get_member(ctx, &obj, key);
}
void GfxBuffer_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,GfxBuffer*))
CATE(TE,FAE("GfxBufferRef's set method","GfxBufferRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxBuffer_funcs;
obj.typeID=EXT->GfxBuffer_typeID;
obj.refCount=1;
obj.data=f->data;
GfxBuffer_set_member(ctx, &obj, key, value);
}
SV Transform_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Transform;
NO obj=(NO)Transform_new(ctx, args2);
obj->funcs=Transform_ptr_funcs;
obj->typeID=EXT->Transform_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Transform_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"TransformRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,Transform*))
CATE(TE,"TransformRef::deref expects TransformRef as first argument."));
RET CV(*(Transform *)((NO)f)->data);
}
SV Transform_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Transform::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,Transform*))
CATE(TE,"TransformRef::refset expects TransformRef as first argument."));
*((Transform *)((NO)f)->data) = val_to_c<Transform>::f(ctx,a[1]);
RET CN;
}

void Transform_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Transform*))
CATE(TE,"TransformRef::__del__ expects TransformRef as first argument."));
SCRIPT_DELETE((Transform *)f->data);
}
SV Transform_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,Transform*))
CATE(TE,FAE("TransformRef's get method","TransformRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("TransformPtr");
EI(keyStr=="__new__")
RET CNF(Transform_ptr_new);
EI(keyStr=="__call__")
RET CNF(Transform_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Transform_ptr_deref);
if(keyStr=="refset")RET CNF(Transform_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Transform_funcs;
obj.typeID=EXT->Transform_typeID;
obj.refCount=1;
obj.data=f->data;
RET Transform_get_member(ctx, &obj, key);
}
void Transform_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,Transform*))
CATE(TE,FAE("TransformRef's set method","TransformRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Transform_funcs;
obj.typeID=EXT->Transform_typeID;
obj.refCount=1;
obj.data=f->data;
Transform_set_member(ctx, &obj, key, value);
}
SV AudioSourceList_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->AudioSourceList;
NO obj=(NO)AudioSourceList_new(ctx, args2);
obj->funcs=AudioSourceList_ptr_funcs;
obj->typeID=EXT->AudioSourceList_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV AudioSourceList_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"AudioSourceListRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,List<AudioSource*>*))
CATE(TE,"AudioSourceListRef::deref expects AudioSourceListRef as first argument."));
RET CV(*(List<AudioSource*> *)((NO)f)->data);
}
SV AudioSourceList_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"AudioSourceList::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,List<AudioSource*>*))
CATE(TE,"AudioSourceListRef::refset expects AudioSourceListRef as first argument."));
*((List<AudioSource*> *)((NO)f)->data) = val_to_c<List<AudioSource*>>::f(ctx,a[1]);
RET CN;
}

void AudioSourceList_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<AudioSource*>*))
CATE(TE,"AudioSourceListRef::__del__ expects AudioSourceListRef as first argument."));
SCRIPT_DELETE((List<AudioSource*> *)f->data);
}
SV AudioSourceList_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,List<AudioSource*>*))
CATE(TE,FAE("AudioSourceListRef's get method","AudioSourceListRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("AudioSourceListPtr");
EI(keyStr=="__new__")
RET CNF(AudioSourceList_ptr_new);
EI(keyStr=="__call__")
RET CNF(AudioSourceList_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(AudioSourceList_ptr_deref);
if(keyStr=="refset")RET CNF(AudioSourceList_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=AudioSourceList_funcs;
obj.typeID=EXT->AudioSourceList_typeID;
obj.refCount=1;
obj.data=f->data;
RET AudioSourceList_get_member(ctx, &obj, key);
}
void AudioSourceList_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,List<AudioSource*>*))
CATE(TE,FAE("AudioSourceListRef's set method","AudioSourceListRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=AudioSourceList_funcs;
obj.typeID=EXT->AudioSourceList_typeID;
obj.refCount=1;
obj.data=f->data;
AudioSourceList_set_member(ctx, &obj, key, value);
}
SV GfxMaterial_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GfxMaterial;
NO obj=(NO)GfxMaterial_new(ctx, args2);
obj->funcs=GfxMaterial_ptr_funcs;
obj->typeID=EXT->GfxMaterial_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GfxMaterial_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxMaterialRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,GfxMaterial*))
CATE(TE,"GfxMaterialRef::deref expects GfxMaterialRef as first argument."));
CATE(TE,"GfxMaterial objects are not copyable."));
}
SV GfxMaterial_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GfxMaterial::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,GfxMaterial*))
CATE(TE,"GfxMaterialRef::refset expects GfxMaterialRef as first argument."));
CATE(TE,"GfxMaterial objects are not copyable."));
RET CN;
}

void GfxMaterial_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxMaterial*))
CATE(TE,"GfxMaterialRef::__del__ expects GfxMaterialRef as first argument."));
GfxMaterial*obj=(GfxMaterial*)f->data;
if(shouldScriptDelete(f->data) && (obj != NULL)) {obj->release();}
}
SV GfxMaterial_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,GfxMaterial*))
CATE(TE,FAE("GfxMaterialRef's get method","GfxMaterialRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxMaterialPtr");
EI(keyStr=="__new__")
RET CNF(GfxMaterial_ptr_new);
EI(keyStr=="__call__")
RET CNF(GfxMaterial_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GfxMaterial_ptr_deref);
if(keyStr=="refset")RET CNF(GfxMaterial_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxMaterial_funcs;
obj.typeID=EXT->GfxMaterial_typeID;
obj.refCount=1;
obj.data=f->data;
RET GfxMaterial_get_member(ctx, &obj, key);
}
void GfxMaterial_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,GfxMaterial*))
CATE(TE,FAE("GfxMaterialRef's set method","GfxMaterialRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxMaterial_funcs;
obj.typeID=EXT->GfxMaterial_typeID;
obj.refCount=1;
obj.data=f->data;
GfxMaterial_set_member(ctx, &obj, key, value);
}
SV Quaternion_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Quaternion;
NO obj=(NO)Quaternion_new(ctx, args2);
obj->funcs=Quaternion_ptr_funcs;
obj->typeID=EXT->Quaternion_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Quaternion_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"QuaternionRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,Quaternion*))
CATE(TE,"QuaternionRef::deref expects QuaternionRef as first argument."));
RET CV(*(Quaternion *)((NO)f)->data);
}
SV Quaternion_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Quaternion::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,Quaternion*))
CATE(TE,"QuaternionRef::refset expects QuaternionRef as first argument."));
*((Quaternion *)((NO)f)->data) = val_to_c<Quaternion>::f(ctx,a[1]);
RET CN;
}

void Quaternion_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Quaternion*))
CATE(TE,"QuaternionRef::__del__ expects QuaternionRef as first argument."));
SCRIPT_DELETE((Quaternion *)f->data);
}
SV Quaternion_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,Quaternion*))
CATE(TE,FAE("QuaternionRef's get method","QuaternionRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("QuaternionPtr");
EI(keyStr=="__new__")
RET CNF(Quaternion_ptr_new);
EI(keyStr=="__call__")
RET CNF(Quaternion_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Quaternion_ptr_deref);
if(keyStr=="refset")RET CNF(Quaternion_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Quaternion_funcs;
obj.typeID=EXT->Quaternion_typeID;
obj.refCount=1;
obj.data=f->data;
RET Quaternion_get_member(ctx, &obj, key);
}
void Quaternion_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,Quaternion*))
CATE(TE,FAE("QuaternionRef's set method","QuaternionRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Quaternion_funcs;
obj.typeID=EXT->Quaternion_typeID;
obj.refCount=1;
obj.data=f->data;
Quaternion_set_member(ctx, &obj, key, value);
}
SV GfxMeshAttrib_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GfxMeshAttrib;
NO obj=(NO)GfxMeshAttrib_new(ctx, args2);
obj->funcs=GfxMeshAttrib_ptr_funcs;
obj->typeID=EXT->GfxMeshAttrib_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GfxMeshAttrib_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxMeshAttribRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,GfxMeshAttrib*))
CATE(TE,"GfxMeshAttribRef::deref expects GfxMeshAttribRef as first argument."));
RET CV(*(GfxMeshAttrib *)((NO)f)->data);
}
SV GfxMeshAttrib_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GfxMeshAttrib::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,GfxMeshAttrib*))
CATE(TE,"GfxMeshAttribRef::refset expects GfxMeshAttribRef as first argument."));
*((GfxMeshAttrib *)((NO)f)->data) = val_to_c<GfxMeshAttrib>::f(ctx,a[1]);
RET CN;
}

void GfxMeshAttrib_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxMeshAttrib*))
CATE(TE,"GfxMeshAttribRef::__del__ expects GfxMeshAttribRef as first argument."));
SCRIPT_DELETE((GfxMeshAttrib *)f->data);
}
SV GfxMeshAttrib_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,GfxMeshAttrib*))
CATE(TE,FAE("GfxMeshAttribRef's get method","GfxMeshAttribRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxMeshAttribPtr");
EI(keyStr=="__new__")
RET CNF(GfxMeshAttrib_ptr_new);
EI(keyStr=="__call__")
RET CNF(GfxMeshAttrib_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GfxMeshAttrib_ptr_deref);
if(keyStr=="refset")RET CNF(GfxMeshAttrib_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxMeshAttrib_funcs;
obj.typeID=EXT->GfxMeshAttrib_typeID;
obj.refCount=1;
obj.data=f->data;
RET GfxMeshAttrib_get_member(ctx, &obj, key);
}
void GfxMeshAttrib_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,GfxMeshAttrib*))
CATE(TE,FAE("GfxMeshAttribRef's set method","GfxMeshAttribRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxMeshAttrib_funcs;
obj.typeID=EXT->GfxMeshAttrib_typeID;
obj.refCount=1;
obj.data=f->data;
GfxMeshAttrib_set_member(ctx, &obj, key, value);
}
SV RenderComponent_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->RenderComponent;
NO obj=(NO)RenderComponent_new(ctx, args2);
obj->funcs=RenderComponent_ptr_funcs;
obj->typeID=EXT->RenderComponent_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV RenderComponent_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"RenderComponentRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,RenderComponent*))
CATE(TE,"RenderComponentRef::deref expects RenderComponentRef as first argument."));
CATE(TE,"RenderComponent objects are not copyable."));
}
SV RenderComponent_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"RenderComponent::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,RenderComponent*))
CATE(TE,"RenderComponentRef::refset expects RenderComponentRef as first argument."));
CATE(TE,"RenderComponent objects are not copyable."));
RET CN;
}

void RenderComponent_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,RenderComponent*))
CATE(TE,"RenderComponentRef::__del__ expects RenderComponentRef as first argument."));
}
SV RenderComponent_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,RenderComponent*))
CATE(TE,FAE("RenderComponentRef's get method","RenderComponentRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("RenderComponentPtr");
EI(keyStr=="__new__")
RET CNF(RenderComponent_ptr_new);
EI(keyStr=="__call__")
RET CNF(RenderComponent_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(RenderComponent_ptr_deref);
if(keyStr=="refset")RET CNF(RenderComponent_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=RenderComponent_funcs;
obj.typeID=EXT->RenderComponent_typeID;
obj.refCount=1;
obj.data=f->data;
RET RenderComponent_get_member(ctx, &obj, key);
}
void RenderComponent_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,RenderComponent*))
CATE(TE,FAE("RenderComponentRef's set method","RenderComponentRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=RenderComponent_funcs;
obj.typeID=EXT->RenderComponent_typeID;
obj.refCount=1;
obj.data=f->data;
RenderComponent_set_member(ctx, &obj, key, value);
}
SV Int2_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Int2;
NO obj=(NO)Int2_new(ctx, args2);
obj->funcs=Int2_ptr_funcs;
obj->typeID=EXT->Int2_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Int2_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Int2Ref::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,T2<int32_t>*))
CATE(TE,"Int2Ref::deref expects Int2Ref as first argument."));
RET CV(*(T2<int32_t> *)((NO)f)->data);
}
SV Int2_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Int2::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,T2<int32_t>*))
CATE(TE,"Int2Ref::refset expects Int2Ref as first argument."));
*((T2<int32_t> *)((NO)f)->data) = val_to_c<T2<int32_t>>::f(ctx,a[1]);
RET CN;
}

void Int2_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T2<int32_t>*))
CATE(TE,"Int2Ref::__del__ expects Int2Ref as first argument."));
SCRIPT_DELETE((T2<int32_t> *)f->data);
}
SV Int2_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,T2<int32_t>*))
CATE(TE,FAE("Int2Ref's get method","Int2Ref")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Int2Ptr");
EI(keyStr=="__new__")
RET CNF(Int2_ptr_new);
EI(keyStr=="__call__")
RET CNF(Int2_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Int2_ptr_deref);
if(keyStr=="refset")RET CNF(Int2_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Int2_funcs;
obj.typeID=EXT->Int2_typeID;
obj.refCount=1;
obj.data=f->data;
RET Int2_get_member(ctx, &obj, key);
}
void Int2_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,T2<int32_t>*))
CATE(TE,FAE("Int2Ref's set method","Int2Ref")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Int2_funcs;
obj.typeID=EXT->Int2_typeID;
obj.refCount=1;
obj.data=f->data;
Int2_set_member(ctx, &obj, key, value);
}
SV AudioWorld_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->AudioWorld;
NO obj=(NO)AudioWorld_new(ctx, args2);
obj->funcs=AudioWorld_ptr_funcs;
obj->typeID=EXT->AudioWorld_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV AudioWorld_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"AudioWorldRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,AudioWorld*))
CATE(TE,"AudioWorldRef::deref expects AudioWorldRef as first argument."));
RET CV(*(AudioWorld *)((NO)f)->data);
}
SV AudioWorld_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"AudioWorld::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,AudioWorld*))
CATE(TE,"AudioWorldRef::refset expects AudioWorldRef as first argument."));
*((AudioWorld *)((NO)f)->data) = val_to_c<AudioWorld>::f(ctx,a[1]);
RET CN;
}

void AudioWorld_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,AudioWorld*))
CATE(TE,"AudioWorldRef::__del__ expects AudioWorldRef as first argument."));
SCRIPT_DELETE((AudioWorld *)f->data);
}
SV AudioWorld_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,AudioWorld*))
CATE(TE,FAE("AudioWorldRef's get method","AudioWorldRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("AudioWorldPtr");
EI(keyStr=="__new__")
RET CNF(AudioWorld_ptr_new);
EI(keyStr=="__call__")
RET CNF(AudioWorld_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(AudioWorld_ptr_deref);
if(keyStr=="refset")RET CNF(AudioWorld_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=AudioWorld_funcs;
obj.typeID=EXT->AudioWorld_typeID;
obj.refCount=1;
obj.data=f->data;
RET AudioWorld_get_member(ctx, &obj, key);
}
void AudioWorld_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,AudioWorld*))
CATE(TE,FAE("AudioWorldRef's set method","AudioWorldRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=AudioWorld_funcs;
obj.typeID=EXT->AudioWorld_typeID;
obj.refCount=1;
obj.data=f->data;
AudioWorld_set_member(ctx, &obj, key, value);
}
SV GuiPlacer_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GuiPlacer;
NO obj=(NO)GuiPlacer_new(ctx, args2);
obj->funcs=GuiPlacer_ptr_funcs;
obj->typeID=EXT->GuiPlacer_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GuiPlacer_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GuiPlacerRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,GuiPlacer*))
CATE(TE,"GuiPlacerRef::deref expects GuiPlacerRef as first argument."));
RET CV(*(GuiPlacer *)((NO)f)->data);
}
SV GuiPlacer_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GuiPlacer::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,GuiPlacer*))
CATE(TE,"GuiPlacerRef::refset expects GuiPlacerRef as first argument."));
*((GuiPlacer *)((NO)f)->data) = val_to_c<GuiPlacer>::f(ctx,a[1]);
RET CN;
}

void GuiPlacer_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GuiPlacer*))
CATE(TE,"GuiPlacerRef::__del__ expects GuiPlacerRef as first argument."));
SCRIPT_DELETE((GuiPlacer *)f->data);
}
SV GuiPlacer_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,GuiPlacer*))
CATE(TE,FAE("GuiPlacerRef's get method","GuiPlacerRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GuiPlacerPtr");
EI(keyStr=="__new__")
RET CNF(GuiPlacer_ptr_new);
EI(keyStr=="__call__")
RET CNF(GuiPlacer_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GuiPlacer_ptr_deref);
if(keyStr=="refset")RET CNF(GuiPlacer_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GuiPlacer_funcs;
obj.typeID=EXT->GuiPlacer_typeID;
obj.refCount=1;
obj.data=f->data;
RET GuiPlacer_get_member(ctx, &obj, key);
}
void GuiPlacer_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,GuiPlacer*))
CATE(TE,FAE("GuiPlacerRef's set method","GuiPlacerRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GuiPlacer_funcs;
obj.typeID=EXT->GuiPlacer_typeID;
obj.refCount=1;
obj.data=f->data;
GuiPlacer_set_member(ctx, &obj, key, value);
}
SV ImGui_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->ImGui;
NO obj=(NO)ImGui_new(ctx, args2);
obj->funcs=ImGui_ptr_funcs;
obj->typeID=EXT->ImGui_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV ImGui_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"ImGuiRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,ImGui*))
CATE(TE,"ImGuiRef::deref expects ImGuiRef as first argument."));
RET CV(*(ImGui *)((NO)f)->data);
}
SV ImGui_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"ImGui::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,ImGui*))
CATE(TE,"ImGuiRef::refset expects ImGuiRef as first argument."));
*((ImGui *)((NO)f)->data) = val_to_c<ImGui>::f(ctx,a[1]);
RET CN;
}

void ImGui_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,ImGui*))
CATE(TE,"ImGuiRef::__del__ expects ImGuiRef as first argument."));
SCRIPT_DELETE((ImGui *)f->data);
}
SV ImGui_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,ImGui*))
CATE(TE,FAE("ImGuiRef's get method","ImGuiRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("ImGuiPtr");
EI(keyStr=="__new__")
RET CNF(ImGui_ptr_new);
EI(keyStr=="__call__")
RET CNF(ImGui_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(ImGui_ptr_deref);
if(keyStr=="refset")RET CNF(ImGui_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=ImGui_funcs;
obj.typeID=EXT->ImGui_typeID;
obj.refCount=1;
obj.data=f->data;
RET ImGui_get_member(ctx, &obj, key);
}
void ImGui_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,ImGui*))
CATE(TE,FAE("ImGuiRef's set method","ImGuiRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=ImGui_funcs;
obj.typeID=EXT->ImGui_typeID;
obj.refCount=1;
obj.data=f->data;
ImGui_set_member(ctx, &obj, key, value);
}
SV StringList_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->StringList;
NO obj=(NO)StringList_new(ctx, args2);
obj->funcs=StringList_ptr_funcs;
obj->typeID=EXT->StringList_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV StringList_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"StringListRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,List<String>*))
CATE(TE,"StringListRef::deref expects StringListRef as first argument."));
RET CV(*(List<String> *)((NO)f)->data);
}
SV StringList_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"StringList::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,List<String>*))
CATE(TE,"StringListRef::refset expects StringListRef as first argument."));
*((List<String> *)((NO)f)->data) = val_to_c<List<String>>::f(ctx,a[1]);
RET CN;
}

void StringList_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<String>*))
CATE(TE,"StringListRef::__del__ expects StringListRef as first argument."));
SCRIPT_DELETE((List<String> *)f->data);
}
SV StringList_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,List<String>*))
CATE(TE,FAE("StringListRef's get method","StringListRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("StringListPtr");
EI(keyStr=="__new__")
RET CNF(StringList_ptr_new);
EI(keyStr=="__call__")
RET CNF(StringList_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(StringList_ptr_deref);
if(keyStr=="refset")RET CNF(StringList_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=StringList_funcs;
obj.typeID=EXT->StringList_typeID;
obj.refCount=1;
obj.data=f->data;
RET StringList_get_member(ctx, &obj, key);
}
void StringList_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,List<String>*))
CATE(TE,FAE("StringListRef's set method","StringListRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=StringList_funcs;
obj.typeID=EXT->StringList_typeID;
obj.refCount=1;
obj.data=f->data;
StringList_set_member(ctx, &obj, key, value);
}
SV Application_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Application;
NO obj=(NO)Application_new(ctx, args2);
obj->funcs=Application_ptr_funcs;
obj->typeID=EXT->Application_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Application_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"ApplicationRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,Application*))
CATE(TE,"ApplicationRef::deref expects ApplicationRef as first argument."));
CATE(TE,"Application objects are not copyable."));
}
SV Application_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Application::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,Application*))
CATE(TE,"ApplicationRef::refset expects ApplicationRef as first argument."));
CATE(TE,"Application objects are not copyable."));
RET CN;
}

void Application_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Application*))
CATE(TE,"ApplicationRef::__del__ expects ApplicationRef as first argument."));
SCRIPT_DELETE((Application *)f->data);
}
SV Application_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,Application*))
CATE(TE,FAE("ApplicationRef's get method","ApplicationRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("ApplicationPtr");
EI(keyStr=="__new__")
RET CNF(Application_ptr_new);
EI(keyStr=="__call__")
RET CNF(Application_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Application_ptr_deref);
if(keyStr=="refset")RET CNF(Application_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Application_funcs;
obj.typeID=EXT->Application_typeID;
obj.refCount=1;
obj.data=f->data;
RET Application_get_member(ctx, &obj, key);
}
void Application_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,Application*))
CATE(TE,FAE("ApplicationRef's set method","ApplicationRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Application_funcs;
obj.typeID=EXT->Application_typeID;
obj.refCount=1;
obj.data=f->data;
Application_set_member(ctx, &obj, key, value);
}
SV LightPointData_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->LightPointData;
NO obj=(NO)LightPointData_new(ctx, args2);
obj->funcs=LightPointData_ptr_funcs;
obj->typeID=EXT->LightPointData_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV LightPointData_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"LightPointDataRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,LightPointData*))
CATE(TE,"LightPointDataRef::deref expects LightPointDataRef as first argument."));
RET CV(*(LightPointData *)((NO)f)->data);
}
SV LightPointData_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"LightPointData::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,LightPointData*))
CATE(TE,"LightPointDataRef::refset expects LightPointDataRef as first argument."));
*((LightPointData *)((NO)f)->data) = val_to_c<LightPointData>::f(ctx,a[1]);
RET CN;
}

void LightPointData_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,LightPointData*))
CATE(TE,"LightPointDataRef::__del__ expects LightPointDataRef as first argument."));
SCRIPT_DELETE((LightPointData *)f->data);
}
SV LightPointData_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,LightPointData*))
CATE(TE,FAE("LightPointDataRef's get method","LightPointDataRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("LightPointDataPtr");
EI(keyStr=="__new__")
RET CNF(LightPointData_ptr_new);
EI(keyStr=="__call__")
RET CNF(LightPointData_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(LightPointData_ptr_deref);
if(keyStr=="refset")RET CNF(LightPointData_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=LightPointData_funcs;
obj.typeID=EXT->LightPointData_typeID;
obj.refCount=1;
obj.data=f->data;
RET LightPointData_get_member(ctx, &obj, key);
}
void LightPointData_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,LightPointData*))
CATE(TE,FAE("LightPointDataRef's set method","LightPointDataRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=LightPointData_funcs;
obj.typeID=EXT->LightPointData_typeID;
obj.refCount=1;
obj.data=f->data;
LightPointData_set_member(ctx, &obj, key, value);
}
SV Float4_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Float4;
NO obj=(NO)Float4_new(ctx, args2);
obj->funcs=Float4_ptr_funcs;
obj->typeID=EXT->Float4_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Float4_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Float4Ref::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,T4<float>*))
CATE(TE,"Float4Ref::deref expects Float4Ref as first argument."));
RET CV(*(T4<float> *)((NO)f)->data);
}
SV Float4_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Float4::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,T4<float>*))
CATE(TE,"Float4Ref::refset expects Float4Ref as first argument."));
*((T4<float> *)((NO)f)->data) = val_to_c<T4<float>>::f(ctx,a[1]);
RET CN;
}

void Float4_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T4<float>*))
CATE(TE,"Float4Ref::__del__ expects Float4Ref as first argument."));
SCRIPT_DELETE((T4<float> *)f->data);
}
SV Float4_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,T4<float>*))
CATE(TE,FAE("Float4Ref's get method","Float4Ref")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Float4Ptr");
EI(keyStr=="__new__")
RET CNF(Float4_ptr_new);
EI(keyStr=="__call__")
RET CNF(Float4_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Float4_ptr_deref);
if(keyStr=="refset")RET CNF(Float4_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Float4_funcs;
obj.typeID=EXT->Float4_typeID;
obj.refCount=1;
obj.data=f->data;
RET Float4_get_member(ctx, &obj, key);
}
void Float4_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,T4<float>*))
CATE(TE,FAE("Float4Ref's set method","Float4Ref")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Float4_funcs;
obj.typeID=EXT->Float4_typeID;
obj.refCount=1;
obj.data=f->data;
Float4_set_member(ctx, &obj, key, value);
}
SV FloatList_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->FloatList;
NO obj=(NO)FloatList_new(ctx, args2);
obj->funcs=FloatList_ptr_funcs;
obj->typeID=EXT->FloatList_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV FloatList_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"FloatListRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,List<float>*))
CATE(TE,"FloatListRef::deref expects FloatListRef as first argument."));
RET CV(*(List<float> *)((NO)f)->data);
}
SV FloatList_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"FloatList::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,List<float>*))
CATE(TE,"FloatListRef::refset expects FloatListRef as first argument."));
*((List<float> *)((NO)f)->data) = val_to_c<List<float>>::f(ctx,a[1]);
RET CN;
}

void FloatList_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<float>*))
CATE(TE,"FloatListRef::__del__ expects FloatListRef as first argument."));
SCRIPT_DELETE((List<float> *)f->data);
}
SV FloatList_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,List<float>*))
CATE(TE,FAE("FloatListRef's get method","FloatListRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("FloatListPtr");
EI(keyStr=="__new__")
RET CNF(FloatList_ptr_new);
EI(keyStr=="__call__")
RET CNF(FloatList_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(FloatList_ptr_deref);
if(keyStr=="refset")RET CNF(FloatList_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=FloatList_funcs;
obj.typeID=EXT->FloatList_typeID;
obj.refCount=1;
obj.data=f->data;
RET FloatList_get_member(ctx, &obj, key);
}
void FloatList_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,List<float>*))
CATE(TE,FAE("FloatListRef's set method","FloatListRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=FloatList_funcs;
obj.typeID=EXT->FloatList_typeID;
obj.refCount=1;
obj.data=f->data;
FloatList_set_member(ctx, &obj, key, value);
}
SV Container_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Container;
NO obj=(NO)Container_new(ctx, args2);
obj->funcs=Container_ptr_funcs;
obj->typeID=EXT->Container_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Container_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"ContainerRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,Container*))
CATE(TE,"ContainerRef::deref expects ContainerRef as first argument."));
RET CV(*(Container *)((NO)f)->data);
}
SV Container_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Container::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,Container*))
CATE(TE,"ContainerRef::refset expects ContainerRef as first argument."));
*((Container *)((NO)f)->data) = val_to_c<Container>::f(ctx,a[1]);
RET CN;
}

void Container_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Container*))
CATE(TE,"ContainerRef::__del__ expects ContainerRef as first argument."));
SCRIPT_DELETE((Container *)f->data);
}
SV Container_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,Container*))
CATE(TE,FAE("ContainerRef's get method","ContainerRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("ContainerPtr");
EI(keyStr=="__new__")
RET CNF(Container_ptr_new);
EI(keyStr=="__call__")
RET CNF(Container_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Container_ptr_deref);
if(keyStr=="refset")RET CNF(Container_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Container_funcs;
obj.typeID=EXT->Container_typeID;
obj.refCount=1;
obj.data=f->data;
RET Container_get_member(ctx, &obj, key);
}
void Container_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,Container*))
CATE(TE,FAE("ContainerRef's set method","ContainerRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Container_funcs;
obj.typeID=EXT->Container_typeID;
obj.refCount=1;
obj.data=f->data;
Container_set_member(ctx, &obj, key, value);
}
SV LightDirectionalData_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->LightDirectionalData;
NO obj=(NO)LightDirectionalData_new(ctx, args2);
obj->funcs=LightDirectionalData_ptr_funcs;
obj->typeID=EXT->LightDirectionalData_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV LightDirectionalData_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"LightDirectionalDataRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,LightDirectionalData*))
CATE(TE,"LightDirectionalDataRef::deref expects LightDirectionalDataRef as first argument."));
RET CV(*(LightDirectionalData *)((NO)f)->data);
}
SV LightDirectionalData_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"LightDirectionalData::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,LightDirectionalData*))
CATE(TE,"LightDirectionalDataRef::refset expects LightDirectionalDataRef as first argument."));
*((LightDirectionalData *)((NO)f)->data) = val_to_c<LightDirectionalData>::f(ctx,a[1]);
RET CN;
}

void LightDirectionalData_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,LightDirectionalData*))
CATE(TE,"LightDirectionalDataRef::__del__ expects LightDirectionalDataRef as first argument."));
SCRIPT_DELETE((LightDirectionalData *)f->data);
}
SV LightDirectionalData_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,LightDirectionalData*))
CATE(TE,FAE("LightDirectionalDataRef's get method","LightDirectionalDataRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("LightDirectionalDataPtr");
EI(keyStr=="__new__")
RET CNF(LightDirectionalData_ptr_new);
EI(keyStr=="__call__")
RET CNF(LightDirectionalData_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(LightDirectionalData_ptr_deref);
if(keyStr=="refset")RET CNF(LightDirectionalData_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=LightDirectionalData_funcs;
obj.typeID=EXT->LightDirectionalData_typeID;
obj.refCount=1;
obj.data=f->data;
RET LightDirectionalData_get_member(ctx, &obj, key);
}
void LightDirectionalData_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,LightDirectionalData*))
CATE(TE,FAE("LightDirectionalDataRef's set method","LightDirectionalDataRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=LightDirectionalData_funcs;
obj.typeID=EXT->LightDirectionalData_typeID;
obj.refCount=1;
obj.data=f->data;
LightDirectionalData_set_member(ctx, &obj, key, value);
}
SV Matrix4x4_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Matrix4x4;
NO obj=(NO)Matrix4x4_new(ctx, args2);
obj->funcs=Matrix4x4_ptr_funcs;
obj->typeID=EXT->Matrix4x4_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Matrix4x4_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Matrix4x4Ref::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,Matrix4x4*))
CATE(TE,"Matrix4x4Ref::deref expects Matrix4x4Ref as first argument."));
RET CV(*(Matrix4x4 *)((NO)f)->data);
}
SV Matrix4x4_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Matrix4x4::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,Matrix4x4*))
CATE(TE,"Matrix4x4Ref::refset expects Matrix4x4Ref as first argument."));
*((Matrix4x4 *)((NO)f)->data) = val_to_c<Matrix4x4>::f(ctx,a[1]);
RET CN;
}

void Matrix4x4_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Matrix4x4*))
CATE(TE,"Matrix4x4Ref::__del__ expects Matrix4x4Ref as first argument."));
SCRIPT_DELETE((Matrix4x4 *)f->data);
}
SV Matrix4x4_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,Matrix4x4*))
CATE(TE,FAE("Matrix4x4Ref's get method","Matrix4x4Ref")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Matrix4x4Ptr");
EI(keyStr=="__new__")
RET CNF(Matrix4x4_ptr_new);
EI(keyStr=="__call__")
RET CNF(Matrix4x4_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Matrix4x4_ptr_deref);
if(keyStr=="refset")RET CNF(Matrix4x4_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Matrix4x4_funcs;
obj.typeID=EXT->Matrix4x4_typeID;
obj.refCount=1;
obj.data=f->data;
RET Matrix4x4_get_member(ctx, &obj, key);
}
void Matrix4x4_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,Matrix4x4*))
CATE(TE,FAE("Matrix4x4Ref's set method","Matrix4x4Ref")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Matrix4x4_funcs;
obj.typeID=EXT->Matrix4x4_typeID;
obj.refCount=1;
obj.data=f->data;
Matrix4x4_set_member(ctx, &obj, key, value);
}
SV Map_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Map;
NO obj=(NO)Map_new(ctx, args2);
obj->funcs=Map_ptr_funcs;
obj->typeID=EXT->Map_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Map_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"MapRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,HashMap<scripting::Value*,scripting::Value*>*))
CATE(TE,"MapRef::deref expects MapRef as first argument."));
RET CV(*(HashMap<scripting::Value*,scripting::Value*> *)((NO)f)->data);
}
SV Map_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Map::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,HashMap<scripting::Value*,scripting::Value*>*))
CATE(TE,"MapRef::refset expects MapRef as first argument."));
*((HashMap<scripting::Value*,scripting::Value*> *)((NO)f)->data) = val_to_c<HashMap<scripting::Value*,scripting::Value*>>::f(ctx,a[1]);
RET CN;
}

void Map_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,HashMap<scripting::Value*,scripting::Value*>*))
CATE(TE,"MapRef::__del__ expects MapRef as first argument."));
SCRIPT_DELETE((HashMap<scripting::Value*,scripting::Value*> *)f->data);
}
SV Map_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,HashMap<scripting::Value*,scripting::Value*>*))
CATE(TE,FAE("MapRef's get method","MapRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("MapPtr");
EI(keyStr=="__new__")
RET CNF(Map_ptr_new);
EI(keyStr=="__call__")
RET CNF(Map_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Map_ptr_deref);
if(keyStr=="refset")RET CNF(Map_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Map_funcs;
obj.typeID=EXT->Map_typeID;
obj.refCount=1;
obj.data=f->data;
RET Map_get_member(ctx, &obj, key);
}
void Map_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,HashMap<scripting::Value*,scripting::Value*>*))
CATE(TE,FAE("MapRef's set method","MapRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Map_funcs;
obj.typeID=EXT->Map_typeID;
obj.refCount=1;
obj.data=f->data;
Map_set_member(ctx, &obj, key, value);
}
SV UInt3_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->UInt3;
NO obj=(NO)UInt3_new(ctx, args2);
obj->funcs=UInt3_ptr_funcs;
obj->typeID=EXT->UInt3_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV UInt3_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"UInt3Ref::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,T3<uint32_t>*))
CATE(TE,"UInt3Ref::deref expects UInt3Ref as first argument."));
RET CV(*(T3<uint32_t> *)((NO)f)->data);
}
SV UInt3_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"UInt3::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,T3<uint32_t>*))
CATE(TE,"UInt3Ref::refset expects UInt3Ref as first argument."));
*((T3<uint32_t> *)((NO)f)->data) = val_to_c<T3<uint32_t>>::f(ctx,a[1]);
RET CN;
}

void UInt3_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T3<uint32_t>*))
CATE(TE,"UInt3Ref::__del__ expects UInt3Ref as first argument."));
SCRIPT_DELETE((T3<uint32_t> *)f->data);
}
SV UInt3_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,T3<uint32_t>*))
CATE(TE,FAE("UInt3Ref's get method","UInt3Ref")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("UInt3Ptr");
EI(keyStr=="__new__")
RET CNF(UInt3_ptr_new);
EI(keyStr=="__call__")
RET CNF(UInt3_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(UInt3_ptr_deref);
if(keyStr=="refset")RET CNF(UInt3_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=UInt3_funcs;
obj.typeID=EXT->UInt3_typeID;
obj.refCount=1;
obj.data=f->data;
RET UInt3_get_member(ctx, &obj, key);
}
void UInt3_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,T3<uint32_t>*))
CATE(TE,FAE("UInt3Ref's set method","UInt3Ref")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=UInt3_funcs;
obj.typeID=EXT->UInt3_typeID;
obj.refCount=1;
obj.data=f->data;
UInt3_set_member(ctx, &obj, key, value);
}
SV LightSpotData_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->LightSpotData;
NO obj=(NO)LightSpotData_new(ctx, args2);
obj->funcs=LightSpotData_ptr_funcs;
obj->typeID=EXT->LightSpotData_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV LightSpotData_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"LightSpotDataRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,LightSpotData*))
CATE(TE,"LightSpotDataRef::deref expects LightSpotDataRef as first argument."));
RET CV(*(LightSpotData *)((NO)f)->data);
}
SV LightSpotData_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"LightSpotData::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,LightSpotData*))
CATE(TE,"LightSpotDataRef::refset expects LightSpotDataRef as first argument."));
*((LightSpotData *)((NO)f)->data) = val_to_c<LightSpotData>::f(ctx,a[1]);
RET CN;
}

void LightSpotData_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,LightSpotData*))
CATE(TE,"LightSpotDataRef::__del__ expects LightSpotDataRef as first argument."));
SCRIPT_DELETE((LightSpotData *)f->data);
}
SV LightSpotData_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,LightSpotData*))
CATE(TE,FAE("LightSpotDataRef's get method","LightSpotDataRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("LightSpotDataPtr");
EI(keyStr=="__new__")
RET CNF(LightSpotData_ptr_new);
EI(keyStr=="__call__")
RET CNF(LightSpotData_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(LightSpotData_ptr_deref);
if(keyStr=="refset")RET CNF(LightSpotData_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=LightSpotData_funcs;
obj.typeID=EXT->LightSpotData_typeID;
obj.refCount=1;
obj.data=f->data;
RET LightSpotData_get_member(ctx, &obj, key);
}
void LightSpotData_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,LightSpotData*))
CATE(TE,FAE("LightSpotDataRef's set method","LightSpotDataRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=LightSpotData_funcs;
obj.typeID=EXT->LightSpotData_typeID;
obj.refCount=1;
obj.data=f->data;
LightSpotData_set_member(ctx, &obj, key, value);
}
SV PhysicsShape_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->PhysicsShape;
NO obj=(NO)PhysicsShape_new(ctx, args2);
obj->funcs=PhysicsShape_ptr_funcs;
obj->typeID=EXT->PhysicsShape_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV PhysicsShape_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"PhysicsShapeRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,PhysicsShape*))
CATE(TE,"PhysicsShapeRef::deref expects PhysicsShapeRef as first argument."));
CATE(TE,"PhysicsShape objects are not copyable."));
}
SV PhysicsShape_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"PhysicsShape::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,PhysicsShape*))
CATE(TE,"PhysicsShapeRef::refset expects PhysicsShapeRef as first argument."));
CATE(TE,"PhysicsShape objects are not copyable."));
RET CN;
}

void PhysicsShape_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,PhysicsShape*))
CATE(TE,"PhysicsShapeRef::__del__ expects PhysicsShapeRef as first argument."));
PhysicsShape*obj=(PhysicsShape*)f->data;
if(shouldScriptDelete(f->data) && (obj != NULL)) {obj->release();}
}
SV PhysicsShape_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,PhysicsShape*))
CATE(TE,FAE("PhysicsShapeRef's get method","PhysicsShapeRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("PhysicsShapePtr");
EI(keyStr=="__new__")
RET CNF(PhysicsShape_ptr_new);
EI(keyStr=="__call__")
RET CNF(PhysicsShape_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(PhysicsShape_ptr_deref);
if(keyStr=="refset")RET CNF(PhysicsShape_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=PhysicsShape_funcs;
obj.typeID=EXT->PhysicsShape_typeID;
obj.refCount=1;
obj.data=f->data;
RET PhysicsShape_get_member(ctx, &obj, key);
}
void PhysicsShape_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,PhysicsShape*))
CATE(TE,FAE("PhysicsShapeRef's set method","PhysicsShapeRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=PhysicsShape_funcs;
obj.typeID=EXT->PhysicsShape_typeID;
obj.refCount=1;
obj.data=f->data;
PhysicsShape_set_member(ctx, &obj, key, value);
}
SV AudioDevice_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->AudioDevice;
NO obj=(NO)AudioDevice_new(ctx, args2);
obj->funcs=AudioDevice_ptr_funcs;
obj->typeID=EXT->AudioDevice_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV AudioDevice_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"AudioDeviceRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,AudioDevice*))
CATE(TE,"AudioDeviceRef::deref expects AudioDeviceRef as first argument."));
RET CV(*(AudioDevice *)((NO)f)->data);
}
SV AudioDevice_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"AudioDevice::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,AudioDevice*))
CATE(TE,"AudioDeviceRef::refset expects AudioDeviceRef as first argument."));
*((AudioDevice *)((NO)f)->data) = val_to_c<AudioDevice>::f(ctx,a[1]);
RET CN;
}

void AudioDevice_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,AudioDevice*))
CATE(TE,"AudioDeviceRef::__del__ expects AudioDeviceRef as first argument."));
SCRIPT_DELETE((AudioDevice *)f->data);
}
SV AudioDevice_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,AudioDevice*))
CATE(TE,FAE("AudioDeviceRef's get method","AudioDeviceRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("AudioDevicePtr");
EI(keyStr=="__new__")
RET CNF(AudioDevice_ptr_new);
EI(keyStr=="__call__")
RET CNF(AudioDevice_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(AudioDevice_ptr_deref);
if(keyStr=="refset")RET CNF(AudioDevice_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=AudioDevice_funcs;
obj.typeID=EXT->AudioDevice_typeID;
obj.refCount=1;
obj.data=f->data;
RET AudioDevice_get_member(ctx, &obj, key);
}
void AudioDevice_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,AudioDevice*))
CATE(TE,FAE("AudioDeviceRef's set method","AudioDeviceRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=AudioDevice_funcs;
obj.typeID=EXT->AudioDevice_typeID;
obj.refCount=1;
obj.data=f->data;
AudioDevice_set_member(ctx, &obj, key, value);
}
SV RigidBodyList_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->RigidBodyList;
NO obj=(NO)RigidBodyList_new(ctx, args2);
obj->funcs=RigidBodyList_ptr_funcs;
obj->typeID=EXT->RigidBodyList_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV RigidBodyList_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"RigidBodyListRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,List<RigidBody*>*))
CATE(TE,"RigidBodyListRef::deref expects RigidBodyListRef as first argument."));
RET CV(*(List<RigidBody*> *)((NO)f)->data);
}
SV RigidBodyList_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"RigidBodyList::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,List<RigidBody*>*))
CATE(TE,"RigidBodyListRef::refset expects RigidBodyListRef as first argument."));
*((List<RigidBody*> *)((NO)f)->data) = val_to_c<List<RigidBody*>>::f(ctx,a[1]);
RET CN;
}

void RigidBodyList_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<RigidBody*>*))
CATE(TE,"RigidBodyListRef::__del__ expects RigidBodyListRef as first argument."));
SCRIPT_DELETE((List<RigidBody*> *)f->data);
}
SV RigidBodyList_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,List<RigidBody*>*))
CATE(TE,FAE("RigidBodyListRef's get method","RigidBodyListRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("RigidBodyListPtr");
EI(keyStr=="__new__")
RET CNF(RigidBodyList_ptr_new);
EI(keyStr=="__call__")
RET CNF(RigidBodyList_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(RigidBodyList_ptr_deref);
if(keyStr=="refset")RET CNF(RigidBodyList_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=RigidBodyList_funcs;
obj.typeID=EXT->RigidBodyList_typeID;
obj.refCount=1;
obj.data=f->data;
RET RigidBodyList_get_member(ctx, &obj, key);
}
void RigidBodyList_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,List<RigidBody*>*))
CATE(TE,FAE("RigidBodyListRef's set method","RigidBodyListRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=RigidBodyList_funcs;
obj.typeID=EXT->RigidBodyList_typeID;
obj.refCount=1;
obj.data=f->data;
RigidBodyList_set_member(ctx, &obj, key, value);
}
SV UInt4_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->UInt4;
NO obj=(NO)UInt4_new(ctx, args2);
obj->funcs=UInt4_ptr_funcs;
obj->typeID=EXT->UInt4_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV UInt4_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"UInt4Ref::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,T4<uint32_t>*))
CATE(TE,"UInt4Ref::deref expects UInt4Ref as first argument."));
RET CV(*(T4<uint32_t> *)((NO)f)->data);
}
SV UInt4_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"UInt4::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,T4<uint32_t>*))
CATE(TE,"UInt4Ref::refset expects UInt4Ref as first argument."));
*((T4<uint32_t> *)((NO)f)->data) = val_to_c<T4<uint32_t>>::f(ctx,a[1]);
RET CN;
}

void UInt4_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,T4<uint32_t>*))
CATE(TE,"UInt4Ref::__del__ expects UInt4Ref as first argument."));
SCRIPT_DELETE((T4<uint32_t> *)f->data);
}
SV UInt4_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,T4<uint32_t>*))
CATE(TE,FAE("UInt4Ref's get method","UInt4Ref")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("UInt4Ptr");
EI(keyStr=="__new__")
RET CNF(UInt4_ptr_new);
EI(keyStr=="__call__")
RET CNF(UInt4_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(UInt4_ptr_deref);
if(keyStr=="refset")RET CNF(UInt4_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=UInt4_funcs;
obj.typeID=EXT->UInt4_typeID;
obj.refCount=1;
obj.data=f->data;
RET UInt4_get_member(ctx, &obj, key);
}
void UInt4_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,T4<uint32_t>*))
CATE(TE,FAE("UInt4Ref's set method","UInt4Ref")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=UInt4_funcs;
obj.typeID=EXT->UInt4_typeID;
obj.refCount=1;
obj.data=f->data;
UInt4_set_member(ctx, &obj, key, value);
}
SV RayCastResult_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->RayCastResult;
NO obj=(NO)RayCastResult_new(ctx, args2);
obj->funcs=RayCastResult_ptr_funcs;
obj->typeID=EXT->RayCastResult_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV RayCastResult_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"RayCastResultRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,RayCastResult*))
CATE(TE,"RayCastResultRef::deref expects RayCastResultRef as first argument."));
RET CV(*(RayCastResult *)((NO)f)->data);
}
SV RayCastResult_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"RayCastResult::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,RayCastResult*))
CATE(TE,"RayCastResultRef::refset expects RayCastResultRef as first argument."));
*((RayCastResult *)((NO)f)->data) = val_to_c<RayCastResult>::f(ctx,a[1]);
RET CN;
}

void RayCastResult_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,RayCastResult*))
CATE(TE,"RayCastResultRef::__del__ expects RayCastResultRef as first argument."));
SCRIPT_DELETE((RayCastResult *)f->data);
}
SV RayCastResult_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,RayCastResult*))
CATE(TE,FAE("RayCastResultRef's get method","RayCastResultRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("RayCastResultPtr");
EI(keyStr=="__new__")
RET CNF(RayCastResult_ptr_new);
EI(keyStr=="__call__")
RET CNF(RayCastResult_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(RayCastResult_ptr_deref);
if(keyStr=="refset")RET CNF(RayCastResult_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=RayCastResult_funcs;
obj.typeID=EXT->RayCastResult_typeID;
obj.refCount=1;
obj.data=f->data;
RET RayCastResult_get_member(ctx, &obj, key);
}
void RayCastResult_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,RayCastResult*))
CATE(TE,FAE("RayCastResultRef's set method","RayCastResultRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=RayCastResult_funcs;
obj.typeID=EXT->RayCastResult_typeID;
obj.refCount=1;
obj.data=f->data;
RayCastResult_set_member(ctx, &obj, key, value);
}
SV GfxLOD_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GfxLOD;
NO obj=(NO)GfxLOD_new(ctx, args2);
obj->funcs=GfxLOD_ptr_funcs;
obj->typeID=EXT->GfxLOD_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GfxLOD_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxLODRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,GfxLOD*))
CATE(TE,"GfxLODRef::deref expects GfxLODRef as first argument."));
RET CV(*(GfxLOD *)((NO)f)->data);
}
SV GfxLOD_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GfxLOD::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,GfxLOD*))
CATE(TE,"GfxLODRef::refset expects GfxLODRef as first argument."));
*((GfxLOD *)((NO)f)->data) = val_to_c<GfxLOD>::f(ctx,a[1]);
RET CN;
}

void GfxLOD_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxLOD*))
CATE(TE,"GfxLODRef::__del__ expects GfxLODRef as first argument."));
SCRIPT_DELETE((GfxLOD *)f->data);
}
SV GfxLOD_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,GfxLOD*))
CATE(TE,FAE("GfxLODRef's get method","GfxLODRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxLODPtr");
EI(keyStr=="__new__")
RET CNF(GfxLOD_ptr_new);
EI(keyStr=="__call__")
RET CNF(GfxLOD_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GfxLOD_ptr_deref);
if(keyStr=="refset")RET CNF(GfxLOD_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxLOD_funcs;
obj.typeID=EXT->GfxLOD_typeID;
obj.refCount=1;
obj.data=f->data;
RET GfxLOD_get_member(ctx, &obj, key);
}
void GfxLOD_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,GfxLOD*))
CATE(TE,FAE("GfxLODRef's set method","GfxLODRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxLOD_funcs;
obj.typeID=EXT->GfxLOD_typeID;
obj.refCount=1;
obj.data=f->data;
GfxLOD_set_member(ctx, &obj, key, value);
}
SV File_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->File;
NO obj=(NO)File_new(ctx, args2);
obj->funcs=File_ptr_funcs;
obj->typeID=EXT->File_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV File_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"FileRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,File*))
CATE(TE,"FileRef::deref expects FileRef as first argument."));
CATE(TE,"File objects are not copyable."));
}
SV File_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"File::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,File*))
CATE(TE,"FileRef::refset expects FileRef as first argument."));
CATE(TE,"File objects are not copyable."));
RET CN;
}

void File_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,File*))
CATE(TE,"FileRef::__del__ expects FileRef as first argument."));
SCRIPT_DELETE((File *)f->data);
}
SV File_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,File*))
CATE(TE,FAE("FileRef's get method","FileRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("FilePtr");
EI(keyStr=="__new__")
RET CNF(File_ptr_new);
EI(keyStr=="__call__")
RET CNF(File_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(File_ptr_deref);
if(keyStr=="refset")RET CNF(File_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=File_funcs;
obj.typeID=EXT->File_typeID;
obj.refCount=1;
obj.data=f->data;
RET File_get_member(ctx, &obj, key);
}
void File_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,File*))
CATE(TE,FAE("FileRef's set method","FileRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=File_funcs;
obj.typeID=EXT->File_typeID;
obj.refCount=1;
obj.data=f->data;
File_set_member(ctx, &obj, key, value);
}
SV AABB_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->AABB;
NO obj=(NO)AABB_new(ctx, args2);
obj->funcs=AABB_ptr_funcs;
obj->typeID=EXT->AABB_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV AABB_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"AABBRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,AABB*))
CATE(TE,"AABBRef::deref expects AABBRef as first argument."));
RET CV(*(AABB *)((NO)f)->data);
}
SV AABB_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"AABB::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,AABB*))
CATE(TE,"AABBRef::refset expects AABBRef as first argument."));
*((AABB *)((NO)f)->data) = val_to_c<AABB>::f(ctx,a[1]);
RET CN;
}

void AABB_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,AABB*))
CATE(TE,"AABBRef::__del__ expects AABBRef as first argument."));
SCRIPT_DELETE((AABB *)f->data);
}
SV AABB_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,AABB*))
CATE(TE,FAE("AABBRef's get method","AABBRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("AABBPtr");
EI(keyStr=="__new__")
RET CNF(AABB_ptr_new);
EI(keyStr=="__call__")
RET CNF(AABB_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(AABB_ptr_deref);
if(keyStr=="refset")RET CNF(AABB_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=AABB_funcs;
obj.typeID=EXT->AABB_typeID;
obj.refCount=1;
obj.data=f->data;
RET AABB_get_member(ctx, &obj, key);
}
void AABB_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,AABB*))
CATE(TE,FAE("AABBRef's set method","AABBRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=AABB_funcs;
obj.typeID=EXT->AABB_typeID;
obj.refCount=1;
obj.data=f->data;
AABB_set_member(ctx, &obj, key, value);
}
SV RigidBodyConstructionInfo_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->RigidBodyConstructionInfo;
NO obj=(NO)RigidBodyConstructionInfo_new(ctx, args2);
obj->funcs=RigidBodyConstructionInfo_ptr_funcs;
obj->typeID=EXT->RigidBodyConstructionInfo_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV RigidBodyConstructionInfo_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"RigidBodyConstructionInfoRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,RigidBodyConstructionInfo*))
CATE(TE,"RigidBodyConstructionInfoRef::deref expects RigidBodyConstructionInfoRef as first argument."));
RET CV(*(RigidBodyConstructionInfo *)((NO)f)->data);
}
SV RigidBodyConstructionInfo_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"RigidBodyConstructionInfo::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,RigidBodyConstructionInfo*))
CATE(TE,"RigidBodyConstructionInfoRef::refset expects RigidBodyConstructionInfoRef as first argument."));
*((RigidBodyConstructionInfo *)((NO)f)->data) = val_to_c<RigidBodyConstructionInfo>::f(ctx,a[1]);
RET CN;
}

void RigidBodyConstructionInfo_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,RigidBodyConstructionInfo*))
CATE(TE,"RigidBodyConstructionInfoRef::__del__ expects RigidBodyConstructionInfoRef as first argument."));
SCRIPT_DELETE((RigidBodyConstructionInfo *)f->data);
}
SV RigidBodyConstructionInfo_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,RigidBodyConstructionInfo*))
CATE(TE,FAE("RigidBodyConstructionInfoRef's get method","RigidBodyConstructionInfoRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("RigidBodyConstructionInfoPtr");
EI(keyStr=="__new__")
RET CNF(RigidBodyConstructionInfo_ptr_new);
EI(keyStr=="__call__")
RET CNF(RigidBodyConstructionInfo_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(RigidBodyConstructionInfo_ptr_deref);
if(keyStr=="refset")RET CNF(RigidBodyConstructionInfo_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=RigidBodyConstructionInfo_funcs;
obj.typeID=EXT->RigidBodyConstructionInfo_typeID;
obj.refCount=1;
obj.data=f->data;
RET RigidBodyConstructionInfo_get_member(ctx, &obj, key);
}
void RigidBodyConstructionInfo_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,RigidBodyConstructionInfo*))
CATE(TE,FAE("RigidBodyConstructionInfoRef's set method","RigidBodyConstructionInfoRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=RigidBodyConstructionInfo_funcs;
obj.typeID=EXT->RigidBodyConstructionInfo_typeID;
obj.refCount=1;
obj.data=f->data;
RigidBodyConstructionInfo_set_member(ctx, &obj, key, value);
}
SV List_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->List;
NO obj=(NO)List_new(ctx, args2);
obj->funcs=List_ptr_funcs;
obj->typeID=EXT->List_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV List_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"ListRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,List<scripting::Value*>*))
CATE(TE,"ListRef::deref expects ListRef as first argument."));
RET CV(*(List<scripting::Value*> *)((NO)f)->data);
}
SV List_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"List::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,List<scripting::Value*>*))
CATE(TE,"ListRef::refset expects ListRef as first argument."));
*((List<scripting::Value*> *)((NO)f)->data) = val_to_c<List<scripting::Value*>>::f(ctx,a[1]);
RET CN;
}

void List_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<scripting::Value*>*))
CATE(TE,"ListRef::__del__ expects ListRef as first argument."));
SCRIPT_DELETE((List<scripting::Value*> *)f->data);
}
SV List_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,List<scripting::Value*>*))
CATE(TE,FAE("ListRef's get method","ListRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("ListPtr");
EI(keyStr=="__new__")
RET CNF(List_ptr_new);
EI(keyStr=="__call__")
RET CNF(List_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(List_ptr_deref);
if(keyStr=="refset")RET CNF(List_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=List_funcs;
obj.typeID=EXT->List_typeID;
obj.refCount=1;
obj.data=f->data;
RET List_get_member(ctx, &obj, key);
}
void List_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,List<scripting::Value*>*))
CATE(TE,FAE("ListRef's set method","ListRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=List_funcs;
obj.typeID=EXT->List_typeID;
obj.refCount=1;
obj.data=f->data;
List_set_member(ctx, &obj, key, value);
}
SV Audio_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Audio;
NO obj=(NO)Audio_new(ctx, args2);
obj->funcs=Audio_ptr_funcs;
obj->typeID=EXT->Audio_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Audio_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"AudioRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,Audio*))
CATE(TE,"AudioRef::deref expects AudioRef as first argument."));
CATE(TE,"Audio objects are not copyable."));
}
SV Audio_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Audio::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,Audio*))
CATE(TE,"AudioRef::refset expects AudioRef as first argument."));
CATE(TE,"Audio objects are not copyable."));
RET CN;
}

void Audio_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Audio*))
CATE(TE,"AudioRef::__del__ expects AudioRef as first argument."));
Audio*obj=(Audio*)f->data;
if(shouldScriptDelete(f->data) && (obj != NULL)) {obj->release();}
}
SV Audio_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,Audio*))
CATE(TE,FAE("AudioRef's get method","AudioRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("AudioPtr");
EI(keyStr=="__new__")
RET CNF(Audio_ptr_new);
EI(keyStr=="__call__")
RET CNF(Audio_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Audio_ptr_deref);
if(keyStr=="refset")RET CNF(Audio_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Audio_funcs;
obj.typeID=EXT->Audio_typeID;
obj.refCount=1;
obj.data=f->data;
RET Audio_get_member(ctx, &obj, key);
}
void Audio_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,Audio*))
CATE(TE,FAE("AudioRef's set method","AudioRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Audio_funcs;
obj.typeID=EXT->Audio_typeID;
obj.refCount=1;
obj.data=f->data;
Audio_set_member(ctx, &obj, key, value);
}
SV GfxTexture_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GfxTexture;
NO obj=(NO)GfxTexture_new(ctx, args2);
obj->funcs=GfxTexture_ptr_funcs;
obj->typeID=EXT->GfxTexture_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GfxTexture_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxTextureRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,GfxTexture*))
CATE(TE,"GfxTextureRef::deref expects GfxTextureRef as first argument."));
CATE(TE,"GfxTexture objects are not copyable."));
}
SV GfxTexture_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GfxTexture::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,GfxTexture*))
CATE(TE,"GfxTextureRef::refset expects GfxTextureRef as first argument."));
CATE(TE,"GfxTexture objects are not copyable."));
RET CN;
}

void GfxTexture_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxTexture*))
CATE(TE,"GfxTextureRef::__del__ expects GfxTextureRef as first argument."));
GfxTexture*obj=(GfxTexture*)f->data;
if(shouldScriptDelete(f->data) && (obj != NULL)) {obj->release();}
}
SV GfxTexture_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,GfxTexture*))
CATE(TE,FAE("GfxTextureRef's get method","GfxTextureRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxTexturePtr");
EI(keyStr=="__new__")
RET CNF(GfxTexture_ptr_new);
EI(keyStr=="__call__")
RET CNF(GfxTexture_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GfxTexture_ptr_deref);
if(keyStr=="refset")RET CNF(GfxTexture_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxTexture_funcs;
obj.typeID=EXT->GfxTexture_typeID;
obj.refCount=1;
obj.data=f->data;
RET GfxTexture_get_member(ctx, &obj, key);
}
void GfxTexture_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,GfxTexture*))
CATE(TE,FAE("GfxTextureRef's set method","GfxTextureRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxTexture_funcs;
obj.typeID=EXT->GfxTexture_typeID;
obj.refCount=1;
obj.data=f->data;
GfxTexture_set_member(ctx, &obj, key, value);
}
SV GfxSubModelList_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GfxSubModelList;
NO obj=(NO)GfxSubModelList_new(ctx, args2);
obj->funcs=GfxSubModelList_ptr_funcs;
obj->typeID=EXT->GfxSubModelList_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GfxSubModelList_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxSubModelListRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,List<GfxModel::SubModel>*))
CATE(TE,"GfxSubModelListRef::deref expects GfxSubModelListRef as first argument."));
RET CV(*(List<GfxModel::SubModel> *)((NO)f)->data);
}
SV GfxSubModelList_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GfxSubModelList::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,List<GfxModel::SubModel>*))
CATE(TE,"GfxSubModelListRef::refset expects GfxSubModelListRef as first argument."));
*((List<GfxModel::SubModel> *)((NO)f)->data) = val_to_c<List<GfxModel::SubModel>>::f(ctx,a[1]);
RET CN;
}

void GfxSubModelList_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<GfxModel::SubModel>*))
CATE(TE,"GfxSubModelListRef::__del__ expects GfxSubModelListRef as first argument."));
SCRIPT_DELETE((List<GfxModel::SubModel> *)f->data);
}
SV GfxSubModelList_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,List<GfxModel::SubModel>*))
CATE(TE,FAE("GfxSubModelListRef's get method","GfxSubModelListRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxSubModelListPtr");
EI(keyStr=="__new__")
RET CNF(GfxSubModelList_ptr_new);
EI(keyStr=="__call__")
RET CNF(GfxSubModelList_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GfxSubModelList_ptr_deref);
if(keyStr=="refset")RET CNF(GfxSubModelList_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxSubModelList_funcs;
obj.typeID=EXT->GfxSubModelList_typeID;
obj.refCount=1;
obj.data=f->data;
RET GfxSubModelList_get_member(ctx, &obj, key);
}
void GfxSubModelList_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,List<GfxModel::SubModel>*))
CATE(TE,FAE("GfxSubModelListRef's set method","GfxSubModelListRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxSubModelList_funcs;
obj.typeID=EXT->GfxSubModelList_typeID;
obj.refCount=1;
obj.data=f->data;
GfxSubModelList_set_member(ctx, &obj, key, value);
}
SV GfxModel_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GfxModel;
NO obj=(NO)GfxModel_new(ctx, args2);
obj->funcs=GfxModel_ptr_funcs;
obj->typeID=EXT->GfxModel_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GfxModel_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxModelRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,GfxModel*))
CATE(TE,"GfxModelRef::deref expects GfxModelRef as first argument."));
CATE(TE,"GfxModel objects are not copyable."));
}
SV GfxModel_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GfxModel::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,GfxModel*))
CATE(TE,"GfxModelRef::refset expects GfxModelRef as first argument."));
CATE(TE,"GfxModel objects are not copyable."));
RET CN;
}

void GfxModel_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxModel*))
CATE(TE,"GfxModelRef::__del__ expects GfxModelRef as first argument."));
GfxModel*obj=(GfxModel*)f->data;
if(shouldScriptDelete(f->data) && (obj != NULL)) {obj->release();}
}
SV GfxModel_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,GfxModel*))
CATE(TE,FAE("GfxModelRef's get method","GfxModelRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxModelPtr");
EI(keyStr=="__new__")
RET CNF(GfxModel_ptr_new);
EI(keyStr=="__call__")
RET CNF(GfxModel_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GfxModel_ptr_deref);
if(keyStr=="refset")RET CNF(GfxModel_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxModel_funcs;
obj.typeID=EXT->GfxModel_typeID;
obj.refCount=1;
obj.data=f->data;
RET GfxModel_get_member(ctx, &obj, key);
}
void GfxModel_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,GfxModel*))
CATE(TE,FAE("GfxModelRef's set method","GfxModelRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxModel_funcs;
obj.typeID=EXT->GfxModel_typeID;
obj.refCount=1;
obj.data=f->data;
GfxModel_set_member(ctx, &obj, key, value);
}
SV GfxLODList_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GfxLODList;
NO obj=(NO)GfxLODList_new(ctx, args2);
obj->funcs=GfxLODList_ptr_funcs;
obj->typeID=EXT->GfxLODList_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GfxLODList_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxLODListRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,List<GfxLOD>*))
CATE(TE,"GfxLODListRef::deref expects GfxLODListRef as first argument."));
RET CV(*(List<GfxLOD> *)((NO)f)->data);
}
SV GfxLODList_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GfxLODList::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,List<GfxLOD>*))
CATE(TE,"GfxLODListRef::refset expects GfxLODListRef as first argument."));
*((List<GfxLOD> *)((NO)f)->data) = val_to_c<List<GfxLOD>>::f(ctx,a[1]);
RET CN;
}

void GfxLODList_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<GfxLOD>*))
CATE(TE,"GfxLODListRef::__del__ expects GfxLODListRef as first argument."));
SCRIPT_DELETE((List<GfxLOD> *)f->data);
}
SV GfxLODList_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,List<GfxLOD>*))
CATE(TE,FAE("GfxLODListRef's get method","GfxLODListRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxLODListPtr");
EI(keyStr=="__new__")
RET CNF(GfxLODList_ptr_new);
EI(keyStr=="__call__")
RET CNF(GfxLODList_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GfxLODList_ptr_deref);
if(keyStr=="refset")RET CNF(GfxLODList_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxLODList_funcs;
obj.typeID=EXT->GfxLODList_typeID;
obj.refCount=1;
obj.data=f->data;
RET GfxLODList_get_member(ctx, &obj, key);
}
void GfxLODList_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,List<GfxLOD>*))
CATE(TE,FAE("GfxLODListRef's set method","GfxLODListRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxLODList_funcs;
obj.typeID=EXT->GfxLODList_typeID;
obj.refCount=1;
obj.data=f->data;
GfxLODList_set_member(ctx, &obj, key, value);
}
SV EntityList_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->EntityList;
NO obj=(NO)EntityList_new(ctx, args2);
obj->funcs=EntityList_ptr_funcs;
obj->typeID=EXT->EntityList_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV EntityList_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"EntityListRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,List<Entity*>*))
CATE(TE,"EntityListRef::deref expects EntityListRef as first argument."));
RET CV(*(List<Entity*> *)((NO)f)->data);
}
SV EntityList_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"EntityList::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,List<Entity*>*))
CATE(TE,"EntityListRef::refset expects EntityListRef as first argument."));
*((List<Entity*> *)((NO)f)->data) = val_to_c<List<Entity*>>::f(ctx,a[1]);
RET CN;
}

void EntityList_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,List<Entity*>*))
CATE(TE,"EntityListRef::__del__ expects EntityListRef as first argument."));
SCRIPT_DELETE((List<Entity*> *)f->data);
}
SV EntityList_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,List<Entity*>*))
CATE(TE,FAE("EntityListRef's get method","EntityListRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("EntityListPtr");
EI(keyStr=="__new__")
RET CNF(EntityList_ptr_new);
EI(keyStr=="__call__")
RET CNF(EntityList_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(EntityList_ptr_deref);
if(keyStr=="refset")RET CNF(EntityList_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=EntityList_funcs;
obj.typeID=EXT->EntityList_typeID;
obj.refCount=1;
obj.data=f->data;
RET EntityList_get_member(ctx, &obj, key);
}
void EntityList_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,List<Entity*>*))
CATE(TE,FAE("EntityListRef's set method","EntityListRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=EntityList_funcs;
obj.typeID=EXT->EntityList_typeID;
obj.refCount=1;
obj.data=f->data;
EntityList_set_member(ctx, &obj, key, value);
}
SV GfxShaderCombination_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GfxShaderCombination;
NO obj=(NO)GfxShaderCombination_new(ctx, args2);
obj->funcs=GfxShaderCombination_ptr_funcs;
obj->typeID=EXT->GfxShaderCombination_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GfxShaderCombination_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxShaderCombinationRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,GfxShaderCombination*))
CATE(TE,"GfxShaderCombinationRef::deref expects GfxShaderCombinationRef as first argument."));
CATE(TE,"GfxShaderCombination objects are not copyable."));
}
SV GfxShaderCombination_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GfxShaderCombination::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,GfxShaderCombination*))
CATE(TE,"GfxShaderCombinationRef::refset expects GfxShaderCombinationRef as first argument."));
CATE(TE,"GfxShaderCombination objects are not copyable."));
RET CN;
}

void GfxShaderCombination_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxShaderCombination*))
CATE(TE,"GfxShaderCombinationRef::__del__ expects GfxShaderCombinationRef as first argument."));
SCRIPT_DELETE((GfxShaderCombination *)f->data);
}
SV GfxShaderCombination_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,GfxShaderCombination*))
CATE(TE,FAE("GfxShaderCombinationRef's get method","GfxShaderCombinationRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxShaderCombinationPtr");
EI(keyStr=="__new__")
RET CNF(GfxShaderCombination_ptr_new);
EI(keyStr=="__call__")
RET CNF(GfxShaderCombination_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GfxShaderCombination_ptr_deref);
if(keyStr=="refset")RET CNF(GfxShaderCombination_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxShaderCombination_funcs;
obj.typeID=EXT->GfxShaderCombination_typeID;
obj.refCount=1;
obj.data=f->data;
RET GfxShaderCombination_get_member(ctx, &obj, key);
}
void GfxShaderCombination_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,GfxShaderCombination*))
CATE(TE,FAE("GfxShaderCombinationRef's set method","GfxShaderCombinationRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxShaderCombination_funcs;
obj.typeID=EXT->GfxShaderCombination_typeID;
obj.refCount=1;
obj.data=f->data;
GfxShaderCombination_set_member(ctx, &obj, key, value);
}
SV Matrix3x3_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->Matrix3x3;
NO obj=(NO)Matrix3x3_new(ctx, args2);
obj->funcs=Matrix3x3_ptr_funcs;
obj->typeID=EXT->Matrix3x3_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV Matrix3x3_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"Matrix3x3Ref::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,Matrix3x3*))
CATE(TE,"Matrix3x3Ref::deref expects Matrix3x3Ref as first argument."));
RET CV(*(Matrix3x3 *)((NO)f)->data);
}
SV Matrix3x3_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"Matrix3x3::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,Matrix3x3*))
CATE(TE,"Matrix3x3Ref::refset expects Matrix3x3Ref as first argument."));
*((Matrix3x3 *)((NO)f)->data) = val_to_c<Matrix3x3>::f(ctx,a[1]);
RET CN;
}

void Matrix3x3_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,Matrix3x3*))
CATE(TE,"Matrix3x3Ref::__del__ expects Matrix3x3Ref as first argument."));
SCRIPT_DELETE((Matrix3x3 *)f->data);
}
SV Matrix3x3_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,Matrix3x3*))
CATE(TE,FAE("Matrix3x3Ref's get method","Matrix3x3Ref")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("Matrix3x3Ptr");
EI(keyStr=="__new__")
RET CNF(Matrix3x3_ptr_new);
EI(keyStr=="__call__")
RET CNF(Matrix3x3_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(Matrix3x3_ptr_deref);
if(keyStr=="refset")RET CNF(Matrix3x3_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Matrix3x3_funcs;
obj.typeID=EXT->Matrix3x3_typeID;
obj.refCount=1;
obj.data=f->data;
RET Matrix3x3_get_member(ctx, &obj, key);
}
void Matrix3x3_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,Matrix3x3*))
CATE(TE,FAE("Matrix3x3Ref's set method","Matrix3x3Ref")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=Matrix3x3_funcs;
obj.typeID=EXT->Matrix3x3_typeID;
obj.refCount=1;
obj.data=f->data;
Matrix3x3_set_member(ctx, &obj, key, value);
}
SV GfxDebugDrawer_ptr_new(CTX ctx,const List<SV>&a)
{
List<SV> args2 = a.copy();
args2[0]=EXT->GfxDebugDrawer;
NO obj=(NO)GfxDebugDrawer_new(ctx, args2);
obj->funcs=GfxDebugDrawer_ptr_funcs;
obj->typeID=EXT->GfxDebugDrawer_ptr_typeID;
setAllocInfo(obj->data, AllocInfo(true, false));
RET(SV)obj;
}
SV GfxDebugDrawer_ptr_deref(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=1)
CATE(VE,"GfxDebugDrawerRef::deref" EAOE));
SV f=a[0];
if(!TS((SV)f,GfxDebugDrawer*))
CATE(TE,"GfxDebugDrawerRef::deref expects GfxDebugDrawerRef as first argument."));
CATE(TE,"GfxDebugDrawer objects are not copyable."));
}
SV GfxDebugDrawer_ptr_set(CTX ctx,const List<SV>&a)
{
if(a.getCount()!=2)
CATE(VE,"GfxDebugDrawer::refset expects two arguments."));
SV f=a[0];
if(!TS((SV)f,GfxDebugDrawer*))
CATE(TE,"GfxDebugDrawerRef::refset expects GfxDebugDrawerRef as first argument."));
CATE(TE,"GfxDebugDrawer objects are not copyable."));
RET CN;
}

void GfxDebugDrawer_ptr_destroy(CTX ctx,NO f)
{
if(!TS((SV)f,GfxDebugDrawer*))
CATE(TE,"GfxDebugDrawerRef::__del__ expects GfxDebugDrawerRef as first argument."));
SCRIPT_DELETE((GfxDebugDrawer *)f->data);
}
SV GfxDebugDrawer_ptr_get_member(CTX ctx,NO f,SV key)
{
if(!TS((SV)f,GfxDebugDrawer*))
CATE(TE,FAE("GfxDebugDrawerRef's get method","GfxDebugDrawerRef")));
if (key->type==STG::ValueType::StringType)
{
String keyStr=((STG::StringValue *)key)->value;
if(f->data==NULL)
{
if(keyStr=="__typeID__")
RET STG::createInt(f->typeID);
EI(keyStr=="__name__")
RET STG::createString("GfxDebugDrawerPtr");
EI(keyStr=="__new__")
RET CNF(GfxDebugDrawer_ptr_new);
EI(keyStr=="__call__")
RET CNF(GfxDebugDrawer_ptr_new);
else
CATE(KE,"Unknown member."));
} else
{
if(keyStr=="deref")RET CNF(GfxDebugDrawer_ptr_deref);
if(keyStr=="refset")RET CNF(GfxDebugDrawer_ptr_set);
}
}
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxDebugDrawer_funcs;
obj.typeID=EXT->GfxDebugDrawer_typeID;
obj.refCount=1;
obj.data=f->data;
RET GfxDebugDrawer_get_member(ctx, &obj, key);
}
void GfxDebugDrawer_ptr_set_member(CTX ctx,NO f,SV key,SV value)
{
if(!TS((SV)f,GfxDebugDrawer*))
CATE(TE,FAE("GfxDebugDrawerRef's set method","GfxDebugDrawerRef")));
STG::NativeObject obj;
obj.head.type=STG::ValueType::NativeObject;
obj.funcs=GfxDebugDrawer_funcs;
obj.typeID=EXT->GfxDebugDrawer_typeID;
obj.refCount=1;
obj.data=f->data;
GfxDebugDrawer_set_member(ctx, &obj, key, value);
}
void *initBindings(scripting::Engine *engine, void *data)
{
    BindingsExt *ext = NEW(BindingsExt);

    int64_t typeID;
    
    typeID = engine->createNewTypeID();
    ext->GhostObject_typeID = typeID;
    ext->GhostObject = scripting::createNativeObject(GhostObject_funcs, NULL, typeID);
    engine->getGlobalVars().set("GhostObject", ext->GhostObject);
    
    typeID = engine->createNewTypeID();
    ext->GhostObject_ptr_typeID = typeID;
    ext->GhostObject_ptr = scripting::createNativeObject(GhostObject_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GhostObjectRef", ext->GhostObject_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Filesystem_typeID = typeID;
    ext->Filesystem = scripting::createNativeObject(Filesystem_funcs, NULL, typeID);
    engine->getGlobalVars().set("Filesystem", ext->Filesystem);
    
    typeID = engine->createNewTypeID();
    ext->Filesystem_ptr_typeID = typeID;
    ext->Filesystem_ptr = scripting::createNativeObject(Filesystem_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("FilesystemRef", ext->Filesystem_ptr);
    
    typeID = engine->createNewTypeID();
    ext->StrStrMap_typeID = typeID;
    ext->StrStrMap = scripting::createNativeObject(StrStrMap_funcs, NULL, typeID);
    engine->getGlobalVars().set("StrStrMap", ext->StrStrMap);
    
    typeID = engine->createNewTypeID();
    ext->StrStrMap_ptr_typeID = typeID;
    ext->StrStrMap_ptr = scripting::createNativeObject(StrStrMap_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("StrStrMapRef", ext->StrStrMap_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GfxApi_typeID = typeID;
    ext->GfxApi = scripting::createNativeObject(GfxApi_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxApi", ext->GfxApi);
    
    typeID = engine->createNewTypeID();
    ext->GfxApi_ptr_typeID = typeID;
    ext->GfxApi_ptr = scripting::createNativeObject(GfxApi_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxApiRef", ext->GfxApi_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GfxCompiledShader_typeID = typeID;
    ext->GfxCompiledShader = scripting::createNativeObject(GfxCompiledShader_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxCompiledShader", ext->GfxCompiledShader);
    
    typeID = engine->createNewTypeID();
    ext->GfxCompiledShader_ptr_typeID = typeID;
    ext->GfxCompiledShader_ptr = scripting::createNativeObject(GfxCompiledShader_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxCompiledShaderRef", ext->GfxCompiledShader_ptr);
    
    typeID = engine->createNewTypeID();
    ext->ScrollBar_typeID = typeID;
    ext->ScrollBar = scripting::createNativeObject(ScrollBar_funcs, NULL, typeID);
    engine->getGlobalVars().set("ScrollBar", ext->ScrollBar);
    
    typeID = engine->createNewTypeID();
    ext->ScrollBar_ptr_typeID = typeID;
    ext->ScrollBar_ptr = scripting::createNativeObject(ScrollBar_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("ScrollBarRef", ext->ScrollBar_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GhostObjList_typeID = typeID;
    ext->GhostObjList = scripting::createNativeObject(GhostObjList_funcs, NULL, typeID);
    engine->getGlobalVars().set("GhostObjList", ext->GhostObjList);
    
    typeID = engine->createNewTypeID();
    ext->GhostObjList_ptr_typeID = typeID;
    ext->GhostObjList_ptr = scripting::createNativeObject(GhostObjList_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GhostObjListRef", ext->GhostObjList_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GPUTimer_typeID = typeID;
    ext->GPUTimer = scripting::createNativeObject(GPUTimer_funcs, NULL, typeID);
    engine->getGlobalVars().set("GPUTimer", ext->GPUTimer);
    
    typeID = engine->createNewTypeID();
    ext->GPUTimer_ptr_typeID = typeID;
    ext->GPUTimer_ptr = scripting::createNativeObject(GPUTimer_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GPUTimerRef", ext->GPUTimer_ptr);
    
    typeID = engine->createNewTypeID();
    ext->RigidBody_typeID = typeID;
    ext->RigidBody = scripting::createNativeObject(RigidBody_funcs, NULL, typeID);
    engine->getGlobalVars().set("RigidBody", ext->RigidBody);
    
    typeID = engine->createNewTypeID();
    ext->RigidBody_ptr_typeID = typeID;
    ext->RigidBody_ptr = scripting::createNativeObject(RigidBody_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("RigidBodyRef", ext->RigidBody_ptr);
    
    typeID = engine->createNewTypeID();
    ext->UInt2_typeID = typeID;
    ext->UInt2 = scripting::createNativeObject(UInt2_funcs, NULL, typeID);
    engine->getGlobalVars().set("UInt2", ext->UInt2);
    
    typeID = engine->createNewTypeID();
    ext->UInt2_ptr_typeID = typeID;
    ext->UInt2_ptr = scripting::createNativeObject(UInt2_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("UInt2Ref", ext->UInt2_ptr);
    
    typeID = engine->createNewTypeID();
    ext->LightList_typeID = typeID;
    ext->LightList = scripting::createNativeObject(LightList_funcs, NULL, typeID);
    engine->getGlobalVars().set("LightList", ext->LightList);
    
    typeID = engine->createNewTypeID();
    ext->LightList_ptr_typeID = typeID;
    ext->LightList_ptr = scripting::createNativeObject(LightList_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("LightListRef", ext->LightList_ptr);
    
    typeID = engine->createNewTypeID();
    ext->ResourceManager_typeID = typeID;
    ext->ResourceManager = scripting::createNativeObject(ResourceManager_funcs, NULL, typeID);
    engine->getGlobalVars().set("ResourceManager", ext->ResourceManager);
    
    typeID = engine->createNewTypeID();
    ext->ResourceManager_ptr_typeID = typeID;
    ext->ResourceManager_ptr = scripting::createNativeObject(ResourceManager_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("ResourceManagerRef", ext->ResourceManager_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Entity_typeID = typeID;
    ext->Entity = scripting::createNativeObject(Entity_funcs, NULL, typeID);
    engine->getGlobalVars().set("Entity", ext->Entity);
    
    typeID = engine->createNewTypeID();
    ext->Entity_ptr_typeID = typeID;
    ext->Entity_ptr = scripting::createNativeObject(Entity_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("EntityRef", ext->Entity_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GfxRenderer_typeID = typeID;
    ext->GfxRenderer = scripting::createNativeObject(GfxRenderer_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxRenderer", ext->GfxRenderer);
    
    typeID = engine->createNewTypeID();
    ext->GfxRenderer_ptr_typeID = typeID;
    ext->GfxRenderer_ptr = scripting::createNativeObject(GfxRenderer_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxRendererRef", ext->GfxRenderer_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Float2_typeID = typeID;
    ext->Float2 = scripting::createNativeObject(Float2_funcs, NULL, typeID);
    engine->getGlobalVars().set("Float2", ext->Float2);
    
    typeID = engine->createNewTypeID();
    ext->Float2_ptr_typeID = typeID;
    ext->Float2_ptr = scripting::createNativeObject(Float2_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("Float2Ref", ext->Float2_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GfxFramebuffer_typeID = typeID;
    ext->GfxFramebuffer = scripting::createNativeObject(GfxFramebuffer_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxFramebuffer", ext->GfxFramebuffer);
    
    typeID = engine->createNewTypeID();
    ext->GfxFramebuffer_ptr_typeID = typeID;
    ext->GfxFramebuffer_ptr = scripting::createNativeObject(GfxFramebuffer_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxFramebufferRef", ext->GfxFramebuffer_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Font_typeID = typeID;
    ext->Font = scripting::createNativeObject(Font_funcs, NULL, typeID);
    engine->getGlobalVars().set("Font", ext->Font);
    
    typeID = engine->createNewTypeID();
    ext->Font_ptr_typeID = typeID;
    ext->Font_ptr = scripting::createNativeObject(Font_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("FontRef", ext->Font_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Event_typeID = typeID;
    ext->Event = scripting::createNativeObject(Event_funcs, NULL, typeID);
    engine->getGlobalVars().set("Event", ext->Event);
    
    typeID = engine->createNewTypeID();
    ext->Event_ptr_typeID = typeID;
    ext->Event_ptr = scripting::createNativeObject(Event_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("EventRef", ext->Event_ptr);
    
    typeID = engine->createNewTypeID();
    ext->PhysicsWorld_typeID = typeID;
    ext->PhysicsWorld = scripting::createNativeObject(PhysicsWorld_funcs, NULL, typeID);
    engine->getGlobalVars().set("PhysicsWorld", ext->PhysicsWorld);
    
    typeID = engine->createNewTypeID();
    ext->PhysicsWorld_ptr_typeID = typeID;
    ext->PhysicsWorld_ptr = scripting::createNativeObject(PhysicsWorld_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("PhysicsWorldRef", ext->PhysicsWorld_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Stats_typeID = typeID;
    ext->Stats = scripting::createNativeObject(Stats_funcs, NULL, typeID);
    engine->getGlobalVars().set("Stats", ext->Stats);
    
    typeID = engine->createNewTypeID();
    ext->Stats_ptr_typeID = typeID;
    ext->Stats_ptr = scripting::createNativeObject(Stats_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("StatsRef", ext->Stats_ptr);
    
    typeID = engine->createNewTypeID();
    ext->AudioSource_typeID = typeID;
    ext->AudioSource = scripting::createNativeObject(AudioSource_funcs, NULL, typeID);
    engine->getGlobalVars().set("AudioSource", ext->AudioSource);
    
    typeID = engine->createNewTypeID();
    ext->AudioSource_ptr_typeID = typeID;
    ext->AudioSource_ptr = scripting::createNativeObject(AudioSource_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("AudioSourceRef", ext->AudioSource_ptr);
    
    typeID = engine->createNewTypeID();
    ext->RayCastResultList_typeID = typeID;
    ext->RayCastResultList = scripting::createNativeObject(RayCastResultList_funcs, NULL, typeID);
    engine->getGlobalVars().set("RayCastResultList", ext->RayCastResultList);
    
    typeID = engine->createNewTypeID();
    ext->RayCastResultList_ptr_typeID = typeID;
    ext->RayCastResultList_ptr = scripting::createNativeObject(RayCastResultList_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("RayCastResultListRef", ext->RayCastResultList_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Platform_typeID = typeID;
    ext->Platform = scripting::createNativeObject(Platform_funcs, NULL, typeID);
    engine->getGlobalVars().set("Platform", ext->Platform);
    
    typeID = engine->createNewTypeID();
    ext->Platform_ptr_typeID = typeID;
    ext->Platform_ptr = scripting::createNativeObject(Platform_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("PlatformRef", ext->Platform_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Camera_typeID = typeID;
    ext->Camera = scripting::createNativeObject(Camera_funcs, NULL, typeID);
    engine->getGlobalVars().set("Camera", ext->Camera);
    
    typeID = engine->createNewTypeID();
    ext->Camera_ptr_typeID = typeID;
    ext->Camera_ptr = scripting::createNativeObject(Camera_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("CameraRef", ext->Camera_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GfxMesh_typeID = typeID;
    ext->GfxMesh = scripting::createNativeObject(GfxMesh_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxMesh", ext->GfxMesh);
    
    typeID = engine->createNewTypeID();
    ext->GfxMesh_ptr_typeID = typeID;
    ext->GfxMesh_ptr = scripting::createNativeObject(GfxMesh_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxMeshRef", ext->GfxMesh_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Resource_typeID = typeID;
    ext->Resource = scripting::createNativeObject(Resource_funcs, NULL, typeID);
    engine->getGlobalVars().set("Resource", ext->Resource);
    
    typeID = engine->createNewTypeID();
    ext->Resource_ptr_typeID = typeID;
    ext->Resource_ptr = scripting::createNativeObject(Resource_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("ResourceRef", ext->Resource_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GfxShader_typeID = typeID;
    ext->GfxShader = scripting::createNativeObject(GfxShader_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxShader", ext->GfxShader);
    
    typeID = engine->createNewTypeID();
    ext->GfxShader_ptr_typeID = typeID;
    ext->GfxShader_ptr = scripting::createNativeObject(GfxShader_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxShaderRef", ext->GfxShader_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Light_typeID = typeID;
    ext->Light = scripting::createNativeObject(Light_funcs, NULL, typeID);
    engine->getGlobalVars().set("Light", ext->Light);
    
    typeID = engine->createNewTypeID();
    ext->Light_ptr_typeID = typeID;
    ext->Light_ptr = scripting::createNativeObject(Light_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("LightRef", ext->Light_ptr);
    
    typeID = engine->createNewTypeID();
    ext->TextureSampler_typeID = typeID;
    ext->TextureSampler = scripting::createNativeObject(TextureSampler_funcs, NULL, typeID);
    engine->getGlobalVars().set("TextureSampler", ext->TextureSampler);
    
    typeID = engine->createNewTypeID();
    ext->TextureSampler_ptr_typeID = typeID;
    ext->TextureSampler_ptr = scripting::createNativeObject(TextureSampler_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("TextureSamplerRef", ext->TextureSampler_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Scene_typeID = typeID;
    ext->Scene = scripting::createNativeObject(Scene_funcs, NULL, typeID);
    engine->getGlobalVars().set("Scene", ext->Scene);
    
    typeID = engine->createNewTypeID();
    ext->Scene_ptr_typeID = typeID;
    ext->Scene_ptr = scripting::createNativeObject(Scene_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("SceneRef", ext->Scene_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Int3_typeID = typeID;
    ext->Int3 = scripting::createNativeObject(Int3_funcs, NULL, typeID);
    engine->getGlobalVars().set("Int3", ext->Int3);
    
    typeID = engine->createNewTypeID();
    ext->Int3_ptr_typeID = typeID;
    ext->Int3_ptr = scripting::createNativeObject(Int3_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("Int3Ref", ext->Int3_ptr);
    
    typeID = engine->createNewTypeID();
    ext->ResizableData_typeID = typeID;
    ext->ResizableData = scripting::createNativeObject(ResizableData_funcs, NULL, typeID);
    engine->getGlobalVars().set("ResizableData", ext->ResizableData);
    
    typeID = engine->createNewTypeID();
    ext->ResizableData_ptr_typeID = typeID;
    ext->ResizableData_ptr = scripting::createNativeObject(ResizableData_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("ResizableDataRef", ext->ResizableData_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Int4_typeID = typeID;
    ext->Int4 = scripting::createNativeObject(Int4_funcs, NULL, typeID);
    engine->getGlobalVars().set("Int4", ext->Int4);
    
    typeID = engine->createNewTypeID();
    ext->Int4_ptr_typeID = typeID;
    ext->Int4_ptr = scripting::createNativeObject(Int4_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("Int4Ref", ext->Int4_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Float3_typeID = typeID;
    ext->Float3 = scripting::createNativeObject(Float3_funcs, NULL, typeID);
    engine->getGlobalVars().set("Float3", ext->Float3);
    
    typeID = engine->createNewTypeID();
    ext->Float3_ptr_typeID = typeID;
    ext->Float3_ptr = scripting::createNativeObject(Float3_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("Float3Ref", ext->Float3_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GfxBuffer_typeID = typeID;
    ext->GfxBuffer = scripting::createNativeObject(GfxBuffer_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxBuffer", ext->GfxBuffer);
    
    typeID = engine->createNewTypeID();
    ext->GfxBuffer_ptr_typeID = typeID;
    ext->GfxBuffer_ptr = scripting::createNativeObject(GfxBuffer_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxBufferRef", ext->GfxBuffer_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Transform_typeID = typeID;
    ext->Transform = scripting::createNativeObject(Transform_funcs, NULL, typeID);
    engine->getGlobalVars().set("Transform", ext->Transform);
    
    typeID = engine->createNewTypeID();
    ext->Transform_ptr_typeID = typeID;
    ext->Transform_ptr = scripting::createNativeObject(Transform_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("TransformRef", ext->Transform_ptr);
    
    typeID = engine->createNewTypeID();
    ext->AudioSourceList_typeID = typeID;
    ext->AudioSourceList = scripting::createNativeObject(AudioSourceList_funcs, NULL, typeID);
    engine->getGlobalVars().set("AudioSourceList", ext->AudioSourceList);
    
    typeID = engine->createNewTypeID();
    ext->AudioSourceList_ptr_typeID = typeID;
    ext->AudioSourceList_ptr = scripting::createNativeObject(AudioSourceList_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("AudioSourceListRef", ext->AudioSourceList_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GfxMaterial_typeID = typeID;
    ext->GfxMaterial = scripting::createNativeObject(GfxMaterial_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxMaterial", ext->GfxMaterial);
    
    typeID = engine->createNewTypeID();
    ext->GfxMaterial_ptr_typeID = typeID;
    ext->GfxMaterial_ptr = scripting::createNativeObject(GfxMaterial_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxMaterialRef", ext->GfxMaterial_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Quaternion_typeID = typeID;
    ext->Quaternion = scripting::createNativeObject(Quaternion_funcs, NULL, typeID);
    engine->getGlobalVars().set("Quaternion", ext->Quaternion);
    
    typeID = engine->createNewTypeID();
    ext->Quaternion_ptr_typeID = typeID;
    ext->Quaternion_ptr = scripting::createNativeObject(Quaternion_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("QuaternionRef", ext->Quaternion_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GfxMeshAttrib_typeID = typeID;
    ext->GfxMeshAttrib = scripting::createNativeObject(GfxMeshAttrib_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxMeshAttrib", ext->GfxMeshAttrib);
    
    typeID = engine->createNewTypeID();
    ext->GfxMeshAttrib_ptr_typeID = typeID;
    ext->GfxMeshAttrib_ptr = scripting::createNativeObject(GfxMeshAttrib_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxMeshAttribRef", ext->GfxMeshAttrib_ptr);
    
    typeID = engine->createNewTypeID();
    ext->RenderComponent_typeID = typeID;
    ext->RenderComponent = scripting::createNativeObject(RenderComponent_funcs, NULL, typeID);
    engine->getGlobalVars().set("RenderComponent", ext->RenderComponent);
    
    typeID = engine->createNewTypeID();
    ext->RenderComponent_ptr_typeID = typeID;
    ext->RenderComponent_ptr = scripting::createNativeObject(RenderComponent_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("RenderComponentRef", ext->RenderComponent_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Int2_typeID = typeID;
    ext->Int2 = scripting::createNativeObject(Int2_funcs, NULL, typeID);
    engine->getGlobalVars().set("Int2", ext->Int2);
    
    typeID = engine->createNewTypeID();
    ext->Int2_ptr_typeID = typeID;
    ext->Int2_ptr = scripting::createNativeObject(Int2_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("Int2Ref", ext->Int2_ptr);
    
    typeID = engine->createNewTypeID();
    ext->AudioWorld_typeID = typeID;
    ext->AudioWorld = scripting::createNativeObject(AudioWorld_funcs, NULL, typeID);
    engine->getGlobalVars().set("AudioWorld", ext->AudioWorld);
    
    typeID = engine->createNewTypeID();
    ext->AudioWorld_ptr_typeID = typeID;
    ext->AudioWorld_ptr = scripting::createNativeObject(AudioWorld_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("AudioWorldRef", ext->AudioWorld_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GuiPlacer_typeID = typeID;
    ext->GuiPlacer = scripting::createNativeObject(GuiPlacer_funcs, NULL, typeID);
    engine->getGlobalVars().set("GuiPlacer", ext->GuiPlacer);
    
    typeID = engine->createNewTypeID();
    ext->GuiPlacer_ptr_typeID = typeID;
    ext->GuiPlacer_ptr = scripting::createNativeObject(GuiPlacer_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GuiPlacerRef", ext->GuiPlacer_ptr);
    
    typeID = engine->createNewTypeID();
    ext->ImGui_typeID = typeID;
    ext->ImGui = scripting::createNativeObject(ImGui_funcs, NULL, typeID);
    engine->getGlobalVars().set("ImGui", ext->ImGui);
    
    typeID = engine->createNewTypeID();
    ext->ImGui_ptr_typeID = typeID;
    ext->ImGui_ptr = scripting::createNativeObject(ImGui_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("ImGuiRef", ext->ImGui_ptr);
    
    typeID = engine->createNewTypeID();
    ext->StringList_typeID = typeID;
    ext->StringList = scripting::createNativeObject(StringList_funcs, NULL, typeID);
    engine->getGlobalVars().set("StringList", ext->StringList);
    
    typeID = engine->createNewTypeID();
    ext->StringList_ptr_typeID = typeID;
    ext->StringList_ptr = scripting::createNativeObject(StringList_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("StringListRef", ext->StringList_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Application_typeID = typeID;
    ext->Application = scripting::createNativeObject(Application_funcs, NULL, typeID);
    engine->getGlobalVars().set("Application", ext->Application);
    
    typeID = engine->createNewTypeID();
    ext->Application_ptr_typeID = typeID;
    ext->Application_ptr = scripting::createNativeObject(Application_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("ApplicationRef", ext->Application_ptr);
    
    typeID = engine->createNewTypeID();
    ext->LightPointData_typeID = typeID;
    ext->LightPointData = scripting::createNativeObject(LightPointData_funcs, NULL, typeID);
    engine->getGlobalVars().set("LightPointData", ext->LightPointData);
    
    typeID = engine->createNewTypeID();
    ext->LightPointData_ptr_typeID = typeID;
    ext->LightPointData_ptr = scripting::createNativeObject(LightPointData_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("LightPointDataRef", ext->LightPointData_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Float4_typeID = typeID;
    ext->Float4 = scripting::createNativeObject(Float4_funcs, NULL, typeID);
    engine->getGlobalVars().set("Float4", ext->Float4);
    
    typeID = engine->createNewTypeID();
    ext->Float4_ptr_typeID = typeID;
    ext->Float4_ptr = scripting::createNativeObject(Float4_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("Float4Ref", ext->Float4_ptr);
    
    typeID = engine->createNewTypeID();
    ext->FloatList_typeID = typeID;
    ext->FloatList = scripting::createNativeObject(FloatList_funcs, NULL, typeID);
    engine->getGlobalVars().set("FloatList", ext->FloatList);
    
    typeID = engine->createNewTypeID();
    ext->FloatList_ptr_typeID = typeID;
    ext->FloatList_ptr = scripting::createNativeObject(FloatList_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("FloatListRef", ext->FloatList_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Container_typeID = typeID;
    ext->Container = scripting::createNativeObject(Container_funcs, NULL, typeID);
    engine->getGlobalVars().set("Container", ext->Container);
    
    typeID = engine->createNewTypeID();
    ext->Container_ptr_typeID = typeID;
    ext->Container_ptr = scripting::createNativeObject(Container_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("ContainerRef", ext->Container_ptr);
    
    typeID = engine->createNewTypeID();
    ext->LightDirectionalData_typeID = typeID;
    ext->LightDirectionalData = scripting::createNativeObject(LightDirectionalData_funcs, NULL, typeID);
    engine->getGlobalVars().set("LightDirectionalData", ext->LightDirectionalData);
    
    typeID = engine->createNewTypeID();
    ext->LightDirectionalData_ptr_typeID = typeID;
    ext->LightDirectionalData_ptr = scripting::createNativeObject(LightDirectionalData_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("LightDirectionalDataRef", ext->LightDirectionalData_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Matrix4x4_typeID = typeID;
    ext->Matrix4x4 = scripting::createNativeObject(Matrix4x4_funcs, NULL, typeID);
    engine->getGlobalVars().set("Matrix4x4", ext->Matrix4x4);
    
    typeID = engine->createNewTypeID();
    ext->Matrix4x4_ptr_typeID = typeID;
    ext->Matrix4x4_ptr = scripting::createNativeObject(Matrix4x4_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("Matrix4x4Ref", ext->Matrix4x4_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Map_typeID = typeID;
    ext->Map = scripting::createNativeObject(Map_funcs, NULL, typeID);
    engine->getGlobalVars().set("Map", ext->Map);
    
    typeID = engine->createNewTypeID();
    ext->Map_ptr_typeID = typeID;
    ext->Map_ptr = scripting::createNativeObject(Map_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("MapRef", ext->Map_ptr);
    
    typeID = engine->createNewTypeID();
    ext->UInt3_typeID = typeID;
    ext->UInt3 = scripting::createNativeObject(UInt3_funcs, NULL, typeID);
    engine->getGlobalVars().set("UInt3", ext->UInt3);
    
    typeID = engine->createNewTypeID();
    ext->UInt3_ptr_typeID = typeID;
    ext->UInt3_ptr = scripting::createNativeObject(UInt3_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("UInt3Ref", ext->UInt3_ptr);
    
    typeID = engine->createNewTypeID();
    ext->LightSpotData_typeID = typeID;
    ext->LightSpotData = scripting::createNativeObject(LightSpotData_funcs, NULL, typeID);
    engine->getGlobalVars().set("LightSpotData", ext->LightSpotData);
    
    typeID = engine->createNewTypeID();
    ext->LightSpotData_ptr_typeID = typeID;
    ext->LightSpotData_ptr = scripting::createNativeObject(LightSpotData_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("LightSpotDataRef", ext->LightSpotData_ptr);
    
    typeID = engine->createNewTypeID();
    ext->PhysicsShape_typeID = typeID;
    ext->PhysicsShape = scripting::createNativeObject(PhysicsShape_funcs, NULL, typeID);
    engine->getGlobalVars().set("PhysicsShape", ext->PhysicsShape);
    
    typeID = engine->createNewTypeID();
    ext->PhysicsShape_ptr_typeID = typeID;
    ext->PhysicsShape_ptr = scripting::createNativeObject(PhysicsShape_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("PhysicsShapeRef", ext->PhysicsShape_ptr);
    
    typeID = engine->createNewTypeID();
    ext->AudioDevice_typeID = typeID;
    ext->AudioDevice = scripting::createNativeObject(AudioDevice_funcs, NULL, typeID);
    engine->getGlobalVars().set("AudioDevice", ext->AudioDevice);
    
    typeID = engine->createNewTypeID();
    ext->AudioDevice_ptr_typeID = typeID;
    ext->AudioDevice_ptr = scripting::createNativeObject(AudioDevice_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("AudioDeviceRef", ext->AudioDevice_ptr);
    
    typeID = engine->createNewTypeID();
    ext->RigidBodyList_typeID = typeID;
    ext->RigidBodyList = scripting::createNativeObject(RigidBodyList_funcs, NULL, typeID);
    engine->getGlobalVars().set("RigidBodyList", ext->RigidBodyList);
    
    typeID = engine->createNewTypeID();
    ext->RigidBodyList_ptr_typeID = typeID;
    ext->RigidBodyList_ptr = scripting::createNativeObject(RigidBodyList_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("RigidBodyListRef", ext->RigidBodyList_ptr);
    
    typeID = engine->createNewTypeID();
    ext->UInt4_typeID = typeID;
    ext->UInt4 = scripting::createNativeObject(UInt4_funcs, NULL, typeID);
    engine->getGlobalVars().set("UInt4", ext->UInt4);
    
    typeID = engine->createNewTypeID();
    ext->UInt4_ptr_typeID = typeID;
    ext->UInt4_ptr = scripting::createNativeObject(UInt4_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("UInt4Ref", ext->UInt4_ptr);
    
    typeID = engine->createNewTypeID();
    ext->RayCastResult_typeID = typeID;
    ext->RayCastResult = scripting::createNativeObject(RayCastResult_funcs, NULL, typeID);
    engine->getGlobalVars().set("RayCastResult", ext->RayCastResult);
    
    typeID = engine->createNewTypeID();
    ext->RayCastResult_ptr_typeID = typeID;
    ext->RayCastResult_ptr = scripting::createNativeObject(RayCastResult_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("RayCastResultRef", ext->RayCastResult_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GfxLOD_typeID = typeID;
    ext->GfxLOD = scripting::createNativeObject(GfxLOD_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxLOD", ext->GfxLOD);
    
    typeID = engine->createNewTypeID();
    ext->GfxLOD_ptr_typeID = typeID;
    ext->GfxLOD_ptr = scripting::createNativeObject(GfxLOD_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxLODRef", ext->GfxLOD_ptr);
    
    typeID = engine->createNewTypeID();
    ext->File_typeID = typeID;
    ext->File = scripting::createNativeObject(File_funcs, NULL, typeID);
    engine->getGlobalVars().set("File", ext->File);
    
    typeID = engine->createNewTypeID();
    ext->File_ptr_typeID = typeID;
    ext->File_ptr = scripting::createNativeObject(File_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("FileRef", ext->File_ptr);
    
    typeID = engine->createNewTypeID();
    ext->AABB_typeID = typeID;
    ext->AABB = scripting::createNativeObject(AABB_funcs, NULL, typeID);
    engine->getGlobalVars().set("AABB", ext->AABB);
    
    typeID = engine->createNewTypeID();
    ext->AABB_ptr_typeID = typeID;
    ext->AABB_ptr = scripting::createNativeObject(AABB_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("AABBRef", ext->AABB_ptr);
    
    typeID = engine->createNewTypeID();
    ext->RigidBodyConstructionInfo_typeID = typeID;
    ext->RigidBodyConstructionInfo = scripting::createNativeObject(RigidBodyConstructionInfo_funcs, NULL, typeID);
    engine->getGlobalVars().set("RigidBodyConstructionInfo", ext->RigidBodyConstructionInfo);
    
    typeID = engine->createNewTypeID();
    ext->RigidBodyConstructionInfo_ptr_typeID = typeID;
    ext->RigidBodyConstructionInfo_ptr = scripting::createNativeObject(RigidBodyConstructionInfo_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("RigidBodyConstructionInfoRef", ext->RigidBodyConstructionInfo_ptr);
    
    typeID = engine->createNewTypeID();
    ext->List_typeID = typeID;
    ext->List = scripting::createNativeObject(List_funcs, NULL, typeID);
    engine->getGlobalVars().set("List", ext->List);
    
    typeID = engine->createNewTypeID();
    ext->List_ptr_typeID = typeID;
    ext->List_ptr = scripting::createNativeObject(List_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("ListRef", ext->List_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Audio_typeID = typeID;
    ext->Audio = scripting::createNativeObject(Audio_funcs, NULL, typeID);
    engine->getGlobalVars().set("Audio", ext->Audio);
    
    typeID = engine->createNewTypeID();
    ext->Audio_ptr_typeID = typeID;
    ext->Audio_ptr = scripting::createNativeObject(Audio_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("AudioRef", ext->Audio_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GfxTexture_typeID = typeID;
    ext->GfxTexture = scripting::createNativeObject(GfxTexture_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxTexture", ext->GfxTexture);
    
    typeID = engine->createNewTypeID();
    ext->GfxTexture_ptr_typeID = typeID;
    ext->GfxTexture_ptr = scripting::createNativeObject(GfxTexture_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxTextureRef", ext->GfxTexture_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GfxSubModelList_typeID = typeID;
    ext->GfxSubModelList = scripting::createNativeObject(GfxSubModelList_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxSubModelList", ext->GfxSubModelList);
    
    typeID = engine->createNewTypeID();
    ext->GfxSubModelList_ptr_typeID = typeID;
    ext->GfxSubModelList_ptr = scripting::createNativeObject(GfxSubModelList_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxSubModelListRef", ext->GfxSubModelList_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GfxModel_typeID = typeID;
    ext->GfxModel = scripting::createNativeObject(GfxModel_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxModel", ext->GfxModel);
    
    typeID = engine->createNewTypeID();
    ext->GfxModel_ptr_typeID = typeID;
    ext->GfxModel_ptr = scripting::createNativeObject(GfxModel_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxModelRef", ext->GfxModel_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GfxLODList_typeID = typeID;
    ext->GfxLODList = scripting::createNativeObject(GfxLODList_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxLODList", ext->GfxLODList);
    
    typeID = engine->createNewTypeID();
    ext->GfxLODList_ptr_typeID = typeID;
    ext->GfxLODList_ptr = scripting::createNativeObject(GfxLODList_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxLODListRef", ext->GfxLODList_ptr);
    
    typeID = engine->createNewTypeID();
    ext->EntityList_typeID = typeID;
    ext->EntityList = scripting::createNativeObject(EntityList_funcs, NULL, typeID);
    engine->getGlobalVars().set("EntityList", ext->EntityList);
    
    typeID = engine->createNewTypeID();
    ext->EntityList_ptr_typeID = typeID;
    ext->EntityList_ptr = scripting::createNativeObject(EntityList_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("EntityListRef", ext->EntityList_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GfxShaderCombination_typeID = typeID;
    ext->GfxShaderCombination = scripting::createNativeObject(GfxShaderCombination_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxShaderCombination", ext->GfxShaderCombination);
    
    typeID = engine->createNewTypeID();
    ext->GfxShaderCombination_ptr_typeID = typeID;
    ext->GfxShaderCombination_ptr = scripting::createNativeObject(GfxShaderCombination_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxShaderCombinationRef", ext->GfxShaderCombination_ptr);
    
    typeID = engine->createNewTypeID();
    ext->Matrix3x3_typeID = typeID;
    ext->Matrix3x3 = scripting::createNativeObject(Matrix3x3_funcs, NULL, typeID);
    engine->getGlobalVars().set("Matrix3x3", ext->Matrix3x3);
    
    typeID = engine->createNewTypeID();
    ext->Matrix3x3_ptr_typeID = typeID;
    ext->Matrix3x3_ptr = scripting::createNativeObject(Matrix3x3_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("Matrix3x3Ref", ext->Matrix3x3_ptr);
    
    typeID = engine->createNewTypeID();
    ext->GfxDebugDrawer_typeID = typeID;
    ext->GfxDebugDrawer = scripting::createNativeObject(GfxDebugDrawer_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxDebugDrawer", ext->GfxDebugDrawer);
    
    typeID = engine->createNewTypeID();
    ext->GfxDebugDrawer_ptr_typeID = typeID;
    ext->GfxDebugDrawer_ptr = scripting::createNativeObject(GfxDebugDrawer_ptr_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxDebugDrawerRef", ext->GfxDebugDrawer_ptr);
    
    engine->getGlobalVars().set("getFileSys", scripting::createNativeFunction(getFileSys_binding));
            engine->getGlobalVars().set("getAudioDevice", scripting::createNativeFunction(getAudioDevice_binding));
            engine->getGlobalVars().set("listFiles", scripting::createNativeFunction(listFiles_binding));
            engine->getGlobalVars().set("getResMgr", scripting::createNativeFunction(getResMgr_binding));
            engine->getGlobalVars().set("getApp", scripting::createNativeFunction(getApp_binding));
            engine->getGlobalVars().set("getDebugDrawer", scripting::createNativeFunction(getDebugDrawer_binding));
            engine->getGlobalVars().set("getPlatform", scripting::createNativeFunction(getPlatform_binding));
            engine->getGlobalVars().set("getGfxApi", scripting::createNativeFunction(getGfxApi_binding));
            engine->getGlobalVars().set("doesFileExist", scripting::createNativeFunction(doesFileExist_binding));
            typeID = engine->createNewTypeID();
    ext->Key_typeID = typeID;
    ext->Key = scripting::createNativeObject(Key_funcs, NULL, typeID);
    engine->getGlobalVars().set("Key", ext->Key);
    
    typeID = engine->createNewTypeID();
    ext->MouseButton_typeID = typeID;
    ext->MouseButton = scripting::createNativeObject(MouseButton_funcs, NULL, typeID);
    engine->getGlobalVars().set("MouseButton", ext->MouseButton);
    
    typeID = engine->createNewTypeID();
    ext->EventType_typeID = typeID;
    ext->EventType = scripting::createNativeObject(EventType_funcs, NULL, typeID);
    engine->getGlobalVars().set("EventType", ext->EventType);
    
    typeID = engine->createNewTypeID();
    ext->FileOrigin_typeID = typeID;
    ext->FileOrigin = scripting::createNativeObject(FileOrigin_funcs, NULL, typeID);
    engine->getGlobalVars().set("FileOrigin", ext->FileOrigin);
    
    typeID = engine->createNewTypeID();
    ext->XOrigin_typeID = typeID;
    ext->XOrigin = scripting::createNativeObject(XOrigin_funcs, NULL, typeID);
    engine->getGlobalVars().set("XOrigin", ext->XOrigin);
    
    typeID = engine->createNewTypeID();
    ext->ResType_typeID = typeID;
    ext->ResType = scripting::createNativeObject(ResType_funcs, NULL, typeID);
    engine->getGlobalVars().set("ResType", ext->ResType);
    
    typeID = engine->createNewTypeID();
    ext->GfxPrimitive_typeID = typeID;
    ext->GfxPrimitive = scripting::createNativeObject(GfxPrimitive_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxPrimitive", ext->GfxPrimitive);
    
    typeID = engine->createNewTypeID();
    ext->GfxDepthFunction_typeID = typeID;
    ext->GfxDepthFunction = scripting::createNativeObject(GfxDepthFunction_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxDepthFunction", ext->GfxDepthFunction);
    
    typeID = engine->createNewTypeID();
    ext->GfxBlendMode_typeID = typeID;
    ext->GfxBlendMode = scripting::createNativeObject(GfxBlendMode_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxBlendMode", ext->GfxBlendMode);
    
    typeID = engine->createNewTypeID();
    ext->GfxBlendFactor_typeID = typeID;
    ext->GfxBlendFactor = scripting::createNativeObject(GfxBlendFactor_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxBlendFactor", ext->GfxBlendFactor);
    
    typeID = engine->createNewTypeID();
    ext->GfxCullMode_typeID = typeID;
    ext->GfxCullMode = scripting::createNativeObject(GfxCullMode_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxCullMode", ext->GfxCullMode);
    
    typeID = engine->createNewTypeID();
    ext->GfxWinding_typeID = typeID;
    ext->GfxWinding = scripting::createNativeObject(GfxWinding_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxWinding", ext->GfxWinding);
    
    typeID = engine->createNewTypeID();
    ext->GfxVertexAttribPurpose_typeID = typeID;
    ext->GfxVertexAttribPurpose = scripting::createNativeObject(GfxVertexAttribPurpose_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxVertexAttribPurpose", ext->GfxVertexAttribPurpose);
    
    typeID = engine->createNewTypeID();
    ext->GfxVertexAttribType_typeID = typeID;
    ext->GfxVertexAttribType = scripting::createNativeObject(GfxVertexAttribType_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxVertexAttribType", ext->GfxVertexAttribType);
    
    typeID = engine->createNewTypeID();
    ext->GfxTextureType_typeID = typeID;
    ext->GfxTextureType = scripting::createNativeObject(GfxTextureType_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxTextureType", ext->GfxTextureType);
    
    typeID = engine->createNewTypeID();
    ext->GfxFilter_typeID = typeID;
    ext->GfxFilter = scripting::createNativeObject(GfxFilter_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxFilter", ext->GfxFilter);
    
    typeID = engine->createNewTypeID();
    ext->GfxMipmapMode_typeID = typeID;
    ext->GfxMipmapMode = scripting::createNativeObject(GfxMipmapMode_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxMipmapMode", ext->GfxMipmapMode);
    
    typeID = engine->createNewTypeID();
    ext->GfxWrapMode_typeID = typeID;
    ext->GfxWrapMode = scripting::createNativeObject(GfxWrapMode_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxWrapMode", ext->GfxWrapMode);
    
    typeID = engine->createNewTypeID();
    ext->GfxTexFormat_typeID = typeID;
    ext->GfxTexFormat = scripting::createNativeObject(GfxTexFormat_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxTexFormat", ext->GfxTexFormat);
    
    typeID = engine->createNewTypeID();
    ext->GfxTexPurpose_typeID = typeID;
    ext->GfxTexPurpose = scripting::createNativeObject(GfxTexPurpose_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxTexPurpose", ext->GfxTexPurpose);
    
    typeID = engine->createNewTypeID();
    ext->GfxFace_typeID = typeID;
    ext->GfxFace = scripting::createNativeObject(GfxFace_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxFace", ext->GfxFace);
    
    typeID = engine->createNewTypeID();
    ext->GfxShaderType_typeID = typeID;
    ext->GfxShaderType = scripting::createNativeObject(GfxShaderType_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxShaderType", ext->GfxShaderType);
    
    typeID = engine->createNewTypeID();
    ext->GfxBufferUsage_typeID = typeID;
    ext->GfxBufferUsage = scripting::createNativeObject(GfxBufferUsage_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxBufferUsage", ext->GfxBufferUsage);
    
    typeID = engine->createNewTypeID();
    ext->GfxMeshIndexDataType_typeID = typeID;
    ext->GfxMeshIndexDataType = scripting::createNativeObject(GfxMeshIndexDataType_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxMeshIndexDataType", ext->GfxMeshIndexDataType);
    
    typeID = engine->createNewTypeID();
    ext->GfxMeshAttribType_typeID = typeID;
    ext->GfxMeshAttribType = scripting::createNativeObject(GfxMeshAttribType_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxMeshAttribType", ext->GfxMeshAttribType);
    
    typeID = engine->createNewTypeID();
    ext->GfxMeshAttribDataType_typeID = typeID;
    ext->GfxMeshAttribDataType = scripting::createNativeObject(GfxMeshAttribDataType_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxMeshAttribDataType", ext->GfxMeshAttribDataType);
    
    typeID = engine->createNewTypeID();
    ext->GfxShadowmapPrecision_typeID = typeID;
    ext->GfxShadowmapPrecision = scripting::createNativeObject(GfxShadowmapPrecision_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxShadowmapPrecision", ext->GfxShadowmapPrecision);
    
    typeID = engine->createNewTypeID();
    ext->GfxLightType_typeID = typeID;
    ext->GfxLightType = scripting::createNativeObject(GfxLightType_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxLightType", ext->GfxLightType);
    
    typeID = engine->createNewTypeID();
    ext->GfxDriver_typeID = typeID;
    ext->GfxDriver = scripting::createNativeObject(GfxDriver_funcs, NULL, typeID);
    engine->getGlobalVars().set("GfxDriver", ext->GfxDriver);
    
    typeID = engine->createNewTypeID();
    ext->CameraType_typeID = typeID;
    ext->CameraType = scripting::createNativeObject(CameraType_funcs, NULL, typeID);
    engine->getGlobalVars().set("CameraType", ext->CameraType);
    
    typeID = engine->createNewTypeID();
    ext->RigidBodyType_typeID = typeID;
    ext->RigidBodyType = scripting::createNativeObject(RigidBodyType_funcs, NULL, typeID);
    engine->getGlobalVars().set("RigidBodyType", ext->RigidBodyType);
    
    typeID = engine->createNewTypeID();
    ext->PhysicsObjectType_typeID = typeID;
    ext->PhysicsObjectType = scripting::createNativeObject(PhysicsObjectType_funcs, NULL, typeID);
    engine->getGlobalVars().set("PhysicsObjectType", ext->PhysicsObjectType);
    
    typeID = engine->createNewTypeID();
    ext->RenderMode_typeID = typeID;
    ext->RenderMode = scripting::createNativeObject(RenderMode_funcs, NULL, typeID);
    engine->getGlobalVars().set("RenderMode", ext->RenderMode);
    
    return ext;
}

void deinitBindings(scripting::Engine *engine, void *data)
{
    DELETE((BindingsExt *)data);
}

namespace scripting
{
void registerBindings(scripting::Engine *engine)
{
    scripting::Extension ext;

    ext.init = initBindings;
    ext.deinit = deinitBindings;

    engine->addExtension("bindings", ext);
}
}
