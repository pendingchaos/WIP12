#extension GL_ARB_tessellation_shader : require

#include "lib/uniform.glsl"

layout (vertices = 3) out;

in gl_PerVertex
{
    vec4 gl_Position;
} gl_in[];

in vec3 control_normal_worldSpace[];
in vec2 control_uv_tangentSpace[];
in vec3 control_position_worldSpace[];

out gl_PerVertex
{
    vec4 gl_Position;
} gl_out[];

out vec3 eval_normal_worldSpace[];
out vec2 eval_uv_tangentSpace[];

uniform float minTessLevel;
uniform float maxTessLevel;
uniform float tessMinDistance;
uniform float tessMaxDistance;
uniform vec3 cameraPosition;

float getTessLevel(in float distance)
{
    return mix(maxTessLevel, minTessLevel, clamp((distance - tessMinDistance) / tessMaxDistance, 0.0, 1.0));
}

void main()
{
    float distance0 = distance(control_position_worldSpace[0], cameraPosition);
    float distance1 = distance(control_position_worldSpace[1], cameraPosition);
    float distance2 = distance(control_position_worldSpace[2], cameraPosition);

    float tessLevel0 = getTessLevel((distance1 + distance2) / 2.0);
    float tessLevel1 = getTessLevel((distance2 + distance0) / 2.0);
    float tessLevel2 = getTessLevel((distance0 + distance1) / 2.0);

    gl_TessLevelOuter[0] = tessLevel0;
    gl_TessLevelOuter[1] = tessLevel1;
    gl_TessLevelOuter[2] = tessLevel2;

    gl_TessLevelInner[0] = (tessLevel0 + tessLevel1 + tessLevel2) / 3.0;

    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;

    eval_normal_worldSpace[gl_InvocationID] = control_normal_worldSpace[gl_InvocationID];
    eval_uv_tangentSpace[gl_InvocationID] = control_uv_tangentSpace[gl_InvocationID];
}
